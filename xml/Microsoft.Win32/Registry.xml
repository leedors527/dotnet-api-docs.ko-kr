<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="99c62b7a1323a992dfece9bd4e11b7dbe0c43bb1" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52210064" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows 레지스트리의 루트 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" /> 개체와 키/값 쌍에 액세스하는 <see langword="static" /> 메서드를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 Windows를 실행 하는 컴퓨터의 레지스트리에 있는 표준 루트 키의 집합을 제공 합니다. 레지스트리는 응용 프로그램, 사용자 및 기본 시스템 설정에 대 한 정보에 대 한 저장소 기능을 합니다. 예를 들어, 응용 프로그램 레지스트리를 사용 하 여 응용 프로그램을 닫은 후 유지 해야 하는 정보를 저장 하 고 응용 프로그램을 다시 로드 되 면이 동일한 정보에 액세스할 수 있습니다. 예를 들어 기본 색, 화면 위치 또는 창의 크기를 저장할 수 있습니다. 레지스트리에서 다른 위치에 정보를 저장 하 여 각 사용자에 대 한이 데이터를 제어할 수 있습니다.  
  
 기본 또는 루트 <xref:Microsoft.Win32.RegistryKey> 에 의해 노출 되는 인스턴스는 `Registry` 클래스 하위 키와 레지스트리 값에 대 한 기본 저장소 메커니즘을 설명 합니다. 레지스트리의 유무에 따라 달라 지므로 모든 키는 읽기 전용입니다. 사용 되는 키 `Registry` 됩니다.  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 사용자 기본 설정에 대 한 정보를 저장합니다.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 로컬 컴퓨터에 대 한 구성 정보를 저장합니다.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 형식 (및 클래스)에 대 한 정보 및 해당 속성을 저장합니다.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 기본 사용자 구성에 대 한 정보를 저장합니다.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 소프트웨어 구성 요소에 대 한 성능 정보를 저장합니다.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 비 사용자 특정 하드웨어 정보를 저장합니다.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 동적 데이터를 저장합니다.  
  
 레지스트리에서 정보를 저장/검색에 루트 키를 식별 한 후 사용할 수 있습니다는 <xref:Microsoft.Win32.RegistryKey> 클래스를 추가 하거나, 하위 키를 제거 하 고 지정된 된 키에 대 한 값을 조작 합니다.  
  
 하드웨어 장치 플러그 앤 플레이 인터페이스를 사용 하 여 자동으로 정보를 배치할 수 있습니다. 소프트웨어 장치 드라이버 설치에 대 한 표준 Api를 작성 하 여 레지스트리에서 정보를 배치할 수 있습니다.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>가져오기 및 값을 설정 하기 위한 정적 메서드  
 .NET Framework 버전 2.0에에서는 <xref:Microsoft.Win32.Registry> 클래스도 포함 되어 있습니다 `static` <xref:Microsoft.Win32.Registry.GetValue%2A> 및 <xref:Microsoft.Win32.Registry.SetValue%2A> 설정 하 고 레지스트리 키에서 값을 검색 하는 방법입니다. 이러한 메서드를 열고 레지스트리 키에서 유사한 메서드가 뿐만 아니라 각 시간 수행 하지 않으므로 하므로 사용 된 <xref:Microsoft.Win32.RegistryKey> 클래스, 많은 수의 값에 액세스할 때.  
  
 <xref:Microsoft.Win32.RegistryKey> 클래스도 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키 삭제에 대 한 Windows 액세스 제어 보안을 설정 하는 데 사용할 수 있는 메서드를 제공 합니다.  
  
   
  
## Examples  
 이 섹션에는 두 코드 예제가 있습니다. 첫 번째 예제에서는 루트 키를 보여 주고 두 번째 예제는 `static` <xref:Microsoft.Win32.Registry.GetValue%2A> 고 <xref:Microsoft.Win32.Registry.SetValue%2A> 메서드.  
  
 예제 1  
  
 다음 코드 예제에서는 HKEY_USERS 키의 하위 키를 검색 하 고 해당 이름을 화면에 인쇄 하는 방법을 보여 줍니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 `RegistryKey` 해당 키를 조작할 수 있습니다.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 예제 2  
  
 다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다. 예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식과 관련된 속성 및 문서의 형식 또는 클래스를 정의합니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_CLASSES_ROOT를 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기존 응용 프로그램과 OLE 응용 프로그램에는이 키 아래에 저장 된 데이터를 사용 합니다. 또한이 키 DDE 및 OLE 지원에 대 한 정보를 저장 하 여 Windows 3.1 등록 데이터베이스를 사용 하 여 이전 버전과 호환성을 제공 합니다. 파일 뷰어 다운로드 및 사용자 인터페이스 확장이이 키에서 OLE 클래스 식별자를 저장 하 고 처리 서버가이 키에 등록 된 키를 누릅니다.  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자와 관련되지 않은 하드웨어에 대한 구성 정보가 들어 있습니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_CURRENT_CONFIG를 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 내의 하위 키에 매핑된 <xref:Microsoft.Win32.Registry.LocalMachine>합니다.  
  
 이 멤버를 사용 하는 예로 시스템을 네트워크에 연결 되었는지 여부에 따라 해당 데이터에 대 한 다른 서버 이름을 저장 하는 응용 프로그램.  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 사용자 기본 설정에 대한 정보가 들어 있습니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_CURRENT_USER를 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 키에 저장 된 정보에는 환경 변수와 프로그램 그룹, 색, 프린터, 네트워크 연결 및 응용 프로그램 기본 설정에 대 한 데이터의 설정이 포함 됩니다. 이 키는 쉽게 현재 사용자의 설정을 만들 수 있습니다. 이 키에서 소프트웨어 공급 업체 응용 프로그램 내에서 사용할 현재 사용자별 기본 설정을 저장 합니다. 예를 들어, Microsoft, Microsoft 키 아래에 자체 하위 키를 만드는 각 응용 프로그램을 사용 하려면 해당 응용 프로그램에 대 한 HKEY_CURRENT_USER\Software\Microsoft 키를 만듭니다.  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 레지스트리 데이터가 들어 있습니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_DYN_DATA를 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 98/Windows Me 레지스트리는 정적 데이터 (레지스트리에 디스크에 저장 됨) 및 동적 데이터 (성능 통계와 같은 자주 변경)를 지원 합니다. 이 동적 데이터 영역은 로컬과 원격으로 실행할 수 있는 Win32 응용 프로그램에 가상 장치 드라이버 (Vxd) 실시간 데이터를 제공할 수 있는 메커니즘을입니다. 시스템 모니터를 원격 Windows 98/Windows Me 시스템에서 성능 통계를 제공할 수도 있습니다.  
  
 Vxd 성능 데이터에 제한 되지 않습니다. 에 전달할 링 0에서에서 링 3 효율적으로 CPU를 차지 하지 않고 원하는 모든 데이터를 제공할 수 있습니다. 레지스트리 값 (또는 여러 개의 값)를 반환 하는 함수에 대 한 포인터를 저장 하 여 동적 데이터를 지원 합니다. 경우 레지스트리 호출 쿼리 값을 사용 하는 연관 된 동적 키와 함수가 호출 되어 값을 원하는 값을 반환 합니다.  
  
> [!NOTE]
>  동적 키는 동적 레지스트리 데이터를 처리 하도록 Microsoft Windows 95에 도입 되었습니다. Me. Windows 98/Windows 에서만 지원 됩니다 것  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다. 이 예제에서는 이후 없을 동적 데이터를 사용할 수 없습니다 실행 중일 수 있습니다 Windows 98 또는 결과 없음를 반환할 수는 / m E 이 키를 사용 하 여 다른 시스템에서 오류가 발생할 수 있습니다.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">운영 체제는 동적 데이터를 지원하지 않습니다. 즉, Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition(Windows Me)이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">"HKEY_CURRENT_USER"와 같이 유효한 레지스트리 루트로 시작하는 키의 전체 레지스트리 경로입니다. </param>
        <param name="valueName">이름/값 쌍의 이름입니다.</param>
        <param name="defaultValue">
          <paramref name="valueName" />이 없는 경우에 반환할 값입니다.</param>
        <summary>지정된 레지스트리 키에서 지정된 이름에 연결된 값을 검색합니다. 지정된 키에 해당 이름이 없으면 사용자가 제공한 기본값이 반환되고, 지정된 키가 없으면 <see langword="null" />이 반환됩니다.</summary>
        <returns>
          <paramref name="keyName" />에 지정된 하위 키가 없으면 <see langword="null" />이 반환되고, 그렇지 않으면 <paramref name="valueName" />과 연결된 값이 반환됩니다. <paramref name="defaultValue" />이 없으면 <paramref name="valueName" />가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문자열 `valueName` 대/소문자 구분 아닙니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 된 하나의 값을 포함할 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열 이름 대신 표시 됩니다. 명명 되지 않은 값이 검색을 지정 하거나 `null` 이거나 빈 문자열 ("")에 대 한 `valuName`합니다.  
  
 유효한 루트 이름을 HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG를 및 HKEY_DYN_DATA입니다. 예를 들어, Visual Basic "HKEY_CURRENT_USER\MyTestKey" 문자열 "MyTestKey" HKEY_CURRENT_USER 루트에 있는 하위 키에 대 한 키/값 쌍에 액세스합니다.  
  
 경우는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 가능한 문자열 값을 검색 하는 메서드 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)을 로컬 환경에서 데이터를 사용 하 여 환경 문자열을 확장 합니다. 환경 변수에 대 한 확장 참조를 포함 하는 값을 문자열로 저장 된 경우 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), 아니라는 확장 가능한 문자열 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 하지 않습니다. 호출 하 여 검색 한 후에 이러한 문자열을 확장할 수 있습니다는 <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> 메서드.  
  
> [!NOTE]
>  HKEY_PERFORMANCE_DATA에서 데이터를 검색 하는 권장된 방법은 사용 하는 것은 <xref:System.Diagnostics.PerformanceCounter> 클래스 보다는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 메서드.  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A> 하 고 <xref:Microsoft.Win32.Registry.SetValue%2A> 메서드를 열고 레지스트리 키의 메서드 뿐 아니라 수행 하지 않으므로 하므로 사용 될 때마다는 <xref:Microsoft.Win32.RegistryKey> 많은 수의 값을 액세스 하는 경우 클래스입니다.  
  
 <xref:Microsoft.Win32.RegistryKey> 또한 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키를 삭제 하는 액세스 제어 목록 (ACL)을 추가할 수 있도록 하는 메서드를 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다. 예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">사용자가 레지스트리 키를 읽는 데 필요한 사용 권한이 없는 경우</exception>
        <exception cref="T:System.IO.IOException">지정된 값이 포함된 <see cref="T:Microsoft.Win32.RegistryKey" />가 삭제 표시된 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" />이 유효한 레지스트리 루트로 시작하지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">레지스트리에서 읽을 수 연결 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">형식 reg_expand_sz와의 레지스트리 키를 읽을 수 연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로컬 컴퓨터에 대한 구성 데이터가 들어 있습니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_LOCAL_MACHINE을 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` 5 개의 키를 포함 합니다.  
  
 하드웨어  
 컴퓨터의 실제 하드웨어를 장치 드라이버는 해당 하드웨어 및 매핑 및 사용자 모드 코드를 사용 하 여 커널 모드 드라이버를 연결 하는 관련된 데이터를 사용 하는 방법을 설명 합니다. 이 키의 모든 데이터에는 시스템 시작 될 때마다 다시 생성 됩니다. 하위 키를 설명 하는 실제 컴퓨터 하드웨어를 설명합니다. DeviceMap 하위 키 형식 드라이버의 특정 클래스의 기타 데이터를 포함합니다. 장치 드라이버는 하드웨어 리소스를 클레임 ResourceMap 하위 키를 설명 합니다. Windows NT 진단을 프로그램 (Winmsdp.exe)는 읽기 쉬운 형태로 내용에 보고할 수 있습니다.  
  
 SAM  
 디렉터리 서비스 데이터베이스의 사용자 및 그룹 계정 및 Windows 2000 Server의 도메인에 대 한 보안 정보 (SAM는 디렉터리 서비스 데이터베이스 라는 보안 계정 관리자).  
  
 보안  
 특정 사용자 권한 같은 로컬 보안 정책을 포함 되어 있습니다. 이 키는 Windows 2000 보안 하위 시스템에 의해서만 사용 됩니다.  
  
 소프트웨어  
 컴퓨터별 소프트웨어 데이터베이스입니다. 이 키는 다양 한 항목의 기타 구성 데이터와 함께 로컬 컴퓨터에 설치 된 소프트웨어에 대 한 데이터를 포함 합니다.  
  
 시스템  
 시스템 시작, 장치 드라이버 로드, Windows 2000 서비스 및 운영 체제 동작을 제어합니다.  
  
 아래와 유사한 데이터가 있는 경우 규칙에 따라 <xref:Microsoft.Win32.Registry.CurrentUser> 아래에서 <xref:Microsoft.Win32.Registry.LocalMachine>, 데이터를 <xref:Microsoft.Win32.Registry.CurrentUser> 우선적으로 적용 합니다. 그러나이 키의 값 수도 확장 대신 대체 Registry.LocalMachine의 데이터입니다. 또한 일부 항목 (예: 장치 드라이버 항목 로드 중)는 Registry.LocalMachine 외부에서 발생 하는 경우에 의미가 없습니다.  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>소프트웨어 구성 요소에 대한 성능 정보를 포함합니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_PERFORMANCE_DATA를 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 소프트웨어 구성 요소는 카운터를 설치 하 고 실행 하는 동안 카운터 데이터를 기록 하는 경우 해당 개체에 대 한 키를 만듭니다. 에 액세스할 때 처럼 다른 레지스트리 데이터를 사용 하 여이 데이터를 액세스할 수는 <xref:Microsoft.Win32.RegistryKey> 함수입니다.  
  
 성능 데이터를 수집 하려면 레지스트리를 사용 하지만 데이터 레지스트리 데이터베이스에 저장 되지 않습니다. 대신,이 키를 사용 하 여 레지스트리를 액세스 하는 적절 한 시스템 개체 관리자에서 데이터를 수집 하도록 시스템에 하면 됩니다.  
  
 로컬 시스템에서 성능 데이터를 가져오려면는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Registry.PerformanceData 키를 사용 하 여 메서드. 첫 번째 호출 (필요가 없습니다를 명시적으로 키를 먼저 열어야) 키를 엽니다. 그러나 사용 해야는 <xref:Microsoft.Win32.RegistryKey.Close%2A> 메서드를 성능 데이터 가져오기 작업을 마쳤으면 키에 대 한 핸들을 닫습니다. 사용자는 설치 하거나 해당 성능 데이터를 사용 하는 동안 소프트웨어 구성 요소를 제거할 수 없습니다.  
  
 원격 시스템에서 성능 데이터를 가져오려면 사용 해야 합니다는 <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> 메서드를 원격 시스템 및 Registry.PerformanceData 키의 컴퓨터 이름입니다. 이 호출은 원격 시스템에 대 한 성능 데이터를 나타내는 키를 검색 합니다. 데이터를 검색 하려면 호출 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Registry.PerformanceData 키 보다는이 키를 사용 합니다.  
  
> [!NOTE]
>  Windows Server 2003에서 사용자 Performance Monitor Users 그룹에이 기본 키의 하위 키에 액세스 하기 위해 속해야 최소한 합니다.  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다. 이 예제에서는 성능 데이터가 될 수 있으므로 없는 결과 반환할 종종 수 참고 합니다.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>레지스트리 키에서 이름/값 쌍의 값을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다. 예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">"HKEY_CURRENT_USER"와 같이 유효한 레지스트리 루트로 시작하는 키의 전체 레지스트리 경로입니다. </param>
        <param name="valueName">이름/값 쌍의 이름입니다.</param>
        <param name="value">저장할 값입니다.</param>
        <summary>지정된 레지스트리 키에 지정된 이름/값 쌍을 설정합니다. 지정된 키가 없으면 키가 새로 만들어집니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 그러나부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 `valueName` 매개 변수는 최대 255 자 제한 되어 더 이상는 `keyName` 계속 255 자로 제한 하도록 하는 매개 변수입니다.  
  
 각 레지스트리 키에 저장할 수 많은 값을 사용 해야는 `valueName` 매개 변수를 설정 하려면 특정 값을 지정 합니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 된 하나의 값을 포함할 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열 이름 대신 표시 됩니다. 명명 되지 않은 값을 설정 하려면 하나를 지정 `null` 이거나 빈 문자열 ("")에 대 한 `valueName`합니다.  
  
 하는 경우 `valueName` 존재 하지 않는 키의 생성 및 연결 된 값으로 설정 됩니다 `value`합니다.  
  
 경우 `keyName` 존재 하지 않는 하위 키를 지정 된 하위 키 지정된 된 루트에 생성 됩니다. 예를 들어, Visual Basic에서 문자열 "HKEY_CURRENT_USER\MyTestKey" HKEY_CURRENT_USER 루트에 "MyTestKey" 하위 키를 만듭니다. "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" 문자열 "MyTestKey", "MyTestKey\Key2" 및 "MyTestKey\Key2\Key3" 중첩 된 하위 키를 만듭니다.  
  
 유효한 루트 이름 HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG를 및 HKEY_DYN_DATA를 포함 합니다.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> 메서드 레지스트리 키를 열고 값을 설정 하 고 호출 될 때마다 키를 닫습니다. 많은 수의 값을 수정 해야 하는 경우는 <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 메서드는 더 나은 성능을 제공할 수 있습니다. <xref:Microsoft.Win32.RegistryKey> 클래스도 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키를 삭제 하는 액세스 제어 목록 (ACL)을 추가할 수 있는 메서드를 제공 합니다.  
  
 이 오버 로드 <xref:Microsoft.Win32.Registry.SetValue%2A> 64 비트 정수를 문자열로 저장 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). 64 비트 숫자를 저장할 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 값을 사용 하 여를 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 메서드 오버 로드.  
  
 이 오버 로드 <xref:Microsoft.Win32.Registry.SetValue%2A> 모든 문자열 값으로 저장 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> 개체를 확장할 수 있는 환경 변수에 참조를 포함 하는 경우에 합니다. 문자열 값으로 확장할 수 있는 문자열을 저장 하려면 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)를 사용 하 여를 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 메서드 오버 로드 합니다.  
  
 이 오버 로드는 호출에 해당 하는 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 메서드 오버 로드 <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  Windows 98 및 Windows Millennium Edition (Windows Me), 레지스트리 유니코드 아니며 일부 유니코드 문자는 모든 코드 페이지에 대해 유효 합니다. 현재 코드 페이지에 대 한 잘못 된 유니코드 문자가 가장 사용 가능한 일치 항목으로 대체 됩니다. 예외가 throw되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다. 예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" />이 유효한 레지스트리 루트로 시작하지 않은 경우  
  
또는 
 <paramref name="keyName" />이 최대 허용 길이(255자)보다 긴 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">루트 수준 노드와 같이 <see cref="T:Microsoft.Win32.RegistryKey" />가 읽기 전용이므로 여기에 쓸 수 없는 경우</exception>
        <exception cref="T:System.Security.SecurityException">사용자가 레지스트리 키를 만들거나 수정하는 데 필요한 사용 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">존재 하는 경우 지정된 된 레지스트리 키를 수정 하려면 또는 아직 없는 경우 레지스트리 키를 만들어야 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">"HKEY_CURRENT_USER"와 같이 유효한 레지스트리 루트로 시작하는 키의 전체 레지스트리 경로입니다. </param>
        <param name="valueName">이름/값 쌍의 이름입니다.</param>
        <param name="value">저장할 값입니다.</param>
        <param name="valueKind">데이터를 저장할 때 사용할 레지스트리 데이터 형식입니다.</param>
        <summary>지정된 레지스트리 데이터 형식을 사용하여 지정된 레지스트리 키에 이름/값 쌍을 설정합니다. 지정된 키가 없으면 키가 새로 만들어집니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 그러나부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 `valueName` 매개 변수는 최대 255 자 제한 되어 더 이상는 `keyName` 매개 변수는 255 자 제한을 계속 합니다.  
  
 각 레지스트리 키에 저장할 수 많은 값을 사용 해야는 `valueName` 매개 변수를 설정 하려면 특정 값을 지정 합니다.  
  
> [!NOTE]
>  레지스트리 키 이름과 연결 된 하나의 값을 포함할 수 있습니다. 레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열 이름 대신 표시 됩니다. 명명 되지 않은 값을 설정 하려면 하나를 지정 `null` 이거나 빈 문자열 ("")에 대 한 `valueName`합니다.  
  
 하는 경우 `valueName` 존재 하지 않는 키의 생성 및 연결 된 값으로 설정 됩니다 `value`합니다.  
  
 경우 `keyName` 존재 하지 않는 하위 키를 지정 된 하위 키 지정된 된 루트에 생성 됩니다. 예를 들어, Visual Basic에서 문자열 "HKEY_CURRENT_USER\MyTestKey" HKEY_CURRENT_USER 루트에 "MyTestKey" 하위 키를 만듭니다. "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" 문자열 "MyTestKey", "MyTestKey\Key2" 및 "MyTestKey\Key2\Key3" 중첩 된 하위 키를 만듭니다.  
  
 유효한 루트 이름 HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG를 및 HKEY_DYN_DATA를 포함 합니다.  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A> 메서드 레지스트리 키를 열고 값을 설정 하 고 호출 될 때마다 키를 닫습니다. 많은 수의 값을 수정 해야 하는 경우는 <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 메서드는 더 나은 성능을 제공할 수 있습니다. <xref:Microsoft.Win32.RegistryKey> 클래스도 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키를 삭제 하는 액세스 제어 목록 (ACL)을 추가할 수 있는 메서드를 제공 합니다.  
  
 경우 지정된 된 형식의 `value` 지정 된 일치 하지 않습니다 `valueKind`, 데이터 일 수 없습니다 및 변환 <xref:System.ArgumentException> throw 됩니다. 예를 들어, 저장할 수 있습니다는 <xref:System.Int64?displayProperty=nameWithType> 으로 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, 해당 값이 최대값 보다 작은 경우에을 <xref:System.Int32?displayProperty=nameWithType>입니다. 단일 문자열 값으로 저장할 수 없습니다는 <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  Boxed 값에 대 한 전달 되 면 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> 또는 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, 변환이 이루어집니다 고정 문화권을 사용 하 여 합니다.  
  
> [!NOTE]
>  Windows 98 및 Windows Millennium Edition (Windows Me), 레지스트리 유니코드 아니며 일부 유니코드 문자는 모든 코드 페이지에 대해 유효 합니다. 현재 코드 페이지에 대 한 잘못 된 유니코드 문자가 가장 사용 가능한 일치 항목으로 대체 됩니다. 예외가 throw되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다. 예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" />이 유효한 레지스트리 루트로 시작하지 않은 경우  
  
또는 
 <paramref name="keyName" />이 최대 허용 길이(255자)보다 긴 경우  
  
또는 
<paramref name="value" />의 형식이 <paramref name="valueKind" />에 지정된 레지스트리 데이터 형식과 일치하지 않아 데이터가 올바르게 변환되지 않은 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" />가 읽기 전용이므로 쓸 수 없는 경우. 예를 들어, 루트 수준 노드이거나 쓰기 권한으로 키를 열지 않은 경우일 수 있습니다.</exception>
        <exception cref="T:System.Security.SecurityException">사용자가 레지스트리 키를 만들거나 수정하는 데 필요한 사용 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">존재 하는 경우 지정된 된 레지스트리 키를 수정 하려면 또는 아직 없는 경우 레지스트리 키를 만들어야 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기본 사용자 구성에 대한 정보가 들어 있습니다. 이 필드는 Windows 레지스트리 기본 키 HKEY_USERS를 읽습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 키는 컴퓨터의 각 사용자에 대 한 분기를 포함합니다. 사용자 기본 설정을 변경 되지 않은 경우 기본 구성은 로컬 컴퓨터에서 새 사용자 및 기본 현재 사용자에 대해 제공 됩니다. 때문에 Windows 98 / Registry.Users 지원 ME, 응용 프로그램 사용자 관련 정보를 Windows 2000에서 수행 하는 동일한 방식으로 액세스할 수 있습니다. 각 사용자의 정보는 로컬 또는 네트워크 서버에 저장할 수 있는 별도 파일에 저장 됩니다. Windows 98 설정을 사용자와 다른 한 컴퓨터에서 이동할 수 있도록 사용자의 현재 시스템에이 파일을 복사할 수 나 /입니다.  
  
   
  
## Examples  
 이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다. 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다. 다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>