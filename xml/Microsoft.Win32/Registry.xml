<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="99c62b7a1323a992dfece9bd4e11b7dbe0c43bb1" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52210064" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="803c8-101">Windows 레지스트리의 루트 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" /> 개체와 키/값 쌍에 액세스하는 <see langword="static" /> 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-101">Provides <see cref="T:Microsoft.Win32.RegistryKey" /> objects that represent the root keys in the Windows registry, and <see langword="static" /> methods to access key/value pairs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-102">이 클래스는 Windows를 실행 하는 컴퓨터의 레지스트리에 있는 표준 루트 키의 집합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-102">This class provides the set of standard root keys found in the registry on machines running Windows.</span></span> <span data-ttu-id="803c8-103">레지스트리는 애플리케이션, 사용자 및 기본 시스템 설정에 대 한 정보에 대 한 저장소 기능을 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-103">The registry is a storage facility for information about applications, users, and default system settings.</span></span> <span data-ttu-id="803c8-104">예를 들어, 애플리케이션 레지스트리를 사용 하 여 애플리케이션을 닫은 후 유지 해야 하는 정보를 저장 하 고 애플리케이션을 다시 로드 되 면이 동일한 정보에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-104">For example, applications can use the registry for storing information that needs to be preserved after the application is closed, and access that same information when the application is reloaded.</span></span> <span data-ttu-id="803c8-105">예를 들어 기본 색, 화면 위치 또는 창의 크기를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-105">For instance, you can store color preferences, screen locations, or the size of the window.</span></span> <span data-ttu-id="803c8-106">레지스트리에서 다른 위치에 정보를 저장 하 여 각 사용자에 대 한이 데이터를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-106">You can control this data for each user by storing the information in a different location in the registry.</span></span>  
  
 <span data-ttu-id="803c8-107">기본 또는 루트 <xref:Microsoft.Win32.RegistryKey> 에 의해 노출 되는 인스턴스는 `Registry` 클래스 하위 키와 레지스트리 값에 대 한 기본 저장소 메커니즘을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-107">The base, or root <xref:Microsoft.Win32.RegistryKey> instances that are exposed by the `Registry` class delineate the basic storage mechanism for subkeys and values in the registry.</span></span> <span data-ttu-id="803c8-108">레지스트리의 유무에 따라 달라 지므로 모든 키는 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-108">All keys are read-only because the registry depends on their existence.</span></span> <span data-ttu-id="803c8-109">사용 되는 키 `Registry` 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-109">The keys exposed by `Registry` are:</span></span>  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 <span data-ttu-id="803c8-110">사용자 기본 설정에 대 한 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-110">Stores information about user preferences.</span></span>  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 <span data-ttu-id="803c8-111">로컬 컴퓨터에 대 한 구성 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-111">Stores configuration information for the local machine.</span></span>  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 <span data-ttu-id="803c8-112">형식 (및 클래스)에 대 한 정보 및 해당 속성을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-112">Stores information about types (and classes) and their properties.</span></span>  
  
 <xref:Microsoft.Win32.Registry.Users>  
 <span data-ttu-id="803c8-113">기본 사용자 구성에 대 한 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-113">Stores information about the default user configuration.</span></span>  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 <span data-ttu-id="803c8-114">소프트웨어 구성 요소에 대 한 성능 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-114">Stores performance information for software components.</span></span>  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 <span data-ttu-id="803c8-115">비 사용자 특정 하드웨어 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-115">Stores non-user-specific hardware information.</span></span>  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 <span data-ttu-id="803c8-116">동적 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-116">Stores dynamic data.</span></span>  
  
 <span data-ttu-id="803c8-117">레지스트리에서 정보를 저장/검색에 루트 키를 식별 한 후 사용할 수 있습니다는 <xref:Microsoft.Win32.RegistryKey> 클래스를 추가 하거나, 하위 키를 제거 하 고 지정된 된 키에 대 한 값을 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-117">Once you have identified the root key under which you want to store/retrieve information from the registry, you can use the <xref:Microsoft.Win32.RegistryKey> class to add or remove subkeys, and manipulate the values for a given key.</span></span>  
  
 <span data-ttu-id="803c8-118">하드웨어 디바이스 플러그 앤 플레이 인터페이스를 사용 하 여 자동으로 정보를 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-118">Hardware devices can place information in the registry automatically using the Plug and Play interface.</span></span> <span data-ttu-id="803c8-119">소프트웨어 디바이스 드라이버 설치에 대 한 표준 Api를 작성 하 여 레지스트리에서 정보를 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-119">Software for installing device drivers can place information in the registry by writing to standard APIs.</span></span>  
  
## <a name="static-methods-for-getting-and-setting-values"></a><span data-ttu-id="803c8-120">가져오기 및 값을 설정 하기 위한 정적 메서드</span><span class="sxs-lookup"><span data-stu-id="803c8-120">Static Methods for Getting and Setting Values</span></span>  
 <span data-ttu-id="803c8-121">.NET Framework 버전 2.0에에서는 <xref:Microsoft.Win32.Registry> 클래스도 포함 되어 있습니다 `static` <xref:Microsoft.Win32.Registry.GetValue%2A> 및 <xref:Microsoft.Win32.Registry.SetValue%2A> 설정 하 고 레지스트리 키에서 값을 검색 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-121">In the .NET Framework version 2.0, the <xref:Microsoft.Win32.Registry> class also contains `static`<xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods for setting and retrieving values from registry keys.</span></span> <span data-ttu-id="803c8-122">이러한 메서드를 열고 레지스트리 키에서 유사한 메서드가 뿐만 아니라 각 시간 수행 하지 않으므로 하므로 사용 된 <xref:Microsoft.Win32.RegistryKey> 클래스, 많은 수의 값에 액세스할 때.</span><span class="sxs-lookup"><span data-stu-id="803c8-122">These methods open and close registry keys each time they are used, so they do not perform as well as analogous methods in the <xref:Microsoft.Win32.RegistryKey> class, when you access a large number of values.</span></span>  
  
 <span data-ttu-id="803c8-123"><xref:Microsoft.Win32.RegistryKey> 클래스도 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키 삭제에 대 한 Windows 액세스 제어 보안을 설정 하는 데 사용할 수 있는 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-123">The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to set Windows access control security for registry keys, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-124">이 섹션에는 두 코드 예제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-124">This section contains two code examples.</span></span> <span data-ttu-id="803c8-125">첫 번째 예제에서는 루트 키를 보여 주고 두 번째 예제는 `static` <xref:Microsoft.Win32.Registry.GetValue%2A> 고 <xref:Microsoft.Win32.Registry.SetValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="803c8-125">The first example demonstrates root keys, and the second example demonstrates the `static`<xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods.</span></span>  
  
 <span data-ttu-id="803c8-126">예제 1</span><span class="sxs-lookup"><span data-stu-id="803c8-126">Example 1</span></span>  
  
 <span data-ttu-id="803c8-127">다음 코드 예제에서는 HKEY_USERS 키의 하위 키를 검색 하 고 해당 이름을 화면에 인쇄 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-127">The following code example demonstrates how to retrieve the subkeys of the HKEY_USERS key, and print their names to the screen.</span></span> <span data-ttu-id="803c8-128">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-128">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-129">다른 작업에 사용할 수 있습니다 `RegistryKey` 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-129">You can then use other operations in `RegistryKey` to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 <span data-ttu-id="803c8-130">예제 2</span><span class="sxs-lookup"><span data-stu-id="803c8-130">Example 2</span></span>  
  
 <span data-ttu-id="803c8-131">다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-131">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="803c8-132">예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="803c8-132">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-133">해당 형식과 관련된 속성 및 문서의 형식 또는 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-133">Defines the types (or classes) of documents and the properties associated with those types.</span></span> <span data-ttu-id="803c8-134">이 필드는 Windows 레지스트리 기본 키 HKEY_CLASSES_ROOT를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-134">This field reads the Windows registry base key HKEY_CLASSES_ROOT.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-135">기존 애플리케이션과 OLE 애플리케이션에는이 키 아래에 저장 된 데이터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-135">Both conventional applications and OLE applications use data that is stored under this key.</span></span> <span data-ttu-id="803c8-136">또한이 키 DDE 및 OLE 지원에 대 한 정보를 저장 하 여 Windows 3.1 등록 데이터베이스를 사용 하 여 이전 버전과 호환성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-136">This key also provides backward compatibility with the Windows 3.1 registration database by storing information for DDE and OLE support.</span></span> <span data-ttu-id="803c8-137">파일 뷰어 다운로드 및 사용자 인터페이스 확장이이 키에서 OLE 클래스 식별자를 저장 하 고 처리 서버가이 키에 등록 된 키를 누릅니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-137">File viewers and user interface extensions store their OLE class identifiers in this key, and processing servers are registered in this key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-138">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-138">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-139">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-139">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-140">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-140">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-141">사용자와 관련되지 않은 하드웨어에 대한 구성 정보가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-141">Contains configuration information pertaining to the hardware that is not specific to the user.</span></span> <span data-ttu-id="803c8-142">이 필드는 Windows 레지스트리 기본 키 HKEY_CURRENT_CONFIG를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-142">This field reads the Windows registry base key HKEY_CURRENT_CONFIG.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-143">이 멤버는 내의 하위 키에 매핑된 <xref:Microsoft.Win32.Registry.LocalMachine>합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-143">This member is mapped to a subkey within <xref:Microsoft.Win32.Registry.LocalMachine>.</span></span>  
  
 <span data-ttu-id="803c8-144">이 멤버를 사용 하는 예로 시스템을 네트워크에 연결 되었는지 여부에 따라 해당 데이터에 대 한 다른 서버 이름을 저장 하는 애플리케이션.</span><span class="sxs-lookup"><span data-stu-id="803c8-144">An example of using this member is an application that stores a different server name for its data depending on whether the system is attached to a network.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-145">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-145">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-146">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-146">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-147">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-147">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-148">현재 사용자 기본 설정에 대한 정보가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-148">Contains information about the current user preferences.</span></span> <span data-ttu-id="803c8-149">이 필드는 Windows 레지스트리 기본 키 HKEY_CURRENT_USER를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-149">This field reads the Windows registry base key HKEY_CURRENT_USER.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-150">이 키에 저장 된 정보에는 환경 변수와 프로그램 그룹, 색, 프린터, 네트워크 연결 및 애플리케이션 기본 설정에 대 한 데이터의 설정이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-150">Information stored in this key includes the settings of environment variables and data about program groups, colors, printers, network connections, and application preferences.</span></span> <span data-ttu-id="803c8-151">이 키는 쉽게 현재 사용자의 설정을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-151">This key makes it easier to establish the current user's settings.</span></span> <span data-ttu-id="803c8-152">이 키에서 소프트웨어 공급 업체 애플리케이션 내에서 사용할 현재 사용자별 기본 설정을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-152">In this key, software vendors store the current user-specific preferences to be used within their applications.</span></span> <span data-ttu-id="803c8-153">예를 들어, Microsoft, Microsoft 키 아래에 자체 하위 키를 만드는 각 애플리케이션을 사용 하려면 해당 애플리케이션에 대 한 HKEY_CURRENT_USER\Software\Microsoft 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-153">Microsoft, for example, creates the HKEY_CURRENT_USER\Software\Microsoft key for its applications to use, with each application creating its own subkey under the Microsoft key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-154">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-154">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-155">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-155">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-156">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-156">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-157">동적 레지스트리 데이터가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-157">Contains dynamic registry data.</span></span> <span data-ttu-id="803c8-158">이 필드는 Windows 레지스트리 기본 키 HKEY_DYN_DATA를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-158">This field reads the Windows registry base key HKEY_DYN_DATA.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-159">Windows 98/Windows Me 레지스트리는 정적 데이터 (레지스트리에 디스크에 저장 됨) 및 동적 데이터 (성능 통계와 같은 자주 변경)를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-159">The Windows 98/Windows Me registry supports both static data (which is stored on disk in the registry) and dynamic data (which changes frequently, such as performance statistics).</span></span> <span data-ttu-id="803c8-160">이 동적 데이터 영역은 로컬과 원격으로 실행할 수 있는 Win32 응용 프로그램에 가상 디바이스 드라이버 (Vxd) 실시간 데이터를 제공할 수 있는 메커니즘을입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-160">This dynamic data area is the mechanism that allows Virtual Device Drivers (VxDs) to provide real-time data to Win32 applications that can run remotely as well as locally.</span></span> <span data-ttu-id="803c8-161">시스템 모니터를 원격 Windows 98/Windows Me 시스템에서 성능 통계를 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-161">It also allows the system monitor to provide performance statistics on remote Windows 98/Windows Me systems.</span></span>  
  
 <span data-ttu-id="803c8-162">Vxd 성능 데이터에 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-162">VxDs are not limited to performance data.</span></span> <span data-ttu-id="803c8-163">에 전달할 링 0에서에서 링 3 효율적으로 CPU를 차지 하지 않고 원하는 모든 데이터를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-163">They can provide any data they want to pass from Ring 0 to Ring 3 efficiently without monopolizing the CPU.</span></span> <span data-ttu-id="803c8-164">레지스트리 값 (또는 여러 개의 값)를 반환 하는 함수에 대 한 포인터를 저장 하 여 동적 데이터를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-164">The registry supports dynamic data by storing a pointer to a function that returns a value (or many values).</span></span> <span data-ttu-id="803c8-165">경우 레지스트리 호출 쿼리 값을 사용 하는 연관 된 동적 키와 함수가 호출 되어 값을 원하는 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-165">When a Registry call queries values associated with a dynamic key, that function is called to return the desired value or values.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-166">동적 키는 동적 레지스트리 데이터를 처리 하도록 Microsoft Windows 95에 도입 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-166">Dynamic keys were introduced in Microsoft Windows 95 to handle dynamic Registry data.</span></span> <span data-ttu-id="803c8-167">Me. Windows 98/Windows 에서만 지원 됩니다 것</span><span class="sxs-lookup"><span data-stu-id="803c8-167">They are supported only in Windows 98/Windows Me.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-168">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-168">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-169">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-169">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-170">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-170">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span> <span data-ttu-id="803c8-171">이 예제에서는 이후 없을 동적 데이터를 사용할 수 없습니다 실행 중일 수 있습니다 Windows 98 또는 결과 없음를 반환할 수는 / m E</span><span class="sxs-lookup"><span data-stu-id="803c8-171">Note that this example can return no results, since there might not be dynamic data available, or you might not be running Windows 98/ME.</span></span> <span data-ttu-id="803c8-172">이 키를 사용 하 여 다른 시스템에서 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-172">Using this key may cause an error on other systems.</span></span>  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="803c8-173">운영 체제는 동적 데이터를 지원하지 않습니다. 즉, Windows 98, Windows 98 Second Edition 또는 Windows Millennium Edition(Windows Me)이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-173">The operating system does not support dynamic data; that is, it is not Windows 98, Windows 98 Second Edition, or Windows Millennium Edition (Windows Me).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="803c8-174">"HKEY_CURRENT_USER"와 같이 유효한 레지스트리 루트로 시작하는 키의 전체 레지스트리 경로입니다. </span><span class="sxs-lookup"><span data-stu-id="803c8-174">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</span></span></param>
        <param name="valueName"><span data-ttu-id="803c8-175">이름/값 쌍의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-175">The name of the name/value pair.</span></span></param>
        <param name="defaultValue"><span data-ttu-id="803c8-176"><paramref name="valueName" />이 없는 경우에 반환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-176">The value to return if <paramref name="valueName" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="803c8-177">지정된 레지스트리 키에서 지정된 이름에 연결된 값을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-177">Retrieves the value associated with the specified name, in the specified registry key.</span></span> <span data-ttu-id="803c8-178">지정된 키에 해당 이름이 없으면 사용자가 제공한 기본값이 반환되고, 지정된 키가 없으면 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-178">If the name is not found in the specified key, returns a default value that you provide, or <see langword="null" /> if the specified key does not exist.</span></span></summary>
        <returns><span data-ttu-id="803c8-179"><paramref name="keyName" />에 지정된 하위 키가 없으면 <see langword="null" />이 반환되고, 그렇지 않으면 <paramref name="valueName" />과 연결된 값이 반환됩니다. <paramref name="defaultValue" />이 없으면 <paramref name="valueName" />가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-179"><see langword="null" /> if the subkey specified by <paramref name="keyName" /> does not exist; otherwise, the value associated with <paramref name="valueName" />, or <paramref name="defaultValue" /> if <paramref name="valueName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-180">문자열 `valueName` 대/소문자 구분 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-180">The string `valueName` is not case-sensitive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-181">레지스트리 키 이름과 연결 된 하나의 값을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-181">A registry key can contain one value that is not associated with any name.</span></span> <span data-ttu-id="803c8-182">레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열 이름 대신 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-182">When this unnamed value is displayed in the registry editor, the string "(Default)" appears instead of a name.</span></span> <span data-ttu-id="803c8-183">명명 되지 않은 값이 검색을 지정 하거나 `null` 이거나 빈 문자열 ("")에 대 한 `valuName`합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-183">To retrieve this unnamed value, specify either `null` or the empty string ("") for `valuName`.</span></span>  
  
 <span data-ttu-id="803c8-184">유효한 루트 이름을 HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG를 및 HKEY_DYN_DATA입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-184">Valid root names are HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</span></span> <span data-ttu-id="803c8-185">예를 들어, Visual Basic "HKEY_CURRENT_USER\MyTestKey" 문자열 "MyTestKey" HKEY_CURRENT_USER 루트에 있는 하위 키에 대 한 키/값 쌍에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-185">For example, in Visual Basic the string "HKEY_CURRENT_USER\MyTestKey" accesses key/value pairs for the subkey "MyTestKey" in the HKEY_CURRENT_USER root.</span></span>  
  
 <span data-ttu-id="803c8-186">경우는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 가능한 문자열 값을 검색 하는 메서드 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)을 로컬 환경에서 데이터를 사용 하 여 환경 문자열을 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-186">When the <xref:Microsoft.Win32.RegistryKey.GetValue%2A> method retrieves expandable string values (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), it expands environment strings using data from the local environment.</span></span> <span data-ttu-id="803c8-187">환경 변수에 대 한 확장 참조를 포함 하는 값을 문자열로 저장 된 경우 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), 아니라는 확장 가능한 문자열 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> 확장 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-187">If a value containing expandable references to environment variables has been stored as a string (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), rather than as an expandable string (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> does not expand it.</span></span> <span data-ttu-id="803c8-188">호출 하 여 검색 한 후에 이러한 문자열을 확장할 수 있습니다는 <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="803c8-188">You can expand such a string after it has been retrieved by calling the <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-189">HKEY_PERFORMANCE_DATA에서 데이터를 검색 하는 권장된 방법은 사용 하는 것은 <xref:System.Diagnostics.PerformanceCounter> 클래스 보다는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="803c8-189">The recommended way to retrieve data from HKEY_PERFORMANCE_DATA is to use the <xref:System.Diagnostics.PerformanceCounter> class rather than the <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="803c8-190"><xref:Microsoft.Win32.Registry.GetValue%2A> 하 고 <xref:Microsoft.Win32.Registry.SetValue%2A> 메서드를 열고 레지스트리 키의 메서드 뿐 아니라 수행 하지 않으므로 하므로 사용 될 때마다는 <xref:Microsoft.Win32.RegistryKey> 많은 수의 값을 액세스 하는 경우 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-190">The <xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods open and close registry keys each time they are used, so they do not perform as well as the methods of the <xref:Microsoft.Win32.RegistryKey> class if you access a large number of values.</span></span>  
  
 <span data-ttu-id="803c8-191"><xref:Microsoft.Win32.RegistryKey> 또한 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키를 삭제 하는 액세스 제어 목록 (ACL)을 추가할 수 있도록 하는 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-191"><xref:Microsoft.Win32.RegistryKey> also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-192">다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-192">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="803c8-193">예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="803c8-193">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="803c8-194">사용자가 레지스트리 키를 읽는 데 필요한 사용 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-194">The user does not have the permissions required to read from the registry key.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="803c8-195">지정된 값이 포함된 <see cref="T:Microsoft.Win32.RegistryKey" />가 삭제 표시된 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-195">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="803c8-196"><paramref name="keyName" />이 유효한 레지스트리 루트로 시작하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-196"><paramref name="keyName" /> does not begin with a valid registry root.</span></span></exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission"><span data-ttu-id="803c8-197">레지스트리에서 읽을 수</span><span class="sxs-lookup"><span data-stu-id="803c8-197">to read from the registry.</span></span> <span data-ttu-id="803c8-198">연결 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="803c8-198">Associated enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="803c8-199">형식 reg_expand_sz와의 레지스트리 키를 읽을 수</span><span class="sxs-lookup"><span data-stu-id="803c8-199">to read a registry key of type REG_EXPAND_SZ.</span></span> <span data-ttu-id="803c8-200">연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="803c8-200">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-201">로컬 컴퓨터에 대한 구성 데이터가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-201">Contains the configuration data for the local machine.</span></span> <span data-ttu-id="803c8-202">이 필드는 Windows 레지스트리 기본 키 HKEY_LOCAL_MACHINE을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-202">This field reads the Windows registry base key HKEY_LOCAL_MACHINE.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-203">`LocalMachine` 5 개의 키를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-203">`LocalMachine` contains five keys:</span></span>  
  
 <span data-ttu-id="803c8-204">하드웨어</span><span class="sxs-lookup"><span data-stu-id="803c8-204">Hardware</span></span>  
 <span data-ttu-id="803c8-205">컴퓨터의 실제 하드웨어를 디바이스 드라이버는 해당 하드웨어 및 매핑 및 사용자 모드 코드를 사용 하 여 커널 모드 드라이버를 연결 하는 관련된 데이터를 사용 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-205">Describes the physical hardware in the computer, the way device drivers use that hardware, and mappings and related data that link kernel-mode drivers with user-mode code.</span></span> <span data-ttu-id="803c8-206">이 키의 모든 데이터에는 시스템 시작 될 때마다 다시 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-206">All data in this key is recreated each time the system is started.</span></span> <span data-ttu-id="803c8-207">하위 키를 설명 하는 실제 컴퓨터 하드웨어를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-207">The Description subkey describes the actual computer hardware.</span></span> <span data-ttu-id="803c8-208">DeviceMap 하위 키 형식 드라이버의 특정 클래스의 기타 데이터를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-208">The DeviceMap subkey contains miscellaneous data in formats specific to particular classes of drivers.</span></span> <span data-ttu-id="803c8-209">디바이스 드라이버는 하드웨어 리소스를 클레임 ResourceMap 하위 키를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-209">The ResourceMap subkey describes which device drivers claim which hardware resources.</span></span> <span data-ttu-id="803c8-210">Windows NT 진단을 프로그램 (Winmsdp.exe)는 읽기 쉬운 형태로 내용에 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-210">The Windows NT Diagnostics program (Winmsdp.exe) can report on its contents in an easy-to-read form.</span></span>  
  
 <span data-ttu-id="803c8-211">SAM</span><span class="sxs-lookup"><span data-stu-id="803c8-211">SAM</span></span>  
 <span data-ttu-id="803c8-212">디렉터리 서비스 데이터베이스의 사용자 및 그룹 계정 및 Windows 2000 Server의 도메인에 대 한 보안 정보 (SAM는 디렉터리 서비스 데이터베이스 라는 보안 계정 관리자).</span><span class="sxs-lookup"><span data-stu-id="803c8-212">The directory services database of security information for user and group accounts, and for the domains in Windows 2000 Server (SAM is the Security Account Manager, known as the directory services database).</span></span>  
  
 <span data-ttu-id="803c8-213">보안</span><span class="sxs-lookup"><span data-stu-id="803c8-213">Security</span></span>  
 <span data-ttu-id="803c8-214">특정 사용자 권한 같은 로컬 보안 정책을 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-214">Contains the local security policy, such as specific user rights.</span></span> <span data-ttu-id="803c8-215">이 키는 Windows 2000 보안 하위 시스템에 의해서만 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-215">This key is used only by the Windows 2000 security subsystem.</span></span>  
  
 <span data-ttu-id="803c8-216">소프트웨어</span><span class="sxs-lookup"><span data-stu-id="803c8-216">Software</span></span>  
 <span data-ttu-id="803c8-217">컴퓨터별 소프트웨어 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-217">The per-computer software database.</span></span> <span data-ttu-id="803c8-218">이 키는 다양 한 항목의 기타 구성 데이터와 함께 로컬 컴퓨터에 설치 된 소프트웨어에 대 한 데이터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-218">This key contains data about software installed on the local computer, along with various items of miscellaneous configuration data.</span></span>  
  
 <span data-ttu-id="803c8-219">시스템</span><span class="sxs-lookup"><span data-stu-id="803c8-219">System</span></span>  
 <span data-ttu-id="803c8-220">시스템 시작, 디바이스 드라이버 로드, Windows 2000 서비스 및 운영 체제 동작을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-220">Controls system startup, device driver loading, Windows 2000 services, and operating system behavior.</span></span>  
  
 <span data-ttu-id="803c8-221">아래와 유사한 데이터가 있는 경우 규칙에 따라 <xref:Microsoft.Win32.Registry.CurrentUser> 아래에서 <xref:Microsoft.Win32.Registry.LocalMachine>, 데이터를 <xref:Microsoft.Win32.Registry.CurrentUser> 우선적으로 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-221">By convention, if similar data exists under <xref:Microsoft.Win32.Registry.CurrentUser> and under <xref:Microsoft.Win32.Registry.LocalMachine>, the data in <xref:Microsoft.Win32.Registry.CurrentUser> takes precedence.</span></span> <span data-ttu-id="803c8-222">그러나이 키의 값 수도 확장 대신 대체 Registry.LocalMachine의 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-222">However, values in this key can also extend (rather than replace) data in Registry.LocalMachine.</span></span> <span data-ttu-id="803c8-223">또한 일부 항목 (예: 디바이스 드라이버 항목 로드 중)는 Registry.LocalMachine 외부에서 발생 하는 경우에 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-223">Also, some items (such as device driver loading entries) are meaningless if they occur outside of Registry.LocalMachine.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-224">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-224">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-225">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-225">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-226">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-226">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-227">소프트웨어 구성 요소에 대한 성능 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-227">Contains performance information for software components.</span></span> <span data-ttu-id="803c8-228">이 필드는 Windows 레지스트리 기본 키 HKEY_PERFORMANCE_DATA를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-228">This field reads the Windows registry base key HKEY_PERFORMANCE_DATA.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-229">각 소프트웨어 구성 요소는 카운터를 설치 하 고 실행 하는 동안 카운터 데이터를 기록 하는 경우 해당 개체에 대 한 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-229">Each software component creates keys for its objects, counters when it is installed, and writes counter data while it is executing.</span></span> <span data-ttu-id="803c8-230">에 액세스할 때 처럼 다른 레지스트리 데이터를 사용 하 여이 데이터를 액세스할 수는 <xref:Microsoft.Win32.RegistryKey> 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-230">You can access this data as you would access any other registry data, using the <xref:Microsoft.Win32.RegistryKey> functions.</span></span>  
  
 <span data-ttu-id="803c8-231">성능 데이터를 수집 하려면 레지스트리를 사용 하지만 데이터 레지스트리 데이터베이스에 저장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-231">Although you use the registry to collect performance data, the data is not stored in the registry database.</span></span> <span data-ttu-id="803c8-232">대신,이 키를 사용 하 여 레지스트리를 액세스 하는 적절 한 시스템 개체 관리자에서 데이터를 수집 하도록 시스템에 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-232">Instead, accessing the registry with this key causes the system to collect the data from the appropriate system object managers.</span></span>  
  
 <span data-ttu-id="803c8-233">로컬 시스템에서 성능 데이터를 가져오려면는 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Registry.PerformanceData 키를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="803c8-233">To obtain performance data from the local system, use the <xref:Microsoft.Win32.RegistryKey.GetValue%2A> method, with the Registry.PerformanceData key.</span></span> <span data-ttu-id="803c8-234">첫 번째 호출 (필요가 없습니다를 명시적으로 키를 먼저 열어야) 키를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-234">The first call opens the key (you do not need to explicitly open the key first).</span></span> <span data-ttu-id="803c8-235">그러나 사용 해야는 <xref:Microsoft.Win32.RegistryKey.Close%2A> 메서드를 성능 데이터 가져오기 작업을 마쳤으면 키에 대 한 핸들을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-235">However, be sure to use the <xref:Microsoft.Win32.RegistryKey.Close%2A> method to close the handle to the key when you are finished obtaining performance data.</span></span> <span data-ttu-id="803c8-236">사용자는 설치 하거나 해당 성능 데이터를 사용 하는 동안 소프트웨어 구성 요소를 제거할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-236">The user cannot install or remove a software component while its performance data is in use.</span></span>  
  
 <span data-ttu-id="803c8-237">원격 시스템에서 성능 데이터를 가져오려면 사용 해야 합니다는 <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> 메서드를 원격 시스템 및 Registry.PerformanceData 키의 컴퓨터 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-237">To obtain performance data from a remote system, you must use the <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> method, with the computer name of the remote system and the Registry.PerformanceData key.</span></span> <span data-ttu-id="803c8-238">이 호출은 원격 시스템에 대 한 성능 데이터를 나타내는 키를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-238">This call retrieves a key representing the performance data for the remote system.</span></span> <span data-ttu-id="803c8-239">데이터를 검색 하려면 호출 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Registry.PerformanceData 키 보다는이 키를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-239">To retrieve the data, call <xref:Microsoft.Win32.RegistryKey.GetValue%2A> using this key, rather than the Registry.PerformanceData key.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-240">Windows Server 2003에서 사용자 Performance Monitor Users 그룹에이 기본 키의 하위 키에 액세스 하기 위해 속해야 최소한 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-240">On Windows Server 2003, a user must at least belong to the Performance Monitor Users group in order to access subkeys of this base key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-241">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-241">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-242">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-242">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-243">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-243">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span> <span data-ttu-id="803c8-244">이 예제에서는 성능 데이터가 될 수 있으므로 없는 결과 반환할 종종 수 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-244">Note that this example can often return no results, since there might be no performance data.</span></span>  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="803c8-245">레지스트리 키에서 이름/값 쌍의 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-245">Sets the value of a name/value pair in a registry key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="803c8-246">다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-246">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="803c8-247">예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="803c8-247">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="803c8-248">"HKEY_CURRENT_USER"와 같이 유효한 레지스트리 루트로 시작하는 키의 전체 레지스트리 경로입니다. </span><span class="sxs-lookup"><span data-stu-id="803c8-248">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</span></span></param>
        <param name="valueName"><span data-ttu-id="803c8-249">이름/값 쌍의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-249">The name of the name/value pair.</span></span></param>
        <param name="value"><span data-ttu-id="803c8-250">저장할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-250">The value to be stored.</span></span></param>
        <summary><span data-ttu-id="803c8-251">지정된 레지스트리 키에 지정된 이름/값 쌍을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-251">Sets the specified name/value pair on the specified registry key.</span></span> <span data-ttu-id="803c8-252">지정된 키가 없으면 키가 새로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-252">If the specified key does not exist, it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-253">그러나부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 `valueName` 매개 변수는 최대 255 자 제한 되어 더 이상는 `keyName` 계속 255 자로 제한 하도록 하는 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-253">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the `valueName` parameter is no longer restricted to a maximum of 255 characters; however, the `keyName` parameter continues to have the 255-character restriction.</span></span>  
  
 <span data-ttu-id="803c8-254">각 레지스트리 키에 저장할 수 많은 값을 사용 해야는 `valueName` 매개 변수를 설정 하려면 특정 값을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-254">Because many values can be stored in each key in the registry, you must use the `valueName` parameter to specify the particular value you want to set.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-255">레지스트리 키 이름과 연결 된 하나의 값을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-255">A registry key can contain one value that is not associated with any name.</span></span> <span data-ttu-id="803c8-256">레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열 이름 대신 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-256">When this unnamed value is displayed in the registry editor, the string "(Default)" appears instead of a name.</span></span> <span data-ttu-id="803c8-257">명명 되지 않은 값을 설정 하려면 하나를 지정 `null` 이거나 빈 문자열 ("")에 대 한 `valueName`합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-257">To set this unnamed value, specify either `null` or the empty string ("") for `valueName`.</span></span>  
  
 <span data-ttu-id="803c8-258">하는 경우 `valueName` 존재 하지 않는 키의 생성 및 연결 된 값으로 설정 됩니다 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-258">If `valueName` does not exist in the key, it is created and the associated value is set to `value`.</span></span>  
  
 <span data-ttu-id="803c8-259">경우 `keyName` 존재 하지 않는 하위 키를 지정 된 하위 키 지정된 된 루트에 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-259">If `keyName` specifies a subkey that does not exist, the subkey is created in the specified root.</span></span> <span data-ttu-id="803c8-260">예를 들어, Visual Basic에서 문자열 "HKEY_CURRENT_USER\MyTestKey" HKEY_CURRENT_USER 루트에 "MyTestKey" 하위 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-260">For example, in Visual Basic the string "HKEY_CURRENT_USER\MyTestKey" creates the subkey "MyTestKey" in the HKEY_CURRENT_USER root.</span></span> <span data-ttu-id="803c8-261">"HKEY_CURRENT_USER\MyTestKey\Key2\Key3" 문자열 "MyTestKey", "MyTestKey\Key2" 및 "MyTestKey\Key2\Key3" 중첩 된 하위 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-261">The string "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" creates the nested subkeys "MyTestKey", "MyTestKey\Key2", and "MyTestKey\Key2\Key3".</span></span>  
  
 <span data-ttu-id="803c8-262">유효한 루트 이름 HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG를 및 HKEY_DYN_DATA를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-262">Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-263"><xref:Microsoft.Win32.Registry.SetValue%2A> 메서드 레지스트리 키를 열고 값을 설정 하 고 호출 될 때마다 키를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-263">The <xref:Microsoft.Win32.Registry.SetValue%2A> method opens a registry key, sets the value, and closes the key each time it is called.</span></span> <span data-ttu-id="803c8-264">많은 수의 값을 수정 해야 하는 경우는 <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 메서드는 더 나은 성능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-264">If you need to modify a large number of values, the <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> method might provide better performance.</span></span> <span data-ttu-id="803c8-265"><xref:Microsoft.Win32.RegistryKey> 클래스도 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키를 삭제 하는 액세스 제어 목록 (ACL)을 추가할 수 있는 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-265">The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
 <span data-ttu-id="803c8-266">이 오버 로드 <xref:Microsoft.Win32.Registry.SetValue%2A> 64 비트 정수를 문자열로 저장 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="803c8-266">This overload of <xref:Microsoft.Win32.Registry.SetValue%2A> stores 64-bit integers as strings (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>).</span></span> <span data-ttu-id="803c8-267">64 비트 숫자를 저장할 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> 값을 사용 하 여를 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 메서드 오버 로드.</span><span class="sxs-lookup"><span data-stu-id="803c8-267">To store 64-bit numbers as <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> values, use the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload.</span></span>  
  
 <span data-ttu-id="803c8-268">이 오버 로드 <xref:Microsoft.Win32.Registry.SetValue%2A> 모든 문자열 값으로 저장 <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> 개체를 확장할 수 있는 환경 변수에 참조를 포함 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-268">This overload of <xref:Microsoft.Win32.Registry.SetValue%2A> stores all string values as <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> objects, even if they contain expandable references to environment variables.</span></span> <span data-ttu-id="803c8-269">문자열 값으로 확장할 수 있는 문자열을 저장 하려면 (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)를 사용 하 여를 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-269">To save string values as expandable strings (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), use the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload.</span></span>  
  
 <span data-ttu-id="803c8-270">이 오버 로드는 호출에 해당 하는 <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> 메서드 오버 로드 <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-270">This overload is equivalent to calling the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload with <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-271">Windows 98 및 Windows Millennium Edition (Windows Me), 레지스트리 유니코드 아니며 일부 유니코드 문자는 모든 코드 페이지에 대해 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-271">On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages.</span></span> <span data-ttu-id="803c8-272">현재 코드 페이지에 대 한 잘못 된 유니코드 문자가 가장 사용 가능한 일치 항목으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-272">A Unicode character that is invalid for the current code page is replaced by the best available match.</span></span> <span data-ttu-id="803c8-273">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-273">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-274">다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-274">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="803c8-275">예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="803c8-275">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="803c8-276"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-276"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="803c8-277"><paramref name="keyName" />이 유효한 레지스트리 루트로 시작하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-277"><paramref name="keyName" /> does not begin with a valid registry root.</span></span>  
  
<span data-ttu-id="803c8-278">또는</span><span class="sxs-lookup"><span data-stu-id="803c8-278">-or-</span></span> 
 <span data-ttu-id="803c8-279"><paramref name="keyName" />이 최대 허용 길이(255자)보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-279"><paramref name="keyName" /> is longer than the maximum length allowed (255 characters).</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="803c8-280">루트 수준 노드와 같이 <see cref="T:Microsoft.Win32.RegistryKey" />가 읽기 전용이므로 여기에 쓸 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-280">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and thus cannot be written to; for example, it is a root-level node.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="803c8-281">사용자가 레지스트리 키를 만들거나 수정하는 데 필요한 사용 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-281">The user does not have the permissions required to create or modify registry keys.</span></span></exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission"><span data-ttu-id="803c8-282">존재 하는 경우 지정된 된 레지스트리 키를 수정 하려면 또는 아직 없는 경우 레지스트리 키를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-282">to modify the specified registry key if it exists, or to create the registry key if it does not already exist.</span></span> <span data-ttu-id="803c8-283">연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></span><span class="sxs-lookup"><span data-stu-id="803c8-283">Associated enumerations: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="803c8-284">"HKEY_CURRENT_USER"와 같이 유효한 레지스트리 루트로 시작하는 키의 전체 레지스트리 경로입니다. </span><span class="sxs-lookup"><span data-stu-id="803c8-284">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</span></span></param>
        <param name="valueName"><span data-ttu-id="803c8-285">이름/값 쌍의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-285">The name of the name/value pair.</span></span></param>
        <param name="value"><span data-ttu-id="803c8-286">저장할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-286">The value to be stored.</span></span></param>
        <param name="valueKind"><span data-ttu-id="803c8-287">데이터를 저장할 때 사용할 레지스트리 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-287">The registry data type to use when storing the data.</span></span></param>
        <summary><span data-ttu-id="803c8-288">지정된 레지스트리 데이터 형식을 사용하여 지정된 레지스트리 키에 이름/값 쌍을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-288">Sets the name/value pair on the specified registry key, using the specified registry data type.</span></span> <span data-ttu-id="803c8-289">지정된 키가 없으면 키가 새로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-289">If the specified key does not exist, it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-290">그러나부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 `valueName` 매개 변수는 최대 255 자 제한 되어 더 이상는 `keyName` 매개 변수는 255 자 제한을 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-290">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the `valueName` parameter is no longer restricted to a maximum of 255 characters; however, the `keyName` parameter continues have the 255-character restriction.</span></span>  
  
 <span data-ttu-id="803c8-291">각 레지스트리 키에 저장할 수 많은 값을 사용 해야는 `valueName` 매개 변수를 설정 하려면 특정 값을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-291">Because many values can be stored in each key in the registry, you must use the `valueName` parameter to specify the particular value you want to set.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-292">레지스트리 키 이름과 연결 된 하나의 값을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-292">A registry key can contain one value that is not associated with any name.</span></span> <span data-ttu-id="803c8-293">레지스트리 편집기에서 명명 되지 않은 값이 표시 되 면 "(기본값)" 문자열 이름 대신 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-293">When this unnamed value is displayed in the registry editor, the string "(Default)" appears instead of a name.</span></span> <span data-ttu-id="803c8-294">명명 되지 않은 값을 설정 하려면 하나를 지정 `null` 이거나 빈 문자열 ("")에 대 한 `valueName`합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-294">To set this unnamed value, specify either `null` or the empty string ("") for `valueName`.</span></span>  
  
 <span data-ttu-id="803c8-295">하는 경우 `valueName` 존재 하지 않는 키의 생성 및 연결 된 값으로 설정 됩니다 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-295">If `valueName` does not exist in the key, it is created and the associated value is set to `value`.</span></span>  
  
 <span data-ttu-id="803c8-296">경우 `keyName` 존재 하지 않는 하위 키를 지정 된 하위 키 지정된 된 루트에 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-296">If `keyName` specifies a subkey that does not exist, the subkey is created in the specified root.</span></span> <span data-ttu-id="803c8-297">예를 들어, Visual Basic에서 문자열 "HKEY_CURRENT_USER\MyTestKey" HKEY_CURRENT_USER 루트에 "MyTestKey" 하위 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-297">For example, in Visual Basic the string "HKEY_CURRENT_USER\MyTestKey" creates the subkey "MyTestKey" in the HKEY_CURRENT_USER root.</span></span> <span data-ttu-id="803c8-298">"HKEY_CURRENT_USER\MyTestKey\Key2\Key3" 문자열 "MyTestKey", "MyTestKey\Key2" 및 "MyTestKey\Key2\Key3" 중첩 된 하위 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-298">The string "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" creates the nested subkeys "MyTestKey", "MyTestKey\Key2", and "MyTestKey\Key2\Key3".</span></span>  
  
 <span data-ttu-id="803c8-299">유효한 루트 이름 HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG를 및 HKEY_DYN_DATA를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-299">Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-300"><xref:Microsoft.Win32.Registry.SetValue%2A> 메서드 레지스트리 키를 열고 값을 설정 하 고 호출 될 때마다 키를 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-300">The <xref:Microsoft.Win32.Registry.SetValue%2A> method opens a registry key, sets the value, and closes the key each time it is called.</span></span> <span data-ttu-id="803c8-301">많은 수의 값을 수정 해야 하는 경우는 <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> 메서드는 더 나은 성능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-301">If you need to modify a large number of values, the <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> method might provide better performance.</span></span> <span data-ttu-id="803c8-302"><xref:Microsoft.Win32.RegistryKey> 클래스도 레지스트리 키를 검색 하기 전에 데이터 형식의 값을 테스트 하 고 키를 삭제 하는 액세스 제어 목록 (ACL)을 추가할 수 있는 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-302">The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</span></span>  
  
 <span data-ttu-id="803c8-303">경우 지정된 된 형식의 `value` 지정 된 일치 하지 않습니다 `valueKind`, 데이터 일 수 없습니다 및 변환 <xref:System.ArgumentException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-303">If the type of the specified `value` does not match the specified `valueKind`, and the data cannot be converted, <xref:System.ArgumentException> is thrown.</span></span> <span data-ttu-id="803c8-304">예를 들어, 저장할 수 있습니다는 <xref:System.Int64?displayProperty=nameWithType> 으로 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, 해당 값이 최대값 보다 작은 경우에을 <xref:System.Int32?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-304">For example, you can store a <xref:System.Int64?displayProperty=nameWithType> as a <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, but only if its value is less than the maximum value of a <xref:System.Int32?displayProperty=nameWithType>.</span></span> <span data-ttu-id="803c8-305">단일 문자열 값으로 저장할 수 없습니다는 <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-305">You cannot store a single string value as a <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-306">Boxed 값에 대 한 전달 되 면 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> 또는 <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, 변환이 이루어집니다 고정 문화권을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-306">If boxed values are passed for <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> or <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, the conversion is done using the invariant culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="803c8-307">Windows 98 및 Windows Millennium Edition (Windows Me), 레지스트리 유니코드 아니며 일부 유니코드 문자는 모든 코드 페이지에 대해 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-307">On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages.</span></span> <span data-ttu-id="803c8-308">현재 코드 페이지에 대 한 잘못 된 유니코드 문자가 가장 사용 가능한 일치 항목으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-308">A Unicode character that is invalid for the current code page is replaced by the best available match.</span></span> <span data-ttu-id="803c8-309">예외가 throw되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-309">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-310">다음 코드 예제를 수행 하 고 다음 검색 하 고 값을 표시 하는 대로 키를 만드는 예제 키에서 여러 데이터 형식의 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-310">The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values.</span></span> <span data-ttu-id="803c8-311">예제에서는 저장 하 고 기본 이름이 없는 이름/값 쌍을 사용 하 여 검색 `defaultValue` 이름/값 쌍을 존재 하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="803c8-311">The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.</span></span>  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="803c8-312"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-312"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="803c8-313"><paramref name="keyName" />이 유효한 레지스트리 루트로 시작하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-313"><paramref name="keyName" /> does not begin with a valid registry root.</span></span>  
  
<span data-ttu-id="803c8-314">또는</span><span class="sxs-lookup"><span data-stu-id="803c8-314">-or-</span></span> 
 <span data-ttu-id="803c8-315"><paramref name="keyName" />이 최대 허용 길이(255자)보다 긴 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-315"><paramref name="keyName" /> is longer than the maximum length allowed (255 characters).</span></span>  
  
<span data-ttu-id="803c8-316">또는</span><span class="sxs-lookup"><span data-stu-id="803c8-316">-or-</span></span> 
<span data-ttu-id="803c8-317"><paramref name="value" />의 형식이 <paramref name="valueKind" />에 지정된 레지스트리 데이터 형식과 일치하지 않아 데이터가 올바르게 변환되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-317">The type of <paramref name="value" /> did not match the registry data type specified by <paramref name="valueKind" />, therefore the data could not be converted properly.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="803c8-318"><see cref="T:Microsoft.Win32.RegistryKey" />가 읽기 전용이므로 쓸 수 없는 경우. 예를 들어, 루트 수준 노드이거나 쓰기 권한으로 키를 열지 않은 경우일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-318">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and thus cannot be written to; for example, it is a root-level node, or the key has not been opened with write access.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="803c8-319">사용자가 레지스트리 키를 만들거나 수정하는 데 필요한 사용 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="803c8-319">The user does not have the permissions required to create or modify registry keys.</span></span></exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission"><span data-ttu-id="803c8-320">존재 하는 경우 지정된 된 레지스트리 키를 수정 하려면 또는 아직 없는 경우 레지스트리 키를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-320">to modify the specified registry key if it exists, or to create the registry key if it does not already exist.</span></span> <span data-ttu-id="803c8-321">연관 된 열거형: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></span><span class="sxs-lookup"><span data-stu-id="803c8-321">Associated enumerations: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="803c8-322">기본 사용자 구성에 대한 정보가 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-322">Contains information about the default user configuration.</span></span> <span data-ttu-id="803c8-323">이 필드는 Windows 레지스트리 기본 키 HKEY_USERS를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-323">This field reads the Windows registry base key HKEY_USERS.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="803c8-324">이 키는 컴퓨터의 각 사용자에 대 한 분기를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-324">This key contains a branch for each user of the computer.</span></span> <span data-ttu-id="803c8-325">사용자 기본 설정을 변경 되지 않은 경우 기본 구성은 로컬 컴퓨터에서 새 사용자 및 기본 현재 사용자에 대해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-325">The default configuration is supplied for new users on the local computer and for the default current user if the user has not changed preferences.</span></span> <span data-ttu-id="803c8-326">때문에 Windows 98 / Registry.Users 지원 ME, 애플리케이션 사용자 관련 정보를 Windows 2000에서 수행 하는 동일한 방식으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-326">Because Windows 98/ME also supports Registry.Users, applications can access the user-specific information the same way they do under Windows 2000.</span></span> <span data-ttu-id="803c8-327">각 사용자의 정보는 로컬 또는 네트워크 서버에 저장할 수 있는 별도 파일에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-327">Each user's information is stored in a separate file, which can be stored locally or on a network server.</span></span> <span data-ttu-id="803c8-328">Windows 98 설정을 사용자와 다른 한 컴퓨터에서 이동할 수 있도록 사용자의 현재 시스템에이 파일을 복사할 수 나 /입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-328">Windows 98/ME can copy this file to the user's current system so that settings can move from one computer to another with the user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="803c8-329">이 키의 하위 키를 검색 하는 방법에 설명 하 고 화면에 해당 이름을 출력 하는 다음 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-329">The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen.</span></span> <span data-ttu-id="803c8-330">사용 하 여는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> 메서드를 원하는 특정 하위 키의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-330">Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest.</span></span> <span data-ttu-id="803c8-331">다른 작업에 사용할 수 있습니다 <xref:Microsoft.Win32.RegistryKey> 해당 키를 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="803c8-331">You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.</span></span>  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>