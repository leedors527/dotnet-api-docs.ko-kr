<Type Name="OrderablePartitioner&lt;TSource&gt;" FullName="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4295a3693c36941120b6d7f8ca16a522af93939a" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58699521" /></Metadata><TypeSignature Language="C#" Value="public abstract class OrderablePartitioner&lt;TSource&gt; : System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit OrderablePartitioner`1&lt;TSource&gt; extends System.Collections.Concurrent.Partitioner`1&lt;!TSource&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.OrderablePartitioner`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class OrderablePartitioner(Of TSource)&#xA;Inherits Partitioner(Of TSource)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSource&gt;&#xA;public ref class OrderablePartitioner abstract : System::Collections::Concurrent::Partitioner&lt;TSource&gt;" />
  <TypeSignature Language="F#" Value="type OrderablePartitioner&lt;'Source&gt; = class&#xA;    inherit Partitioner&lt;'Source&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSource" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.Concurrent.Partitioner&lt;TSource&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="TSource">TSource</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TSource">컬렉션에 있는 요소의 형식입니다.</typeparam>
    <summary>정렬할 수 있는 데이터 소스를 여러 개의 파티션으로 분할하는 특정 방법을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스의 구현은 적절 한 방식으로 키-값 쌍으로 요소를 정렬 하는 일을 담당 합니다. 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 한 번에 하나의 요소를 반환 하는 정렬할 수 있는 파티 셔 너를 구현 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Collections.Concurrent.OrderablePartitioner#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.orderablepartitioner/cs/orderablepartitioner.cs#1)]
 [!code-vb[System.Collections.Concurrent.OrderablePartitioner#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.orderablepartitioner/vb/orderablepartitioner.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>모든 public 멤버나 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 는 스레드로부터 안전 하며 여러 스레드에서 동시에 호출할 수 있습니다.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
    <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected OrderablePartitioner (bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (keysOrderedInEachPartition As Boolean, keysOrderedAcrossPartitions As Boolean, keysNormalized As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; OrderablePartitioner(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; : bool * bool * bool -&gt; System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt;" Usage="new System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; (keysOrderedInEachPartition, keysOrderedAcrossPartitions, keysNormalized)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keysOrderedInEachPartition" Type="System.Boolean" />
        <Parameter Name="keysOrderedAcrossPartitions" Type="System.Boolean" />
        <Parameter Name="keysNormalized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="keysOrderedInEachPartition">각 파티션에 있는 요소가 키가 증가하는 순서로 반환되는지 여부를 나타냅니다.</param>
        <param name="keysOrderedAcrossPartitions">순서가 빠른 파티션의 요소가 순서가 늦은 파티션의 요소보다 항상 먼저 오는지 여부를 나타냅니다. true이면 파티션 0의 모든 요소가 파티션 1의 모든 요소보다 작은 순서 키를 갖고, 파티션 1의 모든 요소가 파티션 2의 모든 요소보다 작은 순서 키를 갖는 식으로 처리됩니다.</param>
        <param name="keysNormalized">키를 정규화할지 여부를 나타냅니다. true인 경우 모든 순서 키가 [0 . numberOfElements-1] 범위의 서로 다른 정수입니다. false이면 순서 키가 서로 다르지만 절대 값이 아니라 상대적인 순서만 고려합니다.</param>
        <summary>인덱스 키에 대해 지정된 제약 조건을 사용하여 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 클래스를 초기화하기 위해 파생 클래스의 생성자에서 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicPartitions">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;TSource&gt; GetDynamicPartitions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;!TSource&gt; GetDynamicPartitions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDynamicPartitions () As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ GetDynamicPartitions();" />
      <MemberSignature Language="F#" Value="override this.GetDynamicPartitions : unit -&gt; seq&lt;'Source&gt;" Usage="orderablePartitioner.GetDynamicPartitions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 컬렉션을 여러 파티션으로 분할할 수 있는 개체를 만듭니다.</summary>
        <returns>내부 데이터 소스에 대한 파티션을 만들 수 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 개체를 구현 하는 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 인터페이스입니다. 호출 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 개체의 시퀀스에 대해 다른 파티션에 만듭니다.  
  
 와 동일한 동작을 제공 하는 기본 구현은 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> 제외 하 고 반환 된 파티션 집합 요소에 대 한 키를 제공 하지 않습니다.  
  
 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A> 메서드는 경우에 지원 되는 <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> 속성이 true를 반환 합니다.  
  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">동적 분할은 기본 클래스에서 지원되지 않습니다. 파생된 클래스에서 구현되어야 합니다.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
    <Member MemberName="GetOrderableDynamicPartitions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;long,TSource&gt;&gt; GetOrderableDynamicPartitions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;int64, !TSource&gt;&gt; GetOrderableDynamicPartitions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOrderableDynamicPartitions () As IEnumerable(Of KeyValuePair(Of Long, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;long, TSource&gt;&gt; ^ GetOrderableDynamicPartitions();" />
      <MemberSignature Language="F#" Value="abstract member GetOrderableDynamicPartitions : unit -&gt; seq&lt;System.Collections.Generic.KeyValuePair&lt;int64, 'Source&gt;&gt;&#xA;override this.GetOrderableDynamicPartitions : unit -&gt; seq&lt;System.Collections.Generic.KeyValuePair&lt;int64, 'Source&gt;&gt;" Usage="orderablePartitioner.GetOrderableDynamicPartitions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.Int64,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 컬렉션을 여러 파티션으로 분할할 수 있는 개체를 만듭니다.</summary>
        <returns>내부 데이터 소스에 대한 파티션을 만들 수 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 개체를 구현 하는 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 인터페이스입니다. 호출 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 개체의 시퀀스에 대해 다른 파티션에 만듭니다.  
  
 각 파티션에 키-값 쌍을 통해 열거자로 표시 됩니다. 쌍의 값은 요소 자체 이며 키 다른 요소에 대해이 요소의 상대 순서를 결정 하는 정수입니다.  
  
 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> 메서드는 경우에 지원 되는 <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> 속성이 true를 반환 합니다.  
  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">동적 분할은 이 파티셔너에서 지원되지 않습니다.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
    <Member MemberName="GetOrderablePartitions">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;long,TSource&gt;&gt;&gt; GetOrderablePartitions (int partitionCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;int64, !TSource&gt;&gt;&gt; GetOrderablePartitions(int32 partitionCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetOrderablePartitions (partitionCount As Integer) As IList(Of IEnumerator(Of KeyValuePair(Of Long, TSource)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IList&lt;System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;long, TSource&gt;&gt; ^&gt; ^ GetOrderablePartitions(int partitionCount);" />
      <MemberSignature Language="F#" Value="abstract member GetOrderablePartitions : int -&gt; System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;int64, 'Source&gt;&gt;&gt;" Usage="orderablePartitioner.GetOrderablePartitions partitionCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.Int64,TSource&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="partitionCount">만들 파티션의 수입니다.</param>
        <summary>기본 컬렉션을 지정된 개수의 정렬할 수 있는 파티션으로 분할합니다.</summary>
        <returns><paramref name="partitionCount" /> 열거자가 포함된 목록입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 파티션에 키-값 쌍을 통해 열거자로 표시 됩니다.  
  
 쌍의 값은 요소 자체 이며 키 데이터 원본에 다른 요소에 대해이 요소의 상대 순서를 결정 하는 정수입니다.  
  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
    <Member MemberName="GetPartitions">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt; GetPartitions (int partitionCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Collections.Generic.IEnumerator`1&lt;!TSource&gt;&gt; GetPartitions(int32 partitionCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPartitions (partitionCount As Integer) As IList(Of IEnumerator(Of TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Collections::Generic::IEnumerator&lt;TSource&gt; ^&gt; ^ GetPartitions(int partitionCount);" />
      <MemberSignature Language="F#" Value="override this.GetPartitions : int -&gt; System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;'Source&gt;&gt;" Usage="orderablePartitioner.GetPartitions partitionCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="partitionCount">만들 파티션의 수입니다.</param>
        <summary>기본 컬렉션을 지정된 개수의 정렬된 파티션으로 분할합니다.</summary>
        <returns><paramref name="partitionCount" /> 열거자가 포함된 목록입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 동일한 동작을 제공 하는 기본 구현은 <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> 제외 하 고 반환 된 파티션 집합 요소에 대 한 키를 제공 하지 않습니다.  
  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
    <Member MemberName="KeysNormalized">
      <MemberSignature Language="C#" Value="public bool KeysNormalized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeysNormalized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeysNormalized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeysNormalized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeysNormalized : bool" Usage="System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt;.KeysNormalized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>순서 키를 정규화할지 여부를 가져옵니다.</summary>
        <value><see langword="true" /> 키를 정규화할지; 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A> 모든 순서 키가 고유한 정수 범위 [0..에서 true를 반환 합니다 numberOfElements-1] 범위의 서로 다른 정수입니다. 속성이 false 이면 순서 키가 고유 수를 반환 하는 경우 다르지만 절대 값이 아니라 해당 상대 순서 고려 합니다.  
  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeysOrderedAcrossPartitions">
      <MemberSignature Language="C#" Value="public bool KeysOrderedAcrossPartitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeysOrderedAcrossPartitions" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeysOrderedAcrossPartitions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeysOrderedAcrossPartitions { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeysOrderedAcrossPartitions : bool" Usage="System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt;.KeysOrderedAcrossPartitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>순서가 빠른 파티션의 요소가 순서가 늦은 파티션의 요소보다 항상 먼저 오는지 여부를 가져옵니다.</summary>
        <value><see langword="true" /> 이전 파티션에 있는 요소가 항상; 늦은 파티션의 요소 보다 먼저 제공 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A> 파티션 0의에서 각 요소에 파티션 1 파티션 1의에서 각 요소에 있는 모든 요소에 파티션 2의 모든 요소 보다 작은 순서 키를 보다 작은 순서 키를 true를 반환 합니다.  
  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
    <Member MemberName="KeysOrderedInEachPartition">
      <MemberSignature Language="C#" Value="public bool KeysOrderedInEachPartition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeysOrderedInEachPartition" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeysOrderedInEachPartition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeysOrderedInEachPartition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeysOrderedInEachPartition : bool" Usage="System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt;.KeysOrderedInEachPartition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>각 파티션에 있는 요소가 키가 증가하는 순서로 생성되는지 여부를 가져옵니다.</summary>
        <value><see langword="true" /> 각 파티션에 있는 요소가 키 증가 하는 순서로 생성 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/96153688-9a01-47c4-8430-909cee9a2887">PLINQ 및 TPL에 대한 사용자 지정 파티셔너</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c7a66677-cb59-4cbf-969a-d2e8fc61a6ce">방법: 작은 루프 본문 속도 개선</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f4410508-cac6-4ba7-bef1-c5e68b2794f3">방법: 정적 개수의 파티션 사용 하 여 파티 셔 너 구현</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c875ad12-a161-43e6-ad1c-3d6927c536a7">방법: 동적 파티션 구현</related>
      </Docs>
    </Member>
  </Members>
</Type>