<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a516bd07714533960843996e6c400673a725ccc2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53503390" /></Metadata><TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ISet&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">해시 집합에 있는 요소의 형식입니다.</typeparam>
    <summary>값 집합을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601> 클래스는 고성능 작업 집합을 제공 합니다. 집합은 중복 된 요소가 들어 있는 컬렉션 요소가 특정 순서 없이 합니다.  
  
> [!NOTE]
>  <xref:System.Collections.Generic.HashSet%601> 구현 합니다 <xref:System.Collections.Generic.IReadOnlyCollection%601> 로 시작 하는 인터페이스를 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; 이전 버전의.NET Framework는 <xref:System.Collections.Generic.HashSet%601> 클래스가이 인터페이스를 구현 하지 않았습니다.  
  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다. <xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.  
  
 합니다 <xref:System.Collections.Generic.HashSet%601> 클래스는 수치 연산 집합의 모델에 기반 하며 고성능 집합 작업의 키에 액세스 하려면 유사한 제공 합니다 <xref:System.Collections.Generic.Dictionary%602> 또는 <xref:System.Collections.Hashtable> 컬렉션입니다. 간단히 말해에서 합니다 <xref:System.Collections.Generic.HashSet%601> 클래스는으로 생각할 수 있습니다를 <xref:System.Collections.Generic.Dictionary%602> 값이 없는 컬렉션입니다.  
  
 <xref:System.Collections.Generic.HashSet%601> 컬렉션은 정렬 되지 않고 중복 요소를 포함할 수 없습니다. 순서 또는 요소 중복 애플리케이션에 대 한 성능 보다 더 중요 한 경우 사용을 고려 합니다 <xref:System.Collections.Generic.List%601> 와 함께 클래스는 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드.  
  
 <xref:System.Collections.Generic.HashSet%601> 여러 수치 연산 집합 더하기 (합집합) 등의 작업을 설정 하 고 집합 빼기를 제공 합니다. 다음 표에 제공 된 <xref:System.Collections.Generic.HashSet%601> 작업 및 해당 하는 수학 합니다.  
  
|HashSet 작업|해당 하는 수학|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|공용 구조체 또는 설정 추가|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|교집합|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|집합 빼기|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|대칭 차이 계산|  
  
 집합 작업 이외에 <xref:System.Collections.Generic.HashSet%601> 클래스 집합의 중복 집합 같은지를 확인 하기 위한 메서드도 제공 및 하위 집합 또는 다른 집합의 상위 집합 인지 합니다.  
  
**.NET framework에만 해당:** 에 대 한 매우 큰 <xref:System.Collections.Generic.HashSet%601> 개체를 설정 하 여 64 비트 시스템에서 2 십억 요소에 최대 용량을 늘릴 수는 `enabled` 특성의 [`<gcAllowVeryLargeObjects>`} (~/docs/framework/configure-apps/file-schema/runtime/ gcallowverylargeobjects-element.md) 구성 요소를 `true` 런타임 환경에서.  
  
 부터 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Collections.Generic.HashSet%601> 구현 클래스는 <xref:System.Collections.Generic.ISet%601> 인터페이스입니다.  
  
## <a name="hashset-and-linq-set-operations"></a>HashSet 및 LINQ 집합 작업  
 LINQ에 대 한 액세스를 제공 합니다 `Distinct`, `Union`, `Intersect` 및 `Except` 구현 하는 모든 데이터 원본에 대 한 작업을 설정 합니다 <xref:System.Collections.IEnumerable> 또는 <xref:System.Linq.IQueryable> 인터페이스.  <xref:System.Collections.Generic.HashSet%601> 집합 작업의 더 큰 적고 더 안정적인 컬렉션을 제공합니다. 예를 들어 <xref:System.Collections.Generic.HashSet%601> 비교와 같은 제공 <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> 고 <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>입니다.  
  
 LINQ의 가장 큰 차이점 작업을 설정 및 <xref:System.Collections.Generic.HashSet%601> operations LINQ 집합 작업 항상 반환할 수 있다는 새 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 반면는 <xref:System.Collections.Generic.HashSet%601> 해당 메서드는 현재 컬렉션을 수정 합니다.  
  
 일반적으로 새 집합을 만들어야 할 경우, 애플리케이션에 제공 된 설정 작업에만 액세스 해야 하는 경우 LINQ를 사용 하 여 설정에서 작업을 <xref:System.Collections.Generic.IEnumerable%601> 컬렉션 또는 배열의 만으로도 충분 합니다. 그러나 애플리케이션에 필요한 추가 설정 작업에 대 한 액세스 또는 바람직하거나 새 컬렉션을 만들 필요가 없으면 사용 하 여는 <xref:System.Collections.Generic.HashSet%601> 클래스입니다.  
  
 다음 표는 <xref:System.Collections.Generic.HashSet%601> 작업 및 해당 하는 LINQ 집합 작업 합니다.  
  
|HashSet 작업|LINQ에 해당|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|제공 되지 않습니다.|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|제공 되지 않습니다.|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|제공 되지 않습니다.|  
  
   
  
## Examples  
 다음 예제에서는 서로 다른 두 집합을 병합 하는 방법에 설명 합니다. 이 예제에서는 두 <xref:System.Collections.Generic.HashSet%601> 개체 이며 각각 홀수 및 짝수 번호를 채웁니다. 세 번째 <xref:System.Collections.Generic.HashSet%601> 개체는 짝수를 포함 하는 집합에서 만들어집니다. 이 예제에서는 호출는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 홀수 집합 세 번째 집합에 추가 하는 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>비어 있으며 집합 형식에 대한 기본 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다. <xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.  
  
 이 생성자는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 예제에서는 만들고 두 값을 채우는 방법을 보여 줍니다. <xref:System.Collections.Generic.HashSet%601> 개체입니다. 이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">해당 요소가 새 집합에 복사되는 컬렉션입니다.</param>
        <summary>집합 형식에 대한 기본 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다. <xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.  
  
 경우 `collection` 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다. 예외가 throw 됩니다. 따라서 결과 집합의 크기가의 크기와 동일 `collection`합니다.  
  
 이 생성자는 (`n`) 작업, 여기서 `n` 의 요소 수를 `collection` 매개 변수.  
  
   
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.Collections.Generic.HashSet%601> 기존 집합을 수집 합니다. 이 예제에서는 두 만들어집니다 홀수 및 짝수 정수를 사용 하 여 각각. 세 번째 <xref:System.Collections.Generic.HashSet%601> 개체는 다음 집합에서 만들어집니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 구현을 사용하려면 <see langword="null" />을(를) 지정합니다.</param>
        <summary>비어 있으며 집합 형식에 대한 지정된 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다. <xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.  
  
 이 생성자는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Collections.Generic.HashSet`1" />의 초기 크기입니다.</param>
        <summary>비어 있지만 <paramref name="capacity" /> 항목에 대한 공간이 예약되어 있고 집합 형식에 대한 기본 같음 비교자를 사용하는 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교적 비용이 많이 드는 크기가 조정 되므로 (해싱하여 필요)의 값을 기반으로 초기 용량을 설정 하 여 크기를 조정할 필요가 최소화 하려고 하는이 `capacity`입니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">해당 요소가 새 집합에 복사되는 컬렉션입니다.</param>
        <param name="comparer">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.EqualityComparer`1" /> 구현을 사용하려면 <see langword="null" />을(를) 지정합니다.</param>
        <summary>집합 형식에 대한 지정된 같음 비교자를 사용하고 지정된 컬렉션에서 복사한 요소가 들어 있으며 복사된 요소 수를 수용하기에 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다. <xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.  
  
 경우 `collection` 중복이 포함 집합 각각의 고유한 요소 중 하나가 포함 됩니다. 예외가 throw 됩니다. 따라서 결과 집합의 크기가의 크기와 동일 `collection`합니다.  
  
 이 생성자는 (`n`) 작업, 여기서 `n` 의 요소 수를 `collection` 매개 변수.  
  
   
  
## Examples  
 다음 예제에서는 제공 된 <xref:System.Collections.Generic.IEqualityComparer%601> 의 요소에 대/소문자 구분 비교를 허용 하는 <xref:System.Collections.Generic.HashSet%601> 차량 형식의 컬렉션입니다.  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Collections.Generic.HashSet`1" />의 초기 크기입니다.</param>
        <param name="comparer">집합의 값을 비교하려면 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하고, 집합 형식에 대한 기본 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 구현을 사용하려면 null(Visual Basic의 경우 Nothing)을 지정합니다.</param>
        <summary>집합 형식에 대해 지정된 같음 비교자를 사용하고 <paramref name="capacity" /> 요소를 수용할 수 있을 만큼 용량이 충분한 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교적 비용이 많이 드는 크기가 조정 되므로 (해싱하여 필요)의 값을 기반으로 초기 용량을 설정 하 여 크기를 조정할 필요가 최소화 하려고 하는이 `capacity`입니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</param>
        <summary>serialize된 데이터를 사용하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 스트림을 통해 전송 되는 개체를 다시 구성 하기 위해 역직렬화 하는 동안 호출 됩니다. 자세한 내용은 [XML 및 SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="hashSet.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">집합에 추가할 요소입니다.</param>
        <summary>지정된 요소를 집합에 추가합니다.</summary>
        <returns>요소가 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 추가되었으면 <see langword="true" />이고, 요소가 이미 있으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 이미의 용량과 <xref:System.Collections.Generic.HashSet%601> 개체를 새 항목에 맞게 용량을 자동으로 조정 됩니다.  
  
 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 작습니다 내부 배열의 용량 보다이 메서드는 o (1) 작업입니다. 경우는 <xref:System.Collections.Generic.HashSet%601> 개체 크기를 조정 해야,이 메서드는 O 됩니다 (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>.  
  
   
  
## Examples  
 다음 예제에서는 만들고 두 값을 채우는 방법을 보여 줍니다. <xref:System.Collections.Generic.HashSet%601> 개체입니다. 이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 요소를 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601.Count%2A> 0으로 설정 된 한 컬렉션의 요소에서 다른 개체에 대 한 참조도 해제 됩니다. 용량에 대 한 호출 될 때까지 변경 되지 않습니다 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> 이루어집니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제를 만들고 채웁니다는 <xref:System.Collections.Generic.HashSet%601> 다음 삭제 하는 예제 컬렉션과 컬렉션에 의해 참조 되는 메모리를 해제 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>집합의 값이 같은지 확인하는 데 사용되는 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 개체를 가져옵니다.</summary>
        <value>집합의 값이 같은지 확인하는 데 사용되는 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="hashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 찾을 요소입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 지정된 요소가 포함되어 있는지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 지정된 요소가 들어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 예제에서 값을 제거 하는 방법에 설명 된 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션을 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드. 이 예제는 <xref:System.Collections.Generic.HashSet%601.Contains%2A> 메서드 집합을 제거 하기 전에 값을 포함 하는 확인 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션의 요소를 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="hashSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다. 배열에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 요소를 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다. 배열에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex"><paramref name="array" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
        <summary>지정된 배열 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 요소를 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arrayIndex" />가 대상 <paramref name="array" />의 길이보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 복사한 요소의 대상인 1차원 배열입니다. 배열에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex"><paramref name="array" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
        <param name="count"><paramref name="array" />에 복사할 요소의 수입니다.</param>
        <summary>지정된 배열 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 수의 요소를 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 `count`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arrayIndex" />가 대상 <paramref name="array" />의 길이보다 큰 경우  
  
또는 
 <paramref name="count" />가 <paramref name="index" />에서 대상 <paramref name="array" /> 끝까지 사용 가능한 공간보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>집합에 포함된 요소 수를 가져옵니다.</summary>
        <value>집합에 포함된 요소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.HashSet%601> 개체는 개체를 저장할 수 있는 요소의 수입니다. <xref:System.Collections.Generic.HashSet%601> 개체의 용량에는 자동으로 개체에 요소를 추가할 때 증가 합니다.  
  
 항상이 용량은 보다 크거나 같은 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다. 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 요소를 추가 하는 동안 용량을 초과, 용량 double 이전 용량 보다 큰 첫 번째 소수로 설정 됩니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는 만들고, 채우고, 두 개를 조작 하는 방법을 보여 줍니다 <xref:System.Collections.Generic.HashSet%601> 개체입니다. 이 예제에서는 두 집합의 내용과 및 <xref:System.Collections.Generic.HashSet%601.Count%2A> 콘솔에 표시 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 같음 테스트에 사용할 수 있는 <see cref="T:System.Collections.IEqualityComparer" /> 개체를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 전체 같음 테스트에 사용할 수 있는 <see cref="T:System.Collections.IEqualityComparer" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IEqualityComparer> 있지만 함께 연결할 수 있습니다 더 깊은 같음 테스트를 수행 하려면 추가 수준의 비교자; 개체 하나만 수준 같음 여부를 검사 합니다.  
  
 이 메서드를 호출 하는 것은 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="hashSet.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 제거할 항목의 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 컬렉션의 모든 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> 메서드 수치 연산 집합 빼기 동일 합니다.  
  
 이 메서드는 O (`n`) 작업 위치 `n` 의 요소 수를 `other` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 겹치는 데이터 집합을 사용 하는 컬렉션입니다. 값의 낮은 범위는 다음을 사용 하 여 더 큰 집합에서 제거 된 <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> 메서드.  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.HashSet&lt;'T&gt;.Enumerator" Usage="hashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 반복되는 열거자를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 대한 <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서) 열거자의 복잡성을 숨깁니다. 따라서 사용 하 여 `foreach` 열거자를 직접 조작 하는 대신 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>합니다.  
  
 합니다 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 라고 합니다. <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>는 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 정의 되지 않습니다. 설정할 수 없습니다 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경에 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제, 열거자가 복구할 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 또는 <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throw는 <xref:System.InvalidOperationException>합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 정보가 포함된 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context"><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에 연결되어 있는 serialize된 스트림의 소스와 대상이 포함된 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 구조체입니다.</param>
        <summary><see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 serialize하는 데 필요한 데이터를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 O (`n`) 작업을 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">serialization 서비스를 제공 합니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션에 동시에 있는 요소만 포함합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표시 되는 컬렉션을 `other` 매개 변수는를 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업을 여기서 `n` 됩니다 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 의 요소입니다 `other`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 적합한 하위 집합인지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 적합한 하위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합은 다른 컬렉션의 적절 한 하위 집합입니다. 따라서이 메서드는 반환 `true` 현재 표시 되는 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 않으면를 `other` 매개 변수는 빈 집합 이기도 합니다.  
  
 이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 보다 크거나의 요소 수가 같지 `other`합니다.  
  
 표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업을 여기서 `n` 됩니다 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 의 요소입니다 `other`합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `lowNumbers` 는 하위 집합 이자의 진 부분 집합이 `allNumbers` 될 때까지 `allNumbers` 사용 하 여 수정 될를 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다. 한 번 `allNumbers` 하 고 `lowNumbers` 동일 `lowNumbers` 의 하위 집합은 여전히 `allNumbers` 이지만 더 이상 적절 한 하위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 적합한 상위 집합인지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 적합한 상위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합은 다른 컬렉션의 적절 한 상위 집합입니다. 따라서이 메서드는 반환 `true` 표시 되는 컬렉션을 `other` 매개 변수는 비어 하지 않는 한 현재 <xref:System.Collections.Generic.HashSet%601> 컬렉션은 비어 있을 수도 있습니다.  
  
 이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수가 보다 작거나 같으면 `other`합니다.  
  
 표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `allNumbers` 며 상위 집합의 진 `lowNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 될는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다. 한 번 `allNumbers` 및 `lowNumbers` 동일 `allNumbers` 은 여전히 `lowNumbers` 이지만 더 이상 적절 한 상위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 하위 집합인지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 하위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합이 빈 집합;를 비롯 한 모든 다른 컬렉션의 하위 집합인 따라서이 메서드는 반환 `true` 현재 표시 되는 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 있더라도 `other` 매개 변수는 빈 집합.  
  
 이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수보다 큽니다 `other`합니다.  
  
 표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업을 여기서 `n` 됩니다 <xref:System.Collections.Generic.HashSet%601.Count%2A> 및 `m` 의 요소입니다 `other`합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `lowNumbers` 는 하위 집합 이자의 진 부분 집합이 `allNumbers` 될 때까지 `allNumbers` 사용 하 여 수정 될를 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다. 한 번 `allNumbers` 하 고 `lowNumbers` 동일 `lowNumbers` 의 하위 집합은 여전히 `allNumbers` 이지만 더 이상 적절 한 하위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 지정된 컬렉션의 상위 집합인지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />의 상위 집합이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 집합을 포함 하 여 모든 컬렉션은 빈 집합의 상위 집합입니다. 따라서이 메서드는 반환 `true` 표시 되는 컬렉션을 `other` 매개 변수가 비어 경우에 현재 <xref:System.Collections.Generic.HashSet%601> 개체가 비어 있습니다.  
  
 이 메서드는 항상 반환 `false` 하는 경우 <xref:System.Collections.Generic.HashSet%601.Count%2A> 의 요소 수보다 작습니다 `other`합니다.  
  
 표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `allNumbers` 며 상위 집합의 진 `lowNumbers` 될 때까지 `allNumbers` 를 사용 하 여 수정 될는 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> 메서드를 두 집합 모두에 존재 하는 값만 포함 합니다. 한 번 `allNumbers` 및 `lowNumbers` 동일 `allNumbers` 은 여전히 `lowNumbers` 이지만 더 이상 적절 한 상위 집합입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">deserialization 이벤트의 소스입니다.</param>
        <summary><see cref="T:System.Runtime.Serialization.ISerializable" /> 인터페이스를 구현하고, deserialization이 완료되면 deserialization 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 O (`n`) 작업을 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체와 관련된 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 잘못된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 지정된 컬렉션이 공통 요소를 공유하는지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 <paramref name="other" />이(가) 요소를 하나 이상 공유하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O (`n`) 작업, 여기서 `n` 의 요소입니다 `other`합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 이 예제에서는 `allNumbers` 하 고 `lowNumbers` 공통 요소를 사용 하 여 공유에 표시 되는 <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="hashSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">제거할 요소입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체에서 지정된 요소를 제거합니다.</summary>
        <returns>요소를 성공적으로 찾아서 제거한 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.  <paramref name="item" /> 개체에 <see cref="T:System.Collections.Generic.HashSet`1" />이(가) 없으면 이 메서드는 <see langword="false" />을(를) 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Collections.Generic.HashSet%601> 개체는 지정된 된 요소를 포함 하지 않습니다, 개체 변경 되지 않습니다. 예외가 throw되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 예제에서 값을 제거 하는 방법에 설명 된 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션을 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드. 이 예제에서는 0 임의로에서 제거 됩니다는 <xref:System.Collections.Generic.HashSet%601> 컬렉션입니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="hashSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">제거할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션에서 지정된 조건자에 정의된 조건과 일치하는 요소를 모두 제거합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 컬렉션에서 제거된 요소의 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 O (`n`) 작업을 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서 값을 제거 하는 방법에 설명 된 <xref:System.Collections.Generic.HashSet%601> 사용 하 여 컬렉션을 <xref:System.Collections.Generic.HashSet%601.Remove%2A> 메서드. 이 예제에서는 모든 홀수 정수에서 제거 되는 <xref:System.Collections.Generic.HashSet%601> 컬렉션에 지정 된 대로 `match` 위임 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 지정된 컬렉션에 같은 요소가 포함되어 있는지 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.HashSet`1" /> 개체가 <paramref name="other" />과(와) 같으면 <see langword="true" />이고, 그렇지 않으면 false입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> 메서드가 중복 된 항목 및에서 요소의 순서를 무시 합니다 `other` 매개 변수입니다.  
  
 표시 되는 컬렉션 `other` 은 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 서로 다른 <xref:System.Collections.Generic.HashSet%601> 개체를 서로 비교 합니다. 처음에 두 집합 같지를 사용 하 여 보여 줍니다는 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> 메서드. 합니다 `allNumbers` <xref:System.Collections.Generic.HashSet%601> 지나면 집합 같은지 개체는 수정 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션 중 하나에 있는 요소만 포함합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `other` 매개 변수는를 <xref:System.Collections.Generic.HashSet%601> 현재 같은 같음 비교자를 사용 하 여 컬렉션 <xref:System.Collections.Generic.HashSet%601> 개체를이 메서드는 O (`n`) 작업입니다. 그렇지 않은 경우이 메서드는 O (`n` + `m`) 작업, 여기서 `n` 의 요소입니다 `other` 및 `m` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 <xref:System.Collections.Generic.HashSet%601> 겹치는 데이터 집합을 사용 하는 컬렉션입니다. 값은 낮은 값을 포함 하는 집합은 다음 수정 하 여를 <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> 메서드를 두 집합 모두에 존재 하지 않는 값만 포함 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.ICollection`1" /> 개체에 추가할 개체입니다.</param>
        <summary><see cref="T:System.Collections.Generic.ICollection`1" /> 개체에 항목을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다. 이 메서드는 O가 용량을 증가 시켜 새 요소를 수용 해야 하는 경우 (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Generic.ICollection`1" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컬렉션이 읽기 전용인지를 나타내는 값을 가져옵니다.</summary>
        <value>컬렉션이 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서) 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>합니다.  
  
 합니다 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 라고 합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 정의 되지 않습니다. 설정할 수 없습니다 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 다시; 컬렉션의 첫 번째 요소에 새 열거자 개체를 대신 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서) 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에 <xref:System.Collections.IEnumerator.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.IEnumerator.Current%2A>합니다.  
  
 합니다 <xref:System.Collections.IEnumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> 라고 합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="hashSet.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.HashSet`1" /> 개체의 용량을 실제로 포함된 요소 수로 설정하고 구현별로 다른 근방 값으로 반올림합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> 최소화 하는 메서드를 <xref:System.Collections.Generic.HashSet%601> 는 알 수 없는 새 요소를 추가할 개체의 메모리 오버 헤드. 완전히 지우려면를 <xref:System.Collections.Generic.HashSet%601> 개체를 참조 하는 모든 메모리를 해제 한 다음 호출한 후이 메서드를 호출 합니다 <xref:System.Collections.Generic.HashSet%601.Clear%2A> 메서드.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.Generic.HashSet%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제를 만들고 채웁니다를 <xref:System.Collections.Generic.HashSet%601> 컬렉션, 컬렉션을 지우고 다음 및 참조 하는 메모리를 해제 합니다.  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="hashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">검색할 값입니다.</param>
        <param name="actualValue">집합에서 검색한 값입니다. 검색에서 일치하는 항목을 찾지 못한 경우 T의 기본값입니다.</param>
        <summary>집합에서 지정된 값을 검색하여 동일한 값을 찾은 경우 해당 값을 반환합니다.</summary>
        <returns>검색에 성공했는지 여부를 나타내는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하지만 현재 있는 값 보다 자세한 데이터를 포함 하는 값을 조회 하거나 (참조의 자세한 공유 발생할 수 있도록) 새로 생성 된 단일 대신 이전에 저장 된 참조를 다시 사용 하려는 경우 유용할 수 있습니다는 비교자 함수 같은지를 나타냅니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체와 비교할 컬렉션입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.HashSet`1" /> 개체를 수정하여 해당 개체와 지정된 컬렉션에 있는 모든 요소를 포함시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 O (`n`) 작업 위치 `n` 의 요소 수를 `other` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 서로 다른 두 집합을 병합 하는 방법에 설명 합니다. 이 예제에서는 두 <xref:System.Collections.Generic.HashSet%601> 개체 이며 각각 홀수 및 짝수 번호를 채웁니다. 세 번째 <xref:System.Collections.Generic.HashSet%601> 개체는 짝수를 포함 하는 집합에서 만들어집니다. 이 예제에서는 호출는 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 홀수 집합 세 번째 집합에 추가 하는 메서드.  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="other" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>