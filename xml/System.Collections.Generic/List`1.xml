<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="649dc28c23dbde95771a5a23c8feb6e1086637c4" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683964" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">목록에 있는 요소의 형식입니다.</typeparam>
    <summary>인덱스로 액세스할 수 있는 강력한 형식의 개체 목록을 나타냅니다. 목록의 검색, 정렬 및 조작에 사용할 수 있는 메서드를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 클래스는 해당 하는 제네릭는 <xref:System.Collections.ArrayList> 클래스입니다. 구현 하는 <xref:System.Collections.Generic.IList%601> 필요에 따라 크기가 동적으로 증가 하는 배열을 사용 하 여 제네릭 인터페이스 필요 합니다.  
  
 항목을 추가할 수는 <xref:System.Collections.Generic.List%601> 를 사용 하 여는 <xref:System.Collections.Generic.List%601.Add%2A> 또는 <xref:System.Collections.Generic.List%601.AddRange%2A> 메서드.  
  
 <xref:System.Collections.Generic.List%601> 클래스 같음 비교자 및 순서 비교자를 모두를 사용 합니다.  
  
-   와 같은 메서드 <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, 및 <xref:System.Collections.Generic.Dictionary%602.Remove%2A> 목록 요소에 대해 같음 비교자를 사용 합니다. 형식에 대 한 기본 같음 비교자 `T` 다음과 같이 결정 됩니다. 경우 형식 `T` 구현 하는 <xref:System.IEquatable%601> 제네릭 인터페이스를 같음 비교자는는 <xref:System.IEquatable%601.Equals%28%600%29> ; 해당 인터페이스의 메서드 그렇지 않으면 기본 같음 비교자는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>합니다.  
  
-   와 같은 메서드 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 및 <xref:System.Collections.Generic.List%601.Sort%2A> 목록 요소에 대해 순서 비교자를 사용 합니다. 형식에 대 한 기본 비교자 `T` 다음과 같이 결정 됩니다.  경우 형식 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스를 기본 비교자는는 <xref:System.IComparable%601.CompareTo%28%600%29> ; 해당 인터페이스의 메서드 그렇지 않은 경우, 형식 `T` 제네릭이 아닌 구현 <xref:System.IComparable> 인터페이스를 다음 기본값 비교자는는 <xref:System.IComparable.CompareTo%28System.Object%29> 해당 인터페이스의 메서드입니다. 경우 형식 `T` 기본 비교 자가 없으므로 고 비교자 또는 비교 대리자를 명시적으로 제공 해야 두 인터페이스를 구현 합니다.  
  
 <xref:System.Collections.Generic.List%601> 정렬할 보장 되지 않습니다.  정렬 해야는 <xref:System.Collections.Generic.List%601> 작업을 수행 하기 전에 (같은 <xref:System.Collections.Generic.List%601.BinarySearch%2A>) 해야 하는 <xref:System.Collections.Generic.List%601> 정렬 합니다.  
  
 이 컬렉션의 요소는 정수 인덱스를 사용 하 여 액세스할 수 있습니다.  이 컬렉션의 인덱스는 0부터 시작 합니다.  
  
 에 대 한 매우 큰 <xref:System.Collections.Generic.List%601> 개체를 설정 하 여 64 비트 시스템의 2 십억 요소에 최대 용량을 늘릴 수는 `enabled` 에 구성 요소의 특성 `true` 런타임 환경에서 합니다.  
  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값을 입력 하 고 중복 요소를 허용 합니다.  
  
 변경할 수 없는 버전의 <xref:System.Collections.Generic.List%601> 클래스를 참조 하십시오. <xref:System.Collections.Immutable.ImmutableList%601>합니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 사용할지 여부를 결정 하는 데는 <xref:System.Collections.Generic.List%601> 또는 <xref:System.Collections.ArrayList> 클래스는 둘 다 유사한 기능을 기억 하는 <xref:System.Collections.Generic.List%601> 클래스 대부분의 경우에서 더 잘 수행 하 고 형식이 안전 합니다. 형식에 대 한 참조 형식이 사용 되는 경우 `T` 의 <xref:System.Collections.Generic.List%601> 클래스는 두 클래스의 동작은 동일 합니다. 그러나 값 형식이 형식에 대해 사용 되는 경우 `T`, 구현 및 boxing 문제를 고려해 야 합니다.  
  
 값 형식이 형식에 대해 사용 되는 경우 `T`, 컴파일러의 구현에서는 오류가 발생 하는 <xref:System.Collections.Generic.List%601> 구체적으로 해당 값 형식에 대 한 클래스입니다. 즉,의 목록 요소는 <xref:System.Collections.Generic.List%601> 개체는 요소를 사용할 수 있습니다, 전에 목록 요소를 boxing 하지 않는 저장 된 메모리는 클래스 구현을 생성 하는 데 사용 된 메모리 보다 큰 약 500 목록 요소를 만든 후 boxed 될 필요가 없습니다.  
  
 이때 형식에 사용 되는 값 형식 `T` 구현 하는 <xref:System.IEquatable%601> 제네릭 인터페이스입니다. 하는 경우와 같은 메서드, <xref:System.Collections.Generic.List%601.Contains%2A> 호출 해야 합니다는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 메서드는 영향을 받는 목록 요소 상자입니다. 값 형식을 구현 하는 경우는 <xref:System.IComparable> 인터페이스 하 고 소스 코드도 구현 소유 하는 <xref:System.IComparable%601> 방지 하기 위해 제네릭 인터페이스는 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 및 <xref:System.Collections.Generic.List%601.Sort%2A> 목록 요소를 boxing 메서드. 소스 코드를 소유 하지 않은 경우 전달 된 <xref:System.Collections.Generic.IComparer%601> 개체는 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 및 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드  
  
 유형별 구현을 사용 하는 <xref:System.Collections.Generic.List%601> 사용 하는 대신 클래스는 <xref:System.Collections.ArrayList> 클래스 또는 강력한 형식의 래퍼 컬렉션을 직접 작성 합니다. 이유는.NET Framework의 용도를 이미 구현 수행 해야 Microsoft intermediate language 코드 및 메타 데이터를 구현할 수 없습니다. 공용 언어 런타임 공유할 수 있습니다.  
  
## <a name="f-considerations"></a>F # 고려 사항  
 <xref:System.Collections.Generic.List%601> 클래스 F # 코드에서 자주 사용 됩니다.  대신, [나열](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), 일반적으로 선호 되는 변경할 수 없는, 단일 연결 목록입니다. F # 목록은 정렬 되 고 변경할 수 없는 일련의 값을 제공 되며 함수 스타일 개발에서 사용 하기 위해 지원 됩니다. F #에서 사용 될 경우는 <xref:System.Collections.Generic.List%601> 클래스 일반적으로 참조 하는 [ResizeArray\<' T >](https://msdn.microsoft.com/library/ee353447.aspx) 형식 약어 F # 나열과 이름이 충돌을 방지 하기 위해  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제에서는 몇 가지의 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 형식 문자열의 제네릭 클래스입니다. (의 예는 <xref:System.Collections.Generic.List%601> 복합 형식의 참조는 <xref:System.Collections.Generic.List%601.Contains%2A> 메서드.)  
  
 기본 생성자가 기본 용량을 사용 하 여 문자열의 목록을 만들려면 사용 합니다. <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 표시 한 다음은 <xref:System.Collections.Generic.List%601.Add%2A> 여러 항목을 추가 메서드를 사용 합니다. 항목을 나열 및 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 표시 함께 다시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 하 여 용량이 필요에 따라 증가 되었습니다.  
  
 <xref:System.Collections.Generic.List%601.Contains%2A> 메서드는 목록에 있는 항목의 존재 유무를 테스트 하는 데 사용 되는 <xref:System.Collections.Generic.List%601.Insert%2A> 메서드를 사용 하는 목록 중에 새 항목을 삽입 하 고 목록의 내용을 다시 표시 됩니다.  
  
 기본 <xref:System.Collections.Generic.List%601.Item%2A> 속성 (C# 인덱서)는 항목을 검색 하는 데 사용 되는 <xref:System.Collections.Generic.List%601.Remove%2A> 메서드를 사용 하 여 이전에 추가한 중복 항목의 첫 번째 인스턴스를 제거 하 고 내용을 다시 표시 됩니다. <xref:System.Collections.Generic.List%601.Remove%2A> 항상 메서드를 발견 하는 첫 번째 인스턴스를 제거 합니다.  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드는 개수와 일치 하는 축소를 사용 하 고 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다. 사용 되지 않는 용량 검색의 총 용량 10% 미만 했다면, 목록은 하지 크기가 조정 되었습니다.  
  
 마지막으로 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드를 사용 하 여 목록에서 모든 항목을 제거 하 고 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual basic에서)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  
  
 다중 읽기 작업을 수행 해도 안전는 <see cref="T:System.Collections.Generic.List`1" />, 하지만 읽는 동안 컬렉션이 수정 되는 경우 문제가 발생할 수 있습니다. 스레드로부터의 안전성을 보장 하려면 읽기는 동안 컬렉션을 잠글 또는 쓰기 작업을 합니다. 에 액세스 하 여 읽기 및 쓰기에 여러 스레드에서 컬렉션을 사용 하도록 설정 하려면 사용자 지정 동기화를 구현 해야 합니다. 기본 제공 동기화 된 컬렉션에 대 한 참조의 클래스는 <see cref="N:System.Collections.Concurrent" /> 네임 스페이스입니다. 기본적으로 스레드 – 안전 대안에 대 한 참조는 <see cref="T:System.Collections.Immutable.ImmutableList`1" /> 클래스입니다.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>비어 있는 상태에서 기본 초기 용량을 가지는 <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량은 <xref:System.Collections.Generic.List%601> 요소의 수가 하는 <xref:System.Collections.Generic.List%601> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.Generic.List%601>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기 예상할 수 있는 경우를 사용 하는 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> 생성자와 초기 용량을 지정 하지 않아도 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행는 <xref:System.Collections.Generic.List%601>합니다.  
  
 호출 하 여 용량을 줄일 수 있습니다는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 설정 하 여는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 명시적으로 합니다. 용량 메모리를 다시 할당 하 고 복사에 있는 모든 요소는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 생성자는 o (1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 생성자는 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. 기본 생성자를 표시 하 여 볼 수 있듯이 기본 용량으로 목록을 만듭니다는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성입니다.  
  
 이 예제에서는 추가 하 고 삽입, 용량 이러한 메서드는 사용 되 고 변경 하는 방법을 보여 주는 항목을 제거 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">요소가 새 목록에 복사되는 컬렉션입니다.</param>
        <summary>지정된 컬렉션에서 복사한 요소를 포함하고 복사한 요소를 모두 수용할 수 있을 정도의 용량을 가진 <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소에 복사 됩니다는 <xref:System.Collections.Generic.List%601> 컬렉션의 열거자가 읽기 순서와 동일 합니다.  
  
 이 생성자는는 O (*n*) 작업, 여기서 *n* 에 있는 요소의 수는 `collection`합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.%23ctor%2A> 생성자와의 다양 한 메서드는 <xref:System.Collections.Generic.List%601> 범위에서 동작 하는 클래스입니다. 문자열의 배열은 만들고 배열의 요소를 사용 하 여 목록 채우기 생성자에 전달 합니다. <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 표시 한 다음 초기 용량 입력된 요소를 보유 하는 데 필요한 란 정확히 임을 나타낼 수 있습니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">새 목록에 처음부터 저장할 수 있는 요소의 수입니다.</param>
        <summary>비어 있는 상태에서 지정한 초기 용량을 가지는 <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량은 <xref:System.Collections.Generic.List%601> 요소의 수가 하는 <xref:System.Collections.Generic.List%601> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.Generic.List%601>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 다양 한 크기 조정 작업에 요소를 추가 하는 동안 수행할 필요가 없습니다 초기 용량을 지정 하는 <xref:System.Collections.Generic.List%601>합니다.  
  
 호출 하 여 용량을 줄일 수 있습니다는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 설정 하 여는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 명시적으로 합니다. 용량 메모리를 다시 할당 하 고 복사에 있는 모든 요소는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 생성자는는 O (*n*) 작업, 여기서 *n* 은 `capacity`합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> 생성자입니다. A <xref:System.Collections.Generic.List%601> 4의 용량을 가진 문자열의 만들어질 목록의 최종 크기는 4로 알려져 있기 때문에 있습니다. 목록은 4 개의 문자열으로 채워지고 사용 하 여 읽기 전용 복사본 만들어집니다는 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 메서드.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" />가 0보다 작습니다.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />의 끝에 추가할 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>개체를 <see cref="T:System.Collections.Generic.List`1" />의 끝 부분에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값을 입력 하 고 중복 요소를 허용 합니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 이미 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량이 <xref:System.Collections.Generic.List%601> 자동으로 내부 배열을 다시 할당 하 여 증가 새 요소를 추가 하기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다. 이 메서드는 O 됩니다 용량을 새 요소로 적용로 늘려야 하는 경우 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제에서는 몇 가지의 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 제네릭 클래스를 포함 하는 <xref:System.Collections.Generic.List%601.Add%2A> 메서드. 기본 생성자가 용량이 0 인 문자열의 목록을 만들려면 사용 합니다. <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 표시 한 다음은 <xref:System.Collections.Generic.List%601.Add%2A> 여러 항목을 추가 메서드를 사용 합니다. 항목을 나열 및 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 표시 함께 다시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 하 여 용량이 필요에 따라 증가 되었습니다.  
  
 다른 속성 및 메서드는 검색, 삽입 및 목록에서 요소를 제거 하는 데 사용 하 고 마지막으로 목록을 지울 수 있습니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">요소가 <see cref="T:System.Collections.Generic.List`1" />의 끝에 추가되어야 하는 컬렉션입니다. 컬렉션 자체가 <see langword="null" />일 수는 없지만 <c>T</c> 형식이 참조 형식인 경우 <see langword="null" />인 요소를 포함할 수 있습니다.</param>
        <summary>지정된 컬렉션의 요소를 <see cref="T:System.Collections.Generic.List`1" />의 끝에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션에 있는 요소의 순서는 유지 된 <xref:System.Collections.Generic.List%601>합니다.  
  
 하는 경우 새 <xref:System.Collections.Generic.List%601.Count%2A> (현재 <xref:System.Collections.Generic.List%601.Count%2A> 컬렉션의 크기를 더한) 보다 커야 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량이 <xref:System.Collections.Generic.List%601> 자동으로 새 요소를 수용 하기 위해 내부 배열을 다시 할당 하 여 증가 및 새 요소가 추가 하기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 을 늘리지 않고도 새 요소를 수용할 수는 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 O는 (*n*) 작업, 여기서 *n* 추가할 요소의 수입니다. 이 메서드는 O 됩니다 용량을 새 요소를 수용 하기 위해 증가 하는 경우 (*n* + *m*) 작업, 여기서 *n* 요소 수는 추가할 및 *m* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.AddRange%2A> 메서드와의 다른 다양 한 메서드는 <xref:System.Collections.Generic.List%601> 범위에서 동작 하는 클래스입니다. 문자열의 배열은 만들고 배열의 요소를 사용 하 여 목록 채우기 생성자에 전달 합니다. <xref:System.Collections.Generic.List%601.AddRange%2A> 목록을 인수로 사용 하 여 메서드를 호출 합니다. 결과 있는 현재 요소는 목록의 모든 요소가 중복 목록의 끝에 추가 됩니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 컬렉션에 대한 읽기 전용 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 래퍼를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Collections.Generic.List`1" />에 대한 읽기 전용 래퍼 역할을 하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 수정 하지 못하게 하는 <xref:System.Collections.Generic.List%601> 개체,이 래퍼를 통해서만 노출 합니다. A <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 개체 컬렉션을 수정 하는 메서드를 노출 하지 않습니다. 그러나 내부에 변경 되 면 <xref:System.Collections.Generic.List%601> 개체를 읽기 전용 컬렉션에 해당 변경 내용을 반영 합니다.  
  
 이 메서드는 o (1) 작업.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 메서드. A <xref:System.Collections.Generic.List%601> 4의 용량을 가진 문자열의 만들어질 목록의 최종 크기는 4로 알려져 있기 때문에 있습니다. 목록 4 개의 문자열 채워집니다 및 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 메서드는 읽기 전용를 가져오는 데 <xref:System.Collections.Generic.IList%601> 원래 목록을 래핑하는 제네릭 인터페이스 구현.  
  
 원래 목록 요소를 사용 하 여 "Coelophysis"로 설정 되어는 <xref:System.Collections.Generic.List%601.Item%2A> 속성 (C# 인덱서) 및 읽기 전용 목록의 내용을 원래 목록에 대 한 래퍼 인지 보여 주기 위해 다시 표시 됩니다.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이진 검색 알고리즘을 사용하여 정렬된 <see cref="T:System.Collections.Generic.List`1" />나 그 일부에서 특정 요소를 찾습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>기본 비교자를 사용하여 정렬된 전체 <see cref="T:System.Collections.Generic.List`1" />에서 요소를 검색하고 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="item" />이 있으면 정렬된 <see cref="T:System.Collections.Generic.List`1" />에 있는 <paramref name="item" />의 인덱스(0부터 시작)이고, 그렇지 않으면 <paramref name="item" />보다 큰 다음 요소의 인덱스에 대한 비트 보수인 음수이거나 더 큰 요소가 없는 경우 <see cref="P:System.Collections.Generic.List`1.Count" />의 비트 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 비교 자가 사용 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 형식에 대 한 `T` 목록 요소의 순서를 결정 합니다. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 속성 검사 하는지 여부를 입력 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스를 구현 하를 사용 하 여 사용 가능한 경우.  그렇지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않는 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Collections.Generic.List%601> ; 비교자 구현에 따라 정렬 되어 있어야 그렇지 않으면 결과 틀립니다.  
  
 비교 `null` 을 다른 참조는 허용 형식과 사용 하는 경우 예외가 생성 되지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스입니다. 정렬할 때 `null` 다른 개체 보다 작은 것으로 간주 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 포함 둘 이상의 요소가 동일한 값을 가진 메서드가 반환, 각 항목 중 하 나와 반드시 첫 번째 항목 중 하나를 반환할 수 있습니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 검색 값 보다 큰 첫 번째 요소의 인덱스를 가져올이 음의 정수 비트 보수 연산을 (~)를 적용할 수 있습니다. 에 값을 삽입할 때는 <xref:System.Collections.Generic.List%601>, 정렬 순서를 유지 하기 위해이 인덱스를 삽입 지점으로 사용 해야 합니다.  
  
 이 메서드는는 O (로그 *n*) 작업, 여기서 *n* 범위의 요소 수입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort> 메서드 오버 로드와 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드 합니다. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다. 목록은 표시 하 고 정렬 하 고 다시 표시 됩니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드는 다음 목록에 없는 두 문자열을 검색 하는 데 사용 됩니다 및 <xref:System.Collections.Generic.List%601.Insert%2A> 삽입할 메서드를 사용 합니다. 반환 값은 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 문자열 목록에 없기 때문에 메서드는 각각의 경우에서 음수입니다. 비트 보수 (고 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)이 음수 숫자 생성 검색 문자열 보다는 커야 하며 삽입이 위치에 있는 목록에서 첫 번째 요소의 인덱스 유지 정렬 순서입니다. 두 번째 검색 문자열 목록에 있는 모든 요소 보다 큰 이므로 목록의 끝에 삽입 위치는입니다.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현입니다.  
  
 또는  
  
 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 정렬된 전체 <see cref="T:System.Collections.Generic.List`1" />에서 요소를 검색하고 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="item" />이 있으면 정렬된 <see cref="T:System.Collections.Generic.List`1" />에 있는 <paramref name="item" />의 인덱스(0부터 시작)이고, 그렇지 않으면 <paramref name="item" />보다 큰 다음 요소의 인덱스에 대한 비트 보수인 음수이거나 더 큰 요소가 없는 경우 <see cref="P:System.Collections.Generic.List`1.Count" />의 비트 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어 사용할 수 있습니다는 <xref:System.Collections.CaseInsensitiveComparer> 인스턴스도 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.  
  
 경우 `comparer` 제공의 요소는 <xref:System.Collections.Generic.List%601> 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스 사용 가능한 경우 해당 구현을 사용 하 여 합니다.  그렇지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않는 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Collections.Generic.List%601> ; 비교자 구현에 따라 정렬 되어 있어야 그렇지 않으면 결과 틀립니다.  
  
 비교 `null` 을 다른 참조는 허용 형식과 사용 하는 경우 예외가 생성 되지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스입니다. 정렬할 때 `null` 다른 개체 보다 작은 것으로 간주 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 포함 둘 이상의 요소가 동일한 값을 가진 메서드가 반환, 각 항목 중 하 나와 반드시 첫 번째 항목 중 하나를 반환할 수 있습니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 검색 값 보다 큰 첫 번째 요소의 인덱스를 가져올이 음의 정수 비트 보수 연산을 (~)를 적용할 수 있습니다. 에 값을 삽입할 때는 <xref:System.Collections.Generic.List%601>, 정렬 순서를 유지 하기 위해이 인덱스를 삽입 지점으로 사용 해야 합니다.  
  
 이 메서드는는 O (로그 *n*) 작업, 여기서 *n* 범위의 요소 수입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드와 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 대체는 비교자 DinoCompare 구현 하는 명명 된 문자열에 대 한 정의 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 다음과 같이 작동 되는 비교자:에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다. 셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다. 목록 다시 표시 됩니다, 대체 비교자를 사용 하 여 정렬 되 고 표시 합니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 하지 목록에서 사용 중인 대체 비교자 여러 문자열을 검색 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.Insert%2A> 메서드를 사용 하 여 문자열을 삽입 합니다. 라는 함수에 있는 다음 두 가지 방법 `SearchAndInsert`, 비트 보수를 수행 하는 코드와 함께 (의 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)에서 반환 된 음수의 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 에 대 한 인덱스로 사용 하 여 새 문자열을 삽입 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">검색할 범위의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 범위의 길이입니다.</param>
        <param name="item">찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현이거나, 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 정렬된 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 요소를 검색하고 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="item" />이 있으면 정렬된 <see cref="T:System.Collections.Generic.List`1" />에 있는 <paramref name="item" />의 인덱스(0부터 시작)이고, 그렇지 않으면 <paramref name="item" />보다 큰 다음 요소의 인덱스에 대한 비트 보수인 음수이거나 더 큰 요소가 없는 경우 <see cref="P:System.Collections.Generic.List`1.Count" />의 비트 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어 사용할 수 있습니다는 <xref:System.Collections.CaseInsensitiveComparer> 인스턴스도 대/소문자 구분 문자열 검색을 수행 하는 비교자입니다.  
  
 경우 `comparer` 제공의 요소는 <xref:System.Collections.Generic.List%601> 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스 사용 가능한 경우 해당 구현을 사용 하 여 합니다.  그렇지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않는 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Collections.Generic.List%601> ; 비교자 구현에 따라 정렬 되어 있어야 그렇지 않으면 결과 틀립니다.  
  
 비교 `null` 을 다른 참조는 허용 형식과 사용 하는 경우 예외가 생성 되지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스입니다. 정렬할 때 `null` 다른 개체 보다 작은 것으로 간주 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 포함 둘 이상의 요소가 동일한 값을 가진 메서드가 반환, 각 항목 중 하 나와 반드시 첫 번째 항목 중 하나를 반환할 수 있습니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 지정 된 값이 포함 되지 않는 메서드가 음의 정수를 반환 합니다. 검색 값 보다 큰 첫 번째 요소의 인덱스를 가져올이 음의 정수 비트 보수 연산을 (~)를 적용할 수 있습니다. 에 값을 삽입할 때는 <xref:System.Collections.Generic.List%601>, 정렬 순서를 유지 하기 위해이 인덱스를 삽입 지점으로 사용 해야 합니다.  
  
 이 메서드는는 O (로그 *n*) 작업, 여기서 *n* 범위의 요소 수입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드와 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 대체는 비교자 DinoCompare 구현 하는 명명 된 문자열에 대 한 정의 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 다음과 같이 작동 되는 비교자:에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다. 셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들고 5 개의 예제 공룡과 예제의 이름으로 채워집니다. 두 그룹의 각 이름은 특정 정렬 순서에 있지 않습니다. 목록이 표시 됩니다, 대체 비교자를 사용 하 여 초 식의 범위에 정렬 하 고 목록을 다시 표시 됩니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 초 식의 범위에만 "Brachiosaurus"를 검색 하는 데 사용 됩니다. 문자열이 없습니다 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)에서 반환 되는 음수의는 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드는 새 문자열을 삽입 하기 위한 인덱스로 사용 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>크기를 조정하지 않고 내부 데이터 구조가 보유할 수 있는 전체 요소 수를 가져오거나 설정합니다.</summary>
        <value>크기를 조정하지 않고 <see cref="T:System.Collections.Generic.List`1" />에 포함될 수 있는 요소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소의 수가 하는 <xref:System.Collections.Generic.List%601> 저장할 수를 조정 하지 않고 필요한 있지만 <xref:System.Collections.Generic.List%601.Count%2A> 에 실제로 있는 요소의 수가는 <xref:System.Collections.Generic.List%601>합니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 보다 크거나 같은 경우는 항상 <xref:System.Collections.Generic.List%601.Count%2A>합니다. 경우 <xref:System.Collections.Generic.List%601.Count%2A> 초과 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소를 추가 하는 동안 용량이 증가 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 자동으로 다시 할당 하 여 합니다.  
  
 용량은 수보다 크게 증가 하 고 사용 되는 메모리를 줄이기 위해 원하는 경우는 <xref:System.Collections.Generic.List%601>를 호출 하 여 용량을 줄일 수 있습니다는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 설정 하 여는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성 더 낮은 값을 명시적으로 합니다. 때의 값 <xref:System.Collections.Generic.List%601.Capacity%2A> 설정 명시적으로 지정된 된 용량을 수용 하기 위해 내부 배열은 다시 할당 하 고 모든 요소 복사 됩니다.  
  
 이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. 속성을 설정 하는 O (*n*) 작업, 여기서 *n* 새 용량입니다.  
  
   
  
## Examples  
 다음 예제에서는 용량 및 개수를 확인 하는 <xref:System.Collections.Generic.List%601> 간단한 비즈니스 개체를 포함 하 고 사용 하 여는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 추가 용량을 제거 하는 메서드.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 다음 예제와 <xref:System.Collections.Generic.List%601.Capacity%2A> 목록 수명의 여러 지점에 속성입니다. 용량이 0 사용 하 여 문자열의 목록을 만들려면 기본 생성자 사용 및 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은이를 보여 주려면 표시 됩니다. 후는 <xref:System.Collections.Generic.List%601.Add%2A> 는 항목을 나열, 메서드는 여러 개의 항목을 추가 하는 데 사용 차례로 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 표시 함께 다시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 하 여 용량이 필요에 따라 증가 되었습니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 후에 다시 속성은 표시의 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드는 개수와 일치 하도록 용량을 줄이기 위해 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드를 사용 하 여 목록에서 모든 항목을 제거 하 고 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 다시 표시 됩니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.List`1.Capacity" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 작은 값으로 설정되어 있습니다.</exception>
        <exception cref="T:System.OutOfMemoryException">시스템에 사용 가능한 메모리가 부족합니다.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />에서 모든 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> 0으로 설정 하 고 컬렉션의 요소에 다른 개체에 대 한 참조도 해제 됩니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 변경 되지 않습니다. 용량을 다시 설정 하는 <xref:System.Collections.Generic.List%601>, 호출의 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 집합은 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성을 직접 합니다. 용량 메모리를 다시 할당 하 고 복사에 있는 모든 요소는 <xref:System.Collections.Generic.List%601>합니다. 빈 트리밍 <xref:System.Collections.Generic.List%601> 의 용량 설정는 <xref:System.Collections.Generic.List%601> 기본 용량을 합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드 및 기타 다양 한 속성과 메서드는 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. <xref:System.Collections.Generic.List%601.Clear%2A> 메서드 목록에서 모든 항목을 제거 하는 프로그램의 끝에는 및 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />에 요소가 있는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="item" />에 있으면 <see cref="T:System.Collections.Generic.List`1" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 개체의 구현에 의해 정의 된 대로 기본 같음 비교자를 사용 하 여 일치 여부를 확인는 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 방법을 `T` (목록에 있는 값의 유형).  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Contains%2A> 및 <xref:System.Collections.Generic.List%601.Exists%2A> 에 대 한 메서드는 <xref:System.Collections.Generic.List%601> 구현 하는 간단한 비즈니스 개체를 포함 하는 <xref:System.IEquatable%601.Equals%2A>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 다음 예제에서는 복합 형식 개체의 목록이 들어 `Cube`합니다. `Cube` 클래스가 구현 하는 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 메서드를 두 개의 큐브 차원을 동일한 경우 같은 것으로 간주 됩니다. 이 예제에서는 <xref:System.Collections.Generic.List%601.Contains%2A> 메서드 반환 `true`지정된 된 크기를 가지는 큐브에 이미 컬렉션에에서 포함 되어 있으므로, 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">대상 배열 요소의 형식입니다.</typeparam>
        <param name="converter">각 요소를 한 형식에서 다른 형식으로 변환하는 <see cref="T:System.Converter`2" /> 대리자입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.List`1" />의 요소를 다른 형식으로 변환하고 변환된 요소를 포함하는 목록을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Collections.Generic.List`1" />에서 변환된 요소를 포함하는 대상 유형의 <see cref="T:System.Collections.Generic.List`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> 개체를 대상 형식으로 변환 하는 메서드에 대리자입니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 를 개별적으로 전달 되는 <xref:System.Converter%602> 대리자 및 변환된 된 요소에 새 저장 <xref:System.Collections.Generic.List%601>합니다.  
  
 현재 <xref:System.Collections.Generic.List%601> 그대로 유지 됩니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 라는 메서드를 정의 하는 다음 예제에서는 `PointFToPoint` 변환 하는 <xref:System.Drawing.PointF> 구조체는 <xref:System.Drawing.Point> 구조입니다. 만듭니다는 <xref:System.Collections.Generic.List%601> 의 <xref:System.Drawing.PointF> 구조, 만듭니다는 `Converter\<PointF, Point>` 위임 (`Converter(Of PointF, Point)` Visual basic에서)를 나타내는 `PointFToPoint` 메서드를에 대리자를 전달는 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 메서드. <xref:System.Collections.Generic.List%601.ConvertAll%2A> 메서드 전달 하는 입력 목록의 각 요소는 `PointFToPoint` 메서드를 새 목록으로 변환된 된 요소를 배치 <xref:System.Drawing.Point> 구조입니다. 두 목록은 모두 표시 됩니다.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />이나 그 일부를 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.Generic.List`1" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <summary>대상 배열의 처음부터 시작하여 전체 <see cref="T:System.Collections.Generic.List`1" />을 호환되는 1차원 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 사용 하 여 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사해올 합니다.  
  
 요소가 복사 되는 <xref:System.Array> 열거자가 반복는 동일한 순서로 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.CopyTo%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 5 개 문자열 채워집니다. 빈 문자열 배열을 15 요소를 만든 및 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 메서드 오버 로드는 목록의 모든 요소는 배열의 첫 번째 요소에서 시작 하는 배열에 복사 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> 메서드 오버 로드는의 모든 요소 6 배열 인덱스에서 시작 하는 배열에 대 한 목록 (배열)를 복사 하는 데 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 배열에서 시작 하는 배열에 인덱스 12 (종료 인덱스 11 비어 있음), 인덱스 2로 시작 하 고 목록에서 3 개 요소를 복사 하는 데 사용 됩니다. 그러면 배열 콘텐츠가 표시 됩니다.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">소스 <see cref="T:System.Collections.Generic.List`1" /> 요소 수가 대상 <paramref name="array" />를 포함할 수 있는 요소 수보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.Generic.List`1" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <summary>대상 배열의 지정된 인덱스에서 시작하여 전체 <see cref="T:System.Collections.Generic.List`1" />을 호환되는 1차원 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 사용 하 여 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사해올 합니다.  
  
 요소가 복사 되는 <xref:System.Array> 열거자가 반복는 동일한 순서로 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.CopyTo%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 5 개 문자열 채워집니다. 빈 문자열 배열을 15 요소를 만든 및 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 메서드 오버 로드는 목록의 모든 요소는 배열의 첫 번째 요소에서 시작 하는 배열에 복사 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> 메서드 오버 로드는의 모든 요소 6 배열 인덱스에서 시작 하는 배열에 대 한 목록 (배열)를 복사 하는 데 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 배열에서 시작 하는 배열에 인덱스 12 (종료 인덱스 11 비어 있음), 인덱스 2로 시작 하 고 목록에서 3 개 요소를 복사 하는 데 사용 됩니다. 그러면 배열 콘텐츠가 표시 됩니다.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">소스 <see cref="T:System.Collections.Generic.List`1" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지 사용 가능한 공간보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">소스 <see cref="T:System.Collections.Generic.List`1" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
        <param name="array">
          <see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.Generic.List`1" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <param name="count">복사할 요소의 수입니다.</param>
        <summary>대상 배열의 지정된 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.List`1" />에 있는 일련의 요소를 호환되는 1차원 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 사용 하 여 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사해올 합니다.  
  
 요소가 복사 되는 <xref:System.Array> 열거자가 반복는 동일한 순서로 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.CopyTo%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 5 개 문자열 채워집니다. 빈 문자열 배열을 15 요소를 만든 및 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 메서드 오버 로드는 목록의 모든 요소는 배열의 첫 번째 요소에서 시작 하는 배열에 복사 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> 메서드 오버 로드는의 모든 요소 6 배열 인덱스에서 시작 하는 배열에 대 한 목록 (배열)를 복사 하는 데 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 배열에서 시작 하는 배열에 인덱스 12 (종료 인덱스 11 비어 있음), 인덱스 2로 시작 하 고 목록에서 3 개 요소를 복사 하는 데 사용 됩니다. 그러면 배열 콘텐츠가 표시 됩니다.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="arrayIndex" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" />가 소스 <see cref="T:System.Collections.Generic.List`1" />의 <see cref="P:System.Collections.Generic.List`1.Count" />보다 크거나 같습니다.  
  
 또는  
  
 소스 <see cref="T:System.Collections.Generic.List`1" />의 <paramref name="index" />부터 끝까지에 포함된 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지의 사용 가능한 공간보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />에 포함된 요소 수를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.Generic.List`1" />에 포함된 요소의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소의 수가 하는 <xref:System.Collections.Generic.List%601> 크기를 조정 하지 전에 저장할 수 있습니다. <xref:System.Collections.Generic.List%601.Count%2A> 에 실제로 있는 요소의 수가 고 <xref:System.Collections.Generic.List%601>합니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 보다 크거나 같은 경우는 항상 <xref:System.Collections.Generic.List%601.Count%2A>합니다. 경우 <xref:System.Collections.Generic.List%601.Count%2A> 초과 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소를 추가 하는 동안 용량이 증가 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 자동으로 다시 할당 하 여 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에서는 용량 및 개수를 확인 하는 <xref:System.Collections.Generic.List%601> 간단한 비즈니스 개체를 포함 하 고 사용 하 여는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 추가 용량을 제거 하는 메서드.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 다음 예제에서는 값이 표시는 <xref:System.Collections.Generic.List%601.Count%2A> 목록 수명의 다양 한 지점에 속성입니다. 요소를 표시 하 고 목록에 만들고 채운 후의 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다. 이러한 속성은 한 후 다시 표시는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드가 호출을 하 고 목록의 내용을 후에 다시 지워집니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소가 <see cref="T:System.Collections.Generic.List`1" />에 포함되어 있는지 여부를 확인합니다.</summary>
        <returns>
          지정된 조건자에 정의된 조건과 일치하는 요소가 하나 이상 <see cref="T:System.Collections.Generic.List`1" />에 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 일치 하는 경우, 대리자 및 처리 중지 됩니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Contains%2A> 및 <xref:System.Collections.Generic.List%601.Exists%2A> 에 대 한 메서드는 <xref:System.Collections.Generic.List%601> 구현 하는 간단한 비즈니스 개체를 포함 하는 <xref:System.IEquatable%601.Equals%2A>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드와 사용 하는 몇 가지 다른 메서드는 <xref:System.Predicate%601> 제네릭 대리자입니다.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 들어 있는입니다. 이 예제에서는 또한 라는 검색 조건자 메서드를 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, 및 <xref:System.Collections.Generic.List%601.FindAll%2A> 메서드는 검색 조건자 메서드를 사용 하 여 목록을 검색 하는 데 사용 됩니다 차례로 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 메서드는 "saurus"로 끝나는 모든 항목을 제거 하는 데 사용 됩니다.  
  
 마지막으로 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드를 호출 합니다. 각 요소에 전달 하는 처음부터 목록 트래버스할는 `EndsWithSaurus` 메서드. 검색이 중지 되 고 메서드가 반환 되는 `true` 경우는 `EndsWithSaurus` 메서드 반환 `true` 모든 요소에 대 한 합니다. <xref:System.Collections.Generic.List%601.Exists%2A> 메서드 반환 `false` 제거 되어 해당 요소가 모두 있습니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <see cref="T:System.Collections.Generic.List`1" />에서 처음으로 검색한 요소를 반환합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소이고, 그렇지 않으면 <paramref name="T" /> 형식의 기본값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 를 개별적으로 전달 되는 <xref:System.Predicate%601> 를 앞으로 이동 하는 대리자는 <xref:System.Collections.Generic.List%601>첫 번째 요소부터 마지막 요소까지 합니다.  일치 하는 경우 처리가 중지 됩니다.  
  
> [!IMPORTANT]
>  값 형식을 포함 하는 목록을 검색할 때 형식에 대 한 기본값 검색 조건자를 충족 하지 않습니다 확인 합니다. 그렇지 않은 경우 일치 항목이 없는 찾았음을 나타내는 기본 값 및 유형에 대 한 기본값을가 하는 목록 요소를 구분 하기 위해 방식은 없습니다. 사용 하 여 검색 조건자를 충족 하는 경우는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드 대신 합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Find%2A> 메서드를 한 <xref:System.Collections.Generic.List%601> 간단한 복잡 한 개체를 포함 하 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 다음 예제에서는 위한 좋은 메서드는 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스 포함 `book` 클래스의 개체 `Book`, 데이터를 사용 하는 [샘플 XML 파일: Books (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)합니다. `FillList` 메서드 예제에서 사용 하 여 [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석 하는 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 하는 예제를 설명 합니다.  
  
|메서드|예|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|해당 갖는 모든 책 찾기 `Genre` 속성은 "컴퓨터"를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|사용 하 여 2001 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책을 찾습니다는 `PubBefore2001` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 컴퓨터의 첫 번째 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 마지막 컴퓨터 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정한 조건자에 정의된 조건과 일치하는 모든 요소를 검색합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 해당 요소를 모두 포함하는 <see cref="T:System.Collections.Generic.List`1" />이고, 그렇지 않으면 빈 <see cref="T:System.Collections.Generic.List`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 를 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자와 조건과 일치 하는 요소는 저장 반환 된 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 위한 좋은 메서드는 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스 포함 `book` 클래스의 개체 `Book`, 데이터를 사용 하는 [샘플 XML 파일: Books (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)합니다. `FillList` 메서드 예제에서 사용 하 여 [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석 하는 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 하는 예제를 설명 합니다.  
  
|메서드|예|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|해당 갖는 모든 책 찾기 `Genre` 속성은 "컴퓨터"를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|사용 하 여 2001 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책을 찾습니다는 `PubBefore2001` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 컴퓨터의 첫 번째 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 마지막 컴퓨터 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 <see cref="T:System.Collections.Generic.List`1" />이나 그 일부에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다. 이 메서드는 조건이 일치하는 항목이 없는 경우 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <see cref="T:System.Collections.Generic.List`1" />에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 검색은 앞으로 첫 번째 요소부터 마지막 요소입니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다. 대리자에 서명을 합니다.  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Employee` 두 필드를 사용 하 여 클래스 `Name` 및 `Id`합니다. 또한 정의 `EmployeeSearch` 단일 메서드를 사용 하 여 클래스 `StartsWith`, 나타내는 여부는 `Employee.Name` 필드의 지정한 부분에 제공 된 시작는 `EmployeeSearch` 클래스 생성자 합니다. 이 메서드의 서명은 참고  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 에 전달 될 수 있는 대리자의 서명과에 해당 하는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드. 이 예제에서는 인스턴스화합니다는 `List<Employee>` 개체를 추가 하는 다양 한 `Employee` 를 차례로 호출 하는 개체는 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 전체 컬렉션을 첫 번째에 대해 처음으로 검색을 두 번 메서드 `Employee` 개체 `Name` 필드가 시작 될 "J" 및 첫 번째에 대 한 두 번째로 `Employee` 개체 `Name` "Ju"로 시작 하는 필드입니다.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 인덱스에서 마지막 요소로 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 까지 검색은 `startIndex` 마지막 요소의 끝입니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다. 대리자에 서명을 합니다.  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 의 요소 수 `startIndex` 의 끝에는 <xref:System.Collections.Generic.List%601>합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Employee` 두 필드를 사용 하 여 클래스 `Name` 및 `Id`합니다. 또한 정의 `EmployeeSearch` 단일 메서드를 사용 하 여 클래스 `StartsWith`, 나타내는 여부는 `Employee.Name` 필드의 지정한 부분에 제공 된 시작는 `EmployeeSearch` 클래스 생성자 합니다. 이 메서드의 서명은 참고  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 에 전달 될 수 있는 대리자의 서명과에 해당 하는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드. 이 예제에서는 인스턴스화합니다는 `List<Employee>` 개체를 추가 하는 다양 한 `Employee` 를 차례로 호출 하는 개체는 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 메서드 (즉, 인덱스 4에 있는 멤버)의 5 번째 멤버로 시작 해 컬렉션에서 검색할를 두 번입니다. 첫 번째 처음으로 검색 `Employee` 개체 `Name` "J"로 시작 하는 필드를 두 번 검색할 첫 번째; `Employee` 개체 `Name` "Ju"로 시작 하는 필드입니다.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 지정된 인덱스부터 시작하여 지정된 수의 요소를 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 까지 검색은 `startIndex` 에서 끝나는 `startIndex` 플러스 `count` 에서 1을 뺀 경우 `count` 가 0 보다 크면 합니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다. 대리자에 서명을 합니다.  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Employee` 두 필드를 사용 하 여 클래스 `Name` 및 `Id`합니다. 또한 정의 `EmployeeSearch` 단일 메서드를 사용 하 여 클래스 `StartsWith`, 나타내는 여부는 `Employee.Name` 필드의 지정한 부분에 제공 된 시작는 `EmployeeSearch` 클래스 생성자 합니다. 이 메서드의 서명은 참고  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 에 전달 될 수 있는 대리자의 서명과에 해당 하는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드. 이 예제에서는 인스턴스화합니다는 `List<Employee>` 개체를 추가 하는 다양 한 `Employee` 를 차례로 호출 하는 개체는 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 컬렉션에서 전체 검색을 두 번 메서드 (즉, 멤버 인덱스 0 인덱스 <xref:System.Collections.Generic.List%601.Count%2A> -1). 첫 번째 처음으로 검색 `Employee` 개체 `Name` "J"로 시작 하는 필드를 두 번 검색할 첫 번째; `Employee` 개체 `Name` "Ju"로 시작 하는 필드입니다.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="startIndex" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 섹션을 나타내지 않는 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <see cref="T:System.Collections.Generic.List`1" />에서 마지막으로 검색한 요소를 반환합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소이고, 그렇지 않으면 <paramref name="T" /> 형식의 기본값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 를 개별적으로 전달 되는 <xref:System.Predicate%601> 뒤로 이동 대리자는 <xref:System.Collections.Generic.List%601>은 지난 요소의 시작 하 고 첫 번째 요소까지 합니다.  일치 하는 경우 처리가 중지 됩니다.  
  
> [!IMPORTANT]
>  값 형식을 포함 하는 목록을 검색할 때 형식에 대 한 기본값 검색 조건자를 충족 하지 않습니다 확인 합니다. 그렇지 않은 경우 일치 항목이 없는 찾았음을 나타내는 기본 값 및 유형에 대 한 기본값을가 하는 목록 요소를 구분 하기 위해 방식은 없습니다. 사용 하 여 검색 조건자를 충족 하는 경우는 <xref:System.Collections.Generic.List%601.FindLastIndex%2A> 메서드 대신 합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 위한 좋은 메서드는 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스 포함 `book` 클래스의 개체 `Book`, 데이터를 사용 하는 [샘플 XML 파일: Books (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)합니다. `FillList` 메서드 예제에서 사용 하 여 [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석 하는 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 하는 예제를 설명 합니다.  
  
|메서드|예|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|해당 갖는 모든 책 찾기 `Genre` 속성은 "컴퓨터"를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|사용 하 여 2001 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책을 찾습니다는 `PubBefore2001` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 컴퓨터의 첫 번째 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 마지막 컴퓨터 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 <see cref="T:System.Collections.Generic.List`1" />이나 그 일부에서 마지막으로 검색한 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <see cref="T:System.Collections.Generic.List`1" />에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 위한 좋은 메서드는 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스 포함 `book` 클래스의 개체 `Book`, 데이터를 사용 하는 [샘플 XML 파일: Books (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)합니다. `FillList` 메서드 예제에서 사용 하 여 [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석 하는 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 하는 예제를 설명 합니다.  
  
|메서드|예|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|해당 갖는 모든 책 찾기 `Genre` 속성은 "컴퓨터"를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|사용 하 여 2001 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책을 찾습니다는 `PubBefore2001` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 컴퓨터의 첫 번째 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 마지막 컴퓨터 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 첫 번째 요소에서 지정된 인덱스로 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 검색 됩니다에 `startIndex` 첫 번째 요소의 끝입니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 의 시작 부분에서 요소 수는는 <xref:System.Collections.Generic.List%601> 를 `startIndex`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 수의 요소가 들어 있고 지정된 인덱스에서 끝나는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 검색 됩니다에 `startIndex` 에서 끝나는 `startIndex` 뺀 `count` + 1, 경우 `count` 가 0 보다 크면 합니다.  
  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 위한 좋은 메서드는 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스 포함 `book` 클래스의 개체 `Book`, 데이터를 사용 하는 [샘플 XML 파일: Books (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)합니다. `FillList` 메서드 예제에서 사용 하 여 [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석 하는 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 하는 예제를 설명 합니다.  
  
|메서드|예|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|해당 갖는 모든 책 찾기 `Genre` 속성은 "컴퓨터"를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|사용 하 여 2001 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책을 찾습니다는 `PubBefore2001` predicate 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 컴퓨터의 첫 번째 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|컬렉션의 절반 두 번째에서 마지막 컴퓨터 책의 인덱스를 찾습니다를 사용 하는 `FindComputer` predicate 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="startIndex" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 섹션을 나타내지 않는 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">
          <see cref="T:System.Collections.Generic.List`1" />의 각 요소에 대해 수행할 <see cref="T:System.Action`1" /> 대리자입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />의 각 요소에 대해 지정된 작업을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> 개체에 동작을 수행 하는 메서드에 대리자에 전달 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Action%601> 위임 합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 본문에는 내부 컬렉션을 수정 된 <xref:System.Action%601> 대리자는 지원 되지 않으며 정의 되지 않은 동작이 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Action%601> 의 내용을 인쇄 하는 대리자는 <xref:System.Collections.Generic.List%601> 개체입니다. 이 예제는 `Print` 메서드는 목록의 내용을 콘솔에 표시 하는 데 사용 됩니다.  
  
> [!NOTE]
>  사용 하 여 콘텐츠를 표시 하는 것 외에도 `Print` 메서드는 C# 예제는 콘솔에 결과 표시 하려면의 사용법을 보여줍니다.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">컬렉션의 요소가 수정되었습니다.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />를 반복하는 열거자를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1.Enumerator" />에 대한 <see cref="T:System.Collections.Generic.List`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에서의 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 속성이 정의 되지 않습니다. 따라서 호출 해야 합니다는 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>합니다.  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 속성 반환 될 때까지 동일한 개체 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 호출 됩니다. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>는 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>를 컬렉션의 첫 번째 요소로 다시 설정할 수 없으므로 대신 새 열거자 인스턴스를 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">범위가 시작되는 <see cref="T:System.Collections.Generic.List`1" /> 인덱스(0부터 시작)입니다.</param>
        <param name="count">범위의 요소 수입니다.</param>
        <summary>소스 <see cref="T:System.Collections.Generic.List`1" />에 있는 일련의 요소에 대한 단순 복사본을 만듭니다.</summary>
        <returns>소스 <see cref="T:System.Collections.Generic.List`1" />에 있는 일련의 요소에 대한 단순 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해당 컬렉션의 하위 집합 또는 참조 형식, 컬렉션의 단순 복사본을 컬렉션의 요소에 대 한 참조만 포함 되어 있습니다. 개체 자체가 복사 되지 않습니다. 새 목록에 참조를 원래 목록에 참조로 동일한 개체를 가리킵니다.  
  
 컬렉션의 요소를 포함 하는 값 형식 컬렉션 또는 컬렉션의 하위 집합의 단순 복사본입니다. 그러나 컬렉션의 요소는 다른 개체에 대 한 참조가 들어 있으면 해당 개체 복사 되지 않습니다. 새 컬렉션의 요소에 참조 개체는 원본 컬렉션의 요소에 대 한 참조와 동일한 개체를 가리킵니다.  
  
 반면, 요소를 복사 하는 컬렉션의 전체 복사본 및 뿐만 아니라 해당 요소에서 직접 또는 간접적으로 참조 하는 모든 항목입니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.GetRange%2A> 메서드와는 다른 방법으로는 <xref:System.Collections.Generic.List%601> 범위에서 동작 하는 클래스입니다. 예의 끝에는 <xref:System.Collections.Generic.List%601.GetRange%2A> 메서드 인덱스 위치 2 부터는 목록에서 세 가지 항목을 가져오는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.ToArray%2A> 메서드 결과에 <xref:System.Collections.Generic.List%601>, 세 요소의 배열 생성. 배열 요소의 표시 됩니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에 있는 요소의 올바른 범위를 나타내지 않는 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에서 처음 나오는 값의 인덱스(0부터 시작)를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정된 개체를 검색하고, 전체 <see cref="T:System.Collections.Generic.List`1" />에서 처음으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="item" />이 있으면 전체 <see cref="T:System.Collections.Generic.List`1" />에서 맨 처음 발견되는 값의 0부터 시작하는 인덱스이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 검색은 앞으로 첫 번째 요소부터 마지막 요소입니다.  
  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.IndexOf%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> 메서드 오버 로드는 처음부터 검색 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하는 목록 및 목록의 끝을 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">검색의 0부터 시작하는 인덱스입니다. 0은 빈 목록에서 유효합니다.</param>
        <summary>지정된 개체를 검색하고, 지정된 인덱스에서 마지막 요소로 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 처음으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="index" />부터 마지막 요소까지 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 <paramref name="item" />이 있으면 처음으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 까지 검색은 `index` 마지막 요소의 끝입니다.  
  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 의 요소 수 `index` 의 끝에는 <xref:System.Collections.Generic.List%601>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.IndexOf%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> 메서드 오버 로드는 처음부터 검색 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하는 목록 및 목록의 끝을 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">검색의 0부터 시작하는 인덱스입니다. 0은 빈 목록에서 유효합니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>지정된 개체를 검색하고, 지정된 인덱스에서 시작하여 지정된 수의 요소를 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 처음으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="index" />에서 시작하여 <paramref name="count" />개의 요소를 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 <paramref name="item" />이 있으면 처음으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 까지 검색은 `index` 에서 끝나는 `index` 플러스 `count` 에서 1을 뺀 경우 `count` 가 0 보다 크면 합니다.  
  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.IndexOf%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> 메서드 오버 로드는 처음부터 검색 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하는 목록 및 목록의 끝을 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 두 인덱스 위치에서 시작 하는 두 항목의 범위를 검색 하는 데 사용 됩니다; 해당 범위에 검색 문자열의 인스턴스가 없는 때문에-1을 반환 합니다.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 섹션을 나타내지 않는 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>항목</c>이 삽입될 0부터 시작하는 인덱스입니다.</param>
        <param name="item">삽입할 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />의 지정된 인덱스에 요소를 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값을 입력 하 고 중복 요소를 허용 합니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 이미 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량이 <xref:System.Collections.Generic.List%601> 자동으로 내부 배열을 다시 할당 하 여 증가 새 요소를 추가 하기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 경우 `index` 같으면 <xref:System.Collections.Generic.List%601.Count%2A>, `item` 의 끝에 추가 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Insert%2A> 메서드와 함께 다양 한 다른의 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. 목록을 만든 후에 요소가 추가 됩니다. <xref:System.Collections.Generic.List%601.Insert%2A> 가운데 목록에 항목을 삽입 하려면 메서드를 사용 합니다. 항목 나중에 제거를 사용 하 여 중복은 삽입 된 <xref:System.Collections.Generic.List%601.Remove%2A> 메서드.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 큰 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">새 요소가 삽입되어야 하는 0부터 시작하는 인덱스입니다.</param>
        <param name="collection">요소가 <see cref="T:System.Collections.Generic.List`1" />에 삽입되어야 하는 컬렉션입니다. 컬렉션 자체가 <see langword="null" />일 수는 없지만 <c>T</c> 형식이 참조 형식인 경우 <see langword="null" />인 요소를 포함할 수 있습니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />의 지정된 인덱스에 컬렉션의 요소를 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값을 입력 하 고 중복 요소를 허용 합니다.  
  
 하는 경우 새 <xref:System.Collections.Generic.List%601.Count%2A> (현재 <xref:System.Collections.Generic.List%601.Count%2A> 컬렉션의 크기를 더한) 보다 커야 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량이 <xref:System.Collections.Generic.List%601> 자동으로 새 요소를 수용 하기 위해 내부 배열을 다시 할당 하 여 증가 및 새 요소가 추가 하기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 경우 `index` 같으면 <xref:System.Collections.Generic.List%601.Count%2A>, 요소의 끝에 추가 되어 <xref:System.Collections.Generic.List%601>합니다.  
  
 컬렉션에 있는 요소의 순서는 유지 된 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O는 (*n* * *m*) 작업을 여기서 *n* 추가할 수 있는 요소의 수가 고 *m* 는<xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Collections.Generic.List%601.InsertRange%2A> 메서드와의 다른 다양 한 메서드는 <xref:System.Collections.Generic.List%601> 범위에서 동작 하는 클래스입니다. 목록에 만들고 몇 가지 식 공룡의의 이름으로 채워진 후의 <xref:System.Collections.Generic.List%601.InsertRange%2A> 세 사나운 식 공룡의의 배열 인덱스 위치 3에서 시작 하 여 목록에 삽입할 메서드를 사용 합니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 큰 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져오거나 설정할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary>지정한 인덱스에 있는 요소를 가져오거나 설정합니다.</summary>
        <value>지정한 인덱스의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값을 입력 하 고 중복 요소를 허용 합니다.  
  
 이 속성은 `myCollection[index]` 구문을 사용하여 컬렉션의 특정 요소에 액세스하는 기능을 제공합니다.  
  
 이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.  
  
   
  
## Examples  
 이 섹션의 예제에 <xref:System.Collections.Generic.List%601.Item%2A> 속성 (C# 인덱서) 및 다양 한 다른의 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. 목록 후에 만들고 사용 하 여 채울는 <xref:System.Collections.Generic.List%601.Add%2A> 메서드는 요소를 검색 및 사용 하 여 표시는 <xref:System.Collections.Generic.List%601.Item%2A> 속성입니다. (사용 하는 예제는 <xref:System.Collections.Generic.List%601.Item%2A> 목록 요소 값을 설정 하는 속성 참조 <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C# 및 c + + 모든는 액세스 하기 위한 구문이 <xref:System.Collections.Generic.List%601.Item%2A> 해당 이름을 사용 하지 않고 속성입니다. 대신, 포함 하는 변수는 <xref:System.Collections.Generic.List%601> 배열인 것 처럼 사용 됩니다.  
  
 C# 언어의 키워드를 사용 하 여 구현 하는 대신 인덱서를 정의 하는 <xref:System.Collections.Generic.List%601.Item%2A> 속성입니다. Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <xref:System.Collections.Generic.List%601.Item%2A>을 기본 속성으로 구현합니다.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 크거나 같은 경우</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에서 마지막으로 나오는 값의 인덱스(0부터 시작)를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정된 개체를 검색하고 전체 <see cref="T:System.Collections.Generic.List`1" />에서 마지막으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>전체 <see cref="T:System.Collections.Generic.List`1" />에 <paramref name="item" />이 있으면 마지막으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> 메서드 오버 로드 끝부터 전체 목록을 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하 고 문자열의 첫 번째 목록에서 검색 등과의 시작 부분에 계속 이전 버전과 목록을 검색 하는 데 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <summary>지정된 개체를 검색하고, 첫 번째 요소에서 지정된 인덱스로 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 마지막으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>첫 번째 요소부터 <paramref name="index" />까지 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 <paramref name="item" />이 있으면 마지막으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 검색 됩니다에 `index` 첫 번째 요소의 끝입니다.  
  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 의 시작 부분에서 요소 수는는 <xref:System.Collections.Generic.List%601> 를 `index`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> 메서드 오버 로드 끝부터 전체 목록을 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하 고 문자열의 첫 번째 목록에서 검색 등과의 시작 부분에 계속 이전 버전과 목록을 검색 하는 데 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>지정된 개체를 검색하며, 지정된 수의 요소를 포함하고 지정된 인덱스에서 끝나는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 마지막으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>
          <paramref name="count" />개의 요소를 포함하고 <paramref name="index" />에서 끝나는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 <paramref name="item" />이 있으면 마지막으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 검색 됩니다에 `index` 에서 끝나는 `index` 뺀 `count` + 1, 경우 `count` 가 0 보다 크면 합니다.  
  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 오버 로드를 모두는 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 메서드. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 0과 5 인덱스 위치에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> 메서드 오버 로드 끝부터 전체 목록을 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드는 인덱스 위치 3 시작 하 고 문자열의 첫 번째 목록에서 검색 등과의 시작 부분에 계속 이전 버전과 목록을 검색 하는 데 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 4 개의 항목을 인덱스 위치 4에서 시작 하 고 뒤로 확장할 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스가 없는 때문에이 검색 – 1을 반환 해당 범위에는 문자열입니다.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 섹션을 나타내지 않는 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.List`1" />에서 제거할 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />에서 맨 처음 발견되는 특정 개체를 제거합니다.</summary>
        <returns>
          <paramref name="item" />이 제거되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.  이 메서드는 <see langword="false" />가 <paramref name="item" />에 없는 경우에도 <see cref="T:System.Collections.Generic.List`1" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 형식 `T` 구현 하는 <xref:System.IEquatable%601> 제네릭 인터페이스 같음 비교자는는 <xref:System.IEquatable%601.Equals%2A> ; 해당 인터페이스의 메서드 그렇지 않으면 기본 같음 비교자는 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제에서는 <xref:System.Collections.Generic.List%601.Remove%2A> 메서드. 여러의 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 제네릭 클래스는 추가, 삽입 및 목록을 검색 하는 데 사용 됩니다. 이러한 작업을 수행한 후 목록에 중복 포함 되어 있습니다. <xref:System.Collections.Generic.List%601.Remove%2A> 메서드를 사용 하 여 중복 항목의 첫 번째 인스턴스를 제거 하 고 내용이 표시 됩니다. <xref:System.Collections.Generic.List%601.Remove%2A> 항상 메서드를 발견 하는 첫 번째 인스턴스를 제거 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">제거할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 모두 제거합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1" />에서 제거한 요소의 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 를 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자와 조건과 일치 하는 요소에서 제거 됩니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 메서드와 사용 하는 몇 가지 다른 메서드는 <xref:System.Predicate%601> 제네릭 대리자입니다.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 들어 있는입니다. 이 예제에서는 또한 라는 검색 조건자 메서드를 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, 및 <xref:System.Collections.Generic.List%601.FindAll%2A> 메서드는 검색 조건자 메서드를 사용 하 여 목록을 검색 하는 데 사용 됩니다.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 메서드는 "saurus"로 끝나는 모든 항목을 제거 하는 데 사용 됩니다. 각 요소에 전달 하는 처음부터 목록 트래버스할는 `EndsWithSaurus` 메서드. 요소가 제거 하는 경우는 `EndsWithSaurus` 메서드 반환 `true`합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어는 컨텍스트를 올바른 대리자를 유추 하 고 자동으로 만듭니다.  
  
 마지막으로 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드 "saurus"로 끝나는 없는 문자열 목록에 있는지 확인 합니다.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />의 지정된 인덱스에 있는 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우 <xref:System.Collections.Generic.List%601.RemoveAt%2A> 항목을 제거 하려면 목록에서 나머지 항목 제거 된 항목을 바꾸려면 매겨집니다. 예를 들어 인덱스 3에 있는 항목을 제거 하면 4 인덱스의 항목 3 위치로 이동 합니다. 또한 목록에 있는 항목의 수 (로 표현 되는 <xref:System.Collections.Generic.List%601.Count%2A> 속성) 1 씩 감소 됩니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 됩니다 (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 크거나 같은 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 요소의 범위에 대한 0부터 시작하는 인덱스입니다.</param>
        <param name="count">제거할 요소의 수입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />에서 요소의 범위를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목이 제거 되 고에 그 뒤에 모든 요소는 <xref:System.Collections.Generic.List%601> 감소 인덱스가 `count`합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.RemoveRange%2A> 메서드와의 다른 다양 한 메서드는 <xref:System.Collections.Generic.List%601> 범위에서 동작 하는 클래스입니다. 목록 생성 되 고 수정 된 후의 <xref:System.Collections.Generic.List%601.RemoveRange%2A> 메서드를 사용 하 여 인덱스 위치 2에서 시작 하 고 목록에서 두 개의 요소를 제거 하 합니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에 있는 요소의 올바른 범위를 나타내지 않는 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에서 요소의 순서를 반대로 바꿉니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>전체 <see cref="T:System.Collections.Generic.List`1" />에서 요소의 순서를 반대로 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 사용 하 여 <xref:System.Array.Reverse%2A?displayProperty=nameWithType> 요소의 순서를 반대로 하려면.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 <xref:System.Collections.Generic.List%601.Reverse%2A> 메서드. 이 예에서는 만듭니다는 <xref:System.Collections.Generic.List%601> 의 문자열 및 문자열 6 개를 추가 합니다. <xref:System.Collections.Generic.List%601.Reverse> 목록 되돌리려면 메서드 오버 로드를 사용 하는 다음의 <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> 메서드 오버 로드는 요소 1로 시작 하 고 4 개의 요소가 포함 된 목록의 중간을 반대로 하는 데 사용 됩니다.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">순서를 반대로 바꿀 범위의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">순서를 반대로 바꿀 범위의 요소 수입니다.</param>
        <summary>지정된 범위에서 요소의 순서를 반대로 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은 사용 하 여 <xref:System.Array.Reverse%2A?displayProperty=nameWithType> 요소의 순서를 반대로 하려면.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 <xref:System.Collections.Generic.List%601.Reverse%2A> 메서드. 이 예에서는 만듭니다는 <xref:System.Collections.Generic.List%601> 의 문자열 및 문자열 6 개를 추가 합니다. <xref:System.Collections.Generic.List%601.Reverse> 목록 되돌리려면 메서드 오버 로드를 사용 하는 다음의 <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> 메서드 오버 로드는 요소 1로 시작 하 고 4 개의 요소가 포함 된 목록의 중간을 반대로 하는 데 사용 됩니다.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에 있는 요소의 올바른 범위를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에 포함된 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>오버 로드 된 메서드 구문  
 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드를 사용 하면 목록에서 개체 유형에 대 한 기본 비교자를 정렬할 수 또는 고객 정렬 방법을 지정 합니다.  
  
 [목록\<T >. Sort ()](xref:System.Collections.Generic.List`1.Sort*) 개체 유형의 기본 비교자를 사용 하 여 전체 목록의 요소를에서 정렬 합니다. 목록에 보관 합니다.  
  
 [목록\<T >. 정렬 M (비교\<T > 비교)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) 지정된 된 비교자를 사용 하 여 전체 목록에 요소를 정렬 합니다.  
  
 [목록\<T >. 정렬 (IComparer\<T > 비교자)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) 요소를 사용 하 여 지정 된 전체 목록에서 정렬 <xref:System.Comparison%601?displayProperty=nameWithType>합니다.  
  
 [목록\<T >. 정렬 (Int32 인덱스, Int32 카운트 IComparer\<T > 비교자)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) 지정된 된 비교자를 사용 하 여 목록에서 요소의 범위에 있는 요소를 정렬 합니다.  
  
## <a name="parameters"></a>매개 변수  
  
|매개 변수|형식|설명|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|요소를 비교할 때 사용할 대리자 메서드|  
|비교자|<xref:System.Collections.Generic.IComparer%601>|<xref:System.Collections.Generic.IComparer%601> 기본 비교자를 사용 하려면 null 또는 요소를 비교할 때 사용 하도록 구현 <xref:System.Collections.Generic.Comparer%601.Default>합니다.|  
|`index`|<xref:System.Int32>|정렬할 범위의 0부터 시작하는 인덱스입니다.|  
|`count`|<xref:System.Int32>|정렬할 범위의 길이입니다.|  
  
## <a name="exceptions"></a>예외  
  
|예외|조건|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer` 지정 하지 않으면 또는 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 의 구현을 찾을 수 없습니다는 <xref:System.IComparable%601?displayProperty=nameWithType> 제네릭 인터페이스 또는 <xref:System.IComparable?displayProperty=nameWithType> 화 형식에 대 한 인터페이스|  
|<xref:System.ArgumentNullException>|`comparison`가 `null`인 경우|  
|<xref:System.ArgumentException>|구현 `comparison` 또는 `comparer` 정렬 하는 동안 오류가 발생 했습니다. 예를 들어 항목을 자기 자신과 비교할 때 `comparison`에서 0을 반환하지 않을 수 있습니다.<br /><br /> 또는<br /><br /> `index` 및 `count`가 <xref:System.Collections.Generic.List%601>의 올바른 범위를 지정하지 않습니다.|  
|<xref:System.ArgumentOutOfRangeException>|`index` 가 0 보다 작은 또는 `count` 0 보다 작습니다.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 비교자를 사용하여 전체 <see cref="T:System.Collections.Generic.List`1" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 비교 자가 사용 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 형식에 대 한 `T` 목록 요소의 순서를 결정 합니다. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 속성 검사 하는지 여부를 입력 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스를 구현 하를 사용 하 여 사용 가능한 경우.  그렇지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않는 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 이 방법은 사용 하 여는 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 메서드를 다음과 같이 맞추어 내면적인 정렬 적용 됩니다.  
  
-   파티션 크기는 16 개 요소를 삽입 정렬 알고리즘을 사용 됩니다.  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*여기서 *n* 범위는 입력 배열의 Heapsort 알고리즘을 사용 합니다.  
  
-   그렇지 않으면 Quicksort 알고리즘을 사용 합니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는는 O (*n* 로그 *n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 예제에서는 일부 이름을 `List<String>` 목록을 정렬 되지 않은 순서로 호출 하는 개체, 표시는 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드를 다음 정렬된 된 목록을 표시 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 다음 코드에서는 <xref:System.Collections.Generic.List%601.Sort> 및 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 간단한 비즈니스 개체에 메서드 오버 로드 합니다. 호출의 <xref:System.Collections.Generic.List%601.Sort> 메서드 파트 형식에 대 한 기본 비교 자가 사용으로 인해 및 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 메서드는 무명 메서드를 사용 하 여 구현 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort> 메서드 오버 로드와 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드 합니다. A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다. 목록은 표시 하 고 정렬 하 고 다시 표시 됩니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드는 다음 목록에 없는 두 문자열을 검색 하는 데 사용 됩니다 및 <xref:System.Collections.Generic.List%601.Insert%2A> 삽입할 메서드를 사용 합니다. 반환 값은 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 문자열 목록에 없기 때문에 메서드는 각각의 경우에서 음수입니다. 비트 보수 (고 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)이 음수 숫자 생성 검색 문자열 보다는 커야 하며 삽입이 위치에 있는 목록에서 첫 번째 요소의 인덱스 유지 정렬 순서입니다. 두 번째 검색 문자열 목록에 있는 모든 요소 보다 큰 이므로 목록의 끝에 삽입 위치는입니다.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현이거나, 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 전체 <see cref="T:System.Collections.Generic.List`1" />에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 제공의 요소는 <xref:System.Collections.Generic.List%601> 사용 하 여 지정 된 정렬 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스 사용 가능한 경우 해당 구현을 사용 하 여 합니다.  그렇지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않는 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 이 방법은 사용 하 여는 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 메서드를 다음과 같이 맞추어 내면적인 정렬 적용 됩니다.  
  
-   파티션 크기는 16 개 요소를 삽입 정렬 알고리즘을 사용 됩니다.  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*여기서 *n* 범위는 입력 배열의 Heapsort 알고리즘을 사용 합니다.  
  
-   그렇지 않으면 Quicksort 알고리즘을 사용 합니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는는 O (*n* 로그 *n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드와 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 대체는 비교자 DinoCompare 구현 하는 명명 된 문자열에 대 한 정의 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 다음과 같이 작동 되는 비교자:에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다. 셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다. 목록 다시 표시 됩니다, 대체 비교자를 사용 하 여 정렬 되 고 표시 합니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 하지 목록에서 사용 중인 대체 비교자 여러 문자열을 검색 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.Insert%2A> 메서드를 사용 하 여 문자열을 삽입 합니다. 라는 함수에 있는 다음 두 가지 방법 `SearchAndInsert`, 비트 보수를 수행 하는 코드와 함께 (의 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)에서 반환 된 음수의 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 에 대 한 인덱스로 사용 하 여 새 문자열을 삽입 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 또는 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스의 구현을 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">요소를 비교할 때 사용할 <see cref="T:System.Comparison`1" />입니다.</param>
        <summary>지정된 <see cref="T:System.Comparison`1" />을 사용하여 전체 <see cref="T:System.Collections.Generic.List`1" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparison` 제공의 요소는 <xref:System.Collections.Generic.List%601> 대리자가 나타내는 메서드를 사용 하 여 정렬 됩니다.  
  
 경우 `comparison` 은 `null`, <xref:System.ArgumentNullException> throw 됩니다.  
  
 이 방법은 사용 하 여 <xref:System.Array.Sort%2A?displayProperty=nameWithType>, 다음과 같이 맞추어 내면적인 정렬 적용:  
  
-   파티션 크기는 16 개 요소를 삽입 정렬 알고리즘 사용  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*여기서 *n* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 Quicksort 알고리즘을 사용 합니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는는 O (*n* 로그 *n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 코드에서는 <xref:System.Collections.Generic.List%601.Sort%2A> 및 <xref:System.Collections.Generic.List%601.Sort%2A> 간단한 비즈니스 개체에 메서드 오버 로드 합니다. 호출의 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드 파트 형식에 대 한 기본 비교 자가 사용으로 인해 및 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드는 무명 메서드를 사용 하 여 구현 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 문자열에 대 한 대체 비교 메서드를 정의 `CompareDinosByLength`합니다. 이 방법은 다음과 같습니다:에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다. 셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들어지고 특정 순서 없이에서 4 개의 문자열 채워집니다. 목록에는 빈 문자열과 null 참조가 포함 됩니다. 사용 하 여 정렬 목록이 표시 되는 <xref:System.Comparison%601> 나타내는 제네릭 대리자는 `CompareDinosByLength` 메서드를 다시 표시 합니다.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparison" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <altmember cref="T:System.Comparison`1" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">정렬할 범위의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">정렬할 범위의 길이입니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현이거나, 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 제공의 요소는 <xref:System.Collections.Generic.List%601> 사용 하 여 지정 된 정렬 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable%601> 제네릭 인터페이스 사용 가능한 경우 해당 구현을 사용 하 여 합니다.  그렇지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부 입력 `T` 구현 하는 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않는 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 이 방법은 사용 하 여 <xref:System.Array.Sort%2A?displayProperty=nameWithType>, 다음과 같이 맞추어 내면적인 정렬 적용:  
  
-   파티션 크기는 16 개 요소를 삽입 정렬 알고리즘 사용  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*여기서 *n* 는 범위 입력 배열을 사용 하 여 한 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 Quicksort 알고리즘을 사용 합니다.  
  
 이 구현은 수행 불안정 정렬 됩니다. 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정적인 정렬 같은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는는 O (*n* 로그 *n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드와 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 대체는 비교자 DinoCompare 구현 하는 명명 된 문자열에 대 한 정의 `IComparer<string>` (`IComparer(Of String)` Visual Basic의 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 다음과 같이 작동 되는 비교자:에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열이 큰 것으로 간주 됩니다. 셋째, 길이 값이 같으면 일반 문자열 비교 ´ ù.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들고 5 개의 예제 공룡과 예제의 이름으로 채워집니다. 두 그룹의 각 이름은 특정 정렬 순서에 있지 않습니다. 목록이 표시 됩니다, 대체 비교자를 사용 하 여 초 식의 범위에 정렬 하 고 목록을 다시 표시 됩니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 초 식의 범위에만 "Brachiosaurus"를 검색 하는 데 사용 됩니다. 문자열이 없습니다 비트 보수 (에서 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)에서 반환 되는 음수의는 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드는 새 문자열을 삽입 하기 위한 인덱스로 사용 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 0보다 작습니다.  
  
 또는  
  
 <paramref name="count" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 범위를 지정하지 않습니다.  
  
 또는  
  
 <paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 또는 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스의 구현을 찾을 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.ICollection`1" />가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />가 읽기 전용이면 <see cref="T:System.Collections.Generic.ICollection`1" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션에서 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에서의 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성이 정의 되지 않습니다. 따라서 호출 해야 합니다는 <xref:System.Collections.IEnumerator.MoveNext%2A> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>합니다.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성 반환 될 때까지 동일한 개체 <xref:System.Collections.IEnumerator.MoveNext%2A> 호출 됩니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 정의 되지 않습니다. <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 컬렉션의 첫 번째 요소로 다시 설정할 수 없으므로 대신 새 열거자 인스턴스를 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.ICollection" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex">
          <c>배열</c>에서 복사를 시작할 인덱스입니다. 이 인덱스는 0부터 시작합니다.</param>
        <summary>특정 <see cref="T:System.Collections.ICollection" /> 인덱스부터 시작하여 <see cref="T:System.Array" />의 요소를 <see cref="T:System.Array" />에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  경우는 원본의 유형을 <xref:System.Collections.ICollection> 대상의 형식으로 자동 캐스팅할 수 없는 `array`의 제네릭이 아닌 구현은 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, 제네릭 구현 throw 하는 반면, <xref:System.ArgumentException>합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" />가 다차원 배열인 경우  
  
 또는  
  
 <paramref name="array" />에 0부터 시작하는 인덱스가 없습니다.  
  
 또는  
  
 소스 <see cref="T:System.Collections.ICollection" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지 사용 가능한 공간보다 큽니다.  
  
 또는  
  
 소스 <see cref="T:System.Collections.ICollection" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see cref="T:System.Collections.ICollection" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.  열거형 쓰기 권한과 경쟁 하는 드문 경우에 전체 열거 동안 컬렉션을 잠글 수 있습니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체를 반환 된 <xref:System.Collections.ICollection>합니다. 동기화는 모든 스레드에서 컬렉션에 액세스 하기 전에이 개체를 잠그는 경우에 유효 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 현재 인스턴스를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 에 대 한 액세스를 동기화 하는 데 사용할 수 있는 개체를 반환 된 <xref:System.Collections.ICollection>합니다. 동기화는 모든 스레드에서 컬렉션에 액세스 하기 전에이 개체를 잠그는 경우에 유효 합니다. 다음 코드의 사용을 보여 줍니다.는 <xref:System.Collections.ICollection.SyncRoot%2A> C#, c + + 및 Visual Basic에 대 한 속성입니다.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션에서 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual basic에서)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서의 <xref:System.Collections.IEnumerator.Current%2A> 속성이 정의 되지 않습니다. 따라서 호출 해야 합니다는 <xref:System.Collections.IEnumerator.MoveNext%2A> 하 여 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소로 메서드 <xref:System.Collections.IEnumerator.Current%2A>합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> 라고 합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 전달 컬렉션의 마지막 요소 뒤에 열거자는 컬렉션의 끝에 배치 되 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출에서 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 메서드는 o (1) 작업.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" />에 추가할 <see cref="T:System.Collections.IList" />입니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에 항목을 추가합니다.</summary>
        <returns>새 요소가 삽입된 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다. 이 메서드는 O 됩니다 용량을 새 요소로 적용로 늘려야 하는 경우 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" />에서 찾을 <see cref="T:System.Collections.IList" />입니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에 특정 값이 들어 있는지 여부를 확인합니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="item" />에 있으면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.IList" />에서 찾을 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에서 특정 항목의 인덱스를 결정합니다.</summary>
        <returns>목록에 있으면 <paramref name="item" />의 인덱스이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>항목</c>이 삽입될 0부터 시작하는 인덱스입니다.</param>
        <param name="item">
          <see cref="T:System.Collections.IList" />에 삽입할 개체입니다.</param>
        <summary>항목을 <see cref="T:System.Collections.IList" />의 지정된 인덱스에 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`가 <xref:System.Collections.IList>의 항목 수와 같으면 `item`가 끝에 추가됩니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.IList" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IList" />의 크기가 고정되어 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />의 크기가 고정되어 있으면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기가 고정된 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가하거나 제거할 수 없지만 기존 요소는 수정할 수 있습니다.  
  
 크기가 고정된 된 컬렉션은 요소; 추가 및 제거를 방지 하는 래퍼가 지정 된 컬렉션 따라서를 추가 하거나 제거할 요소를 포함 하 여 내부 컬렉션을 변경 하는 경우 고정 크기 컬렉션에 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IList" />가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see langword="true" />가 읽기 전용이면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 될 경우 읽기 전용 컬렉션 해당 변경 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져오거나 설정할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary>지정한 인덱스에 있는 요소를 가져오거나 설정합니다.</summary>
        <value>지정한 인덱스의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 언어의 [이](~/docs/csharp/language-reference/keywords/this.md) 구현 하는 대신 인덱서를 정의 하는 키워드는 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> 속성입니다. Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>을 기본 속성으로 구현합니다.  
  
 이 속성의 값을 검색 하 하는 것은 o (1) 연산입니다. o (1) 작업 이기도 속성을 설정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />가 <see cref="T:System.Collections.IList" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">속성이 설정되어 있고 <paramref name="value" />의 형식을 <see cref="T:System.Collections.IList" />에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.IList" />에서 제거할 개체입니다.</param>
        <summary>
          <see cref="T:System.Collections.IList" />에서 맨 처음 발견되는 특정 개체를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 같음 비교자를 사용 하 여 일치 확인 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는 선형 검색; 수행 따라서이 메서드는는 O (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />의 요소를 새 배열에 복사합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1" />의 요소 복사본을 포함하는 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 요소가 복사 되 <xref:System.Array.Copy%2A?displayProperty=nameWithType>, 변수인는 O (*n*) 작업을 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.ToArray%2A> 메서드와는 다른 방법으로는 <xref:System.Collections.Generic.List%601> 범위에서 동작 하는 클래스입니다. 예의 끝에는 <xref:System.Collections.Generic.List%601.GetRange%2A> 메서드 인덱스 위치 2 부터는 목록에서 세 가지 항목을 가져오는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.ToArray%2A> 메서드 결과에 <xref:System.Collections.Generic.List%601>, 세 요소의 배열 생성. 배열 요소의 표시 됩니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />에 있는 요소의 실제 수가 임계값보다 작은 경우 용량을 요소 수로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 새 요소가 컬렉션에 추가 될 경우 컬렉션의 메모리 오버 헤드를 최소화할 데 사용할 수 있습니다. 그러나 재할당 하 고 복사 큰 비용 <xref:System.Collections.Generic.List%601> 상당히 커질 수 하므로 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드는 아무 작업도 수행 목록의 용량의 90%를 초과 하는 경우. 이 상대적으로 작은 향상 큰 재할당 비용을 발생 시키는 것을 방지 합니다.  
  
> [!NOTE]
>  90%의 현재 임계값 이후 릴리스에서 변경 될 수 있습니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 다시 설정 하는 <xref:System.Collections.Generic.List%601> 를 초기 상태로 호출는 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드 호출 하기 전에 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드. 빈 트리밍 <xref:System.Collections.Generic.List%601> 의 용량 설정는 <xref:System.Collections.Generic.List%601> 기본 용량을 합니다.  
  
 사용 하 여 용량 설정할 수도 있습니다는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 용량 및 개수를 확인 하는 <xref:System.Collections.Generic.List%601> 간단한 비즈니스 개체를 포함 하 고 사용 하 여는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 추가 용량을 제거 하는 메서드.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드. 여러의 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 클래스는 추가, 삽입 및 문자열의 목록에서 항목을 제거 하는 데 사용 됩니다. 그런 다음 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드를 사용 하는 개수와 일치 하는 용량을 줄일 및 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다. 사용 되지 않는 용량 검색의 총 용량 10% 미만 했다면, 목록은 하지 크기가 조정 되었습니다. 마지막으로, 목록의 내용은 지워집니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">요소에 대해 확인할 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>
          <see cref="T:System.Collections.Generic.List`1" />의 모든 요소가 지정된 조건자에 정의된 조건과 일치하는지 여부를 확인합니다.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1" />의 모든 요소가 지정된 조건자에 정의된 조건과 일치하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 목록에 요소가 없으면 반환 값은 <see langword="true" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> 반환 하는 메서드에 대리자 `true` 개체에 전달 하는 경우 대리자에 정의 된 조건과 일치 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 를 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자 및 처리는 대리자가 반환 하는 경우 중지 됩니다 `false` 모든 요소에 대 한 합니다. 단일 스레드에서 모든 호출 및 요소 순서 대로 처리 됩니다.  
  
 이 메서드는 O는 (*n*) 작업, 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.TrueForAll%2A> 메서드와 사용 하는 몇 가지 다른 방법도 <xref:System.Predicate%601> 제네릭 대리자입니다.  
  
 A <xref:System.Collections.Generic.List%601> 문자열의 만들어지면 2 개 (위치 1과 5)에서 "saurus"으로 끝나는 8 공룡 이름이 들어 있는입니다. 이 예제에서는 또한 라는 검색 조건자 메서드를 정의 `EndsWithSaurus`문자열 매개 변수를 허용 하는, 및에서는 나타내는 입력된 문자열이 "saurus"로 끝나는 여부입니다.  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A> 메서드를 차례로 각 요소를 전달 하는 처음부터는 목록을 트래버스는 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드 반환 `false`합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서 필요 없는 만들려는 `Predicate<string>` 위임 (`Predicate(Of String)` Visual basic에서) 명시적으로 합니다. 이러한 언어 올바른 대리자 컨텍스트를 유추 하 고 자동으로 만듭니다.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>