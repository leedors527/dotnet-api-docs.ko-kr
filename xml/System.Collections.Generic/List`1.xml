<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e51f7a63d6289abcd9794c210af15276cb0a2427" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58726191" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">목록에 있는 요소의 형식입니다.</typeparam>
    <summary>인덱스로 액세스할 수 있는 강력한 형식의 개체 목록을 나타냅니다. 목록의 검색, 정렬 및 조작에 사용할 수 있는 메서드를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.Generic.List%601> 클래스는 해당 하는 제네릭의 <xref:System.Collections.ArrayList> 클래스입니다. 구현 된 <xref:System.Collections.Generic.IList%601> 크기가 동적으로 증가 하는 배열을 사용 하 여 제네릭 인터페이스 필요 합니다.  
  
 항목을 추가할 수는 <xref:System.Collections.Generic.List%601> 를 사용 하 여 합니다 <xref:System.Collections.Generic.List%601.Add%2A> 또는 <xref:System.Collections.Generic.List%601.AddRange%2A> 메서드.  
  
 <xref:System.Collections.Generic.List%601> 같음 비교자 및 순서 비교자 클래스를 사용 합니다.  
  
-   와 같은 메서드와 <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>를 <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, 및 <xref:System.Collections.Generic.Dictionary%602.Remove%2A> 목록 요소에 대 한 같음 비교자를 사용 합니다. 형식에 대 한 기본 같음 비교자를 `T` 다음과 같이 결정 됩니다. 경우 형식 `T` 구현 합니다 <xref:System.IEquatable%601> 제네릭 인터페이스를 같음 비교자는는 <xref:System.IEquatable%601.Equals%28%600%29> 해당 인터페이스의 메서드 그렇지 않으면 기본 같음 비교자는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>합니다.  
  
-   와 같은 메서드와 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 고 <xref:System.Collections.Generic.List%601.Sort%2A> 목록 요소에 대 한 정렬 비교자를 사용 합니다. 형식에 대 한 기본 비교자 `T` 다음과 같이 결정 됩니다.  경우 형식 `T` 구현 합니다 <xref:System.IComparable%601> 제네릭 인터페이스를 기본 비교자는 합니다 <xref:System.IComparable%601.CompareTo%28%600%29> 해당 인터페이스의 메서드 그렇지 않은 경우, 형식 `T` 제네릭이 아닌 구현 <xref:System.IComparable> 인터페이스를 기본 비교자는는 <xref:System.IComparable.CompareTo%28System.Object%29> 해당 인터페이스의 메서드입니다. 경우 형식 `T` 방법이 기본 비교 자가 없으며 비교자 또는 비교 대리자를 명시적으로 제공 해야 하 고 두 인터페이스를 구현 합니다.  
  
 <xref:System.Collections.Generic.List%601> 정렬 되도록 보장 되지 않습니다.  정렬 해야 합니다 <xref:System.Collections.Generic.List%601> 작업을 수행 하기 전에 (같은 <xref:System.Collections.Generic.List%601.BinarySearch%2A>) 해야 하는 <xref:System.Collections.Generic.List%601> 정렬할 합니다.  
  
 이 컬렉션의 요소는 정수 인덱스를 사용 하 여 액세스할 수 있습니다.  이 컬렉션의 인덱스는 0부터 시작 합니다.  
  
 **.NET framework에만 해당:** 에 대 한 매우 큰 <xref:System.Collections.Generic.List%601> 개체를 설정 하 여 64 비트 시스템에서 2 십억 요소에 최대 용량을 늘릴 수 있습니다는 `enabled` 특성을 [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) 구성 요소를 `true` 에 런타임 환경입니다.  
  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값 형식 및 중복 요소를 허용 합니다.  
  
 변경할 수 없는 버전의 <xref:System.Collections.Generic.List%601> 클래스를 참조 하십시오 <xref:System.Collections.Immutable.ImmutableList%601>합니다.  
  
## <a name="performance-considerations"></a>성능 고려 사항  
 사용할지 여부를 결정 하는 데는 <xref:System.Collections.Generic.List%601> 또는 <xref:System.Collections.ArrayList> 클래스를 모두 유사한 기능을 기억 하는 <xref:System.Collections.Generic.List%601> 클래스는 대부분의 경우에서 더 잘 수행 하 고 형식이 안전 합니다. 형식에 대 한 참조 형식을 사용 하는 경우 `T` 의 <xref:System.Collections.Generic.List%601> 클래스 두 클래스의 동작은 동일 합니다. 그러나 형식에 대 한 값 형식을 사용 하는 경우 `T`, 구현 및 boxing 문제를 고려해 야 합니다.  
  
 형식에 대 한 값 형식을 사용 하는 경우 `T`, 컴파일러의 구현을 생성 된 <xref:System.Collections.Generic.List%601> 클래스는 값 형식에 맞게 합니다. 즉,의 목록 요소를 <xref:System.Collections.Generic.List%601> 개체 요소를 사용할 수 있습니다 및 목록 요소를 boxing 하지 않는 저장 메모리가 클래스 구현을 생성 하는 데 사용 된 메모리 보다 큰 약 500 목록 요소를 만든 후 전에 큐에 넣이 필요가 없습니다.  
  
 확인 특정 형식에 사용 되는 값 형식 `T` 구현 된 <xref:System.IEquatable%601> 제네릭 인터페이스입니다. 와 같은 메서드 그렇지 않은 경우 <xref:System.Collections.Generic.List%601.Contains%2A> 를 호출 해야 합니다는 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 영향을 받는 목록 요소 상자는 메서드를 합니다. 값 형식을 구현 하는 경우는 <xref:System.IComparable> 인터페이스 이므로 소유 된 소스 코드를 구현 합니다 <xref:System.IComparable%601> 방지 하기 위해 제네릭 인터페이스는 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 및 <xref:System.Collections.Generic.List%601.Sort%2A> 목록 요소를 boxing 메서드. 소스 코드를 소유 하지 않은 경우 전달를 <xref:System.Collections.Generic.IComparer%601> 개체를 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 고 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드  
  
 한 type 별 구현을 사용 하는 것은 <xref:System.Collections.Generic.List%601> 클래스를 사용 하는 대신는 <xref:System.Collections.ArrayList> 클래스 또는 강력한 형식의 래퍼 컬렉션을 직접 작성 합니다. 그 이유는.NET Framework 용도를 이미 구현 해야 공용 언어 런타임에서 Microsoft intermediate language 코드 및 구현 일 수 없습니다. 메타 데이터를 공유할 수 있습니다.  
  
## <a name="f-considerations"></a>F#고려 사항  
 합니다 <xref:System.Collections.Generic.List%601> 클래스에 자주 사용 됩니다 F# 코드입니다. 대신 [나열](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), 변경 불가능 한 단일 연결 목록에는 일반적으로 기본 설정 합니다. F# 목록은 정렬 된, 변경할 수 없는 일련의 값을 제공 및는 기능적 스타일 개발에 사용 하도록 지원 합니다. 사용 될 때 F#의 <xref:System.Collections.Generic.List%601> 클래스는 일반적으로 참조 하는 [ResizeArray\<없음 >](https://msdn.microsoft.com/library/ee353447.aspx) 형식 약어 이름 충돌을 방지 하려면 F# 나열  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 방법을 보여 줍니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제에서는 여러 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 문자열 형식의 제네릭 클래스입니다. (의 예는 <xref:System.Collections.Generic.List%601> 복합 형식 참조를 <xref:System.Collections.Generic.List%601.Contains%2A> 메서드.)  
  
 기본 생성자는 기본 용량을 사용 하 여 문자열의 목록을 만드는 데 사용 됩니다. 합니다 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 표시 됩니다 차례로 <xref:System.Collections.Generic.List%601.Add%2A> 메서드 여러 항목을 추가할 때 사용 됩니다. 항목을 나열 하며 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 표시 됩니다 함께 다시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 하 여 용량이 필요에 따라 증가 되었습니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.Contains%2A> 메서드 목록에서 항목의 존재 여부를 테스트를 사용 하는 <xref:System.Collections.Generic.List%601.Insert%2A> 메서드 사용 하 여 목록 중간에 새 항목을 삽입 하 고 목록의 내용을 다시 표시 됩니다.  
  
 기본값 <xref:System.Collections.Generic.List%601.Item%2A> 속성 (C# 인덱서) 항목을 검색을 사용 하는 <xref:System.Collections.Generic.List%601.Remove%2A> 메서드를 사용 하 여 이전에 추가한 중복 항목의 첫 번째 인스턴스를 제거 하 고 내용을 다시 표시 됩니다. <xref:System.Collections.Generic.List%601.Remove%2A> 메서드는 항상 발견 첫 번째 인스턴스를 제거 합니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드는 개수에 맞게 용량을 줄이는 데 하며 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다. 총 용량을 10% 미만 사용 하지 않은 용량이, 하는 경우 목록은 하지 크기가 조정 되었습니다.  
  
 마지막으로, 합니다 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드를 사용 하 여 목록에서 모든 항목을 제거 하 고 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual Basic의)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  
  
여러 읽기 작업을 수행할 수는 <see cref="T:System.Collections.Generic.List`1" />, 있지만 읽는 동안 컬렉션이 수정 되는 경우 문제가 발생할 수 있습니다. 스레드 보안을 위해 읽기 동안 컬렉션을 잠글 또는 쓰기 작업입니다. 읽기 및 쓰기에 대 한 여러 스레드에서 액세스할 컬렉션을 사용 하려면 고유한 동기화를 구현 해야 합니다. 기본 제공 동기화를 사용 하 여 컬렉션, 참조의 클래스는 <see cref="N:System.Collections.Concurrent" /> 네임 스페이스입니다. 기본적으로 스레드로부터 안전한 대안에 대 한 참조를 <see cref="T:System.Collections.Immutable.ImmutableList`1" /> 클래스입니다.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">반복기(C# 및 Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>비어 있는 상태에서 기본 초기 용량을 가지는 <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.List%601> 요소입니다는 <xref:System.Collections.Generic.List%601> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.Generic.List%601>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우를 사용 하는 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> 생성자 및 지정 된 초기 용량 크기 조정 작업에 요소를 추가 하는 동안 여러 번 수행할 필요가 없습니다를 <xref:System.Collections.Generic.List%601>입니다.  
  
 호출 하 여 용량을 줄일 수 있습니다 합니다 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 설정 하 여는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성 명시적으로 합니다. 용량 메모리를 다시 할당 하 고 복사의 모든 요소는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 생성자는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 생성자는 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. 기본 생성자를 표시 하 여 볼 수 있듯이 기본 용량을 사용 하 여 목록을 만듭니다는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성입니다.  
  
 이 예제에서는 추가 하 고 삽입, 이러한 메서드는 사용 되 고 용량 변경 하는 방법을 보여 주는 항목을 제거 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">요소가 새 목록에 복사되는 컬렉션입니다.</param>
        <summary>지정된 컬렉션에서 복사한 요소를 포함하고 복사한 요소를 모두 수용할 수 있을 정도의 용량을 가진 <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소에 복사 됩니다는 <xref:System.Collections.Generic.List%601> 순서 컬렉션의 열거자가 읽게 됩니다.  
  
 이 생성자는 (*n*) 작업, 여기서 *n* 에 있는 요소의 수는 `collection`합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.%23ctor%2A> 의 다양 한 메서드와 생성자를 <xref:System.Collections.Generic.List%601> 범위에서 작동 하는 클래스입니다. 문자열의 배열은 만들어지고 배열의 요소를 사용 하 여 목록 채우기 생성자에 전달 합니다. <xref:System.Collections.Generic.List%601.Capacity%2A> 속성에 표시 됩니다, 초기 용량을 입력된 요소를 보유 하는 데 필요한 항목은 정확 하 게 되도록 표시 합니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">새 목록에 처음부터 저장할 수 있는 요소의 수입니다.</param>
        <summary>비어 있는 상태에서 지정한 초기 용량을 가지는 <see cref="T:System.Collections.Generic.List`1" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 용량을 <xref:System.Collections.Generic.List%601> 요소입니다는 <xref:System.Collections.Generic.List%601> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.Generic.List%601>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.Generic.List%601>합니다.  
  
 호출 하 여 용량을 줄일 수 있습니다 합니다 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 설정 하 여는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성 명시적으로 합니다. 용량 메모리를 다시 할당 하 고 복사의 모든 요소는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 생성자는 O (*n*) 작업, 여기서 *n* 는 `capacity`합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> 생성자입니다. <xref:System.Collections.Generic.List%601> 용량이 4 사용 하 여 문자열의 만들어지면 목록의 ultimate 크기는 정확히 4로 알려져 있기 때문에 있습니다. 4 개의 문자열 목록이 채워진 만들어지고 읽기 전용 복사본을 사용 하 여를 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 메서드.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />의 끝에 추가할 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>개체를 <see cref="T:System.Collections.Generic.List`1" />의 끝 부분에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값 형식 및 중복 요소를 허용 합니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 이미 같은 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량을 <xref:System.Collections.Generic.List%601> 자동으로 내부 배열을 다시 할당 하 여 증가 하는 새 요소가 추가 되기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 하는 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다. 이 메서드는 O가 용량을 늘려야 하는 새 요소를 수용할 수 있도록 하는 경우 (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 방법을 보여 줍니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제에서는 여러 속성 및 메서드를 <xref:System.Collections.Generic.List%601> 제네릭 클래스를 포함 하 여는 <xref:System.Collections.Generic.List%601.Add%2A> 메서드. 기본 생성자는 0의 용량을 사용 하 여 문자열의 목록을 만드는 데 사용 됩니다. 합니다 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 표시 됩니다 차례로 <xref:System.Collections.Generic.List%601.Add%2A> 메서드 여러 항목을 추가할 때 사용 됩니다. 항목을 나열 하며 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 표시 됩니다 함께 다시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 하 여 용량이 필요에 따라 증가 되었습니다.  
  
 다른 속성 및 메서드는 검색, 삽입 및 목록에서 요소를 제거 하는 데 사용 하 고 마지막으로 목록을 지울 것인지 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">요소가 <see cref="T:System.Collections.Generic.List`1" />의 끝에 추가되어야 하는 컬렉션입니다. 컬렉션 자체가 <see langword="null" />일 수는 없지만 <paramref name="T" />형식이 참조 형식인 경우 <see langword="null" />인 요소를 포함할 수 있습니다.</param>
        <summary>지정된 컬렉션의 요소를 <see cref="T:System.Collections.Generic.List`1" />의 끝에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션의 요소 순서는 유지 된 <xref:System.Collections.Generic.List%601>합니다.  
  
 하는 경우 새 <xref:System.Collections.Generic.List%601.Count%2A> (현재 <xref:System.Collections.Generic.List%601.Count%2A> 컬렉션의 크기를 더한) 보다 커야 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량을 <xref:System.Collections.Generic.List%601> 자동으로 새 요소를 수용 하기 위해 내부 배열을 다시 할당 하 여 증가 및 기존 요소는 새 요소가 추가 되기 전에 새 배열에 복사 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 증가 하지 않고 새 요소를 수용할 수는 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 (*n*) 작업을 여기서 *n* 추가할 요소입니다. 이 메서드는 O가 용량에 새 요소에 맞게 늘어날 수 해야 하는 경우 (*n* + *m*) 작업, 여기서 *n* 요소입니다 추가 하 고 *m* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.AddRange%2A> 메서드와의 다른 다양 한 메서드를 <xref:System.Collections.Generic.List%601> 범위에서 작동 하는 클래스입니다. 문자열의 배열은 만들어지고 배열의 요소를 사용 하 여 목록 채우기 생성자에 전달 합니다. <xref:System.Collections.Generic.List%601.AddRange%2A> 인수로 목록을 사용 하 여 메서드를 호출 합니다. 결과 목록의 현재 요소 모든 요소가 중복 목록의 끝에 추가 된 경우  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 컬렉션에 대한 읽기 전용 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 래퍼를 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Collections.Generic.List`1" />에 대한 읽기 전용 래퍼 역할을 하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 수정 하지 못하게 하는 <xref:System.Collections.Generic.List%601> 개체,이 래퍼를 통해서만 노출 합니다. <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 개체 컬렉션을 수정 하는 메서드를 노출 하지 않습니다. 그러나 기본 변경 되 면 <xref:System.Collections.Generic.List%601> 개체를 읽기 전용 컬렉션에 해당 변경 내용을 반영 합니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 메서드. <xref:System.Collections.Generic.List%601> 용량이 4 사용 하 여 문자열의 만들어지면 목록의 ultimate 크기는 정확히 4로 알려져 있기 때문에 있습니다. 4 개의 문자열 목록이 채워진 및 <xref:System.Collections.Generic.List%601.AsReadOnly%2A> 메서드는 읽기 전용를 가져오는 데 사용 됩니다 <xref:System.Collections.Generic.IList%601> 원본 목록을 래핑하는 제네릭 인터페이스 구현.  
  
 원래 목록 요소를 사용 하 여 "Coelophysis"로 설정 되는 <xref:System.Collections.Generic.List%601.Item%2A> 속성 (C# 인덱서) 및 읽기 전용 목록의 내용을 표시 되어 다시 원래 목록에 대 한 일 뿐 임을 보여 줍니다.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이진 검색 알고리즘을 사용하여 정렬된 <see cref="T:System.Collections.Generic.List`1" />나 그 일부에서 특정 요소를 찾습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>기본 비교자를 사용하여 정렬된 전체 <see cref="T:System.Collections.Generic.List`1" />에서 요소를 검색하고 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="item" />이 있으면 정렬된 <see cref="T:System.Collections.Generic.List`1" />에 있는 <paramref name="item" />의 인덱스(0부터 시작)이고, 그렇지 않으면 <paramref name="item" />보다 큰 다음 요소의 인덱스에 대한 비트 보수인 음수이거나 더 큰 요소가 없는 경우 <see cref="P:System.Collections.Generic.List`1.Count" />의 비트 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 비교자를 사용 하는이 메서드가 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 형식에 대 한 `T` 목록 요소의 순서를 결정 합니다. 합니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 속성 검사 여부를 입력 합니다. `T` 구현를 <xref:System.IComparable%601> 제네릭 인터페이스 구현에는 사용 하 여 사용 가능한 경우.  그러지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현 된 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않습니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Collections.Generic.List%601> ; 비교자 구현에 따라 정렬 되어 있어야 합니다 그렇지 않으면 결과 올바르지 않습니다.  
  
 비교 `null` 모든 참조를 사용 하 여 허용 되는 형식과 사용 하는 경우 예외를 생성 하지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스입니다. 정렬할 때 `null` 다른 개체 보다 작은 것으로 간주 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 포함 된 둘 이상의 요소가 동일한 값을 가진 메서드가 반환 반드시 첫 번째 항목을 중 하나를 반환할 수는 항목 중 하나입니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 지정 된 값을 포함 하지 않는 메서드가 음수를 반환 합니다. 검색 값 보다 큰 첫 번째 요소의 인덱스를 가져올이 음의 정수 비트 보수 연산의 (~)를 적용할 수 있습니다. 값을 삽입 하는 경우는 <xref:System.Collections.Generic.List%601>, 정렬 순서를 유지 하기 위해이 인덱스를 삽입 지점으로 사용 해야 합니다.  
  
 이 메서드는 O (로그 *n*) 작업, 여기서 *n* 범위의 요소 수입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort> 메서드 오버 로드 및 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드 합니다. <xref:System.Collections.Generic.List%601> 문자열 생성 되어 특정 순서 없이 4 개의 문자열을 사용 하 여 채워집니다. 목록은 표시 하 고 정렬 하 고 다시 표시 됩니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드는 다음 목록에 없는 두 문자열을 검색 하는 데 사용 됩니다 및 <xref:System.Collections.Generic.List%601.Insert%2A> 메서드 삽입 하기를 사용 합니다. 반환 값은 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 문자열 목록에 없기 때문에 메서드는 각각의 경우에서 음수입니다. 비트 보수 (의 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)이 음수 숫자 생성, 검색 문자열 보다 크고 삽입이 위치에 있는 목록의 첫 번째 요소의 인덱스 유지 정렬 순서입니다. 두 번째 검색 문자열은 목록 끝에 삽입 위치 이므로 목록에 있는 모든 요소 보다 큰 합니다.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="comparer">요소를 비교할 때 사용하는 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현입니다.  
  
또는 
 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 정렬된 전체 <see cref="T:System.Collections.Generic.List`1" />에서 요소를 검색하고 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="item" />이 있으면 정렬된 <see cref="T:System.Collections.Generic.List`1" />에 있는 <paramref name="item" />의 인덱스(0부터 시작)이고, 그렇지 않으면 <paramref name="item" />보다 큰 다음 요소의 인덱스에 대한 비트 보수인 음수이거나 더 큰 요소가 없는 경우 <see cref="P:System.Collections.Generic.List`1.Count" />의 비트 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어 사용할 수 있습니다는 <xref:System.Collections.CaseInsensitiveComparer> 인스턴스로 대/소문자 문자열 검색을 수행 하는 비교자입니다.  
  
 하는 경우 `comparer` 제공 되는 요소의 합니다 <xref:System.Collections.Generic.List%601> 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현를 <xref:System.IComparable%601> 제네릭 인터페이스 구현에는 사용 하 여 사용 가능한 경우.  그러지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현 된 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않습니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Collections.Generic.List%601> ; 비교자 구현에 따라 정렬 되어 있어야 합니다 그렇지 않으면 결과 올바르지 않습니다.  
  
 비교 `null` 모든 참조를 사용 하 여 허용 되는 형식과 사용 하는 경우 예외를 생성 하지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스입니다. 정렬할 때 `null` 다른 개체 보다 작은 것으로 간주 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 포함 된 둘 이상의 요소가 동일한 값을 가진 메서드가 반환 반드시 첫 번째 항목을 중 하나를 반환할 수는 항목 중 하나입니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 지정 된 값을 포함 하지 않는 메서드가 음수를 반환 합니다. 검색 값 보다 큰 첫 번째 요소의 인덱스를 가져올이 음의 정수 비트 보수 연산의 (~)를 적용할 수 있습니다. 값을 삽입 하는 경우는 <xref:System.Collections.Generic.List%601>, 정렬 순서를 유지 하기 위해이 인덱스를 삽입 지점으로 사용 해야 합니다.  
  
 이 메서드는 O (로그 *n*) 작업, 여기서 *n* 범위의 요소 수입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 및 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 라는 DinoCompare 구현 하는 문자열에 대 한 대체는 비교자를 정의 합니다 `IComparer<string>` (`IComparer(Of String)` Visual Basic에서는 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자 같이 작동합니다. 에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열인 큰 것으로 간주 됩니다. 셋째, 길이가 같으면 일반적인 문자열 비교가 됩니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열 생성 되어 특정 순서 없이 4 개의 문자열을 사용 하 여 채워집니다. 목록은 다시 표시 됩니다, 대체 비교자를 사용 하 여 정렬 및 표시.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 하지 목록에서 사용 중인 비교자를 대체 하는 여러 문자열을 검색 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.Insert%2A> 메서드 사용 하 여 문자열을 삽입 합니다. 이 두 메서드 라는 함수에 있는 `SearchAndInsert`, 비트 보수를 수행 하는 코드와 함께 (는 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 반환한 음수 개수 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 에 대 한 인덱스로 사용 새 문자열을 삽입 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">검색할 범위의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 범위의 길이입니다.</param>
        <param name="item">찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현이거나, 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 정렬된 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 요소를 검색하고 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="item" />이 있으면 정렬된 <see cref="T:System.Collections.Generic.List`1" />에 있는 <paramref name="item" />의 인덱스(0부터 시작)이고, 그렇지 않으면 <paramref name="item" />보다 큰 다음 요소의 인덱스에 대한 비트 보수인 음수이거나 더 큰 요소가 없는 경우 <see cref="P:System.Collections.Generic.List`1.Count" />의 비트 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비교자는 요소를 비교 하는 방법을 사용자 지정 합니다. 예를 들어 사용할 수 있습니다는 <xref:System.Collections.CaseInsensitiveComparer> 인스턴스로 대/소문자 문자열 검색을 수행 하는 비교자입니다.  
  
 하는 경우 `comparer` 제공 되는 요소의 합니다 <xref:System.Collections.Generic.List%601> 사용 하 여 지정된 된 값과 비교할 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현를 <xref:System.IComparable%601> 제네릭 인터페이스 구현에는 사용 하 여 사용 가능한 경우.  그러지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현 된 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않습니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Collections.Generic.List%601> ; 비교자 구현에 따라 정렬 되어 있어야 합니다 그렇지 않으면 결과 올바르지 않습니다.  
  
 비교 `null` 모든 참조를 사용 하 여 허용 되는 형식과 사용 하는 경우 예외를 생성 하지 않습니다는 <xref:System.IComparable%601> 제네릭 인터페이스입니다. 정렬할 때 `null` 다른 개체 보다 작은 것으로 간주 됩니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 포함 된 둘 이상의 요소가 동일한 값을 가진 메서드가 반환 반드시 첫 번째 항목을 중 하나를 반환할 수는 항목 중 하나입니다.  
  
 경우는 <xref:System.Collections.Generic.List%601> 지정 된 값을 포함 하지 않는 메서드가 음수를 반환 합니다. 검색 값 보다 큰 첫 번째 요소의 인덱스를 가져올이 음의 정수 비트 보수 연산의 (~)를 적용할 수 있습니다. 값을 삽입 하는 경우는 <xref:System.Collections.Generic.List%601>, 정렬 순서를 유지 하기 위해이 인덱스를 삽입 지점으로 사용 해야 합니다.  
  
 이 메서드는 O (로그 *n*) 작업, 여기서 *n* 범위의 요소 수입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 및 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 라는 DinoCompare 구현 하는 문자열에 대 한 대체는 비교자를 정의 합니다 `IComparer<string>` (`IComparer(Of String)` Visual Basic에서는 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자 같이 작동합니다. 에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열인 큰 것으로 간주 됩니다. 셋째, 길이가 같으면 일반적인 문자열 비교가 됩니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열를 만들고 5 개의 예제 dinosaurs 및 예제 이름으로 채웁니다. 각 두 그룹의 이름을 특정 정렬 순서에 있지 않습니다. 목록이 표시 됩니다 하 고 초 식의 범위는 대체 비교자를 사용 하 여 정렬 된 목록이 다시 표시 됩니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 "Brachiosaurus" 초 식의 범위에만 검색 하는 데 사용 됩니다. 문자열 없는 비트 보수 (의 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 반환한 음수 개수는 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드는 새 문자열을 삽입 하는 것에 대 한 인덱스로 사용 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>크기를 조정하지 않고 내부 데이터 구조가 보유할 수 있는 전체 요소 수를 가져오거나 설정합니다.</summary>
        <value>크기를 조정하지 않고 <see cref="T:System.Collections.Generic.List`1" />에 포함될 수 있는 요소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소입니다는 <xref:System.Collections.Generic.List%601> 반면 크기를 조정 하는 것은 필요 하기 전에 저장할 수 있습니다 <xref:System.Collections.Generic.List%601.Count%2A> 에 실제로 있는 요소의 수는 <xref:System.Collections.Generic.List%601>합니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 항상 보다 크거나 같음 <xref:System.Collections.Generic.List%601.Count%2A>합니다. 하는 경우 <xref:System.Collections.Generic.List%601.Count%2A> 초과 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소를 추가 하는 동안 용량을 자동으로 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 재할당 하 여 증가 합니다.  
  
 용량에는 개수 보다 훨씬 더 큽니다 및를 사용 하는 메모리를 줄이려는 경우는 <xref:System.Collections.Generic.List%601>, 호출 하 여 용량을 줄일 수 있습니다를 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 설정 하 여를 <xref:System.Collections.Generic.List%601.Capacity%2A> 낮은 값으로 명시적으로 속성. 때 변수의 <xref:System.Collections.Generic.List%601.Capacity%2A> 설정 명시적으로 지정된 된 용량을 수용 하기 위해 내부 배열을 다시 할당 됩니다 하 고 모든 요소에 복사 됩니다.  
  
 이 속성의 값을 검색 하는 것은 O(1) 작업; 속성을 설정 하는 O (*n*) 작업, 여기서 *n* 은 새 용량입니다.  
  
   
  
## Examples  
 다음 예제에는 용량 및 개수를 확인 하는 방법을 보여 줍니다.는 <xref:System.Collections.Generic.List%601> 간단한 비즈니스 개체를 포함 하 고 사용 하는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 추가 용량을 제거 하는 방법입니다.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 다음 예제와 <xref:System.Collections.Generic.List%601.Capacity%2A> 목록의 여러 지점에서 속성입니다. 기본 생성자는 0으로 용량을 사용 하 여 문자열의 목록을 만드는 데 및 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은이 보여 주기 위해 표시 됩니다. 후는 <xref:System.Collections.Generic.List%601.Add%2A> 여러 항목을 추가 하는 데 사용 된 메서드, 항목 나열 된 차례로 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성이 표시 됩니다 함께 다시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 하 여 용량이 필요에 따라 증가 되었습니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성은 후에 다시 표시는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 수에 맞게 용량을 줄이기 위해 사용 됩니다. 마지막으로 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드를 사용 하 여 목록에서 모든 항목을 제거 하 고 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 다시 표시 됩니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 작은 값으로 설정되어 있습니다.</exception>
        <exception cref="T:System.OutOfMemoryException">시스템에 사용 가능한 메모리가 부족합니다.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" />에서 요소를 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> 0으로 설정 되 고 컬렉션의 요소에서 다른 개체에 대 한 참조도 해제 됩니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 변경 되지 않습니다. 용량을 다시 설정 하는 <xref:System.Collections.Generic.List%601>를 호출 합니다 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드 또는 집합은 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성을 직접. 용량 메모리를 다시 할당 하 고 복사의 모든 요소는 <xref:System.Collections.Generic.List%601>합니다. 빈 트리밍 <xref:System.Collections.Generic.List%601> 의 용량을 설정 합니다 <xref:System.Collections.Generic.List%601> 기본 용량입니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드 및 기타 다양 한 속성과 메서드를 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. <xref:System.Collections.Generic.List%601.Clear%2A> 목록에서 모든 항목을 제거 하려면 프로그램의 끝에 메서드는 하며 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성을 표시 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />에 요소가 있는지 여부를 확인합니다.</summary>
        <returns><see langword="true" />가 <paramref name="item" />에 있으면 <see cref="T:System.Collections.Generic.List`1" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 개체의 구현에 의해 정의 된 대로 기본 같음 비교자를 사용 하 여 일치 여부를 확인 합니다 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 에 대 한 메서드 `T` (목록에 있는 값의 형식).  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.Contains%2A> 하 고 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드를 <xref:System.Collections.Generic.List%601> 구현 하는 간단한 비즈니스 개체를 포함 하는 <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 다음 예제에서는 형식의 복잡 한 개체의 목록이 들어 `Cube`합니다. 합니다 `Cube` 구현 클래스는 <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> 메서드는 두 개의 큐브 차원을 동일한 경우 같은 것으로 간주 됩니다. 이 예제에서는 합니다 <xref:System.Collections.Generic.List%601.Contains%2A> 메서드가 반환 되는 `true`이므로 지정 된 차원이 있는 큐브 컬렉션에 이미 있습니다.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">대상 배열 요소의 형식입니다.</typeparam>
        <param name="converter">각 요소를 한 형식에서 다른 형식으로 변환하는 <see cref="T:System.Converter`2" /> 대리자입니다.</param>
        <summary>현재 <see cref="T:System.Collections.Generic.List`1" />의 요소를 다른 형식으로 변환하고 변환된 요소를 포함하는 목록을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Collections.Generic.List`1" />에서 변환된 요소를 포함하는 대상 유형의 <see cref="T:System.Collections.Generic.List`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> 개체를 대상 형식으로 변환 하는 메서드에 대리자입니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Converter%602> 대리자와 변환 된 요소를 새 저장 됩니다 <xref:System.Collections.Generic.List%601>합니다.  
  
 현재 <xref:System.Collections.Generic.List%601> 그대로 유지 됩니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 라는 메서드를 정의 하는 다음 예제에서는 `PointFToPoint` 변환 하는 <xref:System.Drawing.PointF> 구조체를 <xref:System.Drawing.Point> 구조입니다. 만듭니다는 <xref:System.Collections.Generic.List%601> 의 <xref:System.Drawing.PointF> 구조를 만들고를 `Converter\<PointF, Point>` 대리자 (`Converter(Of PointF, Point)` Visual Basic의)를 나타내는 `PointFToPoint` 메서드를 대리자를 전달 하 고는 <xref:System.Collections.Generic.List%601.ConvertAll%2A> 메서드. <xref:System.Collections.Generic.List%601.ConvertAll%2A> 메서드는 입력 목록의 각 요소에 전달 합니다 `PointFToPoint` 메서드를 새 목록으로 변환 된 요소를 배치 하 고 <xref:System.Drawing.Point> 구조. 두 목록은 모두 표시 됩니다.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" />이나 그 일부를 배열에 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.Generic.List`1" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <summary>대상 배열의 처음부터 시작하여 전체 <see cref="T:System.Collections.Generic.List`1" />을 호환되는 1차원 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사 합니다.  
  
 요소에 복사 됩니다는 <xref:System.Array> 열거자가 반복 나타나는 순서에서는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.CopyTo%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열를 만들고 5 개의 문자열을 사용 하 여 채웁니다. 15 개 요소가 빈 문자열 배열을 만들어지면 및 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 메서드 오버 로드는 배열의 첫 번째 요소에서 시작 하 여 배열에 목록의 모든 요소를 복사 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> 요소를 복사할 모든 6 배열 인덱스에서 시작 된 배열에 목록 (배열) 메서드 오버 로드를 사용 합니다. 마지막으로 <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드를 인덱스 2 부터는 목록에서 3 개 요소를 복사 하 여 배열에서 시작 하는 배열 인덱스 12 (그대로 유지 되어 인덱스 11 비어 있음)를 사용 합니다. 그러면 배열의 내용은 표시 됩니다.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">소스 <see cref="T:System.Collections.Generic.List`1" /> 요소 수가 대상 <paramref name="array" />를 포함할 수 있는 요소 수보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.Generic.List`1" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex"><paramref name="array" />에서 복사가 시작되는 0부터 시작하는 인덱스입니다.</param>
        <summary>대상 배열의 지정된 인덱스에서 시작하여 전체 <see cref="T:System.Collections.Generic.List`1" />을 호환되는 1차원 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사 합니다.  
  
 요소에 복사 됩니다는 <xref:System.Array> 열거자가 반복 나타나는 순서에서는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.CopyTo%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열를 만들고 5 개의 문자열을 사용 하 여 채웁니다. 15 개 요소가 빈 문자열 배열을 만들어지면 및 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 메서드 오버 로드는 배열의 첫 번째 요소에서 시작 하 여 배열에 목록의 모든 요소를 복사 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> 요소를 복사할 모든 6 배열 인덱스에서 시작 된 배열에 목록 (배열) 메서드 오버 로드를 사용 합니다. 마지막으로 <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드를 인덱스 2 부터는 목록에서 3 개 요소를 복사 하 여 배열에서 시작 하는 배열 인덱스 12 (그대로 유지 되어 인덱스 11 비어 있음)를 사용 합니다. 그러면 배열의 내용은 표시 됩니다.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException">소스 <see cref="T:System.Collections.Generic.List`1" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지 사용 가능한 공간보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">소스 <see cref="T:System.Collections.Generic.List`1" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
        <param name="array"><see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.Generic.List`1" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex"><paramref name="array" />에서 복사가 시작되는 0부터 시작하는 인덱스입니다.</param>
        <param name="count">복사할 요소의 수입니다.</param>
        <summary>대상 배열의 지정된 인덱스에서 시작하여 <see cref="T:System.Collections.Generic.List`1" />에 있는 일련의 요소를 호환되는 1차원 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사 합니다.  
  
 요소에 복사 됩니다는 <xref:System.Array> 열거자가 반복 나타나는 순서에서는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.CopyTo%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열를 만들고 5 개의 문자열을 사용 하 여 채웁니다. 15 개 요소가 빈 문자열 배열을 만들어지면 및 <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> 메서드 오버 로드는 배열의 첫 번째 요소에서 시작 하 여 배열에 목록의 모든 요소를 복사 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> 요소를 복사할 모든 6 배열 인덱스에서 시작 된 배열에 목록 (배열) 메서드 오버 로드를 사용 합니다. 마지막으로 <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드를 인덱스 2 부터는 목록에서 3 개 요소를 복사 하 여 배열에서 시작 하는 배열 인덱스 12 (그대로 유지 되어 인덱스 11 비어 있음)를 사용 합니다. 그러면 배열의 내용은 표시 됩니다.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="arrayIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />가 소스 <see cref="T:System.Collections.Generic.List`1" />의 <see cref="P:System.Collections.Generic.List`1.Count" />보다 크거나 같습니다.  
  
또는 
소스 <see cref="T:System.Collections.Generic.List`1" />의 <paramref name="index" />부터 끝까지에 포함된 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지의 사용 가능한 공간보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" />에 포함된 요소 수를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.Generic.List`1" />에 포함된 요소의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소의 수는 <xref:System.Collections.Generic.List%601> 크기를 조정 하지 전에 저장할 수 있습니다. <xref:System.Collections.Generic.List%601.Count%2A> 에 실제로 있는 요소의 수는 <xref:System.Collections.Generic.List%601>합니다.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> 항상 보다 크거나 같음 <xref:System.Collections.Generic.List%601.Count%2A>합니다. 하는 경우 <xref:System.Collections.Generic.List%601.Count%2A> 초과 <xref:System.Collections.Generic.List%601.Capacity%2A> 요소를 추가 하는 동안 용량을 자동으로 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 재할당 하 여 증가 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 예제에는 용량 및 개수를 확인 하는 방법을 보여 줍니다.는 <xref:System.Collections.Generic.List%601> 간단한 비즈니스 개체를 포함 하 고 사용 하는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 추가 용량을 제거 하는 방법입니다.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 다음 예제에서는 값이 표시는 <xref:System.Collections.Generic.List%601.Count%2A> 속성 목록의 다양 한 시점입니다. 요소를 표시 하 고 목록 만들어지고 채워진 후 합니다 <xref:System.Collections.Generic.List%601.Capacity%2A> 고 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다. 이러한 속성은 후에 다시 표시는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드가 호출 하 고 목록의 내용 뒤 다시 지워집니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소가 <see cref="T:System.Collections.Generic.List`1" />에 포함되어 있는지 여부를 확인합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 하나 이상 <see cref="T:System.Collections.Generic.List`1" />에 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 일치 하는 경우 대리자 및 처리 중지 됩니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.Contains%2A> 하 고 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드를 <xref:System.Collections.Generic.List%601> 구현 하는 간단한 비즈니스 개체를 포함 하는 <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드와 사용 하는 몇 가지 다른 방법도 <xref:System.Predicate%601> 제네릭 대리자입니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열 만들어진, "saurus"를 사용 하 여 종료 (위치 1과 5)는 두 개의 8 공룡 이름이 들어 있는입니다. 이 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 수락 하 고 부울 값을 반환 나타내는 "saurus"로 입력된 문자열 종료 여부를 합니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, 및 <xref:System.Collections.Generic.List%601.FindAll%2A> 메서드를 사용 하 여 검색 조건자 목록을 검색 하는 데 사용 됩니다 차례로 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 메서드는 "saurus"로 끝나는 모든 항목을 제거 하는 데 사용 됩니다.  
  
 마지막으로 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드가 호출 됩니다. 목록의 각 요소를 차례로 전달부터 통과할는 `EndsWithSaurus` 메서드. 검색이 중지 되 고 메서드 반환 `true` 경우는 `EndsWithSaurus` 메서드가 반환 되는 `true` 모든 요소에 대 한 합니다. 합니다 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드가 반환 되는 `false` 제거 되었으므로 이러한 모든 요소입니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서는 필요 없는 만들려면 합니다 `Predicate<string>` 대리자 (`Predicate(Of String)` Visual Basic의) 명시적으로 합니다. 이러한 언어는 상황에 맞는 올바른 대리자 유추 하 고 자동으로 만듭니다.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <see cref="T:System.Collections.Generic.List`1" />에서 처음으로 검색한 요소를 반환합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째 요소이고, 그렇지 않으면 <paramref name="T" /> 형식의 기본값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자를 앞으로 이동 합니다 <xref:System.Collections.Generic.List%601>첫 번째 요소부터 마지막 요소까지 합니다.  일치 하는 경우 처리가 중지 됩니다.  
  
> [!IMPORTANT]
>  값 형식이 포함 된 목록을 검색 하는 경우 형식에 대 한 기본값 검색 조건자를 충족 하지 않는 있는지 확인 합니다. 이 고, 그렇지는 일치가 발견 되지 않았음을 나타내는 기본 값 및 형식에 대해 기본값이 지정 하는 목록 요소를 구분할 수 없으므로가 있습니다. 검색 조건자를 충족 하는 기본값을 사용 하 여를 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드 대신 합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Find%2A> 메서드를 <xref:System.Collections.Generic.List%601> 간단한 복잡 한 개체를 포함 하는 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 다음 예제에 대해 find 메서드를 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스를 포함 `book` 클래스의 개체 `Book`에서 데이터를 사용 하는 [샘플 XML 파일: Books(LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` 예제의 메서드를 사용 하 여 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석을 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 된 예제를 설명 합니다.  
  
|메서드|예제|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|모든 온라인 설명서는 해당 하는 찾기 `Genre` 속성이 "컴퓨터"를 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 년 사용 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책 찾습니다는 `PubBefore2001` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 첫 번째 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여를 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 마지막 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정한 조건자에 정의된 조건과 일치하는 모든 요소를 검색합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 해당 요소를 모두 포함하는 <see cref="T:System.Collections.Generic.List`1" />이고, 그렇지 않으면 빈 <see cref="T:System.Collections.Generic.List`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자 및 조건과 일치 하는 요소가 저장 되는 반환 된 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에 대해 find 메서드를 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스를 포함 `book` 클래스의 개체 `Book`에서 데이터를 사용 하는 [샘플 XML 파일: Books(LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` 예제의 메서드를 사용 하 여 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석을 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 된 예제를 설명 합니다.  
  
|메서드|예제|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|모든 온라인 설명서는 해당 하는 찾기 `Genre` 속성이 "컴퓨터"를 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 년 사용 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책 찾습니다는 `PubBefore2001` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 첫 번째 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여를 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 마지막 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 <see cref="T:System.Collections.Generic.List`1" />이나 그 일부에서 처음으로 검색한 요소의 인덱스(0부터 시작)를 반환합니다. 이 메서드는 조건이 일치하는 항목이 없는 경우 -1을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <see cref="T:System.Collections.Generic.List`1" />에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 검색은 앞으로 첫 번째 요소부터 마지막 요소입니다.  
  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다. 대리자에 서명을 합니다.  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Employee` 두 필드를 사용 하 여 클래스 `Name` 고 `Id`입니다. 또한 정의 `EmployeeSearch` 단일 메서드를 사용 하 여 클래스 `StartsWith`, 나타내는 여부를 `Employee.Name` 제공 되는 지정된 된 부분 문자열을 사용 하 여 필드의 시작를 `EmployeeSearch` 클래스 생성자. 이 메서드의 서명은 참고  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 에 전달 될 수 있는 대리자의 서명과에 해당 하는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드. 이 예제에서는 인스턴스화합니다를 `List<Employee>` 개체를 추가 하는 다양 한 `Employee` , 개체를 호출 해를 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 메서드 첫 번째를 위해 처음으로 전체 컬렉션을 검색 하려면 두 번 `Employee` 개체 `Name` 필드가 시작 될 "J" 및 첫 번째로 `Employee` 개체 `Name` 필드 "Ju"로 시작 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정된 인덱스에서 마지막 요소로 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.Generic.List%601> 부터 앞으로 검색 됩니다 `startIndex` 및 마지막 요소에 종료 합니다.  
  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다. 대리자에 서명을 합니다.  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업을 여기서 *n* 의 요소입니다 `startIndex` 의 끝에는 <xref:System.Collections.Generic.List%601>합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Employee` 두 필드를 사용 하 여 클래스 `Name` 고 `Id`입니다. 또한 정의 `EmployeeSearch` 단일 메서드를 사용 하 여 클래스 `StartsWith`, 나타내는 여부를 `Employee.Name` 제공 되는 지정된 된 부분 문자열을 사용 하 여 필드의 시작를 `EmployeeSearch` 클래스 생성자. 이 메서드의 서명은 참고  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 에 전달 될 수 있는 대리자의 서명과에 해당 하는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드. 이 예제에서는 인스턴스화합니다를 `List<Employee>` 개체를 추가 하는 다양 한 `Employee` , 개체를 호출 해를 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 메서드 (즉, 4 인덱스에 있는 멤버)의 다섯 번째 멤버를 사용 하 여 시작 하는 컬렉션을 검색 하려면 두 번. 첫 번째 처음으로 검색 `Employee` 개체 `Name` "J"를 사용 하 여 필드부터 시작 되며, 첫 번째로 검색 `Employee` 개체 `Name` 필드 "Ju"로 시작 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 지정된 인덱스부터 시작하여 지정된 수의 요소를 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 첫 번째 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 첫 번째로 나타나는 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 부터 앞으로 검색 됩니다 `startIndex` 에서 끝나는 `startIndex` plus `count` 에서 1을 뺀 경우 `count` 0 보다 큽니다.  
  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다. 대리자에 서명을 합니다.  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Employee` 두 필드를 사용 하 여 클래스 `Name` 고 `Id`입니다. 또한 정의 `EmployeeSearch` 단일 메서드를 사용 하 여 클래스 `StartsWith`, 나타내는 여부를 `Employee.Name` 제공 되는 지정된 된 부분 문자열을 사용 하 여 필드의 시작를 `EmployeeSearch` 클래스 생성자. 이 메서드의 서명은 참고  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 에 전달 될 수 있는 대리자의 서명과에 해당 하는 <xref:System.Collections.Generic.List%601.FindIndex%2A> 메서드. 이 예제에서는 인스턴스화합니다를 `List<Employee>` 개체를 추가 하는 다양 한 `Employee` , 개체를 호출 해를 <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> 메서드 전체 컬렉션에서 검색할 두 번 (인덱스를 인덱스 0 멤버 즉, <xref:System.Collections.Generic.List%601.Count%2A> -1). 첫 번째 처음으로 검색 `Employee` 개체 `Name` "J"를 사용 하 여 필드부터 시작 되며, 첫 번째로 검색 `Employee` 개체 `Name` 필드 "Ju"로 시작 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
또는 
 <paramref name="count" />가 0보다 작은 경우  
  
또는 
 <paramref name="startIndex" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 전체 <see cref="T:System.Collections.Generic.List`1" />에서 마지막으로 검색한 요소를 반환합니다.</summary>
        <returns>지정된 조건자에 정의된 조건과 일치하는 요소가 있으면 일치하는 요소 중 마지막 요소이고, 그렇지 않으면 <paramref name="T" /> 형식의 기본값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 에 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자를 뒤로 이동는 <xref:System.Collections.Generic.List%601>, 마지막 요소를 사용 하 여 시작 하 고 첫 번째 요소를 사용 하 여 종료 합니다.  일치 하는 경우 처리가 중지 됩니다.  
  
> [!IMPORTANT]
>  값 형식이 포함 된 목록을 검색 하는 경우 형식에 대 한 기본값 검색 조건자를 충족 하지 않는 있는지 확인 합니다. 이 고, 그렇지는 일치가 발견 되지 않았음을 나타내는 기본 값 및 형식에 대해 기본값이 지정 하는 목록 요소를 구분할 수 없으므로가 있습니다. 검색 조건자를 충족 하는 기본값을 사용 하 여를 <xref:System.Collections.Generic.List%601.FindLastIndex%2A> 메서드 대신 합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에 대해 find 메서드를 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스를 포함 `book` 클래스의 개체 `Book`에서 데이터를 사용 하는 [샘플 XML 파일: Books(LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` 예제의 메서드를 사용 하 여 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석을 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 된 예제를 설명 합니다.  
  
|메서드|예제|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|모든 온라인 설명서는 해당 하는 찾기 `Genre` 속성이 "컴퓨터"를 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 년 사용 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책 찾습니다는 `PubBefore2001` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 첫 번째 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여를 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 마지막 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하고 <see cref="T:System.Collections.Generic.List`1" />이나 그 일부에서 마지막으로 검색한 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정한 조건자에 정의된 조건과 일치하는 요소를 검색하여 전체 <see cref="T:System.Collections.Generic.List`1" />에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 그 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에 대해 find 메서드를 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스를 포함 `book` 클래스의 개체 `Book`에서 데이터를 사용 하는 [샘플 XML 파일: Books(LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` 예제의 메서드를 사용 하 여 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석을 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 된 예제를 설명 합니다.  
  
|메서드|예제|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|모든 온라인 설명서는 해당 하는 찾기 `Genre` 속성이 "컴퓨터"를 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 년 사용 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책 찾습니다는 `PubBefore2001` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 첫 번째 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여를 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 마지막 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 검색하여 첫 번째 요소에서 지정된 인덱스로 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 그 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.Generic.List%601> 뒤로 검색 됩니다에서 `startIndex` 첫 번째 요소에서 끝나는 합니다.  
  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업 위치 *n* 의 시작 부분에서 요소의 수는 <xref:System.Collections.Generic.List%601> 를 `startIndex`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <param name="match">검색할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정한 조건자에 정의된 조건과 일치하는 요소를 검색하여 지정한 수의 요소가 들어 있고 지정한 인덱스에서 끝나는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 일치하는 요소 중 마지막 요소의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="match" />에 정의된 조건과 일치하는 요소가 있으면 그 중 마지막 요소의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 검색에서 시작 됩니다 `startIndex` 에서 끝나는 `startIndex` 빼기 `count` + 1, 경우 `count` 0 보다 큽니다.  
  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 위임 합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 `count`합니다.  
  
   
  
## Examples  
 다음 예제에 대해 find 메서드를 <xref:System.Collections.Generic.List%601> 클래스입니다. 에 대 한 예제는 <xref:System.Collections.Generic.List%601> 클래스를 포함 `book` 클래스의 개체 `Book`에서 데이터를 사용 하는 [샘플 XML 파일: Books(LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` 예제의 메서드를 사용 하 여 [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) 의 속성 값을 XML에서 값을 구문 분석을 `book` 개체입니다.  
  
 다음 표에서 find 메서드에 제공 된 예제를 설명 합니다.  
  
|메서드|예제|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|ID를 사용 하 여 책을 찾습니다는 `IDToFind` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|모든 온라인 설명서는 해당 하는 찾기 `Genre` 속성이 "컴퓨터"를 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|2001 년 사용 하기 전에 게시 날짜가 들어 있는 컬렉션에서 마지막 책 찾습니다는 `PubBefore2001` 조건자 대리자입니다.<br /><br /> C# 예제에서는 익명 대리자를 사용합니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 첫 번째 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|사용 하 여 마지막 컴퓨터 책의 인덱스를 찾습니다는 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 첫 번째 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여를 `FindComputer` 조건자 대리자입니다.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|인덱스를 찾습니다 마지막 컴퓨터 책의 두 번째 컬렉션의 절반을 사용 하 여는 `FindComputer` 조건자 대리자입니다.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
또는 
 <paramref name="count" />가 0보다 작은 경우  
  
또는 
 <paramref name="startIndex" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><see cref="T:System.Action`1" />의 각 요소에 대해 수행할 <see cref="T:System.Collections.Generic.List`1" /> 대리자입니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />의 각 요소에 대해 지정된 작업을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> 대리자 개체에서 작업을 수행 하는 메서드를 전달 합니다.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Action%601> 위임 합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 본문에서 기본 컬렉션을 수정 합니다 <xref:System.Action%601> 대리자는 지원 되지 않으며 정의 되지 않은 동작이 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 합니다 <xref:System.Action%601> 의 내용을 인쇄 하는 대리자를 <xref:System.Collections.Generic.List%601> 개체입니다. 이 예제는 `Print` 메서드는 목록의 내용을 콘솔에 표시 하는 데 사용 됩니다.  
  
> [!NOTE]
>  사용 하 여 콘텐츠를 표시 하는 것 외에도 `Print` 메서드, C# 예제는 콘솔에 결과 표시 하려면의 사용법을 보여줍니다.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">컬렉션의 요소가 수정된 경우</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" />를 반복하는 열거자를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1.Enumerator" />에 대한 <see cref="T:System.Collections.Generic.List`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual Basic에서) 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>합니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 라고 합니다. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>는 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>를 컬렉션의 첫 번째 요소로 다시 설정할 수 없으므로 대신 새 열거자 인스턴스를 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경에 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제, 열거자가 복구할 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> 또는 <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throw는 <xref:System.InvalidOperationException>합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">범위가 시작되는 <see cref="T:System.Collections.Generic.List`1" /> 인덱스(0부터 시작)입니다.</param>
        <param name="count">범위의 요소 수입니다.</param>
        <summary>소스 <see cref="T:System.Collections.Generic.List`1" />에 있는 일련의 요소에 대한 단순 복사본을 만듭니다.</summary>
        <returns>소스 <see cref="T:System.Collections.Generic.List`1" />에 있는 일련의 요소에 대한 단순 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 형식의 컬렉션 또는 컬렉션의 하위 집합의 부분 복사본을 컬렉션의 요소에 대 한 참조만 포함합니다. 개체 자체가 복사 되지 않습니다. 새 목록에 참조를 원래 목록에 대 한 참조로 동일한 개체를 가리킵니다.  
  
 값 형식의 컬렉션 또는 컬렉션의 하위 집합의 부분 복사본을 컬렉션의 요소를 포함합니다. 그러나 다른 개체에 대 한 참조를 포함 하는 컬렉션의 요소를 해당 개체 복사 되지 않습니다. 새 컬렉션의 요소에 대 한 참조가 동일한 개체는 원본 컬렉션의 요소에 대 한 참조를 가리킵니다.  
  
 반면, 컬렉션의 전체 복사본을 요소를 복사 하 고 뿐만 아니라 요소에 의해 직접 또는 간접적으로 참조 하는 모든 것.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.GetRange%2A> 메서드 및 다른 방법으로는 <xref:System.Collections.Generic.List%601> 범위에서 작동 하는 클래스입니다. 예의 끝을 <xref:System.Collections.Generic.List%601.GetRange%2A> 메서드 인덱스 2 부터는 목록에서 세 개의 항목을 가져오는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.ToArray%2A> 메서드는 결과에서 <xref:System.Collections.Generic.List%601>, 3 개 요소의 배열을 만드는 동작 합니다. 배열의 요소가 표시 됩니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 요소 범위를 나타내지 않습니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에서 처음 나오는 값의 인덱스(0부터 시작)를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정된 개체를 검색하고, 전체 <see cref="T:System.Collections.Generic.List`1" />에서 처음으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="item" />가 있으면 전체 <see cref="T:System.Collections.Generic.List`1" />에서 맨 처음 발견되는 값의 0부터 시작하는 인덱스이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 검색은 앞으로 첫 번째 요소부터 마지막 요소입니다.  
  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.IndexOf%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열 만들어진 인덱스 0과 인덱스 위치 5에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> 메서드 오버 로드 목록 검색부터 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드 3 인덱스 위치를 사용 하 여 시작 하는 목록 및 목록 끝에 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드를 사용 하는 다양 한 두 인덱스 위치에서 시작 하는 두 개의 항목을 검색할; 범위에 검색 문자열의 인스턴스인 때문에-1을 반환 합니다.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">검색의 0부터 시작하는 인덱스입니다. 0은 빈 목록에서 유효합니다.</param>
        <summary>지정된 개체를 검색하고, 지정된 인덱스부터 마지막 요소까지 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 처음으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="index" />부터 마지막 요소까지 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 <paramref name="item" />가 있으면 처음으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.Generic.List%601> 부터 앞으로 검색 됩니다 `index` 및 마지막 요소에 종료 합니다.  
  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업을 여기서 *n* 의 요소입니다 `index` 의 끝에는 <xref:System.Collections.Generic.List%601>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.IndexOf%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열 만들어진 인덱스 0과 인덱스 위치 5에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> 메서드 오버 로드 목록 검색부터 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드 3 인덱스 위치를 사용 하 여 시작 하는 목록 및 목록 끝에 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드를 사용 하는 다양 한 두 인덱스 위치에서 시작 하는 두 개의 항목을 검색할; 범위에 검색 문자열의 인스턴스인 때문에-1을 반환 합니다.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">검색의 0부터 시작하는 인덱스입니다. 0은 빈 목록에서 유효합니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>지정된 개체를 검색하고, 지정된 인덱스에서 시작하여 지정된 수의 요소를 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 처음으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="index" />에서 시작하여 <paramref name="count" />개의 요소를 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 <paramref name="item" />가 있으면 처음으로 검색한 개체의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 부터 앞으로 검색 됩니다 `index` 에서 끝나는 `index` plus `count` 에서 1을 뺀 경우 `count` 0 보다 큽니다.  
  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.IndexOf%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열 만들어진 인덱스 0과 인덱스 위치 5에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> 메서드 오버 로드 목록 검색부터 하 고 문자열의 첫 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> 메서드 오버 로드 3 인덱스 위치를 사용 하 여 시작 하는 목록 및 목록 끝에 계속 검색 하는 데 사용 되 고 문자열의 두 번째 항목을 찾습니다. 마지막으로 <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드를 사용 하는 다양 한 두 인덱스 위치에서 시작 하는 두 개의 항목을 검색할; 범위에 검색 문자열의 인스턴스인 때문에-1을 반환 합니다.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
또는 
 <paramref name="count" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="item" />을 삽입해야 하는 인덱스(0부터 시작)입니다.</param>
        <param name="item">삽입할 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />의 지정된 인덱스에 요소를 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값 형식 및 중복 요소를 허용 합니다.  
  
 경우 <xref:System.Collections.Generic.List%601.Count%2A> 이미 같은 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량을 <xref:System.Collections.Generic.List%601> 자동으로 내부 배열을 다시 할당 하 여 증가 하는 새 요소가 추가 되기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 하는 경우 `index` 값과 같음 <xref:System.Collections.Generic.List%601.Count%2A>를 `item` 끝에 추가 됩니다 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 방법을 보여 줍니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Insert%2A> 메서드와 함께 다른 다양 한 속성 및 메서드를 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. 만들어진 후에 요소가 추가 됩니다. <xref:System.Collections.Generic.List%601.Insert%2A> 메서드 사용 하 여 목록 중간에 항목을 삽입 합니다. 항목 중복을 사용 하 여 나중에 제거 되는 삽입 된 <xref:System.Collections.Generic.List%601.Remove%2A> 메서드.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 큰 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">새 요소가 삽입되어야 하는 0부터 시작하는 인덱스입니다.</param>
        <param name="collection">요소가 <see cref="T:System.Collections.Generic.List`1" />에 삽입되어야 하는 컬렉션입니다. 컬렉션 자체가 <see langword="null" />일 수는 없지만 <paramref name="T" />형식이 참조 형식인 경우 <see langword="null" />인 요소를 포함할 수 있습니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />의 지정된 인덱스에 컬렉션의 요소를 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값 형식 및 중복 요소를 허용 합니다.  
  
 하는 경우 새 <xref:System.Collections.Generic.List%601.Count%2A> (현재 <xref:System.Collections.Generic.List%601.Count%2A> 컬렉션의 크기를 더한) 보다 커야 <xref:System.Collections.Generic.List%601.Capacity%2A>의 용량을 <xref:System.Collections.Generic.List%601> 자동으로 새 요소를 수용 하기 위해 내부 배열을 다시 할당 하 여 증가 및 기존 요소는 새 요소가 추가 되기 전에 새 배열에 복사 됩니다.  
  
 하는 경우 `index` 값과 같음 <xref:System.Collections.Generic.List%601.Count%2A>, 요소 끝에 추가 됩니다 <xref:System.Collections.Generic.List%601>합니다.  
  
 컬렉션의 요소 순서는 유지 된 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는 O (*n* * *m*) 작업을 여기서 *n* 요소를 추가할 수는 및 *m* 는<xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Collections.Generic.List%601.InsertRange%2A> 메서드와의 다른 다양 한 메서드는 <xref:System.Collections.Generic.List%601> 범위에서 작동 하는 클래스입니다. 목록 생성 되어 여러 식 공룡의 이름으로 채워진 후는 <xref:System.Collections.Generic.List%601.InsertRange%2A> 메서드 사용 하 여 세 사나운 식 공룡의 배열의 인덱스 위치 3부터 목록에 삽입 합니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 큰 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져오거나 설정할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary>지정한 인덱스에 있는 요소를 가져오거나 설정합니다.</summary>
        <value>지정한 인덱스의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 허용 `null` 참조에 대 한 유효한 값 형식 및 중복 요소를 허용 합니다.  
  
 이 속성은 `myCollection[index]` 구문을 사용하여 컬렉션의 특정 요소에 액세스하는 기능을 제공합니다.  
  
 이 속성의 값을 검색 하는 것은 O(1) 작업; O(1) 작업 이기도 속성을 설정 합니다.  
  
   
  
## Examples  
 이 섹션의 예제에 <xref:System.Collections.Generic.List%601.Item%2A> 속성 (C# 인덱서) 및 다른 다양 한 속성과 메서드를 <xref:System.Collections.Generic.List%601> 제네릭 클래스입니다. 목록 후 생성 및 사용 하 여 채울 합니다 <xref:System.Collections.Generic.List%601.Add%2A> 메서드를 요소가 검색 되 고 사용 하 여 표시를 <xref:System.Collections.Generic.List%601.Item%2A> 속성입니다. (사용 하는 예는 <xref:System.Collections.Generic.List%601.Item%2A> 목록 요소 값을 설정 하는 속성 참조 <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C# 및 c + + 모두에 액세스 하기 위한 구문을 사용 해야는 <xref:System.Collections.Generic.List%601.Item%2A> 해당 이름을 사용 하지 않고 속성입니다. 대신 포함 하는 변수는 <xref:System.Collections.Generic.List%601> 배열인 것 처럼 사용 됩니다.  
  
 C# 언어 사용 합니다 [ `this` ](~/docs/csharp/language-reference/keywords/this.md) 구현 하는 대신 인덱서를 정의 하는 키워드는 <xref:System.Collections.Generic.List%601.Item%2A> 속성입니다. Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <xref:System.Collections.Generic.List%601.Item%2A>을 기본 속성으로 구현합니다.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 크거나 같은 경우</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에서 마지막으로 나오는 값의 인덱스(0부터 시작)를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정된 개체를 검색하고, 전체 <see cref="T:System.Collections.Generic.List`1" />에서 마지막으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>전체 <see cref="T:System.Collections.Generic.List`1" />에서 마지막으로 검색된 <paramref name="item" />의 0부터 시작하는 인덱스이고, 검색되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 뒤로 마지막 요소에서 시작 하 고 첫 번째 요소에서 끝나는 검색 됩니다.  
  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열 만들어진 인덱스 0과 인덱스 위치 5에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> 메서드 오버 로드 끝에서 전체 목록을 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> 인덱스 3로 시작 하 고 목록에서 맨 처음 발견 되는 문자열을 찾으면 되므로 목록의 시작 부분에 계속 이전 버전과 목록을 검색 하려면 메서드 오버 로드를 사용 합니다. 마지막으로 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 4부터 시작 하 고 뒤로 확장의 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 인스턴스가 없는 검색 되므로이 검색-1을 반환 해당 범위의 문자열입니다.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <summary>지정된 개체를 검색하고, 첫 번째 요소부터 지정된 인덱스까지 포함하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 마지막으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns>첫 번째 요소부터 <paramref name="index" />까지 확장하는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위 내에서 마지막으로 검색된 <paramref name="item" />의 인덱스(0부터 시작)이고, 검색되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.Generic.List%601> 뒤로 검색 됩니다에서 `index` 첫 번째 요소에서 끝나는 합니다.  
  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업 위치 *n* 의 시작 부분에서 요소의 수는 <xref:System.Collections.Generic.List%601> 를 `index`입니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열 만들어진 인덱스 0과 인덱스 위치 5에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> 메서드 오버 로드 끝에서 전체 목록을 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> 인덱스 3로 시작 하 고 목록에서 맨 처음 발견 되는 문자열을 찾으면 되므로 목록의 시작 부분에 계속 이전 버전과 목록을 검색 하려면 메서드 오버 로드를 사용 합니다. 마지막으로 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 네 개의 항목을 인덱스 4부터 시작 하 고 뒤로 확장의 범위를 검색 하는 데 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 인스턴스가 없는 검색 되므로이 검색-1을 반환 해당 범위의 문자열입니다.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 찾을 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <param name="index">역방향 검색의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">검색할 섹션에 있는 요소 수입니다.</param>
        <summary>지정된 개체를 검색하며, 지정된 수의 요소를 포함하고 지정된 인덱스에서 끝나는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에서 마지막으로 검색한 개체의 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="count" />개의 요소를 포함하고 <paramref name="index" />에서 끝나는 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 마지막으로 검색한 <paramref name="item" />의 인덱스(0부터 시작)이고, 검색되지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> 검색에서 시작 됩니다 `index` 에서 끝나는 `index` 빼기 `count` + 1, 경우 `count` 0 보다 큽니다.  
  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 `count`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 모든 오버 로드는 <xref:System.Collections.Generic.List%601.LastIndexOf%2A> 메서드. <xref:System.Collections.Generic.List%601> 문자열 만들어진 인덱스 0과 인덱스 위치 5에 두 번 나타나는 하나의 항목으로 합니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> 메서드 오버 로드 끝에서 전체 목록을 검색 하 고 문자열의 두 번째 항목을 찾습니다. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> 인덱스 3로 시작 하 고 목록에서 맨 처음 발견 되는 문자열을 찾으면 되므로 목록의 시작 부분에 계속 이전 버전과 목록을 검색 하려면 메서드 오버 로드를 사용 합니다. 마지막으로 <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> 메서드 오버 로드는 4 개의 항목을 인덱스 4부터 시작 하 고 뒤로 확장의 범위를 검색 하려면 사용 됩니다 (즉, 검색 4, 3, 2 및 1 위치에 있는 항목); 검색의 인스턴스인 때문에이 검색-1을 반환 해당 범위의 문자열입니다.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.Generic.List`1" />의 유효한 인덱스 범위를 벗어납니다.  
  
또는 
 <paramref name="count" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 섹션을 지정하지 않습니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.Generic.List`1" />에서 제거할 개체입니다. 참조 형식에 대해 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />에서 맨 처음 발견되는 특정 개체를 제거합니다.</summary>
        <returns><paramref name="item" />이 성공적으로 제거되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.  이 메서드는 <paramref name="item" />이 <see cref="T:System.Collections.Generic.List`1" />에 없는 경우에도 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 형식 `T` 구현 합니다 <xref:System.IEquatable%601> 제네릭 인터페이스를 같음 비교자는는 <xref:System.IEquatable%601.Equals%2A> 해당 인터페이스의 메서드 그렇지 않으면 기본 같음 비교자는 <xref:System.Object.Equals%2A?displayProperty=nameWithType>합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 방법을 보여 줍니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 다음 예제에서는 <xref:System.Collections.Generic.List%601.Remove%2A> 메서드. 여러 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 제네릭 클래스는 추가, 삽입 및 목록을 검색 하는 데 사용 됩니다. 이러한 작업을 수행한 후 목록에 중복 포함 되어 있습니다. <xref:System.Collections.Generic.List%601.Remove%2A> 메서드를 사용 하 여 중복 항목의 첫 번째 인스턴스를 제거 하 고 내용이 표시 됩니다. <xref:System.Collections.Generic.List%601.Remove%2A> 메서드는 항상 발견 첫 번째 인스턴스를 제거 합니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">제거할 요소의 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary>지정된 조건자에 정의된 조건과 일치하는 요소를 모두 제거합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" />에서 제거한 요소의 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자 및 조건과 일치 하는 요소에서 제거 됩니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 메서드와 사용 하는 몇 가지 다른 방법도 <xref:System.Predicate%601> 제네릭 대리자입니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열 만들어진, "saurus"를 사용 하 여 종료 (위치 1과 5)는 두 개의 8 공룡 이름이 들어 있는입니다. 이 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 수락 하 고 부울 값을 반환 나타내는 "saurus"로 입력된 문자열 종료 여부를 합니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, 및 <xref:System.Collections.Generic.List%601.FindAll%2A> 메서드 검색 조건자 메서드를 사용 하 여 목록을 검색 하는 데 사용 됩니다.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> 메서드는 "saurus"로 끝나는 모든 항목을 제거 하는 데 사용 됩니다. 목록의 각 요소를 차례로 전달부터 통과할는 `EndsWithSaurus` 메서드. 요소가 제거 하는 경우는 `EndsWithSaurus` 메서드가 반환 되는 `true`합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서는 필요 없는 만들려면 합니다 `Predicate<string>` 대리자 (`Predicate(Of String)` Visual Basic의) 명시적으로 합니다. 이러한 언어 컨텍스트에서 올바른 대리자 유추 하 고 자동으로 만듭니다.  
  
 마지막으로 <xref:System.Collections.Generic.List%601.Exists%2A> 메서드 "saurus"로 끝나는 없는 문자열 목록에 있는지 확인 합니다.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />의 지정된 인덱스에 있는 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우 <xref:System.Collections.Generic.List%601.RemoveAt%2A> 항목을 제거 하려면 목록에서 나머지 항목 제거 된 항목을 바꾸려면 매겨집니다. 예를 들어 인덱스 3에 있는 항목을 제거 하면 4 인덱스의 항목 3 위치로 이동 됩니다. 또한 목록에서 항목 수 (나타낸는 <xref:System.Collections.Generic.List%601.Count%2A> 속성) 1 씩 감소 됩니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 다음 예제에서는 추가, 제거 및에서 간단한 비즈니스 개체를 삽입 하는 방법을 보여 줍니다는 <xref:System.Collections.Generic.List%601>합니다.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" />가 <see cref="P:System.Collections.Generic.List`1.Count" />보다 크거나 같은 경우</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 요소의 범위에 대한 0부터 시작하는 인덱스입니다.</param>
        <param name="count">제거할 요소의 수입니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />에서 요소의 범위를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목이 제거 되 및 다음에서 모든 요소를 <xref:System.Collections.Generic.List%601> 인하 인덱스가 `count`합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.RemoveRange%2A> 메서드와의 다른 다양 한 메서드를 <xref:System.Collections.Generic.List%601> 범위에서 작동 하는 클래스입니다. 목록 생성 및 수정 된 후의 <xref:System.Collections.Generic.List%601.RemoveRange%2A> 메서드를 사용 하 여 인덱스 위치 2에서 시작 하는 목록에서 두 요소를 제거 하 합니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 요소 범위를 나타내지 않습니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> 또는 그 일부에서 요소의 순서를 반대로 바꿉니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>전체 <see cref="T:System.Collections.Generic.List`1" />에서 요소의 순서를 반대로 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Array.Reverse%2A?displayProperty=nameWithType> 요소의 순서를 반대로 합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 <xref:System.Collections.Generic.List%601.Reverse%2A> 메서드. 이 예에서는 만듭니다는 <xref:System.Collections.Generic.List%601> 의 문자열 및 문자열 6 개를 추가 합니다. <xref:System.Collections.Generic.List%601.Reverse> 목록 되돌리려면 메서드 오버 로드는 차례로 <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> 요소 1로 시작 하 고 4 개의 요소가 포함 목록의 중간 되돌리려면 메서드 오버 로드를 사용 합니다.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">순서를 반대로 바꿀 범위의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">순서를 반대로 바꿀 범위의 요소 수입니다.</param>
        <summary>지정된 범위에서 요소의 순서를 반대로 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Array.Reverse%2A?displayProperty=nameWithType> 요소의 순서를 반대로 합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 <xref:System.Collections.Generic.List%601.Reverse%2A> 메서드. 이 예에서는 만듭니다는 <xref:System.Collections.Generic.List%601> 의 문자열 및 문자열 6 개를 추가 합니다. <xref:System.Collections.Generic.List%601.Reverse> 목록 되돌리려면 메서드 오버 로드는 차례로 <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> 요소 1로 시작 하 고 4 개의 요소가 포함 목록의 중간 되돌리려면 메서드 오버 로드를 사용 합니다.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />에서 올바른 요소 범위를 나타내지 않습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 또는 기본 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현 또는 제공된 <see cref="T:System.Comparison`1" /> 대리자를 사용하여 <see cref="T:System.Collections.Generic.List`1" />의 요소 또는 요소의 일부를 정렬하여 목록 요소를 비교합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 비교자를 사용하여 전체 <see cref="T:System.Collections.Generic.List`1" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 비교자를 사용 하는이 메서드가 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 형식에 대 한 `T` 목록 요소의 순서를 결정 합니다. 합니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 속성 검사 여부를 입력 합니다. `T` 구현를 <xref:System.IComparable%601> 제네릭 인터페이스 구현에는 사용 하 여 사용 가능한 경우.  그러지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현 된 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않습니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 이 메서드는 사용 된 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 내면적인 정렬을 다음과 같이 적용 되는 메서드:  
  
-   파티션 크기를 16 개 요소를 삽입 정렬 알고리즘을 사용 합니다.  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*, 여기서 *n* 범위 입력 배열의 Heapsort 알고리즘을 사용 합니다.  
  
-   그렇지 않으면 빠른 정렬 알고리즘을 사용합니다.  
  
 이 구현은 수행 불안정 한 정렬을; 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정 된 정렬 같지 않은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는 O (*n* 로그 *n*) 작업을 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 예제에서는 일부 이름을 `List<String>` 목록을 정렬 되지 않은 순서로 호출 하는 개체를 표시 합니다 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드를 다음 정렬 된 목록을 표시 합니다.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 다음 코드에서는 합니다 <xref:System.Collections.Generic.List%601.Sort> 고 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 간단한 비즈니스 개체의 메서드 오버 로드 합니다. 호출을 <xref:System.Collections.Generic.List%601.Sort> 파트 형식에 대 한 기본 비교자를 사용 하면 메서드 및 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 메서드는 무명 메서드를 사용 하 여 구현 됩니다.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort> 메서드 오버 로드 및 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드 합니다. <xref:System.Collections.Generic.List%601> 문자열 생성 되어 특정 순서 없이 4 개의 문자열을 사용 하 여 채워집니다. 목록은 표시 하 고 정렬 하 고 다시 표시 됩니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> 메서드 오버 로드는 다음 목록에 없는 두 문자열을 검색 하는 데 사용 됩니다 및 <xref:System.Collections.Generic.List%601.Insert%2A> 메서드 삽입 하기를 사용 합니다. 반환 값은 <xref:System.Collections.Generic.List%601.BinarySearch%2A> 문자열 목록에 없기 때문에 메서드는 각각의 경우에서 음수입니다. 비트 보수 (의 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1)이 음수 숫자 생성, 검색 문자열 보다 크고 삽입이 위치에 있는 목록의 첫 번째 요소의 인덱스 유지 정렬 순서입니다. 두 번째 검색 문자열은 목록 끝에 삽입 위치 이므로 목록에 있는 모든 요소 보다 큰 합니다.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스 또는 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 구현을 찾을 수 없습니다.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현이거나, 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 전체 <see cref="T:System.Collections.Generic.List`1" />에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 제공 되는 요소의 합니다 <xref:System.Collections.Generic.List%601> 지정 된 정렬 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현를 <xref:System.IComparable%601> 제네릭 인터페이스 구현에는 사용 하 여 사용 가능한 경우.  그러지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현 된 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않습니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 이 메서드는 사용 된 <xref:System.Array.Sort%2A?displayProperty=nameWithType> 내면적인 정렬을 다음과 같이 적용 되는 메서드:  
  
-   파티션 크기를 16 개 요소를 삽입 정렬 알고리즘을 사용 합니다.  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*, 여기서 *n* 범위 입력 배열의 Heapsort 알고리즘을 사용 합니다.  
  
-   그렇지 않으면 빠른 정렬 알고리즘을 사용합니다.  
  
 이 구현은 수행 불안정 한 정렬을; 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정 된 정렬 같지 않은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는 O (*n* 로그 *n*) 작업을 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 및 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 라는 DinoCompare 구현 하는 문자열에 대 한 대체는 비교자를 정의 합니다 `IComparer<string>` (`IComparer(Of String)` Visual Basic에서는 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자 같이 작동합니다. 에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열인 큰 것으로 간주 됩니다. 셋째, 길이가 같으면 일반적인 문자열 비교가 됩니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열 생성 되어 특정 순서 없이 4 개의 문자열을 사용 하 여 채워집니다. 목록은 다시 표시 됩니다, 대체 비교자를 사용 하 여 정렬 및 표시.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 하지 목록에서 사용 중인 비교자를 대체 하는 여러 문자열을 검색 하는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.Insert%2A> 메서드 사용 하 여 문자열을 삽입 합니다. 이 두 메서드 라는 함수에 있는 `SearchAndInsert`, 비트 보수를 수행 하는 코드와 함께 (는 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 반환한 음수 개수 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 에 대 한 인덱스로 사용 새 문자열을 삽입 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 또는 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스의 구현을 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">요소를 비교할 때 사용할 <see cref="T:System.Comparison`1" />입니다.</param>
        <summary>지정된 <see cref="T:System.Comparison`1" />을 사용하여 전체 <see cref="T:System.Collections.Generic.List`1" />의 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `comparison` 제공 되는 요소는 <xref:System.Collections.Generic.List%601> 대리자가 나타내는 메서드를 사용 하 여 정렬 됩니다.  
  
 하는 경우 `comparison` 됩니다 `null`, <xref:System.ArgumentNullException> throw 됩니다.  
  
 이 메서드는 <xref:System.Array.Sort%2A?displayProperty=nameWithType>, 내면적인 정렬 다음과 같이 적용 합니다.  
  
-   삽입 정렬 알고리즘을 사용 하 여 파티션 크기가 16 개 요소,  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*여기서 *n* 범위는 사용 입력 배열의 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 빠른 정렬 알고리즘을 사용합니다.  
  
 이 구현은 수행 불안정 한 정렬을; 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정 된 정렬 같지 않은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는 O (*n* 로그 *n*) 작업을 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 코드에서는 합니다 <xref:System.Collections.Generic.List%601.Sort%2A> 고 <xref:System.Collections.Generic.List%601.Sort%2A> 간단한 비즈니스 개체의 메서드 오버 로드 합니다. 호출을 <xref:System.Collections.Generic.List%601.Sort%2A> 파트 형식에 대 한 기본 비교자를 사용 하면 메서드 및 <xref:System.Collections.Generic.List%601.Sort%2A> 메서드는 무명 메서드를 사용 하 여 구현 됩니다.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 문자열에 대 한 대체 비교 메서드를 정의 `CompareDinosByLength`합니다. 이 메서드는 다음과 같이 작동합니다. 에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열인 큰 것으로 간주 됩니다. 셋째, 길이가 같으면 일반적인 문자열 비교가 됩니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열 생성 되어 특정 순서 없이 4 개의 문자열을 사용 하 여 채워집니다. 목록에는 빈 문자열 및 null 참조도 포함 됩니다. 사용 하 여 정렬 된 목록이 표시 되는 <xref:System.Comparison%601> 나타내는 제네릭 대리자는 `CompareDinosByLength` 메서드를 다시 표시 합니다.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparison" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">정렬할 범위의 0부터 시작하는 인덱스입니다.</param>
        <param name="count">정렬할 범위의 길이입니다.</param>
        <param name="comparer">요소를 비교할 때 사용할 <see cref="T:System.Collections.Generic.IComparer`1" /> 구현이거나, 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용하려면 <see langword="null" />입니다.</param>
        <summary>지정된 비교자를 사용하여 <see cref="T:System.Collections.Generic.List`1" />의 요소 범위에 있는 요소를 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `comparer` 제공 되는 요소의 합니다 <xref:System.Collections.Generic.List%601> 지정 된 정렬 <xref:System.Collections.Generic.IComparer%601> 구현 합니다.  
  
 경우 `comparer` 은 `null`, 기본 비교자 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현를 <xref:System.IComparable%601> 제네릭 인터페이스 구현에는 사용 하 여 사용 가능한 경우.  그러지 않으면 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> 검사 여부를 입력 합니다. `T` 구현 된 <xref:System.IComparable> 인터페이스입니다.  경우 형식 `T` 인터페이스 중 하나를 구현 하지 않습니다 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> throw는 <xref:System.InvalidOperationException>합니다.  
  
 이 메서드는 <xref:System.Array.Sort%2A?displayProperty=nameWithType>, 내면적인 정렬 다음과 같이 적용 합니다.  
  
-   삽입 정렬 알고리즘을 사용 하 여 파티션 크기가 16 개 요소,  
  
-   파티션 수가 2 개 로그를 초과 하는 경우 *n*여기서 *n* 범위는 사용 입력 배열의 [Heapsort](https://en.wikipedia.org/wiki/Heapsort) 알고리즘입니다.  
  
-   그렇지 않으면 빠른 정렬 알고리즘을 사용합니다.  
  
 이 구현은 수행 불안정 한 정렬을; 즉, 두 요소가 같은 경우 순서 유지 되지 않을 수 있습니다. 반면, 안정 된 정렬 같지 않은 요소의 순서를 유지 합니다.  
  
 평균적으로이 메서드는 O (*n* 로그 *n*) 작업을 여기서 *n* 은 <xref:System.Collections.Generic.List%601.Count%2A>최악의 경우에는 o (*n* <sup>2</sup>) 작업입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 및 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드 합니다.  
  
 이 예제에서는 라는 DinoCompare 구현 하는 문자열에 대 한 대체는 비교자를 정의 합니다 `IComparer<string>` (`IComparer(Of String)` Visual Basic에서는 `IComparer<String^>` Visual c + +에서) 제네릭 인터페이스입니다. 비교자 같이 작동합니다. 에 대 한 여부도 먼저 `null`, null 참조는 null이 아닌 미만으로 처리 됩니다. 둘째, 문자열 길이 비교 하 고 더 긴 문자열인 큰 것으로 간주 됩니다. 셋째, 길이가 같으면 일반적인 문자열 비교가 됩니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열를 만들고 5 개의 예제 dinosaurs 및 예제 이름으로 채웁니다. 각 두 그룹의 이름을 특정 정렬 순서에 있지 않습니다. 목록이 표시 됩니다 하 고 초 식의 범위는 대체 비교자를 사용 하 여 정렬 된 목록이 다시 표시 됩니다.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드 오버 로드는 다음 "Brachiosaurus" 초 식의 범위에만 검색 하는 데 사용 됩니다. 문자열 없는 비트 보수 (의 ~ C# 및 Visual c + + 연산자 `Xor` Visual Basic의-1) 반환한 음수 개수는 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> 메서드는 새 문자열을 삽입 하는 것에 대 한 인덱스로 사용 합니다.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 및 <paramref name="count" />가 <see cref="T:System.Collections.Generic.List`1" />의 올바른 범위를 지정하지 않습니다.  
  
또는 
<paramref name="comparer" />의 구현으로 인해 정렬 중에 오류가 발생했습니다. 예를 들어 항목을 자기 자신과 비교할 때 <paramref name="comparer" />에서 0을 반환하지 않을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />가 <see langword="null" />이고 기본 비교자 <see cref="P:System.Collections.Generic.Comparer`1.Default" />가 형식 <paramref name="T" />에 대한 <see cref="T:System.IComparable" /> 인터페이스 또는 <see cref="T:System.IComparable`1" /> 제네릭 인터페이스의 구현을 찾을 수 없습니다.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.ICollection`1" />가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 읽기 전용이면 <see cref="T:System.Collections.Generic.ICollection`1" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 되 면 읽기 전용 컬렉션에 이러한 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션에서 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual Basic에서) 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. 이 위치에 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>합니다.  
  
 합니다 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 라고 합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 정의 되지 않습니다. <xref:System.Collections.Generic.IEnumerator%601.Current%2A>를 컬렉션의 첫 번째 요소로 다시 설정할 수 없으므로 대신 새 열거자 인스턴스를 만들어야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경에 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제, 열거자가 복구할 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> throw는 <xref:System.InvalidOperationException>합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.ICollection" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex"><paramref name="array" />에서 복사가 시작되는 0부터 시작하는 인덱스입니다.</param>
        <summary>특정 <see cref="T:System.Collections.ICollection" /> 인덱스부터 시작하여 <see cref="T:System.Array" />의 요소를 <see cref="T:System.Array" />에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  경우는 원본의 유형을 <xref:System.Collections.ICollection> 대상의 형식으로 자동 캐스팅할 수 없는 `array`의 제네릭이 아닌 구현은 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>제네릭 구현은 throw 하는 반면, <xref:System.ArgumentException>합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />가 0보다 작은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />가 다차원 배열인 경우  
  
또는 
 <paramref name="array" />에 0부터 시작하는 인덱스가 없습니다.  
  
또는 
소스 <see cref="T:System.Collections.ICollection" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="arrayIndex" />부터 끝까지 사용 가능한 공간보다 큽니다.  
  
또는 
소스 <see cref="T:System.Collections.ICollection" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ICollection" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see cref="T:System.Collections.ICollection" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.  드문 경우 이지만 열거형 쓰기 액세스를 사용 하 여 경쟁 하는 위치를 열거 하는 동안 컬렉션을 잠글 수 있습니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 에 대 한 액세스를 동기화 할 수 있는 개체를 반환 합니다 <xref:System.Collections.ICollection>합니다. 동기화는 모든 스레드에서 컬렉션에 액세스 하기 전에이 개체를 잠그는 경우에 유효 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ICollection" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ICollection" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 현재 인스턴스를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> 에 대 한 액세스를 동기화 할 수 있는 개체를 반환 합니다 <xref:System.Collections.ICollection>합니다. 동기화는 모든 스레드에서 컬렉션에 액세스 하기 전에이 개체를 잠그는 경우에 유효 합니다. 다음 코드의 사용을 보여 줍니다.는 <xref:System.Collections.ICollection.SyncRoot%2A> C#, c + + 및 Visual Basic에 대 한 속성입니다.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 반복하는 열거자를 반환합니다.</summary>
        <returns>컬렉션에서 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `foreach` C# 언어의 (`for each` c + +에서는 `For Each` Visual Basic에서) 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에 <xref:System.Collections.IEnumerator.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.IEnumerator.Current%2A>합니다.  
  
 합니다 <xref:System.Collections.IEnumerator.Current%2A> 될 때까지 동일한 개체를 반환 하는 속성 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> 라고 합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경에 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제, 열거자가 복구할 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> throw는 <xref:System.InvalidOperationException>합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스에서 컬렉션의 기본 구현은 동기화되지 않습니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" />에 추가할 <see cref="T:System.Collections.IList" />입니다.</param>
        <summary><see cref="T:System.Collections.IList" />에 항목을 추가합니다.</summary>
        <returns>새 요소가 삽입된 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 <xref:System.Collections.Generic.List%601.Count%2A> 는 보다 작은 <xref:System.Collections.Generic.List%601.Capacity%2A>,이 메서드는 o (1) 작업입니다. 이 메서드는 O가 용량을 늘려야 하는 새 요소를 수용할 수 있도록 하는 경우 (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" />에서 찾을 <see cref="T:System.Collections.IList" />입니다.</param>
        <summary><see cref="T:System.Collections.IList" />에 특정 값이 들어 있는지 여부를 확인합니다.</summary>
        <returns><see langword="true" />가 <paramref name="item" />에 있으면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.IList" />에서 찾을 개체입니다.</param>
        <summary><see cref="T:System.Collections.IList" />에서 특정 항목의 인덱스를 결정합니다.</summary>
        <returns>목록에 있으면 <paramref name="item" />의 인덱스이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="item" />을 삽입해야 하는 인덱스(0부터 시작)입니다.</param>
        <param name="item"><see cref="T:System.Collections.IList" />에 삽입할 개체입니다.</param>
        <summary>항목을 <see cref="T:System.Collections.IList" />의 지정된 인덱스에 삽입합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`가 <xref:System.Collections.IList>의 항목 수와 같으면 `item`가 끝에 추가됩니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.IList" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.IList" />의 크기가 고정되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />의 크기가 고정되어 있으면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기가 고정된 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가하거나 제거할 수 없지만 기존 요소는 수정할 수 있습니다.  
  
 크기가 고정된 된 컬렉션은 요소; 추가 및 제거를 방지 하는 래퍼를 지정 된 컬렉션 따라서 기본 컬렉션 추가 또는 제거 요소를 포함 하 여 변경 된 경우 고정 크기 컬렉션에 해당 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.IList" />가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" />이 읽기 전용이면 <see cref="T:System.Collections.IList" />이고, 그렇지 않으면 <see langword="false" />입니다.  <see cref="T:System.Collections.Generic.List`1" />의 기본 구현에서 이 속성은 언제나 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 되 면 읽기 전용 컬렉션에 이러한 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져오거나 설정할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary>지정한 인덱스에 있는 요소를 가져오거나 설정합니다.</summary>
        <value>지정한 인덱스의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C# 언어를 사용 하는 [이](~/docs/csharp/language-reference/keywords/this.md) 구현 하는 대신 인덱서를 정의 하는 키워드는 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> 속성입니다. Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>을 기본 속성으로 구현합니다.  
  
 이 속성의 값을 검색 하는 것은 O(1) 작업; O(1) 작업 이기도 속성을 설정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.IList" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">속성이 설정되어 있고 <paramref name="value" />의 형식을 <see cref="T:System.Collections.IList" />에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Collections.IList" />에서 제거할 개체입니다.</param>
        <summary><see cref="T:System.Collections.IList" />에서 맨 처음 발견되는 특정 개체를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 같음 비교자를 사용 하 여 같은지 여부를 확인 하는이 메서드가 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> 에 대 한 `T`, 목록에서 값의 형식입니다.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" />의 형식은 <see cref="T:System.Collections.IList" />에 할당할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" />의 요소를 새 배열에 복사합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" />의 요소 복사본을 포함하는 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 요소가 복사 되 <xref:System.Array.Copy%2A?displayProperty=nameWithType>, O는 (*n*) 작업을 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Collections.Generic.List%601.ToArray%2A> 메서드 및 다른 방법으로는 <xref:System.Collections.Generic.List%601> 범위에서 작동 하는 클래스입니다. 예의 끝을 <xref:System.Collections.Generic.List%601.GetRange%2A> 메서드 인덱스 2 부터는 목록에서 세 개의 항목을 가져오는 데 사용 됩니다. <xref:System.Collections.Generic.List%601.ToArray%2A> 메서드는 결과에서 <xref:System.Collections.Generic.List%601>, 3 개 요소의 배열을 만드는 동작 합니다. 배열의 요소가 표시 됩니다.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" />에 있는 요소의 실제 수가 임계값보다 작은 경우 용량을 요소 수로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 새 요소가 컬렉션에 추가 될 경우 컬렉션의 메모리 오버 헤드를 최소화할 데 사용할 수 있습니다. 그러나 재할당 하 고 큰 복사의 비용 <xref:System.Collections.Generic.List%601> 상당히 커질 수 있으므로 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드는 아무 효과도 없습니다 목록의 용량의 90%를 초과 하는 합니다. 이 비교적 작은 이익을 얻기에 대 한 큰 재할당 비용을 방지 합니다.  
  
> [!NOTE]
>  현재 임계값을 90%는 이후 릴리스에서 변경 될 수 있습니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
 다시 설정 하는 <xref:System.Collections.Generic.List%601> 초기 상태로 호출 합니다 <xref:System.Collections.Generic.List%601.Clear%2A> 메서드를 호출 하기 전에 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드. 빈 트리밍 <xref:System.Collections.Generic.List%601> 의 용량을 설정 합니다 <xref:System.Collections.Generic.List%601> 기본 용량입니다.  
  
 사용 하 여 용량을 설정할 수도 있습니다는 <xref:System.Collections.Generic.List%601.Capacity%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에는 용량 및 개수를 확인 하는 방법을 보여 줍니다.는 <xref:System.Collections.Generic.List%601> 간단한 비즈니스 개체를 포함 하 고 사용 하는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 추가 용량을 제거 하는 방법입니다.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 다음 예제는 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드. 여러 속성 및 메서드는 <xref:System.Collections.Generic.List%601> 클래스는 추가, 삽입 및 문자열의 목록에서 항목을 제거 하는 데 사용 됩니다. 그런 다음 <xref:System.Collections.Generic.List%601.TrimExcess%2A> 메서드는 개수에 맞게 용량을 줄이는 데 하며 <xref:System.Collections.Generic.List%601.Capacity%2A> 및 <xref:System.Collections.Generic.List%601.Count%2A> 속성이 표시 됩니다. 총 용량을 10% 미만 사용 하지 않은 용량이, 하는 경우 목록은 하지 크기가 조정 되었습니다. 마지막으로, 목록의 내용은 지워집니다.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">요소에 대해 확인할 조건을 정의하는 <see cref="T:System.Predicate`1" /> 대리자입니다.</param>
        <summary><see cref="T:System.Collections.Generic.List`1" />의 모든 요소가 지정된 조건자에 정의된 조건과 일치하는지 여부를 확인합니다.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" />의 모든 요소가 지정된 조건자에 정의된 조건과 일치하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 목록에 요소가 없으면 반환 값은 <see langword="true" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Predicate%601> 가 반환 하는 메서드를 대리자 `true` 대리자에서 정의 된 조건과 일치 하는 개체에 전달 하는 경우.  현재 요소의 <xref:System.Collections.Generic.List%601> 개별적으로 전달 되는 <xref:System.Predicate%601> 대리자 및 처리는 대리자가 반환 하는 경우 중지 됩니다 `false` 모든 요소에 대 한 합니다. 요소가 순서 대로 처리 되 고 모든 호출은 단일 스레드에서 수행 됩니다.  
  
 이 메서드는 O (*n*) 작업, 여기서 *n* 는 <xref:System.Collections.Generic.List%601.Count%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Collections.Generic.List%601.TrueForAll%2A> 메서드와 사용 하는 몇 가지 다른 방법도 <xref:System.Predicate%601> 제네릭 대리자입니다.  
  
 <xref:System.Collections.Generic.List%601> 문자열 만들어진, "saurus"를 사용 하 여 종료 (위치 1과 5)는 두 개의 8 공룡 이름이 들어 있는입니다. 이 예제에서는 명명 된 검색 조건자 메서드도 정의 `EndsWithSaurus`문자열 매개 변수를 수락 하 고 부울 값을 반환 나타내는 "saurus"로 입력된 문자열 종료 여부를 합니다.  
  
 합니다 <xref:System.Collections.Generic.List%601.TrueForAll%2A> 메서드를 차례로 각 요소를 전달부터 목록을 트래버스 합니다 `EndsWithSaurus` 메서드. 검색을 중지 하는 경우는 `EndsWithSaurus` 메서드가 반환 되는 `false`합니다.  
  
> [!NOTE]
>  C# 및 Visual Basic에서는 필요 없는 만들려면 합니다 `Predicate<string>` 대리자 (`Predicate(Of String)` Visual Basic의) 명시적으로 합니다. 이러한 언어는 상황에 맞는 올바른 대리자 유추 하 고 자동으로 만듭니다.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>