<Type Name="ReadOnlyCollectionBase" FullName="System.Collections.ReadOnlyCollectionBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f0e06217611bd0d1a40d32e9e526bbcfe587c551" /><Meta Name="ms.sourcegitcommit" Value="3f21796619d6e69ad383c958cc013ce44c0678de" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/11/2019" /><Meta Name="ms.locfileid" Value="56062343" /></Metadata><TypeSignature Language="C#" Value="public abstract class ReadOnlyCollectionBase : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit ReadOnlyCollectionBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ReadOnlyCollectionBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReadOnlyCollectionBase&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReadOnlyCollectionBase abstract : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type ReadOnlyCollectionBase = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>제네릭이 아닌 강력한 형식의 읽기 전용 컬렉션에 대한 <see langword="abstract" /> 기본 클래스를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Collections.ReadOnlyCollectionBase> 인스턴스는 항상 읽기 전용입니다. 참조 <xref:System.Collections.CollectionBase> 이 클래스의 수정 가능한 버전입니다.  

> [!IMPORTANT]
>  사용 하는 권장 하지 않습니다는 `ReadOnlyCollectionBase` 새로운 개발에 대 한 클래스입니다. 제네릭 사용 하는 권장 대신 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 클래스입니다. 자세한 내용은 [제네릭이 아닌 컬렉션을 사용 하지 않아야](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) github입니다.


## Examples  
 다음 코드 예제에서는 구현 된 <xref:System.Collections.ReadOnlyCollectionBase> 클래스입니다.  
  
 [!code-cpp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CPP/readonlycollectionbase.cpp#1)]
 [!code-csharp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CS/readonlycollectionbase.cs#1)]
 [!code-vb[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/VB/readonlycollectionbase.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual Basic의)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  
  
이 구현은 동기화를 제공 하지 않습니다 스레드로부터 안전한 래퍼를 <see cref="T:System.Collections.ReadOnlyCollectionBase" />, 파생된 클래스의 자체 동기화 된 버전을 만들 수 있지만 <see cref="T:System.Collections.ReadOnlyCollectionBase" /> 사용 하 여를 <see cref="P:System.Collections.ICollection.SyncRoot" /> 속성.  
  
컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</threadsafe>
    <block subset="none" type="overrides"><para>이 기본 클래스는 강력한 형식의 읽기 전용 사용자 지정 컬렉션을 만들 수는 쉽게 수행할 수 있도록 제공 됩니다. 구현자는 자체를 만드는 대신이 기본 클래스를 확장 하는 것이 좋습니다. 이 기본 클래스의 멤버는 파생된 된 클래스를 통해 사용 하기에 적합 하 고 보호 됩니다.  
  
이 클래스를 사용 하면 기본 컬렉션을 통해 사용할 수는 <see cref="P:System.Collections.ReadOnlyCollectionBase.InnerList" /> 속성에서 직접 파생 된 클래스로 사용 하기 위한 <see cref="T:System.Collections.ReadOnlyCollectionBase" />합니다. 파생된 클래스는 자체 사용자가 기본 컬렉션을 수정할 수 없습니다 확인 해야 합니다.</para></block>
    <altmember cref="T:System.Collections.ArrayList" />
    <altmember cref="T:System.Collections.CollectionBase" />
    <altmember cref="N:System.Collections.Generic" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReadOnlyCollectionBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ReadOnlyCollectionBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReadOnlyCollectionBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 o (1) 작업입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ReadOnlyCollectionBase.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.ReadOnlyCollectionBase.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 인스턴스에 포함된 요소의 수를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 인스턴스에 포함된 요소의 수입니다.  
  
이 속성 값을 검색하는 것은 O(1) 연산입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 구현 된 <xref:System.Collections.ReadOnlyCollectionBase> 클래스입니다.  
  
 [!code-cpp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CPP/readonlycollectionbase.cpp#1)]
 [!code-csharp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CS/readonlycollectionbase.cs#1)]
 [!code-vb[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/VB/readonlycollectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ReadOnlyCollectionBase.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="readOnlyCollectionBase.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 인스턴스를 반복하는 열거자를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> 인스턴스의 <see cref="T:System.Collections.ReadOnlyCollectionBase" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>는 정의되지 않습니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 된 <xref:System.Collections.ReadOnlyCollectionBase> 클래스입니다.  
  
 [!code-cpp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CPP/readonlycollectionbase.cpp#1)]
 [!code-csharp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CS/readonlycollectionbase.cs#1)]
 [!code-vb[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/VB/readonlycollectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="InnerList">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList InnerList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList InnerList" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ReadOnlyCollectionBase.InnerList" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InnerList As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ InnerList { System::Collections::ArrayList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerList : System.Collections.ArrayList" Usage="System.Collections.ReadOnlyCollectionBase.InnerList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 인스턴스에 포함된 요소의 목록을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ArrayList" /> 인스턴스 자체를 나타내는 <see cref="T:System.Collections.ReadOnlyCollectionBase" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 구현 된 <xref:System.Collections.ReadOnlyCollectionBase> 클래스입니다.  
  
 [!code-cpp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CPP/readonlycollectionbase.cpp#1)]
 [!code-csharp[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CS/readonlycollectionbase.cs#1)]
 [!code-vb[System.Collections.ReadOnlyCollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/VB/readonlycollectionbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>이 클래스를 사용 하면 기본 컬렉션을 통해 사용할 수는 <see cref="P:System.Collections.ReadOnlyCollectionBase.InnerList" /> 속성에서 직접 파생 된 클래스로 사용 하기 위한 <see cref="T:System.Collections.ReadOnlyCollectionBase" />합니다. 파생된 클래스는 자체 사용자가 기본 컬렉션을 수정할 수 없습니다 확인 해야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ReadOnlyCollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Collections.ReadOnlyCollectionBase" />입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="index"><paramref name="array" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
        <summary>대상 배열의 지정된 인덱스에서 시작하여 전체 <see cref="T:System.Collections.ReadOnlyCollectionBase" />을 호환되는 1차원 <see cref="T:System.Array" />에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정된 된 배열의 호환 되는 형식 이어야 합니다.  
  
 이 메서드는 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 요소를 복사 합니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.ReadOnlyCollectionBase.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />가 다차원 배열인 경우  
  
또는 
소스 <see cref="T:System.Collections.ReadOnlyCollectionBase" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="index" />부터 끝까지 사용 가능한 공간보다 큽니다.</exception>
        <exception cref="T:System.InvalidCastException">소스 <see cref="T:System.Collections.ReadOnlyCollectionBase" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ReadOnlyCollectionBase.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 개체에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 개체에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ReadOnlyCollectionBase> 개체가 동기화 되지 않습니다. 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다 합니다 <xref:System.Collections.ReadOnlyCollectionBase> 를 사용 하 여 클래스를 <xref:System.Collections.ICollection.SyncRoot%2A> 속성입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.ICollection.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[System.Collections.ReadOnlyCollectionBase#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CPP/source2.cpp#2)]
 [!code-csharp[System.Collections.ReadOnlyCollectionBase#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CS/source2.cs#2)]
 [!code-vb[System.Collections.ReadOnlyCollectionBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/VB/source2.vb#2)]  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ReadOnlyCollectionBase.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 개체에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ReadOnlyCollectionBase" /> 개체에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다 합니다 <xref:System.Collections.ReadOnlyCollectionBase> 를 사용 하 여 클래스를 <xref:System.Collections.ICollection.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야 합니다 <xref:System.Collections.ICollection.SyncRoot%2A> 의 속성을 <xref:System.Collections.ReadOnlyCollectionBase> 개체에 직접를 <xref:System.Collections.ReadOnlyCollectionBase> 개체입니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.ReadOnlyCollectionBase> 개체입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.ICollection.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[System.Collections.ReadOnlyCollectionBase#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CPP/source2.cpp#2)]
 [!code-csharp[System.Collections.ReadOnlyCollectionBase#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/CS/source2.cs#2)]
 [!code-vb[System.Collections.ReadOnlyCollectionBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.ReadOnlyCollectionBase/VB/source2.vb#2)]  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
  </Members>
</Type>