<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="662ef7c5fa1e67929e659c9b3e4741d5b2100db0" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58700830" /></Metadata><TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>키를 기준으로 정렬되고 키와 인덱스로 액세스할 수 있는 키/값 쌍의 컬렉션을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

A <xref:System.Collections.SortedList> 요소가 있는 요소와 같은 키를 통해 액세스할 수 있습니다 <xref:System.Collections.IDictionary> 구현 또는 모든 요소와 같은 해당 인덱스로 <xref:System.Collections.IList> 구현 합니다.  

> [!IMPORTANT]
> 사용 하는 권장 하지 않습니다는 `SortedList` 새로운 개발에 대 한 클래스입니다. 제네릭 사용 하는 권장 대신 <xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType> 클래스입니다. 자세한 내용은 [제네릭이 아닌 컬렉션을 사용 하지 않아야](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) github입니다.

 <xref:System.Collections.SortedList> 목록, 즉 키에 대 한 하나의 배열 요소의 스토어로 두 배열 및 연관 된 값에 대 한 다른 배열 개체를 내부적으로 유지 관리 합니다. 각 요소는으로 액세스할 수 있는 키/값 쌍을 <xref:System.Collections.DictionaryEntry> 개체입니다. 키 일 수 없습니다 `null`에 있지만 값 수 있습니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소의 수는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 자동으로 증가 하면 재할당을 통해 필요에 따라 합니다. 호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.SortedList.TrimToSize%2A> 하거나 설정 하 여는 <xref:System.Collections.SortedList.Capacity%2A> 속성이 명시적으로 합니다.  
  
 **.NET framework에만 해당:** 에 대 한 매우 큰 <xref:System.Collections.SortedList> 개체를 설정 하 여 64 비트 시스템에서 2 십억 요소에 최대 용량을 늘릴 수 있습니다는 `enabled` 특성을 [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) 구성 요소를 `true` 에 런타임 환경입니다.  
  
 요소의 <xref:System.Collections.SortedList> 개체 키를 기준으로 정렬 됩니다 특정에 따라 하나 <xref:System.Collections.IComparer> 구현 될 때 지정 되는 <xref:System.Collections.SortedList> 생성 인지에 따라는 <xref:System.IComparable> 자체 키를 기준으로 제공 되는 구현 합니다. 두 경우 모두를 <xref:System.Collections.SortedList> 중복 키를 허용 하지 않습니다.  
  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList> 개체입니다.  
  
 에 대 한 작업을 <xref:System.Collections.SortedList> 개체에 대 한 작업 보다 느린 경향이 <xref:System.Collections.Hashtable> 정렬로 인해 개체입니다. 그러나는 <xref:System.Collections.SortedList> 연결 된 키 또는 인덱스를 통해 값에 대 한 액세스를 허용 하 여 더 많은 유연성을 제공 합니다.  
  
 이 컬렉션의 요소는 정수 인덱스를 사용 하 여 액세스할 수 있습니다.  이 컬렉션의 인덱스는 0부터 시작 합니다.  
  
 합니다 `foreach` C# 언어의 (`for each` Visual Basic에서) 컬렉션 요소의 형식의 개체를 반환 합니다. 각 요소의 이후를 <xref:System.Collections.SortedList> 개체는 키/값 쌍, 요소 형식이 키의 형식 또는 값의 형식입니다. 요소 형식은 아니라 <xref:System.Collections.DictionaryEntry>합니다. 예:  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 `foreach` 문을 열거자를 컬렉션에 쓰는 것부터 읽기만 허용 하는 래퍼입니다.  
  
   
  
## Examples  
 다음 코드 예제를 만들고 초기화 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체 및 해당 키와 값을 출력 하는 방법입니다.  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 정적 (<see langword="Shared" /> Visual Basic의)이 형식의 멤버는 스레드로부터 안전 합니다. 인터페이스 멤버는 스레드로부터 안전하지 않습니다.  
  
<see cref="T:System.Collections.SortedList" /> 개체 수 여러 판독기 동시에 지원할으로 컬렉션을 수정 되지 않습니다. 스레드로부터 안전을 보장 하려면 합니다 <see cref="T:System.Collections.SortedList" />에서 반환 되는 래퍼를 통해 모든 작업을 완료 해야 합니다 <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> 메서드.  
  
컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>비어 있는 상태이고 기본 초기 용량을 가지며 <see cref="T:System.Collections.SortedList" /> 개체에 추가된 각 키에서 구현하는 <see cref="T:System.IComparable" /> 인터페이스에 따라 정렬되는 <see cref="T:System.Collections.SortedList" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키를 구현 해야 합니다 <xref:System.IComparable> 인터페이스의 다른 모든 키와 비교할 수는 <xref:System.Collections.SortedList> 개체. 요소에 따라 정렬 되는 <xref:System.IComparable> 구현에 추가 된 각 키의는 <xref:System.Collections.SortedList>합니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소 수는는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 생성자는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 컬렉션을 다른 만듭니다 <xref:System.Collections.SortedList> 생성자 컬렉션 동작의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">키를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  
  
또는 
 각 키의 <see cref="T:System.IComparable" /> 구현을 사용하면 <see langword="null" />입니다.</param>
        <summary>비어 있고 기본 초기 용량을 갖고 있으며 지정된 <see cref="T:System.Collections.SortedList" /> 인터페이스에 따라 정렬되는 <see cref="T:System.Collections.IComparer" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소는 정렬에 따라 <xref:System.Collections.IComparer> 구현 합니다. 경우는 `comparer` 매개 변수는 `null`, <xref:System.IComparable> 각 키의 구현이 사용 됩니다; 그리고 따라서 각 키를 구현 해야 합니다는 <xref:System.IComparable> 인터페이스의 다른 모든 키와 비교할 수는 <xref:System.Collections.SortedList> 개체입니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소 수는는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 생성자는 o (1) 작업입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 컬렉션을 다른 만듭니다 <xref:System.Collections.SortedList> 생성자 컬렉션 동작의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.SortedList" /> 구현입니다.</param>
        <summary>지정된 사전에서 복사된 요소가 포함되어 있고 복사된 요소의 수와 같은 초기 용량을 갖고 있으며 각 키에서 구현된 <see cref="T:System.Collections.SortedList" /> 인터페이스에 따라 정렬되는 <see cref="T:System.IComparable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키를 구현 해야 합니다 <xref:System.IComparable> 인터페이스의 다른 모든 키와 비교할 수는 <xref:System.Collections.SortedList> 개체. 요소에 따라 정렬 되는 <xref:System.IComparable> 구현에 추가 된 각 키의는 <xref:System.Collections.SortedList>합니다.  
  
 A <xref:System.Collections.Hashtable> 개체의 한 예로 <xref:System.Collections.IDictionary> 이 생성자에 전달할 수 있는 구현 합니다. 새 <xref:System.Collections.SortedList> 키와 값에 저장 된 복사본을 포함 하는 개체는 <xref:System.Collections.Hashtable>합니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소 수는는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 생성자는 (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `d`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 컬렉션을 다른 만듭니다 <xref:System.Collections.SortedList> 생성자 컬렉션 동작의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="d" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity"><see cref="T:System.Collections.SortedList" /> 개체에 포함될 수 있는 초기 요소 수입니다.</param>
        <summary>비어 있는 상태이고 지정된 초기 용량을 가지며 <see cref="T:System.Collections.SortedList" /> 개체에 추가된 각 키에서 구현된 <see cref="T:System.IComparable" /> 인터페이스에 따라 정렬되는 <see cref="T:System.Collections.SortedList" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 키를 구현 해야 합니다 <xref:System.IComparable> 인터페이스의 다른 모든 키와 비교할 수는 <xref:System.Collections.SortedList> 개체. 요소에 따라 정렬 되는 <xref:System.IComparable> 구현에 추가 된 각 키의는 <xref:System.Collections.SortedList>합니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소 수는는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 생성자는 O (`n`) 작업, 여기서 `n` 는 `initialCapacity`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 컬렉션을 다른 만듭니다 <xref:System.Collections.SortedList> 생성자 컬렉션 동작의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCapacity" />가 0보다 작은 경우</exception>
        <exception cref="T:System.OutOfMemoryException">지정된 <paramref name="initialCapacity" />의 <see cref="T:System.Collections.SortedList" /> 개체를 만드는 데 사용할 수 있는 메모리가 충분하지 않은 경우</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">키를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  
  
또는 
 각 키의 <see cref="T:System.IComparable" /> 구현을 사용하면 <see langword="null" />입니다.</param>
        <param name="capacity"><see cref="T:System.Collections.SortedList" /> 개체에 포함될 수 있는 초기 요소 수입니다.</param>
        <summary>비어 있고 지정된 초기 용량을 갖고 있으며 지정된 <see cref="T:System.Collections.SortedList" /> 인터페이스에 따라 정렬되는 <see cref="T:System.Collections.IComparer" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소는 정렬에 따라 <xref:System.Collections.IComparer> 구현 합니다. 경우는 `comparer` 매개 변수는 `null`, <xref:System.IComparable> 각 키의 구현이 사용 됩니다; 그리고 따라서 각 키를 구현 해야 합니다는 <xref:System.IComparable> 인터페이스의 다른 모든 키와 비교할 수는 <xref:System.Collections.SortedList> 개체입니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소 수는는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 생성자는 O (`n`) 작업, 여기서 `n` 는 `capacity`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 컬렉션을 다른 만듭니다 <xref:System.Collections.SortedList> 생성자 컬렉션 동작의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />가 0보다 작은 경우</exception>
        <exception cref="T:System.OutOfMemoryException">지정된 <paramref name="capacity" />의 <see cref="T:System.Collections.SortedList" /> 개체를 만드는 데 사용할 수 있는 메모리가 충분하지 않은 경우</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">새 <see cref="T:System.Collections.IDictionary" /> 개체로 복사할 <see cref="T:System.Collections.SortedList" /> 구현입니다.</param>
        <param name="comparer">키를 비교할 때 사용하는 <see cref="T:System.Collections.IComparer" /> 구현입니다.  
  
또는 
 각 키의 <see cref="T:System.IComparable" /> 구현을 사용하면 <see langword="null" />입니다.</param>
        <summary>지정된 사전에서 복사된 요소가 포함되어 있고 복사된 요소의 수와 같은 초기 용량을 갖고 있으며 지정된 <see cref="T:System.Collections.SortedList" /> 인터페이스에 따라 정렬되는 <see cref="T:System.Collections.IComparer" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소는 정렬에 따라 <xref:System.Collections.IComparer> 구현 합니다. 경우는 `comparer` 매개 변수는 `null`, <xref:System.IComparable> 각 키의 구현이 사용 됩니다; 그리고 따라서 각 키를 구현 해야 합니다는 <xref:System.IComparable> 인터페이스의 다른 모든 키와 비교할 수는 <xref:System.Collections.SortedList> 개체입니다.  
  
 A <xref:System.Collections.Hashtable> 개체의 한 예로 <xref:System.Collections.IDictionary> 이 생성자에 전달할 수 있는 구현 합니다. 새 <xref:System.Collections.SortedList> 키와 값에 저장 된 복사본을 포함 하는 개체는 <xref:System.Collections.Hashtable>합니다.  
  
 용량을 <xref:System.Collections.SortedList> 개체가 요소 수는는 <xref:System.Collections.SortedList> 보유할 수 있습니다. 요소에 추가 되는 <xref:System.Collections.SortedList>, 용량을 증가 시켜 자동으로 내부 배열을 다시 할당 하 여 필요에 따라 합니다.  
  
 컬렉션의 크기를 예상할 수 있는 경우에 여러 요소를 추가 하는 동안 크기 조정 작업을 수행할 필요가 없습니다 초기 용량을 지정 합니다 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 생성자는 (`n`) 작업, 여기서 `n` 에 있는 요소의 수는 `d`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 컬렉션을 다른 만듭니다 <xref:System.Collections.SortedList> 생성자 컬렉션 동작의 차이점을 보여 줍니다.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="comparer" />가 <see langword="null" />이고 <paramref name="d" />의 요소 중 하나 이상이 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">추가할 요소의 키입니다.</param>
        <param name="value">추가할 요소의 값입니다. 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정한 키와 값을 가진 요소를 <see cref="T:System.Collections.SortedList" /> 개체에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 삽입 지점을 명시적으로 나 기본적으로 선택 된 비교자에 따라 결정 됩니다 때는 <xref:System.Collections.SortedList> 개체가 만들어진 합니다.  
  
 경우 <xref:System.Collections.SortedList.Count%2A> 가 이미 <xref:System.Collections.SortedList.Capacity%2A>의 용량을 <xref:System.Collections.SortedList> 개체 자동으로 내부 배열을 다시 할당 하 여 증가 하 고 새 요소가 추가 되기 전에 기존 요소를 새 배열에 복사 됩니다.  
  
 사용할 수도 있습니다는 <xref:System.Collections.SortedList.Item%2A> 는 키의 값을 설정 하 여 새 요소를 추가 하는 속성에 없는 경우는 <xref:System.Collections.SortedList> 개체 (예를 들어 `myCollection["myNonexistentKey"] = myValue`). 그러나 지정된 된 키가 이미 있는 경우는 <xref:System.Collections.SortedList>설정의 <xref:System.Collections.SortedList.Item%2A> 속성 이전 값을 덮어씁니다. 반면,는 <xref:System.Collections.SortedList.Add%2A> 메서드는 기존 요소를 수정 하지 않습니다.  
  
 요소의 <xref:System.Collections.SortedList> 개체 키를 기준으로 정렬 됩니다 특정에 따라 하나 <xref:System.Collections.IComparer> 구현 될 때 지정 되는 <xref:System.Collections.SortedList> 생성 인지에 따라는 <xref:System.IComparable> 자체 키를 기준으로 제공 되는 구현 합니다.  
  
 키 일 수 없습니다 `null`에 있지만 값 수 있습니다.  
  
 이 메서드는 O (`n`) 정렬 되지 않은 데이터에 대 한 작업 위치 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다. o (로그 `n`)는 새 요소가 목록 끝에 추가 되 면 작업 합니다. 삽입으로 크기가 조정 작업이 O (`n`).  
  
   
  
## Examples  
 다음 코드 예제에서는 요소를 추가 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">지정한 <paramref name="key" />를 가진 요소가 이미 <see cref="T:System.Collections.SortedList" /> 개체에 있는 경우  
  
또는 
<see cref="T:System.Collections.SortedList" />가 <see cref="T:System.IComparable" /> 인터페이스를 사용하도록 설정되었으나 <paramref name="key" />는 <see cref="T:System.IComparable" /> 인터페이스를 구현하지 않는 경우</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" />이 읽기 전용인 경우  
  
또는 
<see cref="T:System.Collections.SortedList" />가 고정 크기입니다.</exception>
        <exception cref="T:System.OutOfMemoryException"><see cref="T:System.Collections.SortedList" />에 요소를 추가할 수 있는 메모리가 충분하지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">비교자에서 예외를 throw하는 경우</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 용량을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Collections.SortedList" /> 개체에 포함될 수 있는 요소의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A> 요소의 수는 <xref:System.Collections.SortedList> 개체를 저장할 수 있습니다. <xref:System.Collections.SortedList.Count%2A> 에 실제로 있는 요소의 수는 <xref:System.Collections.SortedList>합니다.  
  
 <xref:System.Collections.SortedList.Capacity%2A> 항상 보다 크거나 같음 <xref:System.Collections.SortedList.Count%2A>합니다. 하는 경우 <xref:System.Collections.SortedList.Count%2A> 초과 <xref:System.Collections.SortedList.Capacity%2A> 요소를 추가 하는 동안 용량을 자동으로 증가 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 다시 할당 하 여 합니다.  
  
 호출 하 여 용량을 줄일 수 있습니다 <xref:System.Collections.SortedList.TrimToSize%2A> 하거나 설정 하 여는 <xref:System.Collections.SortedList.Capacity%2A> 속성이 명시적으로 합니다. 때 변수의 <xref:System.Collections.SortedList.Capacity%2A> 설정 된 명시적으로 지정된 된 용량에 맞게 내부 배열을 다시 할당 됩니다.  
  
 이 속성의 값을 검색 하는 것은 O(1) 작업; 속성을 설정 하는 O (`n`) 작업을 여기서 `n` 새 용량입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">할당된 값이 <see cref="T:System.Collections.SortedList" /> 개체의 현재 요소 수보다 작은 경우</exception>
        <exception cref="T:System.OutOfMemoryException">시스템에 사용 가능한 메모리가 부족합니다.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에서 요소를 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A> 0으로 설정 된 한 컬렉션의 요소에서 다른 개체에 대 한 참조도 해제 됩니다.  
  
 <xref:System.Collections.SortedList.Capacity%2A> 변경 되지 않습니다. 용량을 다시 설정 하는 <xref:System.Collections.SortedList> 개체를 호출 <xref:System.Collections.SortedList.TrimToSize%2A> 설정할지를 <xref:System.Collections.SortedList.Capacity%2A> 속성을 직접. 빈 트리밍 <xref:System.Collections.SortedList> 의 용량을 설정 합니다 <xref:System.Collections.SortedList> 기본 용량입니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하지 않는 부분을 트리밍하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 값의 선택을 취소 하는 방법과 개체는 <xref:System.Collections.SortedList>합니다.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> 개체가 읽기 전용인 경우  
  
또는 
<see cref="T:System.Collections.SortedList" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 단순 복사본을 만듭니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체의 단순 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션의 단순 복사본은 참조 형식 또는 값 형식 이지만 참조에서 참조 하는 개체를 복사 하지 않습니다 컬렉션의 요소를 복사 합니다. 새 컬렉션에 대 한 참조는 원본 컬렉션에 대 한 참조를 가리키는 동일한 개체를 가리킵니다.  
  
 반면, 컬렉션의 전체 복사본을 요소를 복사 하 고 뿐만 아니라 요소에 의해 직접 또는 간접적으로 참조 하는 모든 것.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Collections.SortedList" /> 개체에서 찾을 키입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 특정 키가 포함되어 있는지 여부를 확인합니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체에 지정된 <paramref name="key" />를 가진 요소가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소의 <xref:System.Collections.SortedList> 개체 키를 기준으로 정렬 됩니다 특정에 따라 하나 <xref:System.Collections.IComparer> 구현 될 때 지정 되는 <xref:System.Collections.SortedList> 생성 인지에 따라는 <xref:System.IComparable> 자체 키를 기준으로 제공 되는 구현 합니다.  
  
 <xref:System.Collections.SortedList.Contains%2A>는 <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>를 구현합니다. 와 동일 하 게 작동 <xref:System.Collections.SortedList.ContainsKey%2A>합니다.  
  
 이 메서드는 이진 검색 알고리즘을 사용 하 여 따라서이 메서드는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 하 고 <xref:System.IComparable.CompareTo%2A> 메서드를 `item` 항목이 있는지 여부를 확인 하려면. .NET Framework의 이전 버전을 사용 하 여이 결정 했습니다 합니다 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제를 확인 하는 방법을 보여 줍니다 여부는 <xref:System.Collections.SortedList> 특정 요소를 포함 하는 개체입니다.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">비교자에서 예외를 throw하는 경우</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Collections.SortedList" /> 개체에서 찾을 키입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 특정 키가 포함되어 있는지 여부를 확인합니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체에 지정된 <paramref name="key" />를 가진 요소가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소의 <xref:System.Collections.SortedList> 개체 키를 기준으로 정렬 됩니다 특정에 따라 하나 <xref:System.Collections.IComparer> 구현 될 때 지정 되는 <xref:System.Collections.SortedList> 생성 인지에 따라는 <xref:System.IComparable> 자체 키를 기준으로 제공 되는 구현 합니다.  
  
 이 메서드가 동일 하 게 동작 합니다 <xref:System.Collections.SortedList.Contains%2A> 메서드.  
  
 이 메서드는 이진 검색 알고리즘을 사용 하 여 따라서이 메서드는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 하 고 <xref:System.IComparable.CompareTo%2A> 메서드를 `item` 항목이 있는지 여부를 확인 하려면. .NET Framework의 이전 버전을 사용 하 여이 결정 했습니다 합니다 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제를 확인 하는 방법을 보여 줍니다 여부는 <xref:System.Collections.SortedList> 특정 요소를 포함 하는 개체입니다.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">비교자에서 예외를 throw하는 경우</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Collections.SortedList" /> 개체에서 찾을 값입니다. 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 특정 값이 포함되어 있는지 여부를 확인합니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체에 지정된 <paramref name="value" />를 가진 요소가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소의 값을 <xref:System.Collections.SortedList> 사용 하 여 지정 된 값 개체는 비교는 <xref:System.Object.Equals%2A> 메서드.  
  
 이 메서드는; 선형 검색을 수행합니다. 따라서 평균 실행 시간에 비례 <xref:System.Collections.SortedList.Count%2A>합니다. 즉,이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 하 고 <xref:System.IComparable.CompareTo%2A> 메서드를 `item` 항목이 있는지 여부를 확인 하려면. .NET Framework의 이전 버전을 사용 하 여이 결정 했습니다 합니다 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제를 확인 하는 방법을 보여 줍니다 여부는 <xref:System.Collections.SortedList> 특정 요소를 포함 하는 개체입니다.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" />에서 복사한 <see cref="T:System.Collections.DictionaryEntry" /> 개체의 대상인 1차원 <see cref="T:System.Collections.SortedList" /> 개체입니다. <see cref="T:System.Array" />에는 0부터 시작하는 인덱스가 있어야 합니다.</param>
        <param name="arrayIndex"><paramref name="array" />에서 복사가 시작되는 0부터 시작하는 인덱스입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 요소를 지정한 배열 인덱스에서 시작하여 1차원 <see cref="T:System.Array" /> 개체에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키/값 쌍을 복사할 합니다 <xref:System.Array> 열거자가 반복는 동일한 순서로 개체는 <xref:System.Collections.SortedList> 개체입니다.  
  
 에 있는 키를 복사 하는 <xref:System.Collections.SortedList>를 사용 하 여 `SortedList.Keys.CopyTo`입니다.  
  
 값만 복사 하는 <xref:System.Collections.SortedList>를 사용 하 여 `SortedList.Values.CopyTo`입니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 값을 복사 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체를 1 차원으로 <xref:System.Array> 개체입니다.  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />가 다차원 배열인 경우  
  
또는 
소스 <see cref="T:System.Collections.SortedList" /> 개체의 요소 수가 <paramref name="arrayIndex" />에서 대상 <paramref name="array" /> 끝까지 사용 가능한 공간보다 큰 경우</exception>
        <exception cref="T:System.InvalidCastException">소스 <see cref="T:System.Collections.SortedList" />의 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없습니다.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 포함된 요소 수를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.SortedList" /> 개체에 포함된 요소 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소는으로 액세스할 수 있는 키/값 쌍을 <xref:System.Collections.DictionaryEntry> 개체입니다.  
  
 <xref:System.Collections.SortedList.Capacity%2A> 요소의 수는 <xref:System.Collections.SortedList> 개체를 저장할 수 있습니다. <xref:System.Collections.SortedList.Count%2A> 에 실제로 있는 요소의 수는 <xref:System.Collections.SortedList>합니다.  
  
 <xref:System.Collections.SortedList.Capacity%2A> 항상 보다 크거나 같음 <xref:System.Collections.SortedList.Count%2A>합니다. 하는 경우 <xref:System.Collections.SortedList.Count%2A> 초과 <xref:System.Collections.SortedList.Capacity%2A> 요소를 추가 하는 동안 용량을 자동으로 증가 이전 요소를 복사 하 고 새 요소를 추가 하기 전에 내부 배열을 다시 할당 하 여 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져올 값의 0부터 시작하는 인덱스입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 지정한 인덱스에서 값을 가져옵니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체의 지정한 인덱스에 있는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 키 하나 또는 모두를 가져오는 방법을 보여 줍니다 또는 값을 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.SortedList" /> 개체의 유효한 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IDictionaryEnumerator" /> 개체를 반복하는 <see cref="T:System.Collections.SortedList" /> 개체를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> 개체의 <see cref="T:System.Collections.SortedList" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다.  이 위치에서 <xref:System.Collections.IEnumerator.Current%2A>는 정의되지 않습니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`, <xref:System.Collections.IEnumerator.Current%2A> 정의 되지 않습니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다.  열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다.  여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">가져올 키의 0부터 시작하는 인덱스입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 지정한 인덱스에서 키를 가져옵니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체의 지정한 인덱스 키입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 키 하나 또는 모두를 가져오는 방법을 보여 줍니다 또는 값을 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.SortedList" /> 개체의 유효한 인덱스 범위 밖에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 키를 가져옵니다.</summary>
        <returns><see cref="T:System.Collections.IList" /> 개체의 키가 포함된 <see cref="T:System.Collections.SortedList" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 <xref:System.Collections.IList> 개체는 읽기 전용 보기의 키를 <xref:System.Collections.SortedList> 개체입니다. 기본 수정한 <xref:System.Collections.SortedList> 에 바로 반영 됩니다는 <xref:System.Collections.IList>합니다.  
  
 반환된 된 요소의 <xref:System.Collections.IList> 의 키와 같은 순서로 정렬 되는 <xref:System.Collections.SortedList>합니다.  
  
 이 메서드는 비슷합니다는 <xref:System.Collections.SortedList.Keys%2A> 속성인 하지만 반환을 <xref:System.Collections.IList> 개체 대신는 <xref:System.Collections.ICollection> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 키 하나 또는 모두를 가져오는 방법을 보여 줍니다 또는 값을 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 값을 가져옵니다.</summary>
        <returns><see cref="T:System.Collections.IList" /> 개체의 값이 포함된 <see cref="T:System.Collections.SortedList" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 <xref:System.Collections.IList> 개체는 값의 읽기 전용 보기를 <xref:System.Collections.SortedList> 개체입니다. 기본 수정한 <xref:System.Collections.SortedList> 에 바로 반영 됩니다는 <xref:System.Collections.IList>합니다.  
  
 반환된 된 요소의 <xref:System.Collections.IList> 의 값과 같은 순서로 정렬 되는 <xref:System.Collections.SortedList>합니다.  
  
 이 메서드는 비슷합니다는 <xref:System.Collections.SortedList.Values%2A> 속성인 하지만 반환을 <xref:System.Collections.IList> 개체 대신는 <xref:System.Collections.ICollection> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 키 하나 또는 모두를 가져오는 방법을 보여 줍니다 또는 값을 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Collections.SortedList" /> 개체에서 찾을 키입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 지정된 키 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="key" />가 <see cref="T:System.Collections.SortedList" /> 개체에 있으면 <paramref name="key" /> 매개 변수의 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소를 <xref:System.Collections.SortedList> 개체 키를 기준으로 정렬 됩니다 특정에 따라 하나 <xref:System.Collections.IComparer> 구현 될 때 지정 되는 <xref:System.Collections.SortedList> 생성 인지에 따라를 <xref:System.IComparable> 자체 키를 기준으로 제공 되는 구현.  
  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList>합니다.  
  
 이 메서드는 이진 검색 알고리즘을 사용 하 여 따라서이 메서드는 O (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 하 고 <xref:System.IComparable.CompareTo%2A> 메서드를 `item` 항목이 있는지 여부를 확인 하려면. .NET Framework의 이전 버전을 사용 하 여이 결정 했습니다 합니다 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 키 또는 값의 인덱스를 확인 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">비교자에서 예외를 throw하는 경우</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Collections.SortedList" /> 개체에서 찾을 값입니다. 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary>지정한 값이 <see cref="T:System.Collections.SortedList" /> 개체에서 맨 처음 발견되는 인덱스(0부터 시작)를 반환합니다.</summary>
        <returns><paramref name="value" />가 <see cref="T:System.Collections.SortedList" /> 개체에 있으면 <paramref name="value" /> 매개 변수가 맨 처음 발견되는 인덱스(0부터 시작)이고, 그렇지 않으면 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList> 개체입니다.  
  
 요소의 값을 <xref:System.Collections.SortedList> 사용 하 여 지정 된 값과 비교할는 <xref:System.Object.Equals%2A> 메서드.  
  
 이 메서드는 한 선형 검색 따라서이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
 컬렉션의 개체를 사용 하 여이 메서드는.NET Framework 2.0 부터는 <xref:System.Object.Equals%2A> 하 고 <xref:System.IComparable.CompareTo%2A> 메서드를 `item` 항목이 있는지 여부를 확인 하려면. .NET Framework의 이전 버전을 사용 하 여이 결정 했습니다 합니다 <xref:System.Object.Equals%2A> 및 <xref:System.IComparable.CompareTo%2A> 의 메서드는 `item` 컬렉션의 개체에 대 한 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 키 또는 값의 인덱스를 확인 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 크기가 고정되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.SortedList" /> 개체의 크기가 고정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기가 고정된 된 컬렉션인 컬렉션 만들어지기는 하지만 기존 요소를 수정할 수는 후에 추가 하거나 제거할 요소의 수 없습니다.  
  
 크기가 고정된 된 컬렉션은 요소; 추가 및 제거를 방지 하는 래퍼를 지정 된 컬렉션 따라서 기본 컬렉션 추가 또는 제거 요소를 포함 하 여 변경 된 경우 고정 크기 컬렉션에 해당 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체가 읽기 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.SortedList" /> 개체가 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 컬렉션에서는 컬렉션을 만든 다음에 요소를 추가, 제거 또는 수정할 수 없습니다.  
  
 읽기 전용 컬렉션은 지정 된 컬렉션을 수정 하지 못하도록 하는 래퍼 컬렉션 따라서 기본 컬렉션이 변경 되 면 읽기 전용 컬렉션에 이러한 내용을 반영 합니다.  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.SortedList" /> 개체에 대한 액세스가 동기화되어 스레드로부터 안전하게 보호되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드로부터 안전을 보장 하려면를 <xref:System.Collections.SortedList> 개체를 반환 하는 래퍼를 통해 모든 작업을 완료 해야 합니다 <xref:System.Collections.SortedList.Synchronized%2A> 메서드.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.SortedList.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 다음 코드 예제에는 동기화 하는 방법을 보여 줍니다를 <xref:System.Collections.SortedList> 개체를 결정 합니다. 여부는 <xref:System.Collections.SortedList> 동기화 되 고 동기화를 사용 하 여 <xref:System.Collections.SortedList>합니다.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">가져오거나 설정할 값과 관련된 키입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 특정 키와 연관된 값을 가져오거나 설정합니다.</summary>
        <value><paramref name="key" />가 있으면 <see cref="T:System.Collections.SortedList" /> 개체의 <paramref name="key" /> 매개 변수와 연관된 값이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Collections.SortedList.Item%2A> 구문을 지정 하 여 컬렉션의 특정 요소에 액세스 하는 속성: `myCollection[key]`합니다.  
  
 존재 하지 않는 키 값을 설정 하 여 새 요소를 추가 하려면이 속성을 이용할 수 있습니다 합니다 <xref:System.Collections.SortedList> 개체 (예를 들어 `myCollection["myNonexistentKey"] = myValue)`합니다. 그러나 지정된 된 키가 이미 있는 경우는 <xref:System.Collections.SortedList>설정의 <xref:System.Collections.SortedList.Item%2A> 속성 이전 값을 덮어씁니다. 반면,는 <xref:System.Collections.SortedList.Add%2A> 메서드는 기존 요소를 수정 하지 않습니다.  
  
 키 일 수 없습니다 `null`에 있지만 값 수 있습니다. 구분 하기 위해 `null` 지정된 된 키를 찾을 수 없으므로 반환 되는 및 `null` 지정된 된 키의 값은 반환 되는 `null`를 사용 합니다 <xref:System.Collections.SortedList.Contains%2A> 메서드 또는 <xref:System.Collections.SortedList.ContainsKey%2A> 확인 하는 방법 키 목록에 있습니다.  
  
 요소의 <xref:System.Collections.SortedList> 키를 기준으로 정렬 됩니다 특정에 따라 하나 <xref:System.Collections.IComparer> 구현 될 때 지정 되는 <xref:System.Collections.SortedList> 생성 인지에 따라는 <xref:System.IComparable> 자체 키를 기준으로 제공 되는 구현 합니다.  
  
 C# 언어 사용 합니다 [ `this` ](~/docs/csharp/language-reference/keywords/this.md) 구현 하는 대신 인덱서를 정의 하는 키워드는 <xref:System.Collections.SortedList.Keys%2A> 속성입니다. Visual Basic에서는 동일한 인덱싱 기능을 제공하는 <xref:System.Collections.SortedList.Item%2A>을 기본 속성으로 구현합니다.  
  
 이 속성의 값을 검색 하는 (로그 `n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다. 속성을 설정 하는 O (로그 `n`) 키가 이미 있는 경우 작업은 <xref:System.Collections.SortedList>합니다. 키 목록에 없는 경우 속성을 설정 하는 O (`n`) 작업을 정렬 되지 않은 데이터 또는 O (로그 `n`) 새 요소가 목록 끝에 추가 하는 경우. 삽입으로 크기가 조정 작업이 O (`n`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">속성이 설정되어 있고 <see cref="T:System.Collections.SortedList" /> 개체가 읽기 전용인 경우  
  
또는 
속성이 설정되어 있고 <paramref name="key" />가 컬렉션에 없으며 <see cref="T:System.Collections.SortedList" />의 크기가 고정된 경우</exception>
        <exception cref="T:System.OutOfMemoryException"><see cref="T:System.Collections.SortedList" />에 요소를 추가할 수 있는 메모리가 충분하지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">비교자에서 예외를 throw하는 경우</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 키를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ICollection" /> 개체의 키가 포함된 <see cref="T:System.Collections.SortedList" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Collections.ICollection> 개체는 읽기 전용 보기의 키를 <xref:System.Collections.SortedList> 개체입니다. 기본 수정한 <xref:System.Collections.SortedList> 에 바로 반영 됩니다는 <xref:System.Collections.ICollection>합니다.  
  
 요소를 <xref:System.Collections.ICollection> 의 키와 같은 순서로 정렬 되는 <xref:System.Collections.SortedList>합니다.  
  
 이 속성은 비슷합니다는 <xref:System.Collections.SortedList.GetKeyList%2A> 메서드이지만 반환을 <xref:System.Collections.ICollection> 개체 대신는 <xref:System.Collections.IList> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">제거할 요소의 키입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에서 지정된 키를 가진 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList> 개체에 지정한 키를 가진 요소가 없으면 <xref:System.Collections.SortedList>가 변경되지 않은 상태로 유지됩니다. 예외가 throw되지 않습니다.  
  
 목록처럼 연속된 요소로 구성된 컬렉션에서는 제거된 요소 다음에 있는 요소를 위로 이동하여 빈 자리를 채웁니다. 컬렉션에 인덱스가 지정된 경우 이동되는 요소의 인덱스도 업데이트됩니다. 요소가 해시 테이블 같은 버킷으로 개념적으로 그룹화되어 있는 컬렉션에는 이러한 동작이 적용되지 않습니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 요소를 제거 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> 개체가 읽기 전용인 경우  
  
또는 
<see cref="T:System.Collections.SortedList" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">제거할 요소의 인덱스(0부터 시작)입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 지정한 인덱스에서 요소를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList> 개체입니다.  
  
 목록처럼 연속된 요소로 구성된 컬렉션에서는 제거된 요소 다음에 있는 요소를 위로 이동하여 빈 자리를 채웁니다. 컬렉션에 인덱스가 지정된 경우 이동되는 요소의 인덱스도 업데이트됩니다. 요소가 해시 테이블 같은 버킷으로 개념적으로 그룹화되어 있는 컬렉션에는 이러한 동작이 적용되지 않습니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 요소를 제거 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.SortedList" /> 개체의 유효한 인덱스 범위 밖에 있는 경우</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" />이 읽기 전용인 경우  
  
또는 
<see cref="T:System.Collections.SortedList" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><paramref name="value" />를 저장할 0부터 시작하는 인덱스입니다.</param>
        <param name="value"><see cref="T:System.Object" /> 개체에 저장할 <see cref="T:System.Collections.SortedList" />입니다. 값은 <see langword="null" />이 될 수 있습니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 지정한 인덱스에서 값을 바꿉니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인덱스 순서는 정렬 순서를 기반으로 합니다. 에 삽입 된 요소에 추가 되 면 <xref:System.Collections.SortedList> 올바른 정렬에서 순서, 인덱싱 및 그에 따라 조정 합니다. 요소가 제거 되 면 인덱싱도 그에 따라 조정 됩니다. 요소는 추가 하거나 제거 하는 특정 키/값 쌍의 인덱스 변경 될 수 있습니다 따라서는 <xref:System.Collections.SortedList> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 기존 요소의 값을 교체 하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체입니다.  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 <see cref="T:System.Collections.SortedList" /> 개체의 유효한 인덱스 범위 밖에 있는 경우</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">동기화할 <see cref="T:System.Collections.SortedList" /> 개체입니다.</param>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 대해 동기화되어 스레드로부터 안전하게 보호되는 래퍼를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.SortedList" /> 개체에 대해 동기화되어 스레드로부터 안전하게 보호되는 래퍼입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드로부터 안전을 보장 하려면를 <xref:System.Collections.SortedList> 개체에이 래퍼를 통해 모든 작업을 완료 해야 합니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.SortedList.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 다음 코드 예제에는 동기화 하는 방법을 보여 줍니다를 <xref:System.Collections.SortedList> 개체를 결정 합니다. 여부는 <xref:System.Collections.SortedList> 동기화 되 고 동기화를 사용 하 여 <xref:System.Collections.SortedList>합니다.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" />가 <see langword="null" />입니다.</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Collections.SortedList" /> 개체에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동기화 된 버전을 만들려면 합니다 <xref:System.Collections.SortedList> 개체는 <xref:System.Collections.SortedList.Synchronized%2A> 메서드. 하지만 파생된 클래스의 동기화 된 버전을 제공할 수 있습니다 합니다 <xref:System.Collections.SortedList> 를 사용 하 여는 <xref:System.Collections.SortedList.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야 합니다 <xref:System.Collections.SortedList.SyncRoot%2A> 의 합니다 <xref:System.Collections.SortedList>에서 직접는 <xref:System.Collections.SortedList>합니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히, 동시에 수정할 수 있는 다른 스레드와 적절 한 동기화를 유지 관리는 <xref:System.Collections.SortedList> 개체입니다.  
  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 컬렉션을 잠그는 방법을 보여 줍니다는 <xref:System.Collections.SortedList.SyncRoot%2A> 열거 하는 동안 속성입니다.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 이 속성 값을 검색하는 것은 O(1) 연산입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IEnumerator" />를 반복하는 <see cref="T:System.Collections.SortedList" />를 반환합니다.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" />에 대한 <see cref="T:System.Collections.SortedList" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic의 경우 C#]  
  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다.  그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A>을 실행하면 열거자가 이 위치로 복원됩니다. 이 위치에서, 호출 <xref:System.Collections.IEnumerator.Current%2A> 예외를 throw 합니다. 따라서 <xref:System.Collections.IEnumerator.MoveNext%2A>의 값을 읽기 전에 <xref:System.Collections.IEnumerator.Current%2A>를 호출하여 열거자를 해당 컬렉션의 첫 번째 요소로 보내야 합니다.  
  
 <xref:System.Collections.IEnumerator.Current%2A>에서는 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A>이 호출될 때까지 동일한 개체를 반환합니다. <xref:System.Collections.IEnumerator.MoveNext%2A>는 <xref:System.Collections.IEnumerator.Current%2A>를 다음 요소로 설정합니다.  
  
 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 열거자를 컬렉션의 끝 컬렉션의 마지막 요소 뒤에 배치 되는 전달 하 고 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`합니다. 열거자가 있는 경우이 위치에 대 한 후속 호출은 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환할 수도 `false`합니다. 마지막으로 호출 하는 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 반환 `false`호출, <xref:System.Collections.IEnumerator.Current%2A> 예외를 throw 합니다. <xref:System.Collections.IEnumerator.Current%2A>를 컬렉션의 첫째 요소에 다시 설정하려면 <xref:System.Collections.IEnumerator.Reset%2A>을 호출한 뒤 <xref:System.Collections.IEnumerator.MoveNext%2A>를 호출해야 합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 변경에 추가 하는 등 컬렉션을 수정 하거나 요소를 삭제, 열거자가 복구할 유효 하지 않으며을 다음에 호출할 <xref:System.Collections.IEnumerator.MoveNext%2A> 또는 <xref:System.Collections.IEnumerator.Reset%2A> throw는 <xref:System.InvalidOperationException>합니다. 컬렉션 사이 수정 된 경우 <xref:System.Collections.IEnumerator.MoveNext%2A> 하 고 <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> 열거자가 이미 무효화 된 경우에로 설정 되어 있는 요소를 반환 합니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>용량을 <see cref="T:System.Collections.SortedList" /> 개체의 실제 요소 수로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 새 요소가 컬렉션에 추가 될 경우 컬렉션의 메모리 오버 헤드를 최소화할 데 사용할 수 있습니다.  
  
 다시 설정 하는 <xref:System.Collections.SortedList> 개체를 초기 상태로 호출 합니다 <xref:System.Collections.SortedList.Clear%2A> 메서드를 호출 하기 전에 <xref:System.Collections.SortedList.TrimToSize%2A>입니다. 빈 트리밍 <xref:System.Collections.SortedList> 의 용량을 설정 합니다 <xref:System.Collections.SortedList> 기본 용량입니다.  
  
 이 메서드는 O (`n`) 작업, 여기서 `n` 는 <xref:System.Collections.SortedList.Count%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하지 않는 부분을 트리밍하는 방법을 보여 줍니다는 <xref:System.Collections.SortedList> 개체 및 해당 값의 선택을 취소 하는 방법입니다.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> 개체가 읽기 전용인 경우  
  
또는 
<see cref="T:System.Collections.SortedList" />가 고정 크기입니다.</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.SortedList" /> 개체의 값을 가져옵니다.</summary>
        <value><see cref="T:System.Collections.ICollection" /> 개체의 값이 포함된 <see cref="T:System.Collections.SortedList" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection> 개체는 값의 읽기 전용 보기를 <xref:System.Collections.SortedList> 개체입니다. 기본 수정한 <xref:System.Collections.SortedList> 에 바로 반영 됩니다는 <xref:System.Collections.ICollection>합니다.  
  
 요소를 <xref:System.Collections.ICollection> 값과 같은 순서로 정렬 되는 <xref:System.Collections.SortedList>.  
  
 이 속성은 비슷합니다는 <xref:System.Collections.SortedList.GetValueList%2A> 메서드이지만 반환을 <xref:System.Collections.ICollection> 개체 대신는 <xref:System.Collections.IList> 개체입니다.  
  
 이 방법은 O(1) 작업에 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">컬렉션에서 Culture를 구분하지 않는 문자열 작업 수행</related>
      </Docs>
    </Member>
  </Members>
</Type>