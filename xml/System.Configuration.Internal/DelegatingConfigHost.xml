<Type Name="DelegatingConfigHost" FullName="System.Configuration.Internal.DelegatingConfigHost">
  <Metadata><Meta Name="ms.openlocfilehash" Value="064b9f7c87c7ae5dd00789ab7ccd0ef292c07f15" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57910877" /></Metadata><TypeSignature Language="C#" Value="public class DelegatingConfigHost : System.Configuration.Internal.IInternalConfigHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DelegatingConfigHost extends System.Object implements class System.Configuration.Internal.IInternalConfigHost" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.Internal.DelegatingConfigHost" />
  <TypeSignature Language="VB.NET" Value="Public Class DelegatingConfigHost&#xA;Implements IInternalConfigHost" />
  <TypeSignature Language="C++ CLI" Value="public ref class DelegatingConfigHost : System::Configuration::Internal::IInternalConfigHost" />
  <TypeSignature Language="F#" Value="type DelegatingConfigHost = class&#xA;    interface IInternalConfigHost" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Configuration.Internal.IInternalConfigHost</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><see cref="T:System.Configuration.Internal.IInternalConfigHost" /> 인터페이스의 모든 멤버를 호스트의 다른 인스턴스에 위임합니다.</summary>
    <remarks>To be added.</remarks>
    <forInternalUseOnly />
    <altmember cref="T:System.Configuration.Internal.IInternalConfigHost" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DelegatingConfigHost ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DelegatingConfigHost();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Configuration.Internal.DelegatingConfigHost" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ConfigBuilderHost">
      <MemberSignature Language="C#" Value="protected System.Configuration.Internal.IInternalConfigurationBuilderHost ConfigBuilderHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.Internal.IInternalConfigurationBuilderHost ConfigBuilderHost" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.ConfigBuilderHost" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ConfigBuilderHost As IInternalConfigurationBuilderHost" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Configuration::Internal::IInternalConfigurationBuilderHost ^ ConfigBuilderHost { System::Configuration::Internal::IInternalConfigurationBuilderHost ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConfigBuilderHost : System.Configuration.Internal.IInternalConfigurationBuilderHost" Usage="System.Configuration.Internal.DelegatingConfigHost.ConfigBuilderHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Internal.IInternalConfigurationBuilderHost</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>위임된 호스트에서 해당 인터페이스에서 필요한 기능을 제공하는 경우 <see cref="T:System.Configuration.Internal.IInternalConfigurationBuilderHost" /> 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Configuration.Internal.IInternalConfigurationBuilderHost" /> 개체</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateConfigurationContext">
      <MemberSignature Language="C#" Value="public virtual object CreateConfigurationContext (string configPath, string locationSubPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateConfigurationContext(string configPath, string locationSubPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.CreateConfigurationContext(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateConfigurationContext (configPath As String, locationSubPath As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateConfigurationContext(System::String ^ configPath, System::String ^ locationSubPath);" />
      <MemberSignature Language="F#" Value="abstract member CreateConfigurationContext : string * string -&gt; obj&#xA;override this.CreateConfigurationContext : string * string -&gt; obj" Usage="delegatingConfigHost.CreateConfigurationContext (configPath, locationSubPath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.CreateConfigurationContext(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
        <Parameter Name="locationSubPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <param name="locationSubPath">위치 하위 경로를 나타내는 문자열입니다.</param>
        <summary>새 구성 컨텍스트를 만듭니다.</summary>
        <returns>새 구성 컨텍스트를 나타내는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="CreateDeprecatedConfigContext">
      <MemberSignature Language="C#" Value="public virtual object CreateDeprecatedConfigContext (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateDeprecatedConfigContext(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.CreateDeprecatedConfigContext(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDeprecatedConfigContext (configPath As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateDeprecatedConfigContext(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member CreateDeprecatedConfigContext : string -&gt; obj&#xA;override this.CreateDeprecatedConfigContext : string -&gt; obj" Usage="delegatingConfigHost.CreateDeprecatedConfigContext configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.CreateDeprecatedConfigContext(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>사용되지 않는 구성 컨텍스트를 만듭니다.</summary>
        <returns>사용되지 않는 구성 컨텍스트를 나타내는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="DecryptSection">
      <MemberSignature Language="C#" Value="public virtual string DecryptSection (string encryptedXml, System.Configuration.ProtectedConfigurationProvider protectionProvider, System.Configuration.ProtectedConfigurationSection protectedConfigSection);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string DecryptSection(string encryptedXml, class System.Configuration.ProtectedConfigurationProvider protectionProvider, class System.Configuration.ProtectedConfigurationSection protectedConfigSection) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DecryptSection (encryptedXml As String, protectionProvider As ProtectedConfigurationProvider, protectedConfigSection As ProtectedConfigurationSection) As String" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ DecryptSection(System::String ^ encryptedXml, System::Configuration::ProtectedConfigurationProvider ^ protectionProvider, System::Configuration::ProtectedConfigurationSection ^ protectedConfigSection);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual string DecryptSection (string encryptedXml, System.Configuration.ProtectedConfigurationProvider protectionProvider, System.Configuration.ProtectedConfigurationSection protectedSection);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string DecryptSection(string encryptedXml, class System.Configuration.ProtectedConfigurationProvider protectionProvider, class System.Configuration.ProtectedConfigurationSection protectedSection) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DecryptSection (encryptedXml As String, protectionProvider As ProtectedConfigurationProvider, protectedSection As ProtectedConfigurationSection) As String" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ DecryptSection(System::String ^ encryptedXml, System::Configuration::ProtectedConfigurationProvider ^ protectionProvider, System::Configuration::ProtectedConfigurationSection ^ protectedSection);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.DecryptSection(System.String,System.Configuration.ProtectedConfigurationProvider,System.Configuration.ProtectedConfigurationSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DecryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string&#xA;override this.DecryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string" Usage="delegatingConfigHost.DecryptSection (encryptedXml, protectionProvider, protectedSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.DecryptSection(System.String,System.Configuration.ProtectedConfigurationProvider,System.Configuration.ProtectedConfigurationSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DecryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string&#xA;override this.DecryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string" Usage="delegatingConfigHost.DecryptSection (encryptedXml, protectionProvider, protectedSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.DecryptSection(System.String,System.Configuration.ProtectedConfigurationProvider,System.Configuration.ProtectedConfigurationSection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encryptedXml" Type="System.String" Index="0" />
        <Parameter Name="protectionProvider" Type="System.Configuration.ProtectedConfigurationProvider" Index="1" />
        <Parameter Name="protectedConfigSection" Type="System.Configuration.ProtectedConfigurationSection" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="protectedSection" Type="System.Configuration.ProtectedConfigurationSection" Index="2" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="encryptedXml">구성 파일의 암호화된 섹션입니다.</param>
        <param name="protectionProvider"><see cref="T:System.Configuration.ProtectedConfigurationProvider" /> 개체입니다.</param>
        <param name="protectedConfigSection"><see cref="T:System.Configuration.ProtectedConfigurationSection" /> 개체입니다.</param>
        <param name="protectedSection">To be added.</param>
        <summary>암호화된 구성 섹션을 해독합니다.</summary>
        <returns>해독된 구성 섹션을 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="DeleteStream">
      <MemberSignature Language="C#" Value="public virtual void DeleteStream (string streamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteStream(string streamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.DeleteStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DeleteStream (streamName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteStream(System::String ^ streamName);" />
      <MemberSignature Language="F#" Value="abstract member DeleteStream : string -&gt; unit&#xA;override this.DeleteStream : string -&gt; unit" Usage="delegatingConfigHost.DeleteStream streamName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.DeleteStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <summary>구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체를 삭제합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="EncryptSection">
      <MemberSignature Language="C#" Value="public virtual string EncryptSection (string clearTextXml, System.Configuration.ProtectedConfigurationProvider protectionProvider, System.Configuration.ProtectedConfigurationSection protectedConfigSection);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string EncryptSection(string clearTextXml, class System.Configuration.ProtectedConfigurationProvider protectionProvider, class System.Configuration.ProtectedConfigurationSection protectedConfigSection) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EncryptSection (clearTextXml As String, protectionProvider As ProtectedConfigurationProvider, protectedConfigSection As ProtectedConfigurationSection) As String" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ EncryptSection(System::String ^ clearTextXml, System::Configuration::ProtectedConfigurationProvider ^ protectionProvider, System::Configuration::ProtectedConfigurationSection ^ protectedConfigSection);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual string EncryptSection (string encryptedXml, System.Configuration.ProtectedConfigurationProvider protectionProvider, System.Configuration.ProtectedConfigurationSection protectedSection);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string EncryptSection(string encryptedXml, class System.Configuration.ProtectedConfigurationProvider protectionProvider, class System.Configuration.ProtectedConfigurationSection protectedSection) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EncryptSection (encryptedXml As String, protectionProvider As ProtectedConfigurationProvider, protectedSection As ProtectedConfigurationSection) As String" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ EncryptSection(System::String ^ encryptedXml, System::Configuration::ProtectedConfigurationProvider ^ protectionProvider, System::Configuration::ProtectedConfigurationSection ^ protectedSection);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.EncryptSection(System.String,System.Configuration.ProtectedConfigurationProvider,System.Configuration.ProtectedConfigurationSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EncryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string&#xA;override this.EncryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string" Usage="delegatingConfigHost.EncryptSection (encryptedXml, protectionProvider, protectedSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.EncryptSection(System.String,System.Configuration.ProtectedConfigurationProvider,System.Configuration.ProtectedConfigurationSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EncryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string&#xA;override this.EncryptSection : string * System.Configuration.ProtectedConfigurationProvider * System.Configuration.ProtectedConfigurationSection -&gt; string" Usage="delegatingConfigHost.EncryptSection (encryptedXml, protectionProvider, protectedSection)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.EncryptSection(System.String,System.Configuration.ProtectedConfigurationProvider,System.Configuration.ProtectedConfigurationSection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clearTextXml" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="encryptedXml" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="protectionProvider" Type="System.Configuration.ProtectedConfigurationProvider" Index="1" />
        <Parameter Name="protectedConfigSection" Type="System.Configuration.ProtectedConfigurationSection" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="protectedSection" Type="System.Configuration.ProtectedConfigurationSection" Index="2" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="clearTextXml">암호화되지 않은 구성 섹션입니다.</param>
        <param name="encryptedXml">To be added.</param>
        <param name="protectionProvider"><see cref="T:System.Configuration.ProtectedConfigurationProvider" /> 개체입니다.</param>
        <param name="protectedConfigSection"><see cref="T:System.Configuration.ProtectedConfigurationSection" /> 개체입니다.</param>
        <param name="protectedSection">To be added.</param>
        <summary>구성 개체의 섹션을 암호화합니다.</summary>
        <returns>구성 개체의 암호화된 섹션을 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetConfigPathFromLocationSubPath">
      <MemberSignature Language="C#" Value="public virtual string GetConfigPathFromLocationSubPath (string configPath, string locationSubPath);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetConfigPathFromLocationSubPath(string configPath, string locationSubPath) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigPathFromLocationSubPath (configPath As String, locationSubPath As String) As String" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetConfigPathFromLocationSubPath(System::String ^ configPath, System::String ^ locationSubPath);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual string GetConfigPathFromLocationSubPath (string configPath, string locatinSubPath);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetConfigPathFromLocationSubPath(string configPath, string locatinSubPath) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigPathFromLocationSubPath (configPath As String, locatinSubPath As String) As String" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetConfigPathFromLocationSubPath(System::String ^ configPath, System::String ^ locatinSubPath);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetConfigPathFromLocationSubPath(System.String,System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConfigPathFromLocationSubPath : string * string -&gt; string&#xA;override this.GetConfigPathFromLocationSubPath : string * string -&gt; string" Usage="delegatingConfigHost.GetConfigPathFromLocationSubPath (configPath, locatinSubPath)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetConfigPathFromLocationSubPath(System.String,System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConfigPathFromLocationSubPath : string * string -&gt; string&#xA;override this.GetConfigPathFromLocationSubPath : string * string -&gt; string" Usage="delegatingConfigHost.GetConfigPathFromLocationSubPath (configPath, locatinSubPath)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetConfigPathFromLocationSubPath(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" Index="0" />
        <Parameter Name="locationSubPath" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="locatinSubPath" Type="System.String" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <param name="locationSubPath">위치 하위 경로를 나타내는 문자열입니다.</param>
        <param name="locatinSubPath">To be added.</param>
        <summary>위치 하위 경로를 기반으로 구성 경로를 반환합니다.</summary>
        <returns>구성 경로를 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetConfigType">
      <MemberSignature Language="C#" Value="public virtual Type GetConfigType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetConfigType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetConfigType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetConfigType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="abstract member GetConfigType : string * bool -&gt; Type&#xA;override this.GetConfigType : string * bool -&gt; Type" Usage="delegatingConfigHost.GetConfigType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetConfigType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">구성 형식을 나타내는 문자열입니다.</param>
        <param name="throwOnError">오류가 발생하는 경우 예외가 throw되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>구성의 형식을 나타내는 <see cref="T:System.Type" />을 반환합니다.</summary>
        <returns>구성의 형식을 나타내는 <see cref="T:System.Type" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetConfigTypeName">
      <MemberSignature Language="C#" Value="public virtual string GetConfigTypeName (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetConfigTypeName(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetConfigTypeName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConfigTypeName (t As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetConfigTypeName(Type ^ t);" />
      <MemberSignature Language="F#" Value="abstract member GetConfigTypeName : Type -&gt; string&#xA;override this.GetConfigTypeName : Type -&gt; string" Usage="delegatingConfigHost.GetConfigTypeName t" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetConfigTypeName(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t"><see cref="T:System.Type" /> 개체입니다.</param>
        <summary>구성 개체의 형식 이름을 나타내는 문자열을 반환합니다.</summary>
        <returns>구성 개체의 형식 이름을 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetRestrictedPermissions">
      <MemberSignature Language="C#" Value="public virtual void GetRestrictedPermissions (System.Configuration.Internal.IInternalConfigRecord configRecord, out System.Security.PermissionSet permissionSet, out bool isHostReady);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetRestrictedPermissions(class System.Configuration.Internal.IInternalConfigRecord configRecord, [out] class System.Security.PermissionSet&amp; permissionSet, [out] bool&amp; isHostReady) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetRestrictedPermissions(System.Configuration.Internal.IInternalConfigRecord,System.Security.PermissionSet@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetRestrictedPermissions (configRecord As IInternalConfigRecord, ByRef permissionSet As PermissionSet, ByRef isHostReady As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetRestrictedPermissions(System::Configuration::Internal::IInternalConfigRecord ^ configRecord, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % permissionSet, [Runtime::InteropServices::Out] bool % isHostReady);" />
      <MemberSignature Language="F#" Value="abstract member GetRestrictedPermissions : System.Configuration.Internal.IInternalConfigRecord *  *  -&gt; unit&#xA;override this.GetRestrictedPermissions : System.Configuration.Internal.IInternalConfigRecord *  *  -&gt; unit" Usage="delegatingConfigHost.GetRestrictedPermissions (configRecord, permissionSet, isHostReady)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetRestrictedPermissions(System.Configuration.Internal.IInternalConfigRecord,System.Security.PermissionSet@,System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configRecord" Type="System.Configuration.Internal.IInternalConfigRecord" />
        <Parameter Name="permissionSet" Type="System.Security.PermissionSet" RefType="out" />
        <Parameter Name="isHostReady" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="configRecord"><see cref="T:System.Configuration.Internal.IInternalConfigRecord" /> 개체</param>
        <param name="permissionSet"><see cref="T:System.Security.PermissionSet" /> 개체입니다.</param>
        <param name="isHostReady">호스트에서 초기화를 마쳤으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>호스트 개체에서 사용할 수 있는 경우 지정된 권한 집합을 설정합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetStreamName">
      <MemberSignature Language="C#" Value="public virtual string GetStreamName (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetStreamName(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetStreamName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStreamName (configPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetStreamName(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamName : string -&gt; string&#xA;override this.GetStreamName : string -&gt; string" Usage="delegatingConfigHost.GetStreamName configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetStreamName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름을 반환합니다.</summary>
        <returns>구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름을 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetStreamNameForConfigSource">
      <MemberSignature Language="C#" Value="public virtual string GetStreamNameForConfigSource (string streamName, string configSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetStreamNameForConfigSource(string streamName, string configSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetStreamNameForConfigSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStreamNameForConfigSource (streamName As String, configSource As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetStreamNameForConfigSource(System::String ^ streamName, System::String ^ configSource);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamNameForConfigSource : string * string -&gt; string&#xA;override this.GetStreamNameForConfigSource : string * string -&gt; string" Usage="delegatingConfigHost.GetStreamNameForConfigSource (streamName, configSource)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetStreamNameForConfigSource(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="configSource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="configSource">구성 소스를 나타내는 문자열입니다.</param>
        <summary>구성 소스에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름을 반환합니다.</summary>
        <returns>구성 소스에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름을 나타내는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="GetStreamVersion">
      <MemberSignature Language="C#" Value="public virtual object GetStreamVersion (string streamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetStreamVersion(string streamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.GetStreamVersion(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetStreamVersion (streamName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetStreamVersion(System::String ^ streamName);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamVersion : string -&gt; obj&#xA;override this.GetStreamVersion : string -&gt; obj" Usage="delegatingConfigHost.GetStreamVersion streamName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.GetStreamVersion(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <summary>구성 파일에서 I/O 작업을 수행하는 <see cref="P:System.Diagnostics.FileVersionInfo.FileVersion" /> 개체의 버전을 나타내는 <see cref="T:System.IO.Stream" /> 개체를 반환합니다.</summary>
        <returns>구성 파일에서 I/O 작업을 수행하는 <see cref="P:System.Diagnostics.FileVersionInfo.FileVersion" /> 개체의 버전을 나타내는 <see cref="T:System.IO.Stream" /> 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="HasLocalConfig">
      <MemberSignature Language="C#" Value="public virtual bool HasLocalConfig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasLocalConfig" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.HasLocalConfig" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasLocalConfig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasLocalConfig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasLocalConfig : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.HasLocalConfig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHostPaths.HasLocalConfig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasRoamingConfig">
      <MemberSignature Language="C#" Value="public virtual bool HasRoamingConfig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRoamingConfig" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.HasRoamingConfig" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasRoamingConfig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRoamingConfig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRoamingConfig : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.HasRoamingConfig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHostPaths.HasRoamingConfig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="protected System.Configuration.Internal.IInternalConfigHost Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.Internal.IInternalConfigHost Host" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.Host" />
      <MemberSignature Language="VB.NET" Value="Protected Property Host As IInternalConfigHost" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Configuration::Internal::IInternalConfigHost ^ Host { System::Configuration::Internal::IInternalConfigHost ^ get(); void set(System::Configuration::Internal::IInternalConfigHost ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : System.Configuration.Internal.IInternalConfigHost with get, set" Usage="System.Configuration.Internal.DelegatingConfigHost.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Internal.IInternalConfigHost</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Configuration.Internal.IInternalConfigHost" /> 개체를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Configuration.Internal.IInternalConfigHost" /> 개체입니다.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Impersonate">
      <MemberSignature Language="C#" Value="public virtual IDisposable Impersonate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable Impersonate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.Impersonate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Impersonate () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ Impersonate();" />
      <MemberSignature Language="F#" Value="abstract member Impersonate : unit -&gt; IDisposable&#xA;override this.Impersonate : unit -&gt; IDisposable" Usage="delegatingConfigHost.Impersonate " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.Impersonate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가장하도록 호스트에 지시하고 .NET Framework에서 내부적으로 필요한 <see cref="T:System.IDisposable" /> 개체를 반환합니다.</summary>
        <returns><see cref="T:System.IDisposable" /> 값입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public virtual void Init (System.Configuration.Internal.IInternalConfigRoot configRoot, params object[] hostInitParams);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Init(class System.Configuration.Internal.IInternalConfigRoot configRoot, object[] hostInitParams) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Init (configRoot As IInternalConfigRoot, ParamArray hostInitParams As Object())" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Init(System::Configuration::Internal::IInternalConfigRoot ^ configRoot, ... cli::array &lt;System::Object ^&gt; ^ hostInitParams);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual void Init (System.Configuration.Internal.IInternalConfigRoot root, params object[] hostInitParams);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Init(class System.Configuration.Internal.IInternalConfigRoot root, object[] hostInitParams) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Init (root As IInternalConfigRoot, ParamArray hostInitParams As Object())" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Init(System::Configuration::Internal::IInternalConfigRoot ^ root, ... cli::array &lt;System::Object ^&gt; ^ hostInitParams);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.Init(System.Configuration.Internal.IInternalConfigRoot,System.Object[])" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Init : System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit&#xA;override this.Init : System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit" Usage="delegatingConfigHost.Init (root, hostInitParams)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.Init(System.Configuration.Internal.IInternalConfigRoot,System.Object[])" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Init : System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit&#xA;override this.Init : System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit" Usage="delegatingConfigHost.Init (root, hostInitParams)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.Init(System.Configuration.Internal.IInternalConfigRoot,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configRoot" Type="System.Configuration.Internal.IInternalConfigRoot" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="root" Type="System.Configuration.Internal.IInternalConfigRoot" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="hostInitParams" Type="System.Object[]" Index="1">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="configRoot"><see cref="T:System.Configuration.Internal.IInternalConfigRoot" /> 개체</param>
        <param name="root">To be added.</param>
        <param name="hostInitParams">구성 호스트 초기화에 사용되는 값을 포함하는 매개 변수 개체입니다.</param>
        <summary>구성 호스트를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="InitForConfiguration">
      <MemberSignature Language="C#" Value="public virtual void InitForConfiguration (ref string locationSubPath, out string configPath, out string locationConfigPath, System.Configuration.Internal.IInternalConfigRoot configRoot, params object[] hostInitConfigurationParams);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InitForConfiguration(string&amp; locationSubPath, [out] string&amp; configPath, [out] string&amp; locationConfigPath, class System.Configuration.Internal.IInternalConfigRoot configRoot, object[] hostInitConfigurationParams) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InitForConfiguration (ByRef locationSubPath As String, ByRef configPath As String, ByRef locationConfigPath As String, configRoot As IInternalConfigRoot, ParamArray hostInitConfigurationParams As Object())" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InitForConfiguration(System::String ^ % locationSubPath, [Runtime::InteropServices::Out] System::String ^ % configPath, [Runtime::InteropServices::Out] System::String ^ % locationConfigPath, System::Configuration::Internal::IInternalConfigRoot ^ configRoot, ... cli::array &lt;System::Object ^&gt; ^ hostInitConfigurationParams);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual void InitForConfiguration (ref string locationSubPath, out string configPath, out string locationConfigPath, System.Configuration.Internal.IInternalConfigRoot root, params object[] hostInitConfigurationParams);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InitForConfiguration(string&amp; locationSubPath, [out] string&amp; configPath, [out] string&amp; locationConfigPath, class System.Configuration.Internal.IInternalConfigRoot root, object[] hostInitConfigurationParams) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub InitForConfiguration (ByRef locationSubPath As String, ByRef configPath As String, ByRef locationConfigPath As String, root As IInternalConfigRoot, ParamArray hostInitConfigurationParams As Object())" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void InitForConfiguration(System::String ^ % locationSubPath, [Runtime::InteropServices::Out] System::String ^ % configPath, [Runtime::InteropServices::Out] System::String ^ % locationConfigPath, System::Configuration::Internal::IInternalConfigRoot ^ root, ... cli::array &lt;System::Object ^&gt; ^ hostInitConfigurationParams);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.InitForConfiguration(System.String@,System.String@,System.String@,System.Configuration.Internal.IInternalConfigRoot,System.Object[])" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InitForConfiguration :  *  *  * System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit&#xA;override this.InitForConfiguration :  *  *  * System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit" Usage="delegatingConfigHost.InitForConfiguration (locationSubPath, configPath, locationConfigPath, root, hostInitConfigurationParams)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.InitForConfiguration(System.String@,System.String@,System.String@,System.Configuration.Internal.IInternalConfigRoot,System.Object[])" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InitForConfiguration :  *  *  * System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit&#xA;override this.InitForConfiguration :  *  *  * System.Configuration.Internal.IInternalConfigRoot * obj[] -&gt; unit" Usage="delegatingConfigHost.InitForConfiguration (locationSubPath, configPath, locationConfigPath, root, hostInitConfigurationParams)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.InitForConfiguration(System.String@,System.String@,System.String@,System.Configuration.Internal.IInternalConfigRoot,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="locationSubPath" Type="System.String" RefType="ref" Index="0" />
        <Parameter Name="configPath" Type="System.String" RefType="out" Index="1" />
        <Parameter Name="locationConfigPath" Type="System.String" RefType="out" Index="2" />
        <Parameter Name="configRoot" Type="System.Configuration.Internal.IInternalConfigRoot" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="root" Type="System.Configuration.Internal.IInternalConfigRoot" Index="3" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="hostInitConfigurationParams" Type="System.Object[]" Index="4">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="locationSubPath">위치 하위 경로를 나타내는 문자열이며 참조로 전달됩니다.</param>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <param name="locationConfigPath">위치 구성 경로입니다.</param>
        <param name="configRoot">구성 루트 요소입니다.</param>
        <param name="root">To be added.</param>
        <param name="hostInitConfigurationParams">호스트를 초기화하는 데 사용되는 매개 변수를 나타내는 매개 변수 개체입니다.</param>
        <summary>구성을 위해 호스트를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsAboveApplication">
      <MemberSignature Language="C#" Value="public virtual bool IsAboveApplication (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAboveApplication(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsAboveApplication(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAboveApplication (configPath As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAboveApplication(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member IsAboveApplication : string -&gt; bool&#xA;override this.IsAboveApplication : string -&gt; bool" Usage="delegatingConfigHost.IsAboveApplication configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsAboveApplication(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>구성이 구성 계층 구조에서 응용 프로그램 구성 위에 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성이 구성 계층 구조에서 응용 프로그램 구성 위에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsAppConfigHttp">
      <MemberSignature Language="C#" Value="public virtual bool IsAppConfigHttp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAppConfigHttp" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.IsAppConfigHttp" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAppConfigHttp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAppConfigHttp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAppConfigHttp : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.IsAppConfigHttp" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHostPaths.IsAppConfigHttp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConfigRecordRequired">
      <MemberSignature Language="C#" Value="public virtual bool IsConfigRecordRequired (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsConfigRecordRequired(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsConfigRecordRequired(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsConfigRecordRequired (configPath As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsConfigRecordRequired(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member IsConfigRecordRequired : string -&gt; bool&#xA;override this.IsConfigRecordRequired : string -&gt; bool" Usage="delegatingConfigHost.IsConfigRecordRequired configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsConfigRecordRequired(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>구성 레코드가 호스트 구성 초기화에 필요한지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성 레코드가 호스트 구성 초기화에 필요하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsDefinitionAllowed">
      <MemberSignature Language="C#" Value="public virtual bool IsDefinitionAllowed (string configPath, System.Configuration.ConfigurationAllowDefinition allowDefinition, System.Configuration.ConfigurationAllowExeDefinition allowExeDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefinitionAllowed(string configPath, valuetype System.Configuration.ConfigurationAllowDefinition allowDefinition, valuetype System.Configuration.ConfigurationAllowExeDefinition allowExeDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsDefinitionAllowed(System.String,System.Configuration.ConfigurationAllowDefinition,System.Configuration.ConfigurationAllowExeDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefinitionAllowed (configPath As String, allowDefinition As ConfigurationAllowDefinition, allowExeDefinition As ConfigurationAllowExeDefinition) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefinitionAllowed(System::String ^ configPath, System::Configuration::ConfigurationAllowDefinition allowDefinition, System::Configuration::ConfigurationAllowExeDefinition allowExeDefinition);" />
      <MemberSignature Language="F#" Value="abstract member IsDefinitionAllowed : string * System.Configuration.ConfigurationAllowDefinition * System.Configuration.ConfigurationAllowExeDefinition -&gt; bool&#xA;override this.IsDefinitionAllowed : string * System.Configuration.ConfigurationAllowDefinition * System.Configuration.ConfigurationAllowExeDefinition -&gt; bool" Usage="delegatingConfigHost.IsDefinitionAllowed (configPath, allowDefinition, allowExeDefinition)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsDefinitionAllowed(System.String,System.Configuration.ConfigurationAllowDefinition,System.Configuration.ConfigurationAllowExeDefinition)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
        <Parameter Name="allowDefinition" Type="System.Configuration.ConfigurationAllowDefinition" />
        <Parameter Name="allowExeDefinition" Type="System.Configuration.ConfigurationAllowExeDefinition" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <param name="allowDefinition"><see cref="T:System.Configuration.ConfigurationAllowDefinition" /> 개체</param>
        <param name="allowExeDefinition"><see cref="T:System.Configuration.ConfigurationAllowExeDefinition" /> 개체</param>
        <summary>호스트 구성에서 정의를 제한하거나 허용합니다.</summary>
        <returns>호스트 구성에서 정의의 허용 또는 제한에 성공했으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public virtual bool IsFile (string streamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsFile(string streamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsFile (streamName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsFile(System::String ^ streamName);" />
      <MemberSignature Language="F#" Value="abstract member IsFile : string -&gt; bool&#xA;override this.IsFile : string -&gt; bool" Usage="delegatingConfigHost.IsFile streamName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <summary><see cref="T:System.IO.Stream" /> 개체에서 구성 파일을 읽는 데 사용하는 파일 경로가 올바른 경로인지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="T:System.IO.Stream" /> 개체에서 구성 파일을 읽는 데 사용하는 경로가 올바른 경로이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsFullTrustSectionWithoutAptcaAllowed">
      <MemberSignature Language="C#" Value="public virtual bool IsFullTrustSectionWithoutAptcaAllowed (System.Configuration.Internal.IInternalConfigRecord configRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsFullTrustSectionWithoutAptcaAllowed(class System.Configuration.Internal.IInternalConfigRecord configRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsFullTrustSectionWithoutAptcaAllowed(System.Configuration.Internal.IInternalConfigRecord)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsFullTrustSectionWithoutAptcaAllowed (configRecord As IInternalConfigRecord) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsFullTrustSectionWithoutAptcaAllowed(System::Configuration::Internal::IInternalConfigRecord ^ configRecord);" />
      <MemberSignature Language="F#" Value="abstract member IsFullTrustSectionWithoutAptcaAllowed : System.Configuration.Internal.IInternalConfigRecord -&gt; bool&#xA;override this.IsFullTrustSectionWithoutAptcaAllowed : System.Configuration.Internal.IInternalConfigRecord -&gt; bool" Usage="delegatingConfigHost.IsFullTrustSectionWithoutAptcaAllowed configRecord" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsFullTrustSectionWithoutAptcaAllowed(System.Configuration.Internal.IInternalConfigRecord)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configRecord" Type="System.Configuration.Internal.IInternalConfigRecord" />
      </Parameters>
      <Docs>
        <param name="configRecord"><see cref="T:System.Configuration.Internal.IInternalConfigRecord" /> 개체</param>
        <summary>구성 섹션에서 완전히 신뢰된 코드 액세스 보안 수준이 필요하고 <see cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" /> 특성을 통해 암시적 링크 요청을 사용하지 않는 것을 허용하지 않는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성 섹션에서 완전히 신뢰된 코드 액세스 보안 수준이 필요하고 <see cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" /> 특성을 통해 암시적 링크 요청을 사용하지 않는 것을 허용하지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsInitDelayed">
      <MemberSignature Language="C#" Value="public virtual bool IsInitDelayed (System.Configuration.Internal.IInternalConfigRecord configRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInitDelayed(class System.Configuration.Internal.IInternalConfigRecord configRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsInitDelayed(System.Configuration.Internal.IInternalConfigRecord)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInitDelayed (configRecord As IInternalConfigRecord) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInitDelayed(System::Configuration::Internal::IInternalConfigRecord ^ configRecord);" />
      <MemberSignature Language="F#" Value="abstract member IsInitDelayed : System.Configuration.Internal.IInternalConfigRecord -&gt; bool&#xA;override this.IsInitDelayed : System.Configuration.Internal.IInternalConfigRecord -&gt; bool" Usage="delegatingConfigHost.IsInitDelayed configRecord" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsInitDelayed(System.Configuration.Internal.IInternalConfigRecord)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configRecord" Type="System.Configuration.Internal.IInternalConfigRecord" />
      </Parameters>
      <Docs>
        <param name="configRecord"><see cref="T:System.Configuration.Internal.IInternalConfigRecord" /> 개체</param>
        <summary>구성 개체의 초기화가 지연되는 것으로 간주되는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성 개체의 초기화가 지연되는 것으로 간주되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsLocationApplicable">
      <MemberSignature Language="C#" Value="public virtual bool IsLocationApplicable (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsLocationApplicable(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsLocationApplicable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsLocationApplicable (configPath As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsLocationApplicable(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member IsLocationApplicable : string -&gt; bool&#xA;override this.IsLocationApplicable : string -&gt; bool" Usage="delegatingConfigHost.IsLocationApplicable configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsLocationApplicable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>구성 개체에서 위치 태그를 지원하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성 개체에서 위치 태그를 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsRemote">
      <MemberSignature Language="C#" Value="public virtual bool IsRemote { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRemote" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.IsRemote" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsRemote As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsRemote { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRemote : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.IsRemote" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHost.IsRemote</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>구성이 원격 구성인지 여부를 나타내는 값을 반환합니다.</summary>
        <value>구성이 원격 구성이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsSecondaryRoot">
      <MemberSignature Language="C#" Value="public virtual bool IsSecondaryRoot (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSecondaryRoot(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsSecondaryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSecondaryRoot (configPath As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSecondaryRoot(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member IsSecondaryRoot : string -&gt; bool&#xA;override this.IsSecondaryRoot : string -&gt; bool" Usage="delegatingConfigHost.IsSecondaryRoot configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsSecondaryRoot(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>구성 경로가 루트로 내용을 처리해야 하는 구성 노드의 경로인지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성 경로가 루트로 내용을 처리해야 하는 구성 노드의 경로이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="IsTrustedConfigPath">
      <MemberSignature Language="C#" Value="public virtual bool IsTrustedConfigPath (string configPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsTrustedConfigPath(string configPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.IsTrustedConfigPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsTrustedConfigPath (configPath As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsTrustedConfigPath(System::String ^ configPath);" />
      <MemberSignature Language="F#" Value="abstract member IsTrustedConfigPath : string -&gt; bool&#xA;override this.IsTrustedConfigPath : string -&gt; bool" Usage="delegatingConfigHost.IsTrustedConfigPath configPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.IsTrustedConfigPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <summary>구성 경로가 신뢰되는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>구성 경로가 신뢰되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStreamForRead">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>구성 파일을 읽기 위해 <see cref="T:System.IO.Stream" /> 개체를 열고 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStreamForRead">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream OpenStreamForRead (string streamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream OpenStreamForRead(string streamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.OpenStreamForRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenStreamForRead (streamName As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ OpenStreamForRead(System::String ^ streamName);" />
      <MemberSignature Language="F#" Value="abstract member OpenStreamForRead : string -&gt; System.IO.Stream&#xA;override this.OpenStreamForRead : string -&gt; System.IO.Stream" Usage="delegatingConfigHost.OpenStreamForRead streamName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.OpenStreamForRead(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <summary>구성 파일을 읽기 위해 <see cref="T:System.IO.Stream" /> 개체를 엽니다.</summary>
        <returns><paramref name="streamName" />에서 지정된 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="OpenStreamForRead">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream OpenStreamForRead (string streamName, bool assertPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream OpenStreamForRead(string streamName, bool assertPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.OpenStreamForRead(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenStreamForRead (streamName As String, assertPermissions As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ OpenStreamForRead(System::String ^ streamName, bool assertPermissions);" />
      <MemberSignature Language="F#" Value="abstract member OpenStreamForRead : string * bool -&gt; System.IO.Stream&#xA;override this.OpenStreamForRead : string * bool -&gt; System.IO.Stream" Usage="delegatingConfigHost.OpenStreamForRead (streamName, assertPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.OpenStreamForRead(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="assertPermissions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="assertPermissions">사용 권한을 어설션하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>구성 파일을 읽기 위해 <see cref="T:System.IO.Stream" /> 개체를 엽니다.</summary>
        <returns><paramref name="streamName" />에서 지정된 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStreamForWrite">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>구성 파일에 쓰기 위해 <see cref="T:System.IO.Stream" /> 개체를 열고 반환합니다. <see cref="T:System.IO.Stream" /> 개체가 파일 특성을 복사하는 데 사용할 템플릿으로 지정될 수 있도록 합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStreamForWrite">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream OpenStreamForWrite (string streamName, string templateStreamName, ref object writeContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream OpenStreamForWrite(string streamName, string templateStreamName, object&amp; writeContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.OpenStreamForWrite(System.String,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenStreamForWrite (streamName As String, templateStreamName As String, ByRef writeContext As Object) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ OpenStreamForWrite(System::String ^ streamName, System::String ^ templateStreamName, System::Object ^ % writeContext);" />
      <MemberSignature Language="F#" Value="abstract member OpenStreamForWrite : string * string *  -&gt; System.IO.Stream&#xA;override this.OpenStreamForWrite : string * string *  -&gt; System.IO.Stream" Usage="delegatingConfigHost.OpenStreamForWrite (streamName, templateStreamName, writeContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.OpenStreamForWrite(System.String,System.String,System.Object@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="templateStreamName" Type="System.String" />
        <Parameter Name="writeContext" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="templateStreamName">파일 특성을 복사할 템플릿인 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="writeContext"><see cref="T:System.IO.Stream" /> 개체의 쓰기 컨텍스트이며 참조로 전달됩니다.</param>
        <summary>구성 파일에 쓰거나 구성 파일을 만드는 데 사용되는 임시 파일에 쓰기 위해 <see cref="T:System.IO.Stream" /> 개체를 엽니다. <see cref="T:System.IO.Stream" /> 개체가 파일 특성을 복사하는 데 사용할 템플릿으로 지정될 수 있도록 합니다.</summary>
        <returns><see cref="T:System.IO.Stream" /> 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="OpenStreamForWrite">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream OpenStreamForWrite (string streamName, string templateStreamName, ref object writeContext, bool assertPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream OpenStreamForWrite(string streamName, string templateStreamName, object&amp; writeContext, bool assertPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.OpenStreamForWrite(System.String,System.String,System.Object@,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenStreamForWrite (streamName As String, templateStreamName As String, ByRef writeContext As Object, assertPermissions As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ OpenStreamForWrite(System::String ^ streamName, System::String ^ templateStreamName, System::Object ^ % writeContext, bool assertPermissions);" />
      <MemberSignature Language="F#" Value="abstract member OpenStreamForWrite : string * string *  * bool -&gt; System.IO.Stream&#xA;override this.OpenStreamForWrite : string * string *  * bool -&gt; System.IO.Stream" Usage="delegatingConfigHost.OpenStreamForWrite (streamName, templateStreamName, writeContext, assertPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.OpenStreamForWrite(System.String,System.String,System.Object@,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="templateStreamName" Type="System.String" />
        <Parameter Name="writeContext" Type="System.Object" RefType="ref" />
        <Parameter Name="assertPermissions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="templateStreamName">파일 특성을 복사할 템플릿인 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="writeContext">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 쓰기 컨텍스트이며 참조로 전달됩니다.</param>
        <param name="assertPermissions">사용 권한을 어설션하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>구성 파일에 쓰기 위해 <see cref="T:System.IO.Stream" /> 개체를 엽니다. <see cref="T:System.IO.Stream" /> 개체가 파일 특성을 복사하는 데 사용할 템플릿으로 지정될 수 있도록 합니다.</summary>
        <returns><paramref name="streamName" /> 매개 변수에서 지정한 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="PrefetchAll">
      <MemberSignature Language="C#" Value="public virtual bool PrefetchAll (string configPath, string streamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PrefetchAll(string configPath, string streamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.PrefetchAll(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrefetchAll (configPath As String, streamName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PrefetchAll(System::String ^ configPath, System::String ^ streamName);" />
      <MemberSignature Language="F#" Value="abstract member PrefetchAll : string * string -&gt; bool&#xA;override this.PrefetchAll : string * string -&gt; bool" Usage="delegatingConfigHost.PrefetchAll (configPath, streamName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.PrefetchAll(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
        <Parameter Name="streamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <summary>전체 구성 파일을 지정된 <see cref="T:System.IO.Stream" /> 개체에서 읽을 수 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>전체 구성 파일을 <paramref name="streamName" />으로 지정된 <see cref="T:System.IO.Stream" /> 개체에서 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="PrefetchSection">
      <MemberSignature Language="C#" Value="public virtual bool PrefetchSection (string sectionGroupName, string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PrefetchSection(string sectionGroupName, string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.PrefetchSection(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrefetchSection (sectionGroupName As String, sectionName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PrefetchSection(System::String ^ sectionGroupName, System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="abstract member PrefetchSection : string * string -&gt; bool&#xA;override this.PrefetchSection : string * string -&gt; bool" Usage="delegatingConfigHost.PrefetchSection (sectionGroupName, sectionName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.PrefetchSection(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionGroupName" Type="System.String" />
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionGroupName">구성 파일에 있는 섹션 그룹의 이름을 나타내는 문자열입니다.</param>
        <param name="sectionName">구성 파일에 있는 섹션의 이름을 나타내는 문자열입니다.</param>
        <summary>연결된 구성 파일의 지정된 섹션을 읽도록 <see cref="T:System.Configuration.Internal.IInternalConfigHost" /> 개체에 지시합니다.</summary>
        <returns><paramref name="sectionGroupName" /> 및 <paramref name="sectionName" /> 매개 변수로 지정된 구성 파일의 섹션을 <see cref="T:System.IO.Stream" /> 개체에서 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ProcessConfigurationSection">
      <MemberSignature Language="C#" Value="public virtual System.Configuration.ConfigurationSection ProcessConfigurationSection (System.Configuration.ConfigurationSection configSection, System.Configuration.ConfigurationBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Configuration.ConfigurationSection ProcessConfigurationSection(class System.Configuration.ConfigurationSection configSection, class System.Configuration.ConfigurationBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.ProcessConfigurationSection(System.Configuration.ConfigurationSection,System.Configuration.ConfigurationBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProcessConfigurationSection (configSection As ConfigurationSection, builder As ConfigurationBuilder) As ConfigurationSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Configuration::ConfigurationSection ^ ProcessConfigurationSection(System::Configuration::ConfigurationSection ^ configSection, System::Configuration::ConfigurationBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member ProcessConfigurationSection : System.Configuration.ConfigurationSection * System.Configuration.ConfigurationBuilder -&gt; System.Configuration.ConfigurationSection&#xA;override this.ProcessConfigurationSection : System.Configuration.ConfigurationSection * System.Configuration.ConfigurationBuilder -&gt; System.Configuration.ConfigurationSection" Usage="delegatingConfigHost.ProcessConfigurationSection (configSection, builder)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigurationBuilderHost.ProcessConfigurationSection(System.Configuration.ConfigurationSection,System.Configuration.ConfigurationBuilder)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configSection" Type="System.Configuration.ConfigurationSection" Index="0" FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="builder" Type="System.Configuration.ConfigurationBuilder" Index="1" FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="configSection">처리할 <see cref="T:System.Configuration.ConfigurationSection" />입니다.</param>
        <param name="builder"><paramref name="configSection" />을 처리하는 데 사용할 <see cref="T:System.Configuration.ConfigurationBuilder" />입니다.</param>
        <summary>제공된 <see cref="T:System.Configuration.ConfigurationBuilder" />를 사용하여 <see cref="T:System.Configuration.ConfigurationSection" /> 개체를 처리합니다.</summary>
        <returns>처리된 <see cref="T:System.Configuration.ConfigurationSection" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessRawXml">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ProcessRawXml (System.Xml.XmlNode rawXml, System.Configuration.ConfigurationBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ProcessRawXml(class System.Xml.XmlNode rawXml, class System.Configuration.ConfigurationBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.ProcessRawXml(System.Xml.XmlNode,System.Configuration.ConfigurationBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProcessRawXml (rawXml As XmlNode, builder As ConfigurationBuilder) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ProcessRawXml(System::Xml::XmlNode ^ rawXml, System::Configuration::ConfigurationBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member ProcessRawXml : System.Xml.XmlNode * System.Configuration.ConfigurationBuilder -&gt; System.Xml.XmlNode&#xA;override this.ProcessRawXml : System.Xml.XmlNode * System.Configuration.ConfigurationBuilder -&gt; System.Xml.XmlNode" Usage="delegatingConfigHost.ProcessRawXml (rawXml, builder)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigurationBuilderHost.ProcessRawXml(System.Xml.XmlNode,System.Configuration.ConfigurationBuilder)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawXml" Type="System.Xml.XmlNode" Index="0" FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="builder" Type="System.Configuration.ConfigurationBuilder" Index="1" FrameworkAlternate="netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="rawXml">처리할 <see cref="T:System.Xml.XmlNode" />입니다.</param>
        <param name="builder"><paramref name="rawXml" />을 처리하는 데 사용할 <see cref="T:System.Configuration.ConfigurationBuilder" />입니다.</param>
        <summary>제공된 <see cref="T:System.Configuration.ConfigurationBuilder" />를 사용하여 구성 섹션의 태그를 처리합니다.</summary>
        <returns>처리된 <see cref="T:System.Xml.XmlNode" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshConfigPaths">
      <MemberSignature Language="C#" Value="public virtual void RefreshConfigPaths ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RefreshConfigPaths() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.RefreshConfigPaths" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RefreshConfigPaths ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RefreshConfigPaths();" />
      <MemberSignature Language="F#" Value="abstract member RefreshConfigPaths : unit -&gt; unit&#xA;override this.RefreshConfigPaths : unit -&gt; unit" Usage="delegatingConfigHost.RefreshConfigPaths " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHostPaths.RefreshConfigPaths</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequireCompleteInit">
      <MemberSignature Language="C#" Value="public virtual void RequireCompleteInit (System.Configuration.Internal.IInternalConfigRecord configRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RequireCompleteInit(class System.Configuration.Internal.IInternalConfigRecord configRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.RequireCompleteInit(System.Configuration.Internal.IInternalConfigRecord)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RequireCompleteInit (configRecord As IInternalConfigRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RequireCompleteInit(System::Configuration::Internal::IInternalConfigRecord ^ configRecord);" />
      <MemberSignature Language="F#" Value="abstract member RequireCompleteInit : System.Configuration.Internal.IInternalConfigRecord -&gt; unit&#xA;override this.RequireCompleteInit : System.Configuration.Internal.IInternalConfigRecord -&gt; unit" Usage="delegatingConfigHost.RequireCompleteInit configRecord" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.RequireCompleteInit(System.Configuration.Internal.IInternalConfigRecord)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configRecord" Type="System.Configuration.Internal.IInternalConfigRecord" />
      </Parameters>
      <Docs>
        <param name="configRecord"><see cref="T:System.Configuration.Internal.IInternalConfigRecord" /> 개체</param>
        <summary>새 구성 레코드에 완전한 초기화가 필요함을 나타냅니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="StartMonitoringStreamForChanges">
      <MemberSignature Language="C#" Value="public virtual object StartMonitoringStreamForChanges (string streamName, System.Configuration.Internal.StreamChangeCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object StartMonitoringStreamForChanges(string streamName, class System.Configuration.Internal.StreamChangeCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.StartMonitoringStreamForChanges(System.String,System.Configuration.Internal.StreamChangeCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function StartMonitoringStreamForChanges (streamName As String, callback As StreamChangeCallback) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ StartMonitoringStreamForChanges(System::String ^ streamName, System::Configuration::Internal::StreamChangeCallback ^ callback);" />
      <MemberSignature Language="F#" Value="abstract member StartMonitoringStreamForChanges : string * System.Configuration.Internal.StreamChangeCallback -&gt; obj&#xA;override this.StartMonitoringStreamForChanges : string * System.Configuration.Internal.StreamChangeCallback -&gt; obj" Usage="delegatingConfigHost.StartMonitoringStreamForChanges (streamName, callback)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.StartMonitoringStreamForChanges(System.String,System.Configuration.Internal.StreamChangeCallback)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="callback" Type="System.Configuration.Internal.StreamChangeCallback" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="callback">구성 파일의 변경 사항을 나타내는 반환된 데이터를 받을 <see cref="T:System.Configuration.Internal.StreamChangeCallback" /> 개체입니다.</param>
        <summary>연결된 <see cref="T:System.IO.Stream" /> 개체에서 구성 파일의 변경 사항을 모니터링하도록 호스트에 지시합니다.</summary>
        <returns>변경된 구성 설정을 포함하는 <see cref="T:System.Object" /> 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="StopMonitoringStreamForChanges">
      <MemberSignature Language="C#" Value="public virtual void StopMonitoringStreamForChanges (string streamName, System.Configuration.Internal.StreamChangeCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopMonitoringStreamForChanges(string streamName, class System.Configuration.Internal.StreamChangeCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.StopMonitoringStreamForChanges(System.String,System.Configuration.Internal.StreamChangeCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub StopMonitoringStreamForChanges (streamName As String, callback As StreamChangeCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void StopMonitoringStreamForChanges(System::String ^ streamName, System::Configuration::Internal::StreamChangeCallback ^ callback);" />
      <MemberSignature Language="F#" Value="abstract member StopMonitoringStreamForChanges : string * System.Configuration.Internal.StreamChangeCallback -&gt; unit&#xA;override this.StopMonitoringStreamForChanges : string * System.Configuration.Internal.StreamChangeCallback -&gt; unit" Usage="delegatingConfigHost.StopMonitoringStreamForChanges (streamName, callback)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.StopMonitoringStreamForChanges(System.String,System.Configuration.Internal.StreamChangeCallback)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="callback" Type="System.Configuration.Internal.StreamChangeCallback" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="callback"><see cref="T:System.Configuration.Internal.StreamChangeCallback" /> 개체입니다.</param>
        <summary>연결된 <see cref="T:System.IO.Stream" /> 개체에서 구성 파일의 변경 사항을 모니터링하는 작업을 중지하도록 호스트에 지시합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotifications">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotifications { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotifications" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.SupportsChangeNotifications" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeNotifications As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeNotifications { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeNotifications : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.SupportsChangeNotifications" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHost.SupportsChangeNotifications</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호스트 구성에서 변경 알림을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>호스트에서 변경 알림을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="SupportsLocation">
      <MemberSignature Language="C#" Value="public virtual bool SupportsLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsLocation" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.SupportsLocation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsLocation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsLocation { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsLocation : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.SupportsLocation" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHost.SupportsLocation</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호스트 구성에서 위치 태그를 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>호스트에서 위치 태그를 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="SupportsPath">
      <MemberSignature Language="C#" Value="public virtual bool SupportsPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPath" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.SupportsPath" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsPath As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsPath { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPath : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.SupportsPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHost.SupportsPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호스트 구성에 경로 지원이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>호스트 구성에 경로 지원이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="SupportsRefresh">
      <MemberSignature Language="C#" Value="public virtual bool SupportsRefresh { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsRefresh" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.Internal.DelegatingConfigHost.SupportsRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsRefresh As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsRefresh { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsRefresh : bool" Usage="System.Configuration.Internal.DelegatingConfigHost.SupportsRefresh" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Configuration.Internal.IInternalConfigHost.SupportsRefresh</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호스트 구성에서 새로 고침을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>호스트 구성에서 새로 고침을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="VerifyDefinitionAllowed">
      <MemberSignature Language="C#" Value="public virtual void VerifyDefinitionAllowed (string configPath, System.Configuration.ConfigurationAllowDefinition allowDefinition, System.Configuration.ConfigurationAllowExeDefinition allowExeDefinition, System.Configuration.Internal.IConfigErrorInfo errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyDefinitionAllowed(string configPath, valuetype System.Configuration.ConfigurationAllowDefinition allowDefinition, valuetype System.Configuration.ConfigurationAllowExeDefinition allowExeDefinition, class System.Configuration.Internal.IConfigErrorInfo errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.VerifyDefinitionAllowed(System.String,System.Configuration.ConfigurationAllowDefinition,System.Configuration.ConfigurationAllowExeDefinition,System.Configuration.Internal.IConfigErrorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub VerifyDefinitionAllowed (configPath As String, allowDefinition As ConfigurationAllowDefinition, allowExeDefinition As ConfigurationAllowExeDefinition, errorInfo As IConfigErrorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyDefinitionAllowed(System::String ^ configPath, System::Configuration::ConfigurationAllowDefinition allowDefinition, System::Configuration::ConfigurationAllowExeDefinition allowExeDefinition, System::Configuration::Internal::IConfigErrorInfo ^ errorInfo);" />
      <MemberSignature Language="F#" Value="abstract member VerifyDefinitionAllowed : string * System.Configuration.ConfigurationAllowDefinition * System.Configuration.ConfigurationAllowExeDefinition * System.Configuration.Internal.IConfigErrorInfo -&gt; unit&#xA;override this.VerifyDefinitionAllowed : string * System.Configuration.ConfigurationAllowDefinition * System.Configuration.ConfigurationAllowExeDefinition * System.Configuration.Internal.IConfigErrorInfo -&gt; unit" Usage="delegatingConfigHost.VerifyDefinitionAllowed (configPath, allowDefinition, allowExeDefinition, errorInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.VerifyDefinitionAllowed(System.String,System.Configuration.ConfigurationAllowDefinition,System.Configuration.ConfigurationAllowExeDefinition,System.Configuration.Internal.IConfigErrorInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configPath" Type="System.String" />
        <Parameter Name="allowDefinition" Type="System.Configuration.ConfigurationAllowDefinition" />
        <Parameter Name="allowExeDefinition" Type="System.Configuration.ConfigurationAllowExeDefinition" />
        <Parameter Name="errorInfo" Type="System.Configuration.Internal.IConfigErrorInfo" />
      </Parameters>
      <Docs>
        <param name="configPath">구성 파일의 경로를 나타내는 문자열입니다.</param>
        <param name="allowDefinition"><see cref="P:System.Configuration.SectionInformation.AllowDefinition" /> 개체</param>
        <param name="allowExeDefinition"><see cref="T:System.Configuration.ConfigurationAllowExeDefinition" /> 개체입니다.</param>
        <param name="errorInfo"><see cref="T:System.Configuration.Internal.IConfigErrorInfo" /> 개체</param>
        <summary>구성 정의가 구성 레코드에 허용되는지 확인합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteCompleted">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>구성 파일에 대한 쓰기가 모두 완료되었음을 나타내고 권한이 어설션되는지 여부를 지정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteCompleted">
      <MemberSignature Language="C#" Value="public virtual void WriteCompleted (string streamName, bool success, object writeContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteCompleted(string streamName, bool success, object writeContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.WriteCompleted(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteCompleted (streamName As String, success As Boolean, writeContext As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteCompleted(System::String ^ streamName, bool success, System::Object ^ writeContext);" />
      <MemberSignature Language="F#" Value="abstract member WriteCompleted : string * bool * obj -&gt; unit&#xA;override this.WriteCompleted : string * bool * obj -&gt; unit" Usage="delegatingConfigHost.WriteCompleted (streamName, success, writeContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.WriteCompleted(System.String,System.Boolean,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="success" Type="System.Boolean" />
        <Parameter Name="writeContext" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="success">구성 파일에 대한 쓰기가 성공적으로 완료되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="writeContext">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 쓰기 컨텍스트입니다.</param>
        <summary>구성 파일에 대한 쓰기가 모두 완료되었음을 나타냅니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="WriteCompleted">
      <MemberSignature Language="C#" Value="public virtual void WriteCompleted (string streamName, bool success, object writeContext, bool assertPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteCompleted(string streamName, bool success, object writeContext, bool assertPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.Internal.DelegatingConfigHost.WriteCompleted(System.String,System.Boolean,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteCompleted (streamName As String, success As Boolean, writeContext As Object, assertPermissions As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteCompleted(System::String ^ streamName, bool success, System::Object ^ writeContext, bool assertPermissions);" />
      <MemberSignature Language="F#" Value="abstract member WriteCompleted : string * bool * obj * bool -&gt; unit&#xA;override this.WriteCompleted : string * bool * obj * bool -&gt; unit" Usage="delegatingConfigHost.WriteCompleted (streamName, success, writeContext, assertPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Configuration.Internal.IInternalConfigHost.WriteCompleted(System.String,System.Boolean,System.Object,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamName" Type="System.String" />
        <Parameter Name="success" Type="System.Boolean" />
        <Parameter Name="writeContext" Type="System.Object" />
        <Parameter Name="assertPermissions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="streamName">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 이름입니다.</param>
        <param name="success">쓰기가 성공적으로 완료되었음을 나타내려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="writeContext">구성 파일에서 I/O 작업을 수행하는 <see cref="T:System.IO.Stream" /> 개체의 쓰기 컨텍스트입니다.</param>
        <param name="assertPermissions">사용 권한을 어설션하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>구성 파일에 대한 쓰기가 모두 완료되었음을 나타내고 권한이 어설션되는지 여부를 지정합니다.</summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>