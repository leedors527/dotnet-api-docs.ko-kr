<Type Name="ApplicationSettingsBase" FullName="System.Configuration.ApplicationSettingsBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="81e0b3e822204b77302e8c6a560b29fc4205f991" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52915955" /></Metadata><TypeSignature Language="C#" Value="public abstract class ApplicationSettingsBase : System.Configuration.SettingsBase, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ApplicationSettingsBase extends System.Configuration.SettingsBase implements class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ApplicationSettingsBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ApplicationSettingsBase&#xA;Inherits SettingsBase&#xA;Implements INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationSettingsBase abstract : System::Configuration::SettingsBase, System::ComponentModel::INotifyPropertyChanged" />
  <TypeSignature Language="F#" Value="type ApplicationSettingsBase = class&#xA;    inherit SettingsBase&#xA;    interface INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.SettingsBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Window Forms 응용 프로그램에서 응용 프로그램 설정 기능을 구현 하려면 구체적인 파생 래퍼 클래스에 대 한 기본 클래스로 작동 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase> 다음과 같은 기능을 추가 합니다 <xref:System.Configuration.SettingsBase> 웹 기반 응용 프로그램에서 사용 되는 클래스:  
  
-   파생된 설정 래퍼 클래스에 특성을 검색할 수 있습니다. <xref:System.Configuration.ApplicationSettingsBase> 나중에 설명 된 대로 래퍼 클래스 속성에 사용 된 선언적 모델을 지원 합니다.  
  
-   더 높은 수준의 <xref:System.Configuration.ApplicationSettingsBase.Save%2A> 고 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 메서드.  
  
-   개별 설정의 정확성을 유지 하려면 처리할 수 있는 추가 유효성 검사 이벤트입니다.  
  
 응용 프로그램 설정 아키텍처에서 그룹 설정 속성에 액세스 하려면 구체적인 래퍼 클래스를 파생 <xref:System.Configuration.ApplicationSettingsBase>합니다. 래퍼 클래스를 사용자 지정 <xref:System.Configuration.ApplicationSettingsBase> 다음과 같은 방법으로:  
  
-   모든 설정 속성에 액세스할 수에 대 한 해당 강력한 형식의 공용 속성 래퍼 클래스에 추가 됩니다. 이 속성은 `get` 하 고 `set` 만 읽기/쓰기 응용 프로그램 설정에 대 한 접근자를 `get` 읽기 전용으로 설정에 대 한 접근자입니다.  
  
-   설정 로밍에 대 한 기본값을 지원 해야 하는지 여부를 설정의 범위 (응용 프로그램 또는 사용자) 같은 설정 속성의 특성을 나타내는 래퍼 클래스의 공용 속성에 적절 한 특성을 적용 해야 합니다 설정을 사용 하는 설정 공급자입니다. 각 속성 중 하나를 사용 하 여 해당 범위를 지정 해야 <xref:System.Configuration.ApplicationScopedSettingAttribute> 또는 <xref:System.Configuration.UserScopedSettingAttribute>합니다. 응용 프로그램 범위 설정은 읽기 전용 경우 기본 <xref:System.Configuration.LocalFileSettingsProvider> 사용 됩니다.  
  
 <xref:System.Configuration.ApplicationSettingsBase> 클래스 리플렉션을 사용 하 여 런타임 시 이러한 특성을 검색 합니다. 대부분의이 정보를 가져옵니다 저장소, 지 속성 형식 및 등을 담당 하는 설정 공급자 계층으로 전달 됩니다.  
  
 응용 프로그램에 여러 설정 래퍼 클래스, 각 클래스 정의 *설정 그룹*합니다. 각 그룹에는 다음과 같은 특징이 있습니다.  
  
-   그룹 수 나 속성 설정의 형식을 포함할 수 있습니다.  
  
-   그룹 이름을 사용 하 여 래퍼 클래스를 데코 레이트 하 여 명시적으로 설정 하지 않으면는 <xref:System.Configuration.SettingsGroupNameAttribute>, 이름을 자동으로 생성 됩니다.  
  
 기본적으로 모든 클라이언트 기반 응용 프로그램 사용을 <xref:System.Configuration.LocalFileSettingsProvider> 저장소를 제공 합니다. 대체 설정 공급자가 필요한 경우 해당 래퍼 클래스 또는 속성을 지정 합니다 <xref:System.Configuration.SettingsProviderAttribute>합니다.  
  
 응용 프로그램 설정을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Windows Forms에 대 한 응용 프로그램 설정을](~/docs/framework/winforms/advanced/application-settings-for-windows-forms.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 기본 폼의 특성을 유지 하려면 응용 프로그램 설정의 사용을 보여 줍니다: 위치, 크기, 배경색 및 제목 표시줄 텍스트입니다. 이러한 특성은 모두에서 단일 응용 프로그램 설정 속성으로 유지 됩니다는 `FormSettings` 이라는 클래스가 `FormLocation`, `FormSize`, `FormBackColor` 및 `FormText`, 각각. 제외한 `FormText` 하 고 `Size` 데이터 연결된 된 폼 속성에 바인딩된 및 사용 하 여 적용 하는 값을 설정 하는 기본 <xref:System.Configuration.DefaultSettingValueAttribute>입니다.  
  
 폼에는 다음 이름 및 함수는 4 개의 자식 컨트롤 포함 됩니다.  
  
-   이라는 단추가 `btnBackColor` 표시 하는 데 사용 합니다 **색** 일반 대화 상자.  
  
-   이라는 단추가 `btnReload` 데 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 응용 프로그램 설정 합니다.  
  
-   이라는 단추가 `btnReset` 데 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 응용 프로그램 설정 합니다.  
  
-   라는 텍스트 상자 `tbStatus` 프로그램에 대 한 상태 정보를 표시 하는 데 사용 합니다.  
  
 응용 프로그램의 모든 실행 후 있음을, 폼의 제목 텍스트에 마침표 문자가 추가 됩니다.  
  
 이 코드 예제에서는 사용 하 여 폼을 <xref:System.Windows.Forms.ColorDialog> 라는 클래스 `colorDialog1`, 및 <xref:System.Windows.Forms.StatusStrip> 컨트롤을 <xref:System.Windows.Forms.ToolStripStatusLabel> 라는 `tbStatus`합니다. 또한 필요한 세 <xref:System.Windows.Forms.Button> 명명 된 개체 `btnReload`를 `btnReset`, 및 `btnBackColor`합니다.  
  
 [!code-cpp[AppSettingsSample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#1)]
 [!code-csharp[AppSettingsSample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#1)]
 [!code-vb[AppSettingsSample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Configuration.LocalFileSettingsProvider" />
    <altmember cref="T:System.Configuration.ApplicationScopedSettingAttribute" />
    <altmember cref="T:System.Configuration.UserScopedSettingAttribute" />
    <altmember cref="T:System.Configuration.SettingsGroupNameAttribute" />
    <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/64090a34-8556-4904-8ea0-20efe9f8c886">Windows Forms에 대한 응용 프로그램 설정</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Configuration.ApplicationSettingsBase" /> 클래스의 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>인스턴스를 초기화 합니다 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 기본 상태로 클래스입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 생성자에서 파생 되는 현재 설정 래퍼 클래스를 사용 하 여 연결 하는 구성 요소가 없습니다.에 있다는 가정 아래에서 작동 하도록 설계 된 <xref:System.Configuration.ApplicationSettingsBase>합니다.  
  
 래퍼 클래스의 인스턴스를 만들 때 상속 된 코드는 다음 작업을 자동으로 수행 합니다.  
  
1.  클래스를 통해 반영 합니다.  
  
2.  래퍼에 대해 각 속성에 대 한 중 하나를 사용 하 여 표시 `[UserScopedSettingAttribute]` 나 `[ApplicationScopedSettingAttribute]`, 해당 <xref:System.Configuration.SettingsProperty> 만들어집니다.  
  
3.  각 <xref:System.Configuration.SettingsProperty> 에 선택적으로 기본값 설정 공급자와 같은 래퍼의 속성에 있는 다른 특성을 기반으로 하는 속성 집합의 일부가 포함 합니다.  
  
4.  다른 모든 특성은 특성 모음인에 배치 됩니다는 <xref:System.Configuration.SettingsProperty.Attributes%2A> 의 속성을 <xref:System.Configuration.SettingsProperty> 클래스입니다.  
  
5.  모든 <xref:System.Configuration.SettingsProperty> 개체에 추가 됩니다을 <xref:System.Configuration.SettingsPropertyCollection> 나타내는 <xref:System.Configuration.ApplicationSettingsBase.Properties%2A> 의 속성을 <xref:System.Configuration.ApplicationSettingsBase> 클래스입니다. 이 컬렉션에 전달 되는 <xref:System.Configuration.SettingsBase.Initialize%2A> 메서드.  
  
 앞에서 설명한 3 단계에서 암시 한 대로 <xref:System.Configuration.ApplicationSettingsBase> 몇 가지 속성 특성에 특히 다음을 사용 하 여 고유 하 게 작동: <xref:System.Configuration.SettingsProviderAttribute>를 <xref:System.Configuration.DefaultSettingValueAttribute>, 및 <xref:System.Configuration.SettingsSerializeAsAttribute>합니다. 다른 모든 설정 특성 단순히 적절 한 기본 공급자를 통해 전달 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SettingsProperty" />
        <altmember cref="T:System.Configuration.SettingsPropertyCollection" />
        <altmember cref="M:System.Configuration.SettingsBase.Initialize(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection,System.Configuration.SettingsProviderCollection)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (owner As IComponent)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase(System::ComponentModel::IComponent ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ApplicationSettingsBase : System.ComponentModel.IComponent -&gt; System.Configuration.ApplicationSettingsBase" Usage="new System.Configuration.ApplicationSettingsBase owner" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owner">응용 프로그램 설정 개체의 소유자 역할을 할 구성 요소.</param>
        <summary>인스턴스를 초기화 합니다 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 클래스는 제공 된 소유자 구성 요소를 사용 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 동일 합니다 <xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.ComponentModel.IComponent%2CSystem.String%29> 생성자 호출을 사용 하 여:  
  
 `ApplicationSettingsBase(owner, String.Empty)`  
  
 래퍼 클래스를 인스턴스화하는 동안 리플렉션을 사용 하는 방법에 대 한 내용은 기본값을 참조 하세요. <xref:System.Configuration.ApplicationSettingsBase.%23ctor> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="owner" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
        <altmember cref="P:System.ComponentModel.Component.Site" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (settingsKey As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase(System::String ^ settingsKey);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ApplicationSettingsBase : string -&gt; System.Configuration.ApplicationSettingsBase" Usage="new System.Configuration.ApplicationSettingsBase settingsKey" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="settingsKey"><see cref="T:System.String" /> 래퍼 클래스의 개별 인스턴스를 고유 하 게 식별 합니다.</param>
        <summary>인스턴스를 초기화 합니다 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 클래스 제공된 된 설정 키를 사용 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 속성의 값을는 `settingsKey` 매개 변수입니다. 이 속성은 동일한 응용 프로그램 도메인 설정 래퍼 클래스의 다른 인스턴스를 명확히 구분 하는 데 유용 합니다.  
  
 래퍼 클래스를 인스턴스화하는 동안 리플렉션을 사용 하는 방법에 대 한 내용은 기본값을 참조 하세요. <xref:System.Configuration.ApplicationSettingsBase.%23ctor> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner, string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner, string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (owner As IComponent, settingsKey As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ApplicationSettingsBase(System::ComponentModel::IComponent ^ owner, System::String ^ settingsKey);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ApplicationSettingsBase : System.ComponentModel.IComponent * string -&gt; System.Configuration.ApplicationSettingsBase" Usage="new System.Configuration.ApplicationSettingsBase (owner, settingsKey)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owner">응용 프로그램 설정 개체의 소유자 역할을 할 구성 요소.</param>
        <param name="settingsKey"><see cref="T:System.String" /> 래퍼 클래스의 개별 인스턴스를 고유 하 게 식별 합니다.</param>
        <summary>인스턴스를 초기화 합니다 <see cref="T:System.Configuration.ApplicationSettingsBase" /> 클래스는 제공 된 소유자 구성 요소와 설정 키를 사용 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.ComponentModel.IComponent> 로 지정 된 개체는 `owner` 매개 변수는이 응용 프로그램 설정 클래스의 현재 인스턴스 소유자 역할입니다. 래퍼 클래스에서 파생 된 설정을 초기화 하는 동안 <xref:System.Configuration.ApplicationSettingsBase>, 소유자의 사이트에 대 한 쿼리는 <xref:System.Configuration.ISettingsProviderService>합니다. 지정 된 대로 래퍼 클래스의 모든 속성에 기본 설정 공급자 보다 우선적으로 사용 됩니다 있으면는 <xref:System.Configuration.SettingsProviderAttribute>합니다.  
  
 이 생성자는 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 속성의 값을는 `settingsKey` 매개 변수입니다. 이 속성은 동일한 응용 프로그램 도메인에서 래퍼 클래스의 다른 인스턴스를 명확히 구분 하는 데 유용 합니다.  
  
 래퍼 클래스를 인스턴스화하는 동안 리플렉션을 사용 하는 방법에 대 한 내용은 기본값을 참조 하세요. <xref:System.Configuration.ApplicationSettingsBase.%23ctor> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="owner" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Configuration.ISettingsProviderService" />
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Context" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Context As SettingsContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsContext ^ Context { System::Configuration::SettingsContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Configuration.SettingsContext" Usage="System.Configuration.ApplicationSettingsBase.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>설정 그룹과 연결 된 응용 프로그램 설정 컨텍스트를 가져옵니다.</summary>
        <value><see cref="T:System.Configuration.SettingsContext" /> 설정 그룹을 사용 하 여 연결 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 설정 래퍼 클래스에서 파생 된 <xref:System.Configuration.ApplicationSettingsBase> 연결 된 컨텍스트가 있습니다. 컨텍스트 속성은 사용 하는 방법을 식별 하려면 각 속성에 대 한 설정 공급자에 전달 됩니다. 따라서 컨텍스트 설정 공급자가 연결 된 응용 프로그램 설정 값을 유지 하는 최상의 방법을 결정 하는 데 힌트로 역할입니다.  
  
 반면,는 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 속성을 사용 하면 동일한 래퍼 클래스의 여러 인스턴스를 구분 하는 설정 공급자입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Providers" />
        <altmember cref="T:System.Configuration.SettingsContext" />
        <altmember cref="T:System.Configuration.SettingsProvider" />
        <altmember cref="T:System.Configuration.ApplicationSettingsGroup" />
      </Docs>
    </Member>
    <Member MemberName="GetPreviousVersion">
      <MemberSignature Language="C#" Value="public object GetPreviousVersion (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPreviousVersion(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.GetPreviousVersion(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPreviousVersion (propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPreviousVersion(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetPreviousVersion : string -&gt; obj" Usage="applicationSettingsBase.GetPreviousVersion propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName"><see cref="T:System.String" /> 값이 반환 될 설정 속성의 이름을 포함 합니다.</param>
        <summary>이전 버전의 동일한 응용 프로그램에 대 한 명명 된 설정 속성의 값을 반환 합니다.</summary>
        <returns><see cref="T:System.Object" /> 지정된 된 값이 포함 된 <see cref="T:System.Configuration.SettingsProperty" /> , 그렇지 않으면 <see langword="null" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A> 와 함께에서 메서드는 대개는 <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A> 메서드는 응용 프로그램의 새 버전을 설치 하는 동안 응용 프로그램 설정을 마이그레이션하는 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">속성이 존재 하지 않습니다. 속성 개수가 0 이거나 데이터 저장소의 속성을 찾을 수 없습니다.</exception>
        <altmember cref="T:System.Configuration.SettingsProperty" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Upgrade" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.IApplicationSettingsProvider.GetPreviousVersion(System.Configuration.SettingsContext,System.Configuration.SettingsProperty)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string propertyName] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ propertyName); void set(System::String ^ propertyName, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Configuration.ApplicationSettingsBase.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName"><see cref="T:System.String" /> 액세스 하는 속성의 이름을 포함 합니다.</param>
        <summary>지정 된 응용 프로그램 설정 속성의 값을 가져오거나 설정 합니다.</summary>
        <value>하는 경우 명명 된 설정 속성의 값 그렇지 않으면 <see langword="null" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 설정에서 파생 된 래퍼 클래스에서 속성, 인덱서 라고도 정기적으로 <xref:System.Configuration.ApplicationSettingsBase>입니다. <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 해당 설정 속성에 래퍼 클래스의 공용 속성을 바인딩합니다.  
  
 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 수행 되는 작업에 따라 여러 이벤트를 발생 시킵니다.  
  
-   속성을 검색 하 고, 처음으로 <xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded> 이벤트가 발생 합니다.  
  
-   속성을 설정할 때를 <xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A> 이벤트가 발생 합니다. 처리기가 이벤트를 취소 하지 경우 속성 값이 설정 및 <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> 이벤트가 발생 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">현재 래퍼와 관련 된 속성이 없거나 지정된 된 속성을 찾을 수 없습니다.</exception>
        <exception cref="T:System.Configuration.SettingsPropertyIsReadOnlyException">읽기 전용 속성을 설정 하려고 했습니다.</exception>
        <exception cref="T:System.Configuration.SettingsPropertyWrongTypeException">제공 된 값 집합 작업을 하는 동안 설정 속성과 호환 되지 않는 형식입니다.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">구성 파일을 구문 분석할 수 없습니다.</exception>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
        <altmember cref="P:System.Configuration.SettingsProperty.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (object sender, System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(object sender, class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (sender As Object, e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Object ^ sender, System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : obj * System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : obj * System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="applicationSettingsBase.OnPropertyChanged (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">이벤트 소스입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />입니다.</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Configuration.ApplicationSettingsBase.OnPropertyChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSettingChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingChanging (object sender, System.Configuration.SettingChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingChanging(object sender, class System.Configuration.SettingChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSettingChanging (sender As Object, e As SettingChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSettingChanging(System::Object ^ sender, System::Configuration::SettingChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSettingChanging : obj * System.Configuration.SettingChangingEventArgs -&gt; unit&#xA;override this.OnSettingChanging : obj * System.Configuration.SettingChangingEventArgs -&gt; unit" Usage="applicationSettingsBase.OnSettingChanging (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">이벤트 소스입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Configuration.SettingChangingEventArgs" />입니다.</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSettingsLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsLoaded (object sender, System.Configuration.SettingsLoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsLoaded(object sender, class System.Configuration.SettingsLoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSettingsLoaded (sender As Object, e As SettingsLoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSettingsLoaded(System::Object ^ sender, System::Configuration::SettingsLoadedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSettingsLoaded : obj * System.Configuration.SettingsLoadedEventArgs -&gt; unit&#xA;override this.OnSettingsLoaded : obj * System.Configuration.SettingsLoadedEventArgs -&gt; unit" Usage="applicationSettingsBase.OnSettingsLoaded (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingsLoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">이벤트 소스입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Configuration.SettingsLoadedEventArgs" />입니다.</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSettingsSaving">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsSaving (object sender, System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsSaving(object sender, class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSettingsSaving (sender As Object, e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSettingsSaving(System::Object ^ sender, System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSettingsSaving : obj * System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnSettingsSaving : obj * System.ComponentModel.CancelEventArgs -&gt; unit" Usage="applicationSettingsBase.OnSettingsSaving (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">이벤트 소스입니다.</param>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.CancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Configuration.ApplicationSettingsBase.OnSettingsSaving%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Properties As SettingsPropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsPropertyCollection ^ Properties { System::Configuration::SettingsPropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Configuration.SettingsPropertyCollection" Usage="System.Configuration.ApplicationSettingsBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>래퍼에 있는 설정 속성의 컬렉션을 가져옵니다.</summary>
        <value>A <see cref="T:System.Configuration.SettingsPropertyCollection" /> 모두를 포함 하는 <see cref="T:System.Configuration.SettingsProperty" /> 현재 래퍼에서 사용 되는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `get` 의 접근자는 <xref:System.Configuration.ApplicationSettingsBase.Properties%2A> 속성에서 파생 되는 설정 래퍼 클래스의 메타 데이터를 반영 <xref:System.Configuration.ApplicationSettingsBase>을 동적으로 사용 가능한 응용 프로그램 설정 속성의 집합을 확인 합니다.  
  
 <xref:System.Configuration.ApplicationSettingsBase> 만 상태 및 serialization 기본 설정의 읽을 클래스는 응용 프로그램 설정의 이름, 속성 형식, 설정 공급자, 기본값 등의 특정 특성을 고유 하 게 인식 합니다. 이러한 특징에 속성으로는 <xref:System.Configuration.SettingsProperty> 클래스입니다. 설정 속성의 다른 모든 특성은 연결 된 설정 공급자를 통해 전달 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">연결 된 설정 공급자를 찾을 수 없습니다 또는 인스턴스화하지 못했습니다.</exception>
        <altmember cref="P:System.Configuration.SettingsBase.PropertyValues" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Providers" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
        <altmember cref="T:System.Configuration.SettingsProperty" />
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PropertyChanged As PropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::PropertyChangedEventHandler ^ PropertyChanged;" />
      <MemberSignature Language="F#" Value="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " Usage="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 설정 속성의 값이 변경 된 후 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> 설정 속성을 통해 변경 될 때 이벤트가 발생 합니다 `set` 의 접근자는 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 메서드를 또는 호출 하는 경우 복원 되는 모든 속성에 대 한를 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 또는 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 메서드.  
  
 해당 없음 `PropertyChanging` 이 이벤트 클래스를 대신 참조 하세요.를 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />
        <altmember cref="T:System.ComponentModel.PropertyChangedEventArgs" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
      </Docs>
    </Member>
    <Member MemberName="PropertyValues">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyValueCollection PropertyValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyValueCollection PropertyValues" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.PropertyValues" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PropertyValues As SettingsPropertyValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsPropertyValueCollection ^ PropertyValues { System::Configuration::SettingsPropertyValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyValues : System.Configuration.SettingsPropertyValueCollection" Usage="System.Configuration.ApplicationSettingsBase.PropertyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>속성 값의 컬렉션을 가져옵니다.</summary>
        <value><see cref="T:System.Configuration.SettingsPropertyValueCollection" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Providers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Providers As SettingsProviderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::SettingsProviderCollection ^ Providers { System::Configuration::SettingsProviderCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Providers : System.Configuration.SettingsProviderCollection" Usage="System.Configuration.ApplicationSettingsBase.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>래퍼에서 사용 하는 응용 프로그램 설정 공급자의 컬렉션을 가져옵니다.</summary>
        <value>A <see cref="T:System.Configuration.SettingsProviderCollection" /> 모두를 포함 하는 <see cref="T:System.Configuration.SettingsProvider" /> 현재 설정 래퍼의 설정 속성에서 사용 되는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.SettingsProviderAttribute> 설정 공급자가 설정 래퍼 클래스 또는 개별 설정 속성에서 사용을 결정 합니다. 이 특성은 지정 하지 않으면 클라이언트 응용 프로그램을 사용할지는 <xref:System.Configuration.LocalFileSettingsProvider>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
        <altmember cref="M:System.Configuration.SettingsBase.Initialize(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection,System.Configuration.SettingsProviderCollection)" />
      </Docs>
    </Member>
    <Member MemberName="Reload">
      <MemberSignature Language="C#" Value="public void Reload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reload();" />
      <MemberSignature Language="F#" Value="member this.Reload : unit -&gt; unit" Usage="applicationSettingsBase.Reload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>영구 저장소에서 응용 프로그램 설정 속성 값을 새로 고칩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 메서드 이후에 액세스할 때 영구 저장소에서 이러한 값에 대 한 다시 로드를 유발 현재 캐시 된 속성 값을 지웁니다. 이 메서드는 다음 작업을 수행합니다.  
  
-   현재 캐시 된 속성을 나타내는 컬렉션을 선택 취소 하 여 지웁니다는 <xref:System.Configuration.SettingsBase.PropertyValues%2A> 속성입니다.  
  
-   발생 합니다 <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> 의 모든 멤버에 대 한 이벤트를 <xref:System.Configuration.ApplicationSettingsBase.Properties%2A> 컬렉션입니다.  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 와 대조 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 전자 로드 됩니다 저장 된 응용 프로그램 설정 값의 마지막 집합을 로드 하는 기본값을 저장된 하는 반면에 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 메서드 본문에서 호출 되는 <xref:System.Windows.Forms.Control.Click> 이라는 단추에 대 한 이벤트 처리기 `btnReload`합니다. 이 호출의 결과로 응용 프로그램 설정에 대 한 현재 저장 된 값은 해당 속성으로 다시 로드 됩니다. 전체 코드 예제에 나열 된는 <xref:System.Configuration.ApplicationSettingsBase> 클래스 개요입니다.  
  
 [!code-cpp[AppSettingsSample#6](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#6)]
 [!code-csharp[AppSettingsSample#6](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#6)]
 [!code-vb[AppSettingsSample#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
        <altmember cref="P:System.Configuration.SettingsBase.PropertyValues" />
        <altmember cref="M:System.Configuration.SettingsPropertyValueCollection.Clear" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Properties" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="applicationSettingsBase.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>지속형된 응용 프로그램 설정 값을 해당 기본 속성을 복원합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 메서드는 각 응용 프로그램 설정의 현재 유지 된 값을 복원 하 여 사용자 범위 설정 속성을 덮어씁니다. 이 메서드는 다음 작업을 수행합니다.  
  
-   호출 된 <xref:System.Configuration.IApplicationSettingsProvider.Reset%2A?displayProperty=nameWithType> 이 선택적 메서드를 지 원하는 모든 설정 공급자에는 메서드.  
  
-   호출 된 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 설정 속성 값을 새로 고침을 강제 하는 방법입니다.  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 와 대조 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 전자 로드 됩니다 저장 된 응용 프로그램 설정 값의 마지막 집합을 로드 하는 기본값을 저장된 하는 반면에 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 메서드 본문에서 호출 되는 <xref:System.Windows.Forms.Control.Click> 이라는 단추에 대 한 이벤트 처리기 `btnReset`합니다. 이 호출의 결과로 응용 프로그램 설정에 대 한 저장 된 기본값을 해당 속성으로 다시 로드 됩니다. 전체 코드 예제에 나열 된는 <xref:System.Configuration.ApplicationSettingsBase> 클래스 개요입니다.  
  
 [!code-cpp[AppSettingsSample#5](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#5)]
 [!code-csharp[AppSettingsSample#5](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#5)]
 [!code-vb[AppSettingsSample#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">구성 파일을 구문 분석할 수 없습니다.</exception>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
        <altmember cref="M:System.Configuration.IApplicationSettingsProvider.Reset(System.Configuration.SettingsContext)" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public override void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Save" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Save();" />
      <MemberSignature Language="F#" Value="override this.Save : unit -&gt; unit" Usage="applicationSettingsBase.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램 설정 속성의 현재 값을 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Save%2A> 메서드는 연결 된 데이터 저장소에 각 설정 속성의 현재 값을 씁니다. 각 속성에 대해이 메서드를 호출 합니다 <xref:System.Configuration.SettingsProvider.SetPropertyValues%2A> 메서드를 연결 된 설정 공급자입니다.  
  
 이 메서드는 기본 클래스 구현을 점에서 다릅니다 발생을 <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving> 값 기록 되기 전에 이벤트입니다.  
  
 정의 된 유일한 설정은 응용 프로그램 범위 설정 하는 경우 <xref:System.Configuration.ApplicationSettingsBase.Save%2A> 는 아무런 영향을 미치지 않으며 기본값을 사용 하 여 호출 하는 경우 오류가 반환 <xref:System.Configuration.LocalFileSettingsProvider>합니다. <xref:System.Configuration.LocalFileSettingsProvider> 사용자 범위 설정을 저장합니다.  
  
> [!IMPORTANT]
>  응용 프로그램 설정의 값은 자동으로 래퍼 클래스를 초기화 하는 동안 로드 때문에 해당 Load 메서드가 없습니다. 반면, 이러한 값은 응용 프로그램이 종료 될 때 자동으로 저장 되지. 명시적으로 호출 해야 하므로 <xref:System.Configuration.ApplicationSettingsBase.Save%2A> 응용 프로그램 설정의 현재 값을 유지 하는 방법입니다. 이 일반적으로 수행 합니다 <xref:System.Windows.Forms.Form.Closing> 기본 또는 포함 하는 이벤트 처리기 <xref:System.Windows.Forms.Form>합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Configuration.ApplicationSettingsBase.Save%2A> 에서 호출 되는 메서드에 <xref:System.Windows.Forms.Form.Closing> 기본 폼에 대 한 이벤트 처리기입니다. 이 메서드는 폼의 연관 된 설정 속성에 추가 기간을 추가 <xref:System.Windows.Forms.Control.Text%2A> 속성입니다.  
  
 전체 코드 예제에 나열 된는 <xref:System.Configuration.ApplicationSettingsBase> 클래스 개요입니다.  
  
 [!code-cpp[AppSettingsSample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#3)]
 [!code-csharp[AppSettingsSample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#3)]
 [!code-vb[AppSettingsSample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
        <altmember cref="M:System.Configuration.SettingsProvider.SetPropertyValues(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyValueCollection)" />
        <altmember cref="T:System.Configuration.SettingsProviderAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SettingChanging">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingChangingEventHandler SettingChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingChangingEventHandler SettingChanging" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SettingChanging As SettingChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Configuration::SettingChangingEventHandler ^ SettingChanging;" />
      <MemberSignature Language="F#" Value="member this.SettingChanging : System.Configuration.SettingChangingEventHandler " Usage="member this.SettingChanging : System.Configuration.SettingChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 설정 속성의 값이 변경 되기 전에 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 응용 프로그램 설정 값 속성을 통해 변경 되기 전에 이벤트 발생을 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 메서드. 이 이벤트는 없을 때 발생 합니다 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 또는 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 메서드를 호출 합니다. <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 통해 취소할 수는 <xref:System.Configuration.SettingChangingEventArgs> 이벤트 데이터 클래스입니다.  
  
 일반적으로 사용 하는 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 개별 설정 속성의 즉시 유효성 검사를 처리 하는 이벤트입니다. 유효성 검사에 대 한 자세한 내용은 참조 하세요. [방법: 응용 프로그램 설정의 유효성을 검사](~/docs/framework/winforms/advanced/how-to-validate-application-settings.md)합니다.  
  
 해당 없음 `SettingChanged` 이 이벤트 클래스를 대신 참조 하세요.를 <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 형식의 개체에 대 한 이벤트 처리기 `FormSettings`, 래퍼 클래스에서 파생 된 <xref:System.Configuration.ApplicationSettingsBase>합니다. 라는 텍스트 상자에 이벤트 정보를 표시 하는 처리기 `tbStatus`합니다. 전체 코드 예제에 나열 된는 <xref:System.Configuration.ApplicationSettingsBase> 클래스 개요입니다.  
  
 [!code-cpp[AppSettingsSample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#7)]
 [!code-csharp[AppSettingsSample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#7)]
 [!code-vb[AppSettingsSample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
        <altmember cref="T:System.Configuration.SettingChangingEventArgs" />
        <altmember cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/9f145ada-4267-436a-aa4c-c4dcffd0afb7">방법: 응용 프로그램 설정 유효성 검사</related>
      </Docs>
    </Member>
    <Member MemberName="SettingsKey">
      <MemberSignature Language="C#" Value="public string SettingsKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SettingsKey" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      <MemberSignature Language="VB.NET" Value="Public Property SettingsKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SettingsKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SettingsKey : string with get, set" Usage="System.Configuration.ApplicationSettingsBase.SettingsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 설정 그룹에 대 한 설정 키를 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.String" /> 현재 설정 그룹에 대 한 설정 키를 포함 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 속성은 클라이언트 코드에서 사용할 수 있도록 제공 됩니다. 특히 동일한 응용 프로그램 설정 클래스의 여러 인스턴스 간에 명확 하 게 설정 공급자를 합니다.  
  
 설정 래퍼 클래스는 단일 항목 패턴을 사용 하 여를 디자인 하지 않는 한 단일 응용 프로그램에서 동일한 응용 프로그램 설정 클래스의 여러 인스턴스가 있을 수 있습니다. 변수의 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 속성 값을 공유할 수는 방법에 따라 설정 해야 합니다.  
  
-   래퍼의 설정 속성은 동일한 응용 프로그램에서 다음 래퍼의 모든 인스턴스 간에 공유 될 경우 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 인스턴스 모두에 동일한 값이 있어야 합니다. 이 기본적으로는 <xref:System.Configuration.ApplicationSettingsBase> 클래스입니다.  
  
-   래퍼의 설정 속성을 다음 인스턴스당 수 하려는 경우 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 모든 인스턴스에 대해 고유 값이 있어야 합니다. 합니다 <xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.String%29> 생성자의 버전을 사용 하면 초기화 <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> 고유 문자열에 있습니다.  
  
 반면,는 <xref:System.Configuration.ApplicationSettingsBase.Context%2A> 속성은 효율적이 고 순차적인 방식으로 값을 유지할 수 있도록 설정 공급자에 게 힌트를 제공 합니다.  
  
 <xref:System.Configuration.SettingChangingEventArgs> 클래스는 비슷한 포함 <xref:System.Configuration.SettingChangingEventArgs.SettingKey%2A> 원인을 식별 하는 데 도움이 되는 속성을 <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Context" />
        <altmember cref="T:System.Configuration.SettingChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SettingsLoaded">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsLoadedEventHandler SettingsLoaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsLoadedEventHandler SettingsLoaded" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SettingsLoaded As SettingsLoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Configuration::SettingsLoadedEventHandler ^ SettingsLoaded;" />
      <MemberSignature Language="F#" Value="member this.SettingsLoaded : System.Configuration.SettingsLoadedEventHandler " Usage="member this.SettingsLoaded : System.Configuration.SettingsLoadedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsLoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 설정 저장소에서 검색 된 후 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded> 이벤트 발생 후에 `get` 사용을 통해 일반적으로 첫 번째 구성 속성의 액세스는 <xref:System.Configuration.ApplicationSettingsBase.Item%2A> 메서드. 후속 액세스는 로컬로 캐시 된 설정 속성의 값을 사용 합니다. 합니다 <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> 고 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> 후속 속성 액세스 하면이 이벤트가 다시 발생 하므로 메서드 모든 캐시 된 값의 선택을 취소 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
        <altmember cref="T:System.Configuration.SettingsLoadedEventArgs" />
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reset" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
      </Docs>
    </Member>
    <Member MemberName="SettingsSaving">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsSavingEventHandler SettingsSaving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsSavingEventHandler SettingsSaving" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SettingsSaving As SettingsSavingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Configuration::SettingsSavingEventHandler ^ SettingsSaving;" />
      <MemberSignature Language="F#" Value="member this.SettingsSaving : System.Configuration.SettingsSavingEventHandler " Usage="member this.SettingsSaving : System.Configuration.SettingsSavingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsSavingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>값 데이터 저장소에 저장 되기 전에 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving> 이벤트를 발생 합니다 <xref:System.Configuration.ApplicationSettingsBase.Save%2A> 연결된 된 데이터 저장소에 응용 프로그램 설정 속성에 저장 하기 전에 메서드. 연결된 된 이벤트 처리기는이 이벤트를 취소할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving> 형식의 개체에 대 한 이벤트 처리기 `FormSettings`, 래퍼 클래스에서 파생 된 <xref:System.Configuration.ApplicationSettingsBase>합니다. 처리기는 현재 응용 프로그램 설정 속성 값을 저장 하는 사용자를 쿼리 합니다. 전체 코드 예제에 나열 된는 <xref:System.Configuration.ApplicationSettingsBase> 클래스 개요입니다.  
  
 [!code-cpp[AppSettingsSample#8](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#8)]
 [!code-csharp[AppSettingsSample#8](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#8)]
 [!code-vb[AppSettingsSample#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Save" />
      </Docs>
    </Member>
    <Member MemberName="Upgrade">
      <MemberSignature Language="C#" Value="public virtual void Upgrade ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Upgrade() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Upgrade" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Upgrade ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Upgrade();" />
      <MemberSignature Language="F#" Value="abstract member Upgrade : unit -&gt; unit&#xA;override this.Upgrade : unit -&gt; unit" Usage="applicationSettingsBase.Upgrade " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 최신 설치를 반영 하도록 응용 프로그램 설정을 업데이트 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A> 메서드는 응용 프로그램의 새 버전으로 원활 하 게 전환 되도록 두 작업을 수행 합니다.  
  
-   모든 해당 설정 공급자를 호출 하 여 업그레이드 된 응용 프로그램의 존재 여부를 알려줍니다 자신의 <xref:System.Configuration.IApplicationSettingsProvider.Upgrade%2A?displayProperty=nameWithType> 메서드를 구현한 것으로 가정 합니다 <xref:System.Configuration.IApplicationSettingsProvider> 인터페이스입니다. 설정 래퍼 클래스를 사용 하 여 표시 되 면이 동작이 수행 되지 않습니다 <xref:System.Configuration.NoSettingsVersionUpgradeAttribute>합니다.  
  
-   응용 프로그램 설정의 모든 값을 다시 로드 합니다.  
  
 기본 동작을 재정의할 수 있습니다 <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A> 사용자 지정 업그레이드 하거나 병합 동작을 구현 합니다. 사용 된 <xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A> 응용 프로그램의 이전 버전에 대 한 설정에 대 한 개별 값을 검색 하는 방법입니다. 사용자 지정 업그레이드 동작의 예입니다.  
  
-   이전 사용자 지정 값 중 하나 이상을 재정의 하는 새 정책 기본값 또는 이전 기본값을 사용 합니다.  
  
-   최신 범위, 다양 한 설정 속성 그룹을 등와 호환 되도록 이전 값의 특수 변환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">구성 파일을 구문 분석할 수 없습니다.</exception>
        <altmember cref="P:System.Configuration.ApplicationSettingsBase.Providers" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.Reload" />
        <altmember cref="M:System.Configuration.ApplicationSettingsBase.GetPreviousVersion(System.String)" />
        <altmember cref="T:System.Configuration.NoSettingsVersionUpgradeAttribute" />
        <altmember cref="M:System.Configuration.IApplicationSettingsProvider.Upgrade(System.Configuration.SettingsContext,System.Configuration.SettingsPropertyCollection)" />
      </Docs>
    </Member>
  </Members>
</Type>