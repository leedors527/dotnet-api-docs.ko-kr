<Type Name="MergeOption" FullName="System.Data.Objects.MergeOption">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1d49e64ceb971f90e931f64f06cf0918327392a3" /><Meta Name="ms.sourcegitcommit" Value="19b66619a469ee45c85c618f8a605859882eb638" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/10/2019" /><Meta Name="ms.locfileid" Value="54183826" /></Metadata><TypeSignature Language="C#" Value="public enum MergeOption" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed MergeOption extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.MergeOption" />
  <TypeSignature Language="VB.NET" Value="Public Enum MergeOption" />
  <TypeSignature Language="C++ CLI" Value="public enum class MergeOption" />
  <TypeSignature Language="F#" Value="type MergeOption = " />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>개체 컨텍스트에 로드 중인 개체를 개체 컨텍스트에 이미 있는 개체와 병합하는 방법을 지정합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)]는 캐시에서 특정 엔터티 키가 있는 개체의 단일 인스턴스만 유지 관리합니다. <xref:System.Data.EntityKey> 개체는 개체의 id를 나타내는 변경할 수 없는 개체입니다. 엔터티 키는 개체 컨텍스트에서 ID 확인을 수행하는 데 사용됩니다. 자세한 내용은 [엔터티 키 작업](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd283139(v=vs.100))합니다. 데이터 원본 및 상태 관리자의 기존 데이터에서 가져온 데이터에 따라 병합 됩니다 id가 동일한 엔터티가 이미 추적 중인 경우는 <xref:System.Data.Objects.MergeOption> 쿼리 합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AppendOnly">
      <MemberSignature Language="C#" Value="AppendOnly" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption AppendOnly = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.AppendOnly" />
      <MemberSignature Language="VB.NET" Value="AppendOnly" />
      <MemberSignature Language="C++ CLI" Value="AppendOnly" />
      <MemberSignature Language="F#" Value="AppendOnly = 0" Usage="System.Data.Objects.MergeOption.AppendOnly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>개체 컨텍스트에 없는 개체가 컨텍스트에 연결됩니다. 개체가 이미 컨텍스트에 있는 경우 항목의 개체 속성에 대한 현재 값과 원래 값을 데이터 소스 값으로 덮어쓰지 않습니다. 개체의 항목 상태와 항목에 있는 개체의 속성 상태는 변경되지 않습니다. <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />가 기본 병합 옵션입니다.</summary>
      </Docs>
    </Member>
    <Member MemberName="NoTracking">
      <MemberSignature Language="C#" Value="NoTracking" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption NoTracking = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.NoTracking" />
      <MemberSignature Language="VB.NET" Value="NoTracking" />
      <MemberSignature Language="C++ CLI" Value="NoTracking" />
      <MemberSignature Language="F#" Value="NoTracking = 3" Usage="System.Data.Objects.MergeOption.NoTracking" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary>개체가 <see cref="F:System.Data.EntityState.Detached" /> 상태로 유지 관리되며 <see cref="T:System.Data.Objects.ObjectStateManager" />에서 추적되지 않습니다. 그러나 [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)]에서 생성한 엔터티 및 프록시가 있는 POCO 엔터티는 개체 컨텍스트에 대한 참조를 유지하여 관련 개체를 쉽게 로드할 수 있도록 합니다.</summary>
      </Docs>
    </Member>
    <Member MemberName="OverwriteChanges">
      <MemberSignature Language="C#" Value="OverwriteChanges" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption OverwriteChanges = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.OverwriteChanges" />
      <MemberSignature Language="VB.NET" Value="OverwriteChanges" />
      <MemberSignature Language="C++ CLI" Value="OverwriteChanges" />
      <MemberSignature Language="F#" Value="OverwriteChanges = 1" Usage="System.Data.Objects.MergeOption.OverwriteChanges" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>개체 컨텍스트에 없는 개체가 컨텍스트에 연결됩니다. 개체가 이미 컨텍스트에 있는 경우 항목의 개체 속성에 대한 현재 값과 원래 값을 데이터 소스 값으로 덮어씁니다. 개체 항목의 상태가 <see cref="F:System.Data.EntityState.Unchanged" />로 설정되고 속성이 수정되지 않은 것으로 표시됩니다.</summary>
      </Docs>
    </Member>
    <Member MemberName="PreserveChanges">
      <MemberSignature Language="C#" Value="PreserveChanges" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.Objects.MergeOption PreserveChanges = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Data.Objects.MergeOption.PreserveChanges" />
      <MemberSignature Language="VB.NET" Value="PreserveChanges" />
      <MemberSignature Language="C++ CLI" Value="PreserveChanges" />
      <MemberSignature Language="F#" Value="PreserveChanges = 2" Usage="System.Data.Objects.MergeOption.PreserveChanges" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.MergeOption</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>개체 컨텍스트에 없는 개체가 컨텍스트에 연결됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 엔터티 상태가 <xref:System.Data.EntityState.Unchanged>이면 항목의 현재 값과 원래 값이 데이터 소스 값으로 덮어쓰여집니다. 엔터티 상태가 <xref:System.Data.EntityState.Unchanged>로 유지되고 속성이 수정된 것으로 표시되지 않습니다.  
  
 엔터티 상태가 <xref:System.Data.EntityState.Modified>이면 수정된 속성의 현재 값이 데이터 소스 값으로 덮어쓰여지지 않습니다. 수정되지 않은 속성의 원래 값은 데이터 소스의 값으로 덮어쓰여집니다.  
  
 에 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 버전 4는 [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] 데이터 원본에서 반환 된 값으로 수정 되지 않은 속성의 현재 값을 비교 합니다. 값이 동일하지 않으면 속성이 수정된 것으로 표시됩니다.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 버전 3.5 SP1에서 [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)]는 데이터 소스의 값이 다른 경우에도 속성을 수정된 것으로 표시하지 않습니다.  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>를 호출하면 수정된 속성만 데이터 소스에 유지됩니다.  
  
 3.5 SP1 동작을 유지하려면 <xref:System.Data.Objects.ObjectContextOptions.UseLegacyPreserveChangesBehavior%2A>를 `true`로 설정합니다. 로컬 컨텍스트에서 변경 내용을 유지 하는 동안 낙관적 동시성 예외를 해결 하려면 PreserveChanges 옵션을 사용할 수 있습니다. 자세한 내용은 [변경 내용 저장 및 동시성 관리](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>