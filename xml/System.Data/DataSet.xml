<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71af3e1bd87cd24aa792655bc6c65a57f719c0b6" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56393920" /></Metadata><TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>데이터의 인-메모리 캐시를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>, ADO.NET 아키텍처의 주요 구성 요소는 데이터 원본에서 검색 된 데이터의 메모리 내 캐시가 있는 합니다. 합니다 <xref:System.Data.DataSet> 의 컬렉션으로 이루어져 <xref:System.Data.DataTable> 개체를 사용 하 여 서로 연결 될 수 있습니다 <xref:System.Data.DataRelation> 개체입니다. 데이터 무결성을 적용할 수도 있습니다는 <xref:System.Data.DataSet> 를 사용 하 여 합니다 <xref:System.Data.UniqueConstraint> 및 <xref:System.Data.ForeignKeyConstraint> 개체입니다. <xref:System.Data.DataSet> 개체 작업에 대한 자세한 내용은 [DataSets, DataTables 및 DataViews](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)를 참조하세요.  
  
 반면 <xref:System.Data.DataTable> 개체의 데이터를 포함 합니다 <xref:System.Data.DataRelationCollection> 테이블 계층 구조를 탐색할 수 있습니다. 에 포함 된 테이블을 <xref:System.Data.DataTableCollection> 를 통해 액세스를 <xref:System.Data.DataSet.Tables%2A> 속성. 에 액세스할 때 <xref:System.Data.DataTable> 개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다. 예를 들어 하나의 <xref:System.Data.DataTable> "mydatatable" 이름은 "Mydatatable" 라는 다른을 사용 하 여 테이블 중 하나에 대 한 검색 문자열로으로 대/소문자 구분 간주 됩니다. 그러나 "mydatatable" 존재 하 고 "Mydatatable" 하지 않습니다, 검색 문자열으로 대/소문자 구분 간주 됩니다. 작업에 대 한 자세한 내용은 <xref:System.Data.DataTable> 개체를 참조 하세요 [DataTable 만들기](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)합니다.  
  
 <xref:System.Data.DataSet> 읽고 XML 문서로 데이터 및 스키마를 쓸 수 있습니다. 데이터 및 스키마를 다음 HTTP를 통해 전송 하 고 사용할 수는 XML을 사용 하도록 설정 하는 모든 플랫폼에서 모든 애플리케이션에서 합니다. 사용 하 여 XML 스키마와 스키마를 저장할 수 있습니다 합니다 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 모두 스키마 및 데이터를 사용 하 여 저장할 수는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 스키마와 데이터 모두 포함 하는 XML 문서를 읽으려면, 사용 된 <xref:System.Data.DataSet.ReadXml%2A> 메서드.  
  
 일반적인 다중 계층 구현에서는 만들기 및 새로 고침 단계를 <xref:System.Data.DataSet>에 원래 데이터를 업데이트 하 고:  
  
1.  빌드하고 각 채우기 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet> 사용 하 여 데이터 원본에서 데이터를 사용 하 여를 <xref:System.Data.Common.DataAdapter>입니다.  
  
2.  개인의 데이터를 변경할 <xref:System.Data.DataTable> 개체 추가, 업데이트 또는 삭제 하 여 <xref:System.Data.DataRow> 개체입니다.  
  
3.  호출 된 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 하나 더 만듭니다 <xref:System.Data.DataSet> 데이터 변경 내용만 기능입니다.  
  
4.  호출을 <xref:System.Data.Common.DataAdapter.Update%2A> 메서드를 <xref:System.Data.Common.DataAdapter>, 두 번째 전달 <xref:System.Data.DataSet> 인수로.  
  
5.  호출 된 <xref:System.Data.DataSet.Merge%2A> 두 번째에서 변경 내용을 병합 하는 방법 <xref:System.Data.DataSet> 첫 번째입니다.  
  
6.  호출 된 <xref:System.Data.DataSet.AcceptChanges%2A> 에 <xref:System.Data.DataSet>합니다. 또는 호출 <xref:System.Data.DataSet.RejectChanges%2A> 변경 내용을 취소 합니다.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable> 개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>, 및 지원는 <xref:System.Runtime.Serialization.ISerializable> remoting에 대 한 인터페이스입니다. 이 두 개체는 원격으로 연결할 수 있는 유일한 ADO.NET 개체입니다.  
  
> [!NOTE]
>  클래스에서 상속 <xref:System.Data.DataSet> 종료자 억제 되었기 때문에 가비지 수집기에 의해 종료 되지 않습니다 <xref:System.Data.DataSet>합니다. 파생된 클래스를 호출할 수 있습니다는 <xref:System.GC.ReRegisterForFinalize%2A> 해당 생성자 클래스는 가비지 수집기에 의해 종료 될 수 있도록 합니다.  
  
   
  
## Examples  
 다음 예제에서는 결합 하는 여러 가지 방법 중 구성, 만들기 및 채우기는 <xref:System.Data.DataSet> 에서 합니다 **Northwind** 데이터베이스.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 유형은 다중 스레드 읽기 작업에 안전 합니다. 모든 쓰기 작업을 동기화 해야 합니다.</threadsafe>
    <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현 된 <xref:System.Data.DataSet> 생성자 매개 변수가 없는 하 고 새 인스턴스에 대 한 기본 이름이 "NewDataSet"를 만듭니다.  
  
 이름을 합니다 <xref:System.Data.DataSet> 의 XML 표현을 확인 하는 데 필요한는 <xref:System.Data.DataSet> 스키마 정의에서 최상위 요소인 문서 요소에 대 한 이름이 항상 합니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet>를 두 개 추가 <xref:System.Data.DataTable> 개체를 합니다.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName"><see cref="T:System.Data.DataSet" />의 이름입니다.</param>
        <summary>지정된 이름을 사용하여 <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이름을 합니다 <xref:System.Data.DataSet> 의 XML 표현을 확인 하는 데 필요한는 <xref:System.Data.DataSet> 문서 요소는 스키마 정의에서 최상위 수준 요소에 대 한 이름이 항상 합니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet>를 두 개의 <xref:System.Data.DataTable> 개체가 추가 됩니다.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">개체를 serialize 또는 deserialize하는 데 필요한 데이터입니다.</param>
        <param name="context">serialize된 특정 스트림의 소스와 대상입니다.</param>
        <summary>지정한 serialization 정보와 컨텍스트가 있는 <see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체</param>
        <param name="ConstructSchema">부울 값입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Data.DataSet" />이 로드된 이후 또는 <see cref="M:System.Data.DataSet.AcceptChanges" />가 마지막으로 호출된 이후에 변경된 DataSet의 모든 내용을 커밋합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모두를 <xref:System.Data.DataRow> 하 고 <xref:System.Data.DataTable> 클래스에는 <xref:System.Data.DataSet.AcceptChanges%2A> 메서드. 호출 <xref:System.Data.DataTable.AcceptChanges%2A> 에 <xref:System.Data.DataTable> 원인 수준 합니다 <xref:System.Data.DataRow.AcceptChanges%2A> 메서드 각각에 대 한 <xref:System.Data.DataRow> 호출할. 마찬가지로, 호출 <xref:System.Data.DataSet.AcceptChanges%2A> 에 <xref:System.Data.DataSet> 하면 <xref:System.Data.DataTable.AcceptChanges%2A> 각 테이블 내에서 호출할 수는 <xref:System.Data.DataSet>합니다. 이런 방식으로 수준이 여러 메서드를 호출할 수 있습니다. 호출 된 <xref:System.Data.DataSet.AcceptChanges%2A> 의 <xref:System.Data.DataSet> 호출 하 여 모든 하위 개체 (예를 들어, 테이블 및 행)에 대 한 메서드를 호출할 수 있습니다.  
  
 호출 하는 경우 `AcceptChanges` 에 `DataSet`모든 <xref:System.Data.DataRow> 아직 편집 모드에에서는 개체의 편집을 성공적으로 완료 합니다. 합니다 <xref:System.Data.DataRow.RowState%2A> 의 각 속성 <xref:System.Data.DataRow> 도 변경 됩니다. `Added` 하 고 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다.  
  
 경우는 `DataSet` 포함 <xref:System.Data.ForeignKeyConstraint> 개체를 호출 합니다 `AcceptChanges` 메서드를 <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> 적용할 합니다.  
  
> [!NOTE]
>  `AcceptChanges` 및 `RejectChanges` 에 적용 `DataRow` 관련 변경 내용 (즉, 추가, 제거, 삭제 및 수정). 스키마 나 구조 변경 내용을 적용 되지 않습니다.  
>   
>  DataAdapter 사용하여 데이터 세트를 채운 경우 AcceptChanges를 호출해도 이러한 변경 내용이 데이터 원본에 다시 복제되지 않습니다. 이 경우 호출 <xref:System.Data.Common.DataAdapter.Update%2A> 대신 합니다. 참조 [Dataadapter 사용 하 여 데이터 원본 업데이트](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md) 자세한 내용은 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataRow> 에 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet>합니다. <xref:System.Data.DataSet.AcceptChanges%2A> 에서 메서드 호출 됩니다 합니다 <xref:System.Data.DataSet>를 모두에 적용 <xref:System.Data.DataTable> 포함 된 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataSet" />의 초기화를 시작합니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소의 초기화를 시작 합니다. <xref:System.Data.DataSet.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하는 <xref:System.Data.DataSet.BeginInit%2A> 및 <xref:System.Data.DataSet.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.DataTable" /> 개체에서 문자열을 비교할 때 대/소문자를 구분하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see langword="true" /> 문자열 비교는 대/소문자 구분; 하는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.CaseSensitive%2A> 속성이 각 정렬, 검색 및 필터링 작업은 수행 하는 방법에 영향을 줍니다. <xref:System.Data.DataTable> 에 포함 된 개체를 <xref:System.Data.DataSet> 사용 하는 경우는 <xref:System.Data.DataTable.Select%2A> 메서드.  
  
 기본적으로 설정 합니다 <xref:System.Data.DataSet.CaseSensitive%2A> 속성에 대 한는 <xref:System.Data.DataSet> 설정를 <xref:System.Data.DataTable.CaseSensitive%2A> 연결 된 각 속성 <xref:System.Data.DataTable> 동일한 값으로.  
  
   
  
## Examples  
 다음 예제에서는 설정/해제는 <xref:System.Data.DataSet.CaseSensitive%2A> 속성입니다.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 테이블에서 행을 모두 제거하여 데이터의 <see cref="T:System.Data.DataSet" />을 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Data.DataSet> 바인딩되는 <xref:System.Xml.XmlDataDocument>를 호출 <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> 또는 <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> 발생 시킵니다는 <xref:System.NotSupportedException>합니다. 이 상황을 방지 하려면 한 번에 하나씩 행을 제거 하는 각 테이블에 트래버스 합니다.  
  
   
  
## Examples  
 다음 예에서는 삭제 된 <xref:System.Data.DataSet> 모든 테이블의 모든 행입니다.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 <see cref="T:System.Data.DataSet" /> 스키마, 관계 및 제약 조건을 포함하여 <see cref="T:System.Data.DataTable" />의 구조를 복사합니다. 데이터는 복사하지 않습니다.</summary>
        <returns>현재 <see cref="T:System.Data.DataSet" />과 같은 스키마를 가지지만 데이터가 없는 새 <see cref="T:System.Data.DataSet" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  이러한 클래스가 서브클래싱된 경우 서브 클래스도 복제가 됩니다.  
  
   
  
## Examples  
 다음 예제에서는의 복제본을 <xref:System.Data.DataSet> 개체의 스키마입니다.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Data.DataSet" />의 구조와 데이터를 모두 복사합니다.</summary>
        <returns>이 <see cref="T:System.Data.DataSet" />과 같은 구조(테이블 스키마, 관계 및 제약 조건)와 데이터를 가진 새 <see cref="T:System.Data.DataSet" />을 반환합니다.  
  
 <block subset="none" type="note"><para>  
 이 클래스가 서브클래싱된 경우 서브클래스도 복사됩니다.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.Copy%2A> 원래 복사본을 만드는 방법을 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>테이블이 <see cref="T:System.Data.DataTableReader" /> 컬렉션에 나타나는 순서대로 <see cref="T:System.Data.DataTable" />마다 결과 집합이 하나씩 있는 <see cref="P:System.Data.DataSet.Tables" />를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 결과 집합의 순서를 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable> 내에서 <xref:System.Data.DataSet> 는 비어 있는 것으로 표시 됩니다 빈 결과 집합 반환 된 `DataTableReader`합니다.  
  
   
  
## Examples  
 이 예제에서는 콘솔 애플리케이션을 세 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스를 추가 하는 각각에 <xref:System.Data.DataSet>합니다. 예제에서는 호출을 <xref:System.Data.DataSet.CreateDataReader%2A> 메서드와 반환된 된 내용의 표시 <xref:System.Data.DataTableReader>합니다. 결과의 순서를 설정 하는 참고 합니다 `DataTableReader` 의 순으로 제어 됩니다는 `DataTable` 매개 변수로 전달 된 인스턴스.  
  
> [!NOTE]
>  이 예제에서는 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다 `CreateDataReader`합니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 코드를 표시합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>테이블이 <see cref="T:System.Data.DataTableReader" /> 컬렉션에 나타나는 순서대로 <see cref="T:System.Data.DataTable" />마다 결과 집합이 하나씩 있는 <see cref="P:System.Data.DataSet.Tables" />를 반환합니다.</summary>
        <returns>결과 집합을 하나 이상 포함하는 <see cref="T:System.Data.DataTableReader" />이고, 소스 <see cref="T:System.Data.DataTable" />에 포함된 <see cref="T:System.Data.DataSet" /> 인스턴스에 해당합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 결과 집합의 순서를 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable> 내 합니다 <xref:System.Data.DataSet> 는 비어 있는 것은 표현 빈 결과 집합 반환 된 `DataTableReader`합니다.  
  
   
  
## Examples  
 다음 예제에서는 세 <xref:System.Data.DataTable> 인스턴스와 각 추가 <xref:System.Data.DataSet>합니다. 예제는 다음 채워진 전달 `DataSet` 를 호출 하는 프로시저에는 <xref:System.Data.DataSet.CreateDataReader%2A> 메서드를 포함 하는 모든 결과 집합을 반복 하는 진행은 <xref:System.Data.DataTableReader>합니다. 이 예제에서는 콘솔 창에 결과 표시합니다.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables"><see cref="T:System.Data.DataTableReader" />에 반환될 결과 집합의 순서를 제공하는 DataTables의 배열입니다.</param>
        <summary><see cref="T:System.Data.DataTableReader" />마다 결과 집합이 하나씩 있는 <see cref="T:System.Data.DataTable" />를 반환합니다.</summary>
        <returns>결과 집합을 하나 이상 포함하는 <see cref="T:System.Data.DataTableReader" />이고, 소스 <see cref="T:System.Data.DataTable" />에 포함된 <see cref="T:System.Data.DataSet" /> 인스턴스에 해당합니다. 반환된 결과 집합은 <paramref name="dataTables" /> 매개 변수에 의해 지정된 순서를 따릅니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 결과의 순서를 설정 한다는 보장 하기 위해 <xref:System.Data.DataTableReader>경우는 <xref:System.Data.DataTable> 내 합니다 <xref:System.Data.DataSet> 는 비어 있는 것은 표현 빈 결과 집합 반환 된 `DataTableReader`합니다. 이 오버 로드 된 버전의 목록을 제공할 수 있으므로 `DataTable` 매개 변수로 표시 되는 경우 반환 된 결과 집합 표시 되는 순서를 지정할 수 있습니다 `DataTableReader`합니다.  
  
   
  
## Examples  
 이 예제에서는 콘솔 애플리케이션을 세 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스를 추가 하는 각각에 <xref:System.Data.DataSet>합니다. 예제에서는 호출을 <xref:System.Data.DataSet.CreateDataReader%2A> 메서드와 반환된 된 내용의 표시 <xref:System.Data.DataTableReader>합니다. 결과의 순서를 설정 하는 참고 합니다 `DataTableReader` 의 순으로 제어 됩니다는 `DataTable` 매개 변수로 전달 된 인스턴스. 이 예제에서는 콘솔 창에 결과 표시합니다.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Data.DataSet" />의 이름을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Data.DataSet" />의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet> 와 지정 된 <xref:System.Data.DataSet.DataSetName%2A>합니다.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자 지정 <see cref="T:System.Data.DataSet" />를 사용하여 필터링, 검색 및 탐색 작업을 수행할 수 있도록 <see cref="T:System.Data.DataViewManager" />에 포함된 데이터의 사용자 지정 뷰를 가져옵니다.</summary>
        <value><see cref="T:System.Data.DataViewManager" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataViewManager> 반환한 합니다 <xref:System.Data.DataSet.DefaultViewManager%2A> 속성을 사용 하면 각 사용자 지정 설정을 만들 수 있습니다 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet>합니다.  
  
 얻을 때를 <xref:System.Data.DataView> 에서 <xref:System.Data.DataTable>, 필터링, 정렬 순서 및 <xref:System.Data.DataViewRowState> 설정에 따라 구성 된는 <xref:System.Data.DataSet.DefaultViewManager%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 기본값을 가져옵니다 <xref:System.Data.DataViewManager> 에 대 한는 <xref:System.Data.DataSet>, 추가 <xref:System.Data.DataTable> 에 <xref:System.Data.DataTableCollection>합니다.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="P:System.Data.DataSet.SchemaSerializationMode" />의 <see cref="T:System.Data.DataSet" />를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식화 된 역직렬화 할 때이 메서드를 호출할 수 있습니다 <xref:System.Data.DataSet> 결정할 해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />을 deserialization을 수행하는 동안 전달되는 <see cref="T:System.Data.DataSet" /> 인스턴스입니다.</param>
        <summary><see cref="P:System.Data.DataSet.SchemaSerializationMode" />의 <see cref="T:System.Data.DataSet" />를 확인합니다.</summary>
        <returns>스키마 정보가 페이로드에서 생략되었는지 여부를 나타내는 <see cref="T:System.Data.SchemaSerializationMode" /> 열거형입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식화 된 역직렬화 할 때이 메서드를 호출할 수 있습니다 <xref:System.Data.DataSet> 결정할 해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">원격 시나리오에서 deserialization을 수행하는 동안 <see langword="DataSet" />의 protected 생성자 <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 호출하는 데 사용되는 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />입니다.</param>
        <param name="context">원격 시나리오에서 deserialization을 수행하는 동안 <see langword="DataSet" />의 protected 생성자 <see cref="T:System.Runtime.Serialization.StreamingContext" />를 호출하는 데 사용되는 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />입니다.</param>
        <summary><see cref="P:System.Data.DataSet.SchemaSerializationMode" />의 <see cref="T:System.Data.DataSet" />를 확인합니다.</summary>
        <returns>스키마 정보가 페이로드에서 생략되었는지 여부를 나타내는 <see cref="T:System.Data.SchemaSerializationMode" /> 열거형입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식화 된 역직렬화 할 때이 메서드를 호출할 수 있습니다 <xref:System.Data.DataSet> 결정할 해당 <xref:System.Data.DataSet.SchemaSerializationMode%2A>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataSet" />의 초기화를 끝냅니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소의 초기화를 끝냅니다. <xref:System.Data.DataSet.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Data.DataSet.BeginInit%2A> 및 <xref:System.Data.DataSet.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>업데이트 작업을 수행할 때 제약 조건 규칙을 따르는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see langword="true" /> 경우 규칙이 적용 됩니다. 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제약 조건을 설정 합니다 <xref:System.Data.DataTable> 수준 (<xref:System.Data.DataTable.Constraints%2A> 속성). 참조 제약 조건을 만드는 방법에 대 한 자세한 내용은 [DataTable 제약 조건](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Data.DataSet> 와 하나의 테이블 열이 하나, 5 개의 행을 하나 <xref:System.Data.UniqueConstraint>합니다. 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false` 있고 각 행의 값이 동일한 값으로 설정 합니다. 경우는 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성으로 다시 설정 됩니다 `true`, <xref:System.Data.ConstraintException> 생성 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">제약 조건을 적용할 수 없는 경우</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="DataSet" />에 연결된 사용자 지정 사용자 정보의 컬렉션을 가져옵니다.</summary>
        <value>모든 사용자 지정 사용자 정보가 있는 <see cref="T:System.Data.PropertyCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ExtendedProperties%2A> 속성을 사용 하면 사용 하 여 사용자 지정 정보를 저장 하는 `DataSet`합니다. 예를 들어, 데이터를 새로 고쳐야 할 시간을 저장할 수 있습니다.  
  
 확장된 속성 형식 이어야 합니다 <xref:System.String> 하려는 경우 때 유지 된 <xref:System.Data.DataSet> XML로 작성 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 속성을 추가 합니다 <xref:System.Data.PropertyCollection> 반환한는 <xref:System.Data.DataColumn.ExtendedProperties%2A> 속성입니다. 두 번째 예제 사용자 지정 속성을 검색합니다.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>마지막으로 로드되거나 <see cref="T:System.Data.DataSet" />가 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataSet.AcceptChanges" />의 복사본을 가져옵니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>로드되거나 <see cref="T:System.Data.DataSet" />가 마지막으로 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataSet.AcceptChanges" />의 복사본을 가져옵니다.</summary>
        <returns>작업을 수행한 다음 <see cref="T:System.Data.DataSet" />를 사용하여 다시 병합할 수 있는 경우 이 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />의 변경 사항 복사본을 반환합니다. 변경된 행이 없으면 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새로 만듭니다 <xref:System.Data.DataSet> 원래의 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet> 보류 중인 변경 내용이 있는 합니다. 관계 제약 조건을 추가할 새 변경 되지 않은 행을 추가 하면 <xref:System.Data.DataSet> 경우 변경 되지 않은 행 변경된 된 행에서 외래 키에 해당 하는 기본 키를 포함 합니다. 메서드는 반환 `null` 원래에서 행이 없는 경우 <xref:System.Data.DataSet> 보류 중인 변경 내용이입니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 하나의 테이블과 두 개의 열을 10 개의 행을 사용 하 여 합니다. 두 값이 변경 되 고 하나의 행이 추가 됩니다. 변경된 된 데이터의 하위 집합을 사용 하 여 만들어집니다는 <xref:System.Data.DataSet.GetChanges%2A> 메서드. 오류를 조정한 다음 새 열은 스키마 변경 되는 하위 집합에 추가 됩니다. 때를 <xref:System.Data.DataSet.Merge%2A> 메서드를 호출 합니다 `missingSchemaAction` 로 설정 `MissingSchemaAction.Add`, 원본에 새 열 추가 됩니다 <xref:System.Data.DataSet> 개체의 스키마입니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates"><see cref="T:System.Data.DataRowState" /> 값 중 하나입니다.</param>
        <summary>마지막으로 로드되거나 <see cref="T:System.Data.DataSet" />가 호출된 후에 변경되어 <see cref="M:System.Data.DataSet.AcceptChanges" />를 기준으로 필터링된 내용이 모두 들어 있는 <see cref="T:System.Data.DataRowState" />의 복사본을 가져옵니다.</summary>
        <returns>작업을 수행한 다음 <see cref="T:System.Data.DataSet" />를 사용하여 다시 병합할 수 있는 경우 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />의 필터링된 복사본을 반환합니다. 원하는 <see cref="T:System.Data.DataRowState" /> 행이 없으면 이 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.GetChanges%2A> 메서드는 두 번째 생성 데 <xref:System.Data.DataSet> 원래에 도입 된 변경 내용만 포함 하는 개체입니다. 사용 된 `rowStates` 새 개체에 포함 될 변경 유형을 지정 하는 인수입니다.  
  
 이 원본에 다시 병합 하려면 두 복사본은 반환 된이 <xref:System.Data.DataSet>합니다. 관계 제약 조건을 부모 행 표시 않을 `Unchanged` 포함 되도록 합니다. 원하는 행이 없으면 <xref:System.Data.DataRowState> 발견 되는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 반환 되는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 하나 더 만듭니다 <xref:System.Data.DataSet> 다음 데이터 원본을 업데이트 하는 데 사용 되는 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">지정된 스키마 집합입니다.</param>
        <summary>DataSet에 대한 <see cref="T:System.Xml.Schema.XmlSchemaSet" />의 복사본을 가져옵니다.</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchemaSet" />의 복사본입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />과 연결된 serialize된 개체가 들어 있는 <see cref="T:System.Data.DataSet" />입니다.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />과 연결된 serialize된 스트림의 소스와 대상이 들어 있는 <see cref="T:System.Data.DataSet" />입니다.</param>
        <summary><see cref="T:System.Data.DataSet" />을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>serializable <see cref="T:System.Xml.Schema.XmlSchema" /> 인스턴스를 반환합니다.</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchema" /> 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 인스턴스입니다.</param>
        <param name="context">스트리밍 컨텍스트입니다.</param>
        <summary>이진 또는 XML 스트림에서 테이블 데이터를 deserialize합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에 저장된 데이터의 XML 표현을 반환합니다.</summary>
        <returns><see cref="T:System.Data.DataSet" />에 저장된 데이터를 나타내는 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 것은 호출과 동일 <xref:System.Data.DataSet.WriteXml%2A> 사용 하 여 <xref:System.Data.XmlWriteMode> 로 <xref:System.Data.XmlWriteMode.IgnoreSchema>합니다.  
  
 <xref:System.Data.DataSet.GetXml%2A> XML 문자열로 반환 하며 따라서 보다 더 많은 오버 헤드가 <xref:System.Data.DataSet.WriteXml%2A> XML 파일에 쓸 수 있습니다.  
  
 작성 하는 경우는 <xref:System.Data.DataSet> serialize 및 스키마 유추를 사용 하 여 XML 또는 웹 서비스를 사용 하 여, 열 순서 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable>, 샘플 데이터를 추가 하 고 다음 XML 형식으로 데이터를 표시 합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 이 샘플 XML 파일에 데이터 세트에서 데이터를 쓰고 XML에서 데이터 세트로 데이터를 읽는 방법을 보여줍니다. 이 샘플은 두 테이블을 사용하여 하나의 데이터 세트를 만들고 두 가지 방법으로 데이터 세트를 XML 파일(WriteXml 및 GetXml)로 내보내고, 두 가지 방법(ReadXml 및 InferXmlSchema)을 사용하여 XML 파일에서 데이터 세트를 가져옵니다.  
  
 컴파일 및 샘플을 실행 하기 전에 샘플 디렉터리에 있는 네 개의 XML 파일을 만들려고 해야 합니다. 먼저 ElementsWithAttributes.xml를 만듭니다.  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 다음으로 ElementsWithChildElementsxml.xml를 만듭니다.  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 이제 ElementsWithOnlyAttributes.xml를 만듭니다.  
  
```xml
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 마지막으로, RepeatingElements.xml를 만듭니다.  
  
```xml
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 이제 컴파일 및 다음 소스 코드를 실행할 수 있습니다.  [데이터 세트의 데이터를 XML 파일로 저장하는 방법](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)에는 이 샘플에 대한 Visual Basic 및 C# 프로젝트가 있습니다.  
  
```csharp
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에 저장된 데이터의 XML 표현에 대한 XML 스키마를 반환합니다.</summary>
        <returns><see cref="T:System.Data.DataSet" />에 저장된 데이터의 XML 표현에 대한 XML 스키마 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 것은 호출과 동일 <xref:System.Data.DataSet.WriteXmlSchema%2A>한다는 점을 제외 하는 기본 스키마만 쓰여집니다.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> XML 문자열로 반환 하며 따라서 보다 더 많은 오버 헤드가 <xref:System.Data.DataSet.WriteXmlSchema%2A> XML 파일에 쓸 수 있습니다.  
  
 작성 하는 경우는 <xref:System.Data.DataSet> serialize 및 스키마 유추를 사용 하 여 XML 또는 웹 서비스를 사용 하 여, 열 순서 변경 될 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable>, 다음 XML 형식의 스키마를 표시 합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에 새 행, 삭제된 행 또는 수정된 행을 포함하여 변경 내용이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에 새 행, 삭제된 행 또는 수정된 행을 포함하여 변경 내용이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns><see cref="T:System.Data.DataSet" />에 변경 내용이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 하나 더 만듭니다 <xref:System.Data.DataSet> 데이터 원본을 업데이트 하려면 다음 사용 되는 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates"><see cref="T:System.Data.DataRowState" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Data.DataSet" />에 새 행, 삭제된 행 또는 수정된 행을 포함하여 <see cref="T:System.Data.DataRowState" />를 기준으로 필터링된 변경 내용이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns><see cref="T:System.Data.DataSet" />에 변경 내용이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검사는 <xref:System.Data.DataSet.HasChanges%2A> 의 속성을 `DataSet` 를 호출 하기 전에 <xref:System.Data.DataSet.GetChanges%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.GetChanges%2A> 메서드를 하나 더 만듭니다 <xref:System.Data.DataSet> 다음 데이터 원본을 업데이트 하는 데 사용 되는 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Data.DataTable" /> 내의 <see cref="T:System.Data.DataSet" /> 개체에 오류가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 테이블 컬렉션에 오류가 포함 된 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 <xref:System.Data.DataTable> 에 <xref:System.Data.DataSet> 역시는 <xref:System.Data.DataTable.HasErrors%2A> 속성입니다. 사용 하 여는 `HasErrors` 의 속성을 `DataSet` 먼저 개별 확인 하기 전에 모든 테이블 오류가 있는지 확인 합니다 <xref:System.Data.DataTable> 개체입니다. 경우는 `DataTable` 오류가 합니다 <xref:System.Data.DataTable.GetErrors%2A> 의 배열을 반환 합니다 <xref:System.Data.DataRow> 오류를 포함 하는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.HasErrors%2A> 속성을 여부를 <xref:System.Data.DataSet> 개체에 오류가 있는 합니다. 그렇다면 각에 대 한 오류 <xref:System.Data.DataRow> 각 <xref:System.Data.DataTable> 출력 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에 XML 스키마를 적용합니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">스키마를 읽어올 <see langword="Stream" />입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Stream" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">스키마를 읽어올 <see langword="TextReader" />입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">스키마를 읽어올 파일의 경로를 포함한 이름입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 파일에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">스키마를 읽어올 <see langword="XMLReader" />입니다.</param>
        <param name="nsArray">스키마 유추에서 제외할 네임스페이스 URI(Uniform Resource Identifier) 문자열로 이루어진 배열입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 적용합니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />이 초기화된 후 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Data.DataSet.IsInitialized%2A>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이진 또는 XML 스트림에서 DataSet의 모든 테이블 데이터를 deserialize합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체</param>
        <summary><see langword="DataSet" />의 serialize된 표현에 대한 형식을 검사합니다.</summary>
        <returns>지정된 <see cref="T:System.Runtime.Serialization.SerializationInfo" />가 이진 형식으로 serialize된 <see langword="true" />을 나타내면 <see langword="DataSet" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 .NET Framework 인프라를 지원하며 사용자 코드에서 직접 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />이 초기화되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>구성 요소의 초기화가 완료되었음을 나타내려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태를 반환 하는 <xref:System.Data.DataSet> 이 생성 되, 예를 들어 Visual Studio에서 하는 동안. 합니다 <xref:System.Data.DataSet.BeginInit%2A> 메서드를 설정 `false` 하 고 <xref:System.Data.DataSet.EndInit%2A> 메서드를 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 <see cref="T:System.Data.DataSet" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 기술을 제공 <xref:System.Data.DataTable> 에서 검색 한 데이터를 사용 하 여는 <xref:System.Data.IDataReader> 인스턴스. 이 메서드는 동일한 기능을 제공 하지만 있습니다에서 여러 결과 집합을 로드 하는 `IDataReader` 내에서 여러 테이블에는 `DataSet`합니다.  
  
 `DataSet`에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.  
  
 `Load` 몇 가지 일반적인 시나리오는 지정 된 데이터 원본에서 데이터 가져오기 및 현재 데이터 컨테이너에 추가에서 메서드를 사용할 수 있습니다 (이 경우에 `DataSet`). 에 대 한 일반 사용법을 설명 하는 이러한 시나리오는 `DataSet`, 해당 업데이트를 설명 하 고 병합 동작입니다.  
  
 `DataSet` 동기화 하거나 단일 기본 데이터 원본을 업데이트 합니다. `DataSet` 기본 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 합니다. 또한는 `DataSet` 하나 이상의 보조 데이터 원본의 증분 데이터를 허용할 수 있습니다. `DataSet` 보조 데이터 원본과 동기화를 허용 하기 위해 변경 내용 추적에 대 한 책임을 지지 않습니다.  
  
 이러한 두 가상 데이터 원본 지정 되 면 사용자가 다음 동작 중 하나 필요로 할:  
  
-   초기화 `DataSet` 주 데이터 원본에서 합니다. 이 시나리오에서는 사용자가 빈 초기화 `DataSet` 주 데이터 원본에서 값을 사용 하 여 합니다. 하나 이상의 DataTable의 내용 수정 됩니다. 사용자는 나중에 다시 기본 데이터 소스에 변경 내용을 전파 하는입니다.  
  
-   변경 내용을 유지 하 고 기본 데이터 원본에서 다시 동기화 합니다. 이 시나리오에서는 사용자가 수행 합니다 `DataSet` 이전 시나리오에서 입력 하 고 기본 데이터 원본에서 변경 내용을 유지를 사용 하 여 증분 동기화를 수행 합니다 `DataSet`합니다.  
  
-   증분 데이터를 보조 데이터 원본에서 제공 합니다. 이 시나리오에서는 사용자가 하나 이상의 보조 데이터 원본에서 변경 내용을 병합 하 여 이러한 변경 내용을 주 데이터 원본에 다시 전파 합니다.  
  
 `Load` 메서드 수 있게 이러한 모든 시나리오입니다. 이 메서드를 사용 하면 부하 옵션 매개 변수를 지정할 수 있습니다 나타내는 방법에 있는 행을 <xref:System.Data.DataTable> 로드 중인 행과 결합 합니다. 다음 표에에서 제공 하는 다음 세 가지 로드 옵션은 <xref:System.Data.LoadOption> 열거형입니다. 각 예에서 설명 들어오는 데이터의 행의 기본 키가 기존 행의 기본 키와 일치 하는 경우 동작을 나타냅니다.  
  
|로드 옵션|설명|  
|-----------------|-----------------|  
|`PreserveChanges`(기본값)|들어오는 행의 값을 사용 하 여 행의 원래 버전을 업데이트합니다.|  
|`OverwriteChanges`|들어오는 행의 값을 사용 하 여 행의 현재 버전과 원래 버전을 업데이트합니다.|  
|`Upsert`|들어오는 행의 값을 사용 하 여 행의 현재 버전을 업데이트합니다.|  
  
 일반적으로 `PreserveChanges` 하 고 `OverwriteChanges` 사용자를 동기화 해야 하는 시나리오에 대 한 옵션은는 `DataSet` 및 기본 데이터 소스를 사용 하 여 해당 변경 합니다. `Upsert` 옵션에 하나 이상의 보조 데이터 원본에서 집계 변경 용이 하 게 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption"><see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />의 <see cref="T:System.Data.DataSet" /> 인스턴스에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="tables"><see cref="T:System.Data.DataTable" /> 메서드가 이름 및 네임스페이스 정보를 검색하는 <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> 인스턴스의 배열입니다. 이러한 테이블은 각각 이 <see cref="T:System.Data.DataTableCollection" />에 포함된 <see cref="T:System.Data.DataSet" />의 멤버여야 합니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 인스턴스의 배열을 사용해 스키마 및 네임스페이스 정보를 제공하여, 제공된 <see cref="T:System.Data.IDataReader" />를 사용하는 데이터 소스의 값으로 <see cref="T:System.Data.DataTable" />을 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 기술을 제공 <xref:System.Data.DataTable> 에서 검색 한 데이터를 사용 하 여는 <xref:System.Data.IDataReader> 인스턴스. 이 메서드는 동일한 기능을 제공 하지만 있습니다에서 여러 결과 집합을 로드 하는 <xref:System.Data.IDataReader> 내에서 여러 테이블에는 <xref:System.Data.DataSet>합니다.  
  
> [!NOTE]
>  로드 작업을 사용 하 여 실패를 <xref:System.InvalidOperationException> 하나라 들어오는 원본 데이터 열 `reader` 계산 열입니다.  
  
 합니다 `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 하 고 값 중 하나일 수 있습니다 하는 방법을 지정 하는 <xref:System.Data.LoadOption> 열거형입니다. 에 대 한 설명서를 참조 합니다 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> 이 매개 변수를 사용 하는 방법은 메서드.  
  
 합니다 `tables` 매개 변수 배열을 지정할 수 있습니다 <xref:System.Data.DataTable> 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 경우. 합니다 <xref:System.Data.DataSet.Load%2A> 메서드를 입력 한 후 각 제공 <xref:System.Data.DataTable> 단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스. 각 결과 집합 후는 <xref:System.Data.DataSet.Load%2A> 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내의 집합으로 이동 합니다.  
  
 이 메서드에 대 한 이름 확인 체계는 뒤에 있는 동일 합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드의 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet>, 두 개 더한 <xref:System.Data.DataTable> 인스턴스를 <xref:System.Data.DataSet>, 후 채우는 <xref:System.Data.DataSet> 를 사용 하 여를 <xref:System.Data.DataSet.Load%2A> 에서 데이터를 검색할 메서드를를 <xref:System.Data.DataTableReader> 두 결과 집합을 포함 하는 합니다. 마지막으로,이 예제에서는 콘솔 창에서 테이블의 내용을 표시합니다.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption"><see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />의 <see langword="DataSet" /> 인스턴스에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="tables"><see langword="Load" /> 메서드가 테이블 이름 정보를 검색하는 문자열의 배열입니다.</param>
        <summary>문자열의 배열을 사용해 <see langword="DataSet" /> 내의 테이블에 대한 이름을 제공하여, 제공된 <see cref="T:System.Data.DataSet" />를 사용하는 데이터 소스의 값으로 <see cref="T:System.Data.IDataReader" />를 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 기술을 제공 <xref:System.Data.DataTable> 에서 검색 한 데이터를 사용 하 여는 <xref:System.Data.IDataReader> 인스턴스. 이 메서드는 동일한 기능을 제공 하지만 있습니다에서 여러 결과 집합을 로드 하는 `IDataReader` 내에서 여러 테이블에는 `DataSet`합니다.  
  
> [!NOTE]
>  로드 작업을 사용 하 여 실패를 <xref:System.InvalidOperationException> 하나라 들어오는 원본 데이터 열 `reader` 계산 열입니다.  
  
 합니다 `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 하 고 값 중 하나일 수 있습니다 하는 방법을 지정 하는 <xref:System.Data.LoadOption> 열거형입니다. 에 대 한 설명서를 참조 합니다 <xref:System.Data.DataTable.Load%2A> 이 매개 변수를 사용 하는 방법은 메서드.  
  
 `tables` 매개 변수를 사용 하면 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 테이블 이름의 배열을 지정할 수 있습니다. `Load` 메서드 내에서 테이블을 찾으려고 합니다 `DataSet` 순서로 테이블 이름의 배열에서 찾은 이름 일치 합니다. 일치 하는 테이블에 있으면 해당 테이블은 현재 결과 집합의 콘텐츠를 사용 하 여 로드 됩니다. 일치 하는 테이블이 있으면 테이블의 테이블 이름 배열에 제공 된 이름을 사용 하 여 만들어지고 새 테이블의 스키마는 결과 집합에서 유추 됩니다. 각 결과 집합 후는 `Load` 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내의 집합으로 이동 합니다.  
  
 연결 된 기본 네임 스페이스 `DataSet`any, 새로 만든 각 연결 된 경우 `DataTable`합니다. 이 메서드에 대 한 이름 확인 체계는 뒤에 있는 동일 합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드의 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.  
  
   
  
## Examples  
 다음 콘솔 애플리케이션 예제는 먼저 테이블을 만듭니다 및에 판독기에서 데이터를 로드 한 <xref:System.Data.DataSet>를 사용 하 여는 `Load` 메서드. 예제 테이블을 추가한를 <xref:System.Data.DataSet> 데이터로 테이블 채우기 하려고는 <xref:System.Data.DataTableReader>합니다. 이 예제에서는에 전달 된 매개 변수를 `Load` 메서드는 존재 하지 않는 테이블 이름을 나타낼는 `Load` 메서드 매개 변수로 전달 된 이름과 일치 하도록 새 테이블을 만듭니다. 데이터가 로드 되 면이 예제에서는 모든 테이블의 내용을 콘솔 창에 표시 합니다.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption"><see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />의 <see cref="T:System.Data.DataSet" /> 인스턴스에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="errorHandler">데이터를 로드하는 동안 오류가 발생하면 호출할 <see cref="T:System.Data.FillErrorEventHandler" /> 대리자입니다.</param>
        <param name="tables"><see cref="T:System.Data.DataTable" /> 메서드가 이름 및 네임스페이스 정보를 검색하는 <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> 인스턴스의 배열입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 인스턴스의 배열을 사용해 스키마 및 네임스페이스 정보를 제공하여, 제공된 <see cref="T:System.Data.IDataReader" />를 사용하는 데이터 소스의 값으로 <see cref="T:System.Data.DataTable" />을 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.Load%2A> 메서드는 단일을 채우기 위한 기술을 제공 <xref:System.Data.DataTable> 에서 검색 한 데이터를 사용 하 여는 <xref:System.Data.IDataReader> 인스턴스. 이 메서드는 동일한 기능을 제공 하지만 있습니다에서 여러 결과 집합을 로드 하는 <xref:System.Data.IDataReader> 내에서 여러 테이블에는 <xref:System.Data.DataSet>합니다.  
  
> [!NOTE]
>  로드 작업을 사용 하 여 실패를 <xref:System.InvalidOperationException> 하나라 들어오는 원본 데이터 열 `reader` 계산 열입니다.  
  
 합니다 `loadOption` 매개 변수를 사용 하면 가져온 데이터를 기존 데이터와 상호 작용 하 고 값 중 하나일 수 있습니다 하는 방법을 지정 하는 <xref:System.Data.LoadOption> 열거형입니다. 에 대 한 설명서를 참조 합니다 <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> 이 매개 변수를 사용 하는 방법은 메서드.  
  
 합니다 `errorHandler` 매개 변수는 한 <xref:System.Data.FillErrorEventHandler> 데이터를 로드 하는 동안 오류가 발생 하면 호출 되는 프로시저를 참조 하는 대리자입니다. 합니다 <xref:System.Data.FillErrorEventArgs> 발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <xref:System.Data.DataTable> 채워지고 있습니다. 이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리 한 원하는 경우 처리를 계속 합니다. <xref:System.Data.FillErrorEventArgs> 매개 변수를 제공를 <xref:System.Data.FillErrorEventArgs.Continue%2A> 속성:이 속성을 설정 `true` 처리를 계속 하려는 고 오류를 처리 했음을 나타내려면 속성을 설정 합니다 `false` 처리를 중단 하려는 나타냅니다. 주의 해당 속성을 설정 `false` 예외를 throw 하려면 문제를 트리거한 코드를 사용 하면 됩니다.  
  
 합니다 `tables` 매개 변수 배열을 지정할 수 있습니다 <xref:System.Data.DataTable> 해당 각 결과 집합 판독기에서 로드 하는 테이블의 순서를 나타내는 경우. 합니다 <xref:System.Data.DataSet.Load%2A> 메서드를 입력 한 후 각 제공 <xref:System.Data.DataTable> 단일 결과 집합에서 원본 데이터 판독기에서에서 데이터를 사용 하 여 인스턴스. 각 결과 집합 후는 <xref:System.Data.DataSet.Load%2A> 메서드 다음 결과 결과 집합이 더 이상 없을 때까지 판독기 내의 집합으로 이동 합니다.  
  
 이 메서드에 대 한 이름 확인 체계는 뒤에 있는 동일 합니다 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드의 <xref:System.Data.Common.DbDataAdapter> 클래스입니다.  
  
   
  
## Examples  
 표를 추가 하는 다음 예제에서는 <xref:System.Data.DataSet>를 사용 하려고 시도 하 고는 <xref:System.Data.DataSet.Load%2A> 데이터를 로드 하는 방법을 <xref:System.Data.DataTableReader> 호환 되지 않는 스키마를 포함 하는 합니다. 이 예제에서는 오류를 트래핑 하는 대신 한 <xref:System.Data.FillErrorEventHandler> 조사 하 고 오류를 처리할 대리자입니다. 출력은 콘솔 창에 표시 됩니다.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블 내의 문자열을 비교하는 데 사용되는 로캘 정보를 가져오거나 설정합니다.</summary>
        <value>사용자의 컴퓨터 로캘에 대한 데이터가 들어 있는 <see cref="T:System.Globalization.CultureInfo" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Locale%2A> 속성 로캘을 지정 정렬을 적용 됩니다.  
  
 기본적으로 설정 합니다 <xref:System.Data.DataSet.Locale%2A> 에 대 한를 <xref:System.Data.DataSet> 설정를 <xref:System.Data.DataSet.Locale%2A> 각각에 대 한 <xref:System.Data.DataTable> 개체는 `DataSet` 동일한 값으로.  
  
> [!NOTE]
>  식이 포함 된 열에는 <xref:System.StringComparison.InvariantCulture> 사용 됩니다. <xref:System.StringComparison.CurrentCulture> 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Globalization.CultureInfo> 에 대 한는 <xref:System.Data.DataSet> 하 고 출력을 <xref:System.Globalization.CultureInfo.DisplayName%2A> 및 <xref:System.Globalization.CultureInfo.EnglishName%2A> 속성입니다.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" /> 또는 <see cref="T:System.Data.DataRow" /> 개체의 배열을 현재 <see langword="DataSet" /> 또는 <see langword="DataTable" />에 병합합니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows"><see langword="DataRow" />에 병합되는 <see langword="DataSet" /> 개체의 배열입니다.</param>
        <summary><see cref="T:System.Data.DataRow" /> 개체의 배열을 현재 <see cref="T:System.Data.DataSet" />에 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 이 클라이언트 애플리케이션에서는 단일 단추를 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 크기가 작기 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. 병합 끝날 때 모든 제약 조건을 사용할 수 없는 경우를 <xref:System.Data.ConstraintException> 생성 되 고 병합된 된 데이터는 제약 조건을 해제 된 동안 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">데이터와 스키마를 병합할 <see langword="DataSet" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 스키마를 현재 <see langword="DataSet" />에 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 이 클라이언트 애플리케이션에서는 단일 단추를 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 `DataRowState` 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. Merge 끝날 때 모든 제약 조건을 사용할 수 없는 경우는 <xref:System.Data.ConstraintException> 생성 되 고 제약 조건을 해제 된 동안 병합된 된 데이터는 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.GetChanges%2A>, 업데이트 및 <xref:System.Data.DataSet.Merge%2A> 메서드를 <xref:System.Data.DataSet>입니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">제약 조건을 사용할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" />이 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">데이터와 스키마를 병합할 <see cref="T:System.Data.DataTable" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" /> 및 스키마를 현재 <see cref="T:System.Data.DataSet" />에 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 이 클라이언트 애플리케이션에서는 단일 단추를 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 `DataRowState` 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. Merge 끝날 때 모든 제약 조건을 사용할 수 없는 경우는 <xref:System.Data.ConstraintException> 생성 되 고 제약 조건을 해제 된 동안 병합된 된 데이터는 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 하나의 테이블과 두 개의 열을 10 개의 행을 사용 하 여 합니다. 두 번째 <xref:System.Data.DataTable> 가 만들어집니다 첫 번째와 동일 합니다. 다음에 병합 되는 두 번째 테이블에 두 개의 행이 추가 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" />이 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">데이터와 스키마를 병합할 <see langword="DataSet" />입니다.</param>
        <param name="preserveChanges">현재 <see langword="DataSet" />의 변경 내용을 유지하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 스키마를 현재 <see langword="DataSet" />에 병합합니다. 이때 지정된 인수에 따라 이 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 이 클라이언트 애플리케이션에서는 단일 단추를 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 `DataRowState` 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. Merge 끝날 때 모든 제약 조건을 사용할 수 없는 경우는 <xref:System.Data.ConstraintException> 생성 되 고 제약 조건을 해제 된 동안 병합된 된 데이터는 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 하나의 테이블과 두 개의 열을 10 개의 행을 사용 하 여 합니다. 10 개의 행을 추가한 후 두 값이 변경 되 고 하나의 행이 추가 됩니다. 변경된 된 데이터의 하위 집합을 사용 하 여 만들어집니다는 <xref:System.Data.DataSet.GetChanges%2A> 메서드. 오류를 조정한 다음 하위 집합 데이터를 병합할 원본 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows"><see cref="T:System.Data.DataRow" />에 병합되는 <see langword="DataSet" /> 개체의 배열입니다.</param>
        <param name="preserveChanges"><see langword="DataSet" />의 변경 내용을 유지하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="missingSchemaAction"><see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Data.DataRow" /> 개체의 배열을 현재 <see cref="T:System.Data.DataSet" />에 병합합니다. 이때 지정된 인수에 따라 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제하고 호환되지 않는 스키마를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 이 클라이언트 애플리케이션에서는 단일 단추를 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 설명은 용이 하 게 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드를 사용 하 여 "target"을 현재 나타낼 <xref:System.Data.DataSet>, 및 두 번째 매개 변수인 이름을 "source" <xref:System.Data.DataSet>합니다. 대상 <xref:System.Data.DataSet> 액션 (병합) 발생 하는 개체 이기 때문에 따라서 라고 합니다. 두 번째 <xref:System.Data.DataSet> 포함 된 정보를 변경 되지 않지만 대신 현재에 병합 됩니다 때문에 "source" 라고 <xref:System.Data.DataSet>합니다.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 `DataRowState` 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. Merge 끝날 때 모든 제약 조건을 사용할 수 없는 경우는 <xref:System.Data.ConstraintException> 생성 되 고 제약 조건을 해제 된 동안 병합된 된 데이터는 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">데이터와 스키마를 병합할 <see langword="DataSet" />입니다.</param>
        <param name="preserveChanges">현재 <see langword="DataSet" />의 변경 내용을 유지하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="missingSchemaAction"><see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 스키마를 현재 <see langword="DataSet" />에 병합합니다. 이때 지정된 인수에 따라 현재 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제하고 호환되지 않는 스키마를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 이 클라이언트 애플리케이션에서는 단일 단추를 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 설명은 용이 하 게 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드를 사용 하 여 "target"을 현재 나타낼 <xref:System.Data.DataSet>, 및 두 번째 매개 변수인 이름을 "source" <xref:System.Data.DataSet>합니다. 대상 <xref:System.Data.DataSet> 액션 (병합) 발생 하는 개체 이기 때문에 따라서 라고 합니다. 두 번째 <xref:System.Data.DataSet> 포함 된 정보를 변경 되지 않지만 대신 현재에 병합 됩니다 때문에 "source" 라고 <xref:System.Data.DataSet>합니다.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 `DataRowState` 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. Merge 끝날 때 모든 제약 조건을 사용할 수 없는 경우는 <xref:System.Data.ConstraintException> 생성 되 고 제약 조건을 해제 된 동안 병합된 된 데이터는 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 하나의 테이블과 두 개의 열을 10 개의 행을 사용 하 여 합니다. 두 값이 변경 되 고 하나의 행이 추가 됩니다. 변경된 된 데이터의 하위 집합을 사용 하 여 만들어집니다는 <xref:System.Data.DataSet.GetChanges%2A> 메서드. 오류를 조정한 다음 새 열은 스키마 변경 되는 하위 집합에 추가 됩니다. 때를 <xref:System.Data.DataSet.Merge%2A> 메서드를 호출 합니다 `missingSchemaAction` 로 설정 `MissingSchemaAction.Add`, 원본에 새 열 추가 됩니다 <xref:System.Data.DataSet> 개체의 스키마입니다.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" />이 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">데이터와 스키마를 병합할 <see langword="DataTable" />입니다.</param>
        <param name="preserveChanges"><see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <param name="missingSchemaAction"><see langword="DataSet" />의 변경 내용을 유지하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" /> 및 스키마를 현재 <see langword="DataSet" />과 병합합니다. 이때 지정된 인수에 따라 현재 <see langword="DataSet" />의 변경 내용을 유지하거나 삭제하고 호환되지 않는 스키마를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 두 개의 병합 데 <xref:System.Data.DataSet> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 애플리케이션에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataSet>합니다. 이렇게 하면 클라이언트 애플리케이션을 새로 고칠 수 있습니다. <xref:System.Data.DataSet> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 합니다 <xref:System.Data.DataSet.Merge%2A> 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataSet>합니다.  
  
 단일 단추 하려면 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 일반적인 iOn 클라이언트 애플리케이션을 것입니다. 이 시나리오에서는 <xref:System.Data.DataSet.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataSet> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataSet> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataSet>합니다. 이 하위 집합은 일반적으로 작은 및 따라서 더 효율적으로 다시는 중간 계층 구성 요소에 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataSet> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataSet> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataSet.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataSet> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataSet> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataSet> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataSet> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 `DataRowState` 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
 병합 하는 동안 제약 조건 비활성화 됩니다. Merge 끝날 때 모든 제약 조건을 사용할 수 없는 경우는 <xref:System.Data.ConstraintException> 생성 되 고 제약 조건을 해제 된 동안 병합된 된 데이터는 유지 됩니다. 이 경우에 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성이 `false`, 유효 하지 않은 모든 행이 오류가 표시 됩니다. 다시 설정 하기 전에 오류를 해결 해야 합니다 <xref:System.Data.DataSet.EnforceConstraints%2A> 속성을 `true`입니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 <xref:System.Data.DataSet> 하나의 테이블과 두 개의 열을 10 개의 행을 사용 하 여 합니다. 두 번째 <xref:System.Data.DataTable> 가 만들어집니다 거의 동일 하지만 첫 번째 점을 제외 하 고 새 `DataColumn` 테이블에 추가 됩니다. 두 개의 행 다음에 병합 되는 두 번째 테이블에 추가 됩니다는 <xref:System.Data.DataSet> 사용 하 여는 `preserveChanges` 인수와 함께 `false`, 및 `missingSchemaAction` 인수와 함께 `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" />이 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>대상과 소스 <see cref="T:System.Data.DataRow" />의 기본 키 값이 같고 <see cref="P:System.Data.DataSet.EnforceConstraints" />를 true로 설정한 경우 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 된 <xref:System.Data.DataSet.MergeFailed> 이벤트입니다.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />의 네임스페이스를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Data.DataSet" />의 네임스페이스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Namespace%2A> 속성은 읽기 및 쓰기를 XML로 문서화 하는 경우 사용 합니다 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, 또는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 문서의 네임 스페이스는 XML 특성 및 요소를 읽을 때 범위 하는 데 사용 되는 <xref:System.Data.DataSet>합니다. 예를 들어 경우는 <xref:System.Data.DataSet> 스키마가 포함 되어 "myCompany," 네임 스페이스를 사용 하 여 문서에서 읽은 다른 네임 스페이스를 사용 하 여 문서에서에서 데이터를 읽을 하려고 시도 하 고 기존 스키마에 해당 하지 않는 데이터 모두 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.Prefix%2A> 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">네임스페이스에 데이터가 이미 있는 경우</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />입니다.</param>
        <summary><see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스 <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 메서드.</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">제거 중인 <see cref="T:System.Data.DataRelation" />입니다.</param>
        <summary><see cref="T:System.Data.DataRelation" />에서 <see cref="T:System.Data.DataTable" /> 개체를 제거할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제거할 테이블의 제한에 대 한 서브 클래스에서이 메서드를 재정의 해야 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">제거 중인 <see cref="T:System.Data.DataTable" />입니다.</param>
        <summary><see cref="T:System.Data.DataTable" />에서 <see cref="T:System.Data.DataSet" />을 제거할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 제거 되는 테이블의 제한에 대 한 서브 클래스에서 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서 파생 된 클래스를 보여 줍니다.는 <xref:System.Data.DataSet> 사용 하 여는 <xref:System.Data.DataSet.OnRemoveTable%2A> 메서드를 재정의 합니다.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> 네임스페이스의 별칭인 XML 접두사를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Data.DataSet" /> 네임스페이스의 XML 접두사입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.Prefix%2A> 속성은 네임 스페이스에 속하는 요소를 식별 하는 XML 문서 전체에서 사용 합니다 <xref:System.Data.DataSet> 개체 (에서 설정 된를 <xref:System.Data.DataSet.Namespace%2A> 속성).  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataSet.Prefix%2A> 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">변경될 속성의 이름입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 속성이 변경될 것이라는 알림을 보냅니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 스키마와 데이터를 <see cref="T:System.Data.DataSet" />으로 읽어옵니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" />에서 파생되는 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.Stream" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함 `targetNamespace`데이터를 읽을 수 있습니다, 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드를 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나를 사용 하 여 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. 합니다 <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 되는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 스키마 및 데이터로 채우는 데 있습니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">스키마와 데이터를 읽어올 <see langword="TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.TextReader" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함 `targetNamespace`데이터를 읽을 수 있습니다, 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드를 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 클래스에서 상속 되는 <xref:System.IO.TextReader> 클래스를 포함 합니다 <xref:System.IO.StreamReader> 및 <xref:System.IO.StringReader> 클래스입니다.  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나를 사용 하 여 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. 합니다 <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 되는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 스키마 및 데이터로 채우는 데 있습니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">읽어올 파일의 경로를 포함한 이름입니다.</param>
        <summary>지정된 파일을 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.DataSet" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함을 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나를 사용 하 여 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. 합니다 <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 되는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 스키마 및 데이터로 채우는 데 있습니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Xml.XmlReader" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함을 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType>는 <xref:System.Xml.XmlReader>에서 상속됩니다.  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나를 사용 하 여 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. 합니다 <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 되는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 스키마 및 데이터로 채우는 데 있습니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">읽어올 <see cref="T:System.IO.Stream" />입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.IO.Stream" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  사용 하는 경우 <xref:System.Data.DataSet.ReadXml%2A> 설정 <xref:System.Data.XmlReadMode> 하 `Diffgram`, 대상의 내용을 `DataSet` 원래 `DataSet` diffgram 생성 되 고 처리 하는 방법으로 인해 달라질 수 있습니다. Diffgram에 대 한 자세한 내용은 참조 하세요. [Diffgram](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함 `targetNamespace`데이터를 읽을 수 있습니다, 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드를 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.IO.TextReader" />입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.IO.TextReader" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함 `targetNamespace`데이터를 읽을 수 있습니다, 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드를 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">읽어올 파일의 경로를 포함한 이름입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 파일과 <see cref="T:System.Data.DataSet" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함을 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlReadMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" /> 및 <see cref="T:System.Xml.XmlReader" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Data.XmlReadMode" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see langword="XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataSet> XML 문서에서 반면는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `mode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.WriteXml%2A> 및 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataSet`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
 경우에 대 한 XML 스키마를 <xref:System.Data.DataSet> 포함을 `targetNamespace`, 데이터를 읽을 수 있습니다, 그리고 및를 호출할 때 예외가 발생할 수 있습니다 <xref:System.Data.DataSet.ReadXml%2A> 로드 하는 <xref:System.Data.DataSet> 정규화 네임 스페이스가 없는 요소가 포함 된 XML을 사용 하 여 합니다. 비 정규화 된 요소를 읽으려면 설정 `elementFormDefault` 같음 "qualified" XML 스키마에서 다음 예제 에서처럼 합니다.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXml%2A> 지정 하 여 `XmlReadMode.ReadSchema`입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 스키마를 <see cref="T:System.Data.DataSet" />으로 읽어옵니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">읽어올 <see cref="T:System.IO.Stream" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Stream" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataSet>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
 파생 된 클래스는 <xref:System.IO.Stream> 클래스에 포함 <xref:System.IO.BufferedStream>를 <xref:System.IO.FileStream>를 <xref:System.IO.MemoryStream>, 및 <xref:System.Net.Sockets.NetworkStream>합니다.  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 예외가 throw에 스키마를 읽을 때 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXmlSchema%2A>입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 <xref:System.IO.FileStream> 개체를 사용 하 여 XML 스키마 읽기를 호출 하는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 개체를 사용 하 여 메서드.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.IO.TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataSet>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
 클래스에서 상속 되는 <xref:System.IO.TextReader> 클래스를 포함 합니다 <xref:System.IO.StreamReader> 및 <xref:System.IO.StringReader> 클래스입니다.  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 예외가 throw에 스키마를 읽을 때 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXmlSchema%2A>입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 <xref:System.IO.StreamReader> 를 사용 하 여 스키마를 읽거나 개체를 호출 하는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 개체를 사용 하 여 메서드.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">읽을 파일 이름(경로 포함)입니다.</param>
        <summary>지정된 파일에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataSet>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 스키마를 읽을 하려고 할 때 예외가 throw 됩니다 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXmlSchema%2A>입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">읽어올 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlReader" />에서 <see cref="T:System.Data.DataSet" />으로 XML 스키마를 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataSet>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
> [!NOTE]
>  Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 <xref:System.Data.DataSet.ReadXmlSchema%2A> 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataSet.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataSet>합니다.  
  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType> 추상 클래스입니다. 상속 된 클래스는 `XmlReader` 는 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> 클래스입니다.  
  
> [!NOTE]
>  경우에 대 한 스키마에 <xref:System.Data.DataSet> 요소가 동일한 이름 이지만 동일한 네임 스페이스에 다른 종류의 예외가 throw에 스키마를 읽을 때 합니다 <xref:System.Data.DataSet> 사용 하 여 <xref:System.Data.DataSet.ReadXmlSchema%2A>입니다. .NET Framework 버전 1.0 사용 하는 경우에이 예외가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataSet> 고 <xref:System.IO.FileStream?displayProperty=nameWithType> 개체입니다. 합니다 <xref:System.IO.FileStream> 파일 경로 파일 이름을 사용 하 여 만든 개체를 만드는 데 사용 되는 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> 인수로 전달 되는 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">지정된 XML 판독기입니다.</param>
        <summary>특성을 무시하고 빈 DataSet을 반환합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />이 만들어진 이후 또는 <see cref="M:System.Data.DataSet.AcceptChanges" />가 마지막으로 호출된 이후에 해당 DataSet에서 변경된 내용을 모두 롤백합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출을 <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> 를 호출 하는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> 모든 메서드 <xref:System.Data.DataTable> 포함 된 개체는 <xref:System.Data.DataSet>합니다.  
  
 <xref:System.Data.DataRow> 포함 된 개체를 <xref:System.Data.DataSet> 를 호출 하 여 편집 모드로 설정할 수 있습니다는 <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> 메서드. 호출한 후는 <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> 메서드를 호출 하 여 변경 내용을 거부 될 수 있습니다는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> 에 <xref:System.Data.DataTable> 는 <xref:System.Data.DataRow> 개체가 속한 합니다.  
  
 경우는 <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> 메서드가 호출 되 면 편집 모드에서 모든 행의 편집이 취소 합니다. 새 행이 제거 됩니다. 원래 상태로 다시 수정 및 삭제 된 행 반환 (`DataRowState.Unchanged`).  
  
 AcceptChanges 및 RejectChanges에만 적용 <xref:System.Data.DataRow> 관련 변경 내용 (즉, `Add`를 `Remove`를 `Delete`, 및 `Modify`). 스키마 나 구조 변경 내용을 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는에서 파생 된 클래스는 <xref:System.Data.DataSet> 클래스입니다. <xref:System.Data.DataSet.RejectChanges%2A> 이벤트 함수 내에서 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블을 연결하고 부모 테이블에서 자식 테이블까지 탐색할 수 있는 관계 컬렉션을 가져옵니다.</summary>
        <value><see cref="T:System.Data.DataRelationCollection" /> 개체 컬렉션을 포함하는 <see cref="T:System.Data.DataRelation" />입니다. <see cref="T:System.Data.DataRelation" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 출력을 통해 모든 자식 테이블의 열 이름을 <xref:System.Data.DataSet.Relations%2A> 속성입니다.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>원격 작업 동안 사용된 <see cref="T:System.Data.SerializationFormat" />의 <see cref="T:System.Data.DataSet" />을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Data.SerializationFormat" /> 개체입니다.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 테이블을 지우고 <see cref="T:System.Data.DataSet" />에서 모든 관계, 외래 제약 조건 및 테이블을 제거합니다. 서브클래스에서 <see cref="M:System.Data.DataSet.Reset" />을 재정의하여 <see cref="T:System.Data.DataSet" />을 원래 상태로 복원해야 합니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.SchemaSerializationMode" />에 대한 <see cref="T:System.Data.DataSet" />를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Data.SchemaSerializationMode" />에 대한 <see cref="T:System.Data.DataSet" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet> 웹 서비스와 remoting 시나리오에서 기본적으로 해당 스키마 및 인스턴스 데이터를 serialize 합니다. 설정 합니다 <xref:System.Data.DataSet.SchemaSerializationMode%2A> 형식화 된 속성 `DataSet` 에 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 인해 serialization 페이로드에서 제외할 스키마 정보입니다.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 지원 되는 형식화 된 동안만 `DataSet`합니다. 형식화 되지 않은 `DataSet` 이 속성 설정할 수 있습니다 <xref:System.Data.SchemaSerializationMode.IncludeSchema>합니다.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 여기서 기본 스키마 정보를 입력 하는 경우에만 사용 해야 `DataTables`, `DataRelations` 및 `Constraints` 수정 되지 않았습니다. 사용 하 여 발생 한, 완전 한 스키마 정보를 serialize 해야 수정 작업이 필요한 경우 <xref:System.Data.SchemaSerializationMode.IncludeSchema>합니다.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 2.0 이상 버전의.NET Framework에서 지원 됩니다.  
  
 때 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 설정할지를 최상위 수준 런타임 속성에는 <xref:System.Data.DataSet> serialize 됩니다. 또한 기본 값을 다르게 발생 하는 경우에 serialize 합니다. 하나도 합니다 `Tables`, `Relations` 또는 `Constraints` serialize 됩니다. 직렬화 런타임 속성을 포함 <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>를 <xref:System.Data.DataSet.Prefix%2A>를 <xref:System.Data.DataSet.Locale%2A>를 <xref:System.Data.DataSet.EnforceConstraints%2A>, 및 <xref:System.Data.DataSet.CaseSensitive%2A>합니다. 이러한 속성은 전체 런타임 데이터 무결성 유지 되는지 확인 하려면 serialize 됩니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Data.DataSet.Relations" /> 속성을 유지해야 하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>속성 값이 기본값에서 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 중 하나에 대 한 디자이너를 만드는 경우 일반적으로이 메서드를 사용 합니다 <xref:System.Data.DataSet>를 포함 하는 고유한 컨트롤을 만드는 <xref:System.Data.DataSet>합니다.  
  
   
  
## Examples  
 다음 예제에서 파생 된 클래스를 표시 합니다 <xref:System.Data.DataSet> 클래스입니다. 합니다 <xref:System.Data.DataSet.Reset%2A> 고 <xref:System.Data.DataSet.ShouldSerializeRelations%2A> 메서드는 파생된 클래스에서 함수 내에서 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Data.DataSet.Tables" /> 속성을 유지해야 하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns>속성 값이 기본값에서 변경되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하거나에 대 한 디자이너를 만드는 경우에이 메서드를 일반적으로 사용 합니다 <xref:System.Data.DataSet>를 포함 하는 고유한 컨트롤을 만드는 <xref:System.Data.DataSet>합니다.  
  
   
  
## Examples  
 다음 예제에서는에서 파생 된 클래스는 <xref:System.Data.DataSet> 클래스입니다. <xref:System.Data.DataSet.ShouldSerializeTables%2A> 메서드는 파생된 클래스에서 함수 내에서 호출 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataSet" />를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataSet" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사이트 바인딩를 <xref:System.ComponentModel.Component> 에 <xref:System.ComponentModel.Container> 서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />를 참조하십시오.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.ComponentModel.IListSource.GetList" />를 참조하세요.</summary>
        <returns>이 멤버에 대한 설명은 <see cref="M:System.ComponentModel.IListSource.GetList" />를 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">데이터로 채울 <see cref="T:System.Runtime.Serialization.SerializationInfo" />입니다.</param>
        <param name="context">이 serialization에 대한 대상입니다(<see cref="T:System.Runtime.Serialization.StreamingContext" /> 참조).</param>
        <summary><see cref="T:System.Data.DataSet" />을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하십시오.</summary>
        <returns>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /></param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /></param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에 포함된 테이블 컬렉션을 가져옵니다.</summary>
        <value>이 <see cref="T:System.Data.DataTableCollection" />에 포함된 <see cref="T:System.Data.DataSet" />입니다. <see cref="T:System.Data.DataTable" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 테이블 컬렉션에 추가 하려면 사용 하 여 <xref:System.Data.DataTableCollection.Add%2A> 메서드는 <xref:System.Data.DataTableCollection>합니다. 테이블을 제거 하려면 사용 된 <xref:System.Data.DataTableCollection.Remove%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 반환 된 <xref:System.Data.DataSet> 개체의 <xref:System.Data.DataTableCollection>, 하 고 각 테이블에서 행 및 열을 출력 합니다.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />에서 XML 데이터를 쓰고 선택적으로 스키마를 씁니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">파일에 쓸 때 사용되는 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />을 사용하여 <see cref="T:System.IO.Stream" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.FileStream?displayProperty=nameWithType> 개체입니다. 다음 개체를 사용 하 여 사용 하는 <xref:System.Data.DataSet.WriteXml%2A> XML 문서를 작성 하는 방법입니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />을 사용하여 <see cref="T:System.IO.TextWriter" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 대상 파일 이름(경로 포함)입니다.</param>
        <summary>지정된 파일에 <see cref="T:System.Data.DataSet" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.Xml.XmlWriter" />의 현재 데이터를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `mode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">파일에 쓸 때 사용되는 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />와 <see cref="T:System.IO.Stream" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정 합니다 `mode` 매개 변수를 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 작성하는 데 사용되는 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />와 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정 합니다 `mode` 매개 변수를 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한을 먼저 만듭니다 <xref:System.Data.DataSet> 하나를 사용 하 여 <xref:System.Data.DataTable>, 두 개의 열과 10 개 행입니다. 합니다 <xref:System.Data.DataSet> 스키마와 데이터를 호출 하 여 디스크에 기록 되는 <xref:System.Data.DataSet.WriteXml%2A> 메서드. 두 번째 <xref:System.Data.DataSet> 만들어집니다 및 <xref:System.Data.DataSet.ReadXml%2A> 메서드는 스키마 및 데이터로 채우는 데 있습니다.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 대상 파일 이름(경로 포함)입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />를 사용하여 지정된 파일에 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정 합니다 `mode` 매개 변수를 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataSet.WriteXml%2A> 메서드는 XML 문서를 작성 합니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <param name="mode"><see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />와 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataSet> XML 문서로 반면는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 설정 합니다 `mode` 매개 변수를 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataSet.ReadXml%2A> 및 <xref:System.Data.DataSet.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataSet`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.IO.FileStream?displayProperty=nameWithType> 개체를 만들기 위한 사용 되는 <xref:System.Xml.XmlTextWriter>합니다. <xref:System.Xml.XmlTextWriter> 개체를 사용 합니다 <xref:System.Data.DataSet.WriteXml%2A> 메서드는 XML 문서를 작성 합니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> 구조를 XML 스키마로 씁니다.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">파일에 쓸 때 사용되는 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 구조체를 지정된 <see cref="T:System.IO.Stream" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataSet> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
 파생 된 클래스는 <xref:System.IO.Stream> 클래스에 포함 <xref:System.IO.BufferedStream>를 <xref:System.IO.FileStream>를 <xref:System.IO.MemoryStream>, 및 <xref:System.Net.Sockets.NetworkStream>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.IO.FileStream> 에 전달 되는 개체는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드를 디스크에 스키마를 씁니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 구조체를 지정된 <see cref="T:System.IO.TextWriter" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataSet> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
 클래스에서 파생 되는를 <xref:System.IO.TextWriter?displayProperty=nameWithType> 클래스를 포함 합니다 <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, 및 <xref:System.IO.StringWriter?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder?displayProperty=nameWithType> 개체를 새로 만드는 데 사용 됩니다 <xref:System.IO.StringWriter?displayProperty=nameWithType>합니다. 합니다 <xref:System.IO.StringWriter> 에 전달 되는 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드와 결과 문자열이 콘솔 창에 출력 됩니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 대상 파일 이름(경로 포함)입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 구조를 파일에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataSet> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />이 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />로 설정되지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓸 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 구조를 <see cref="T:System.Xml.XmlWriter" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataSet.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataSet> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다. 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataSet.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataSet.WriteXml%2A> 메서드.  
  
 하나의 클래스에서 상속 되는 <xref:System.Xml.XmlWriter?displayProperty=nameWithType> 클래스는를 <xref:System.Xml.XmlTextWriter> 클래스입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.IO.FileStream?displayProperty=nameWithType> 지정된 된 경로 사용 하 여 개체입니다. 합니다 <xref:System.IO.FileStream> 개체를 만드는 데 사용 되는 <xref:System.Xml.XmlTextWriter> 개체입니다. 합니다 <xref:System.Data.DataSet.WriteXmlSchema%2A> 후 메서드가 호출 됩니다는 <xref:System.Xml.XmlTextWriter> 스키마 디스크에 쓸 개체입니다.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">ADO.NET에서 데이터 세트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">쓸 <see cref="T:System.IO.Stream" /> 개체입니다.</param>
        <param name="multipleTargetConverter"><see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 구조체를 지정된 <see cref="T:System.IO.Stream" /> 개체에 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">쓸 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <param name="multipleTargetConverter"><see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.IO.TextWriter" /> 구조를 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">쓸 파일의 이름입니다.</param>
        <param name="multipleTargetConverter"><see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary><see cref="T:System.Data.DataSet" /> 구조를 파일에 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">쓸 <see cref="T:System.Xml.XmlWriter" /> 개체입니다.</param>
        <param name="multipleTargetConverter"><see cref="T:System.Type" />을 문자열로 변환하는 데 사용되는 대리자입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataSet" />에 <see cref="T:System.Xml.XmlWriter" /> 구조를 XML 스키마로 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>