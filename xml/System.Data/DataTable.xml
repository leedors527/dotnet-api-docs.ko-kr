<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="300369f702f863e5f202e1c54c0a83eb9edf7782" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52918437" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>메모리 내 데이터의 한 테이블을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable> ADO.NET 라이브러리의 중앙 개체입니다. 사용 하는 다른 개체를 <xref:System.Data.DataTable> 포함 된 <xref:System.Data.DataSet> 및 <xref:System.Data.DataView>.  
  
 에 액세스할 때 <xref:System.Data.DataTable> 개체, 조건에 따라 대/소문자 구분 되는지 확인 합니다. 예를 들어 하나의 <xref:System.Data.DataTable> "mydatatable" 이름은 "Mydatatable" 라는 다른을 사용 하 여 테이블 중 하나에 대 한 검색 문자열로으로 대/소문자 구분 간주 됩니다. 그러나 "mydatatable" 존재 하 고 "Mydatatable" 하지 않습니다, 검색 문자열으로 대/소문자 구분 간주 됩니다. A <xref:System.Data.DataSet> 두 개를 포함할 수 있습니다 <xref:System.Data.DataTable> 는 동일 개체 <xref:System.Data.DataTable.TableName%2A> 속성 값은 같지만 다른 <xref:System.Data.DataTable.Namespace%2A> 속성 값입니다. 작업에 대 한 자세한 내용은 <xref:System.Data.DataTable> 개체를 참조 하세요 [DataTable 만들기](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)합니다.  
  
 만들려는 경우는 <xref:System.Data.DataTable> 프로그래밍 방식으로 정의 해야 해당 스키마를 추가 하 여 <xref:System.Data.DataColumn> 개체를 <xref:System.Data.DataColumnCollection> (통해 액세스를 <xref:System.Data.DataTable.Columns%2A> 속성). 추가 하는 방법에 대 한 자세한 내용은 <xref:System.Data.DataColumn> 개체를 참조 하세요 [DataTable에 열 추가](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)합니다.  
  
 행을 추가할를 <xref:System.Data.DataTable>를 먼저 사용 해야 합니다 <xref:System.Data.DataTable.NewRow%2A> 새 반환 하는 방법 <xref:System.Data.DataRow> 개체입니다. 합니다 <xref:System.Data.DataTable.NewRow%2A> 의 스키마를 사용 하 여 행을 반환 하는 메서드를 <xref:System.Data.DataTable>테이블의 정의 된 대로, <xref:System.Data.DataColumnCollection>합니다. 최대 행을 <xref:System.Data.DataTable> 수 저장소는 16777216 합니다. 자세한 내용은 [DataTable에 데이터 추가](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)합니다.  
  
 합니다 <xref:System.Data.DataTable> 의 컬렉션도 포함 <xref:System.Data.Constraint> 데이터의 무결성을 확인 하는 데 사용할 수 있습니다. 자세한 내용은 [DataTable 제약 조건](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)합니다.  
  
 여러 <xref:System.Data.DataTable> 테이블에 변경 내용이 시기를 결정 하는 이벤트입니다. 이것에는 <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> 및 <xref:System.Data.DataTable.RowDeleted>가 있습니다. 사용 하 여 사용할 수 있는 이벤트에 대 한 자세한를 <xref:System.Data.DataTable>를 참조 하세요 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
 인스턴스가 <xref:System.Data.DataTable> 를 만드는 경우 일부의 읽기/쓰기 속성 초기 값으로 설정 됩니다. 이러한 값의 목록을 보려면 참조는 <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> 생성자 항목입니다.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> 및 <xref:System.Data.DataTable> 개체에서 상속 <xref:System.ComponentModel.MarshalByValueComponent>를 지원 하 고는 <xref:System.Runtime.Serialization.ISerializable> .NET Framework remoting에 대 한 인터페이스입니다. 이들은.NET Framework remoting에 사용할 수 있는 유일한 ADO.NET 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 <xref:System.Data.DataTable> 개체와 하나의 <xref:System.Data.DataRelation> 개체를 새 개체를 추가 <xref:System.Data.DataSet>합니다. 테이블에 표시 되는 <xref:System.Windows.Forms.DataGridView> 제어 합니다.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 이 샘플에는 특정 스키마 정의가 포함 된 DataTable를 수동으로 만들어야 하는 방법을 보여 줍니다.  
  
-   여러 Datatable을 만들고 첫 열을 정의 합니다.  
  
-   테이블 제약 조건을 만듭니다.  
  
-   값을 삽입 하 고 테이블을 표시 합니다.  
  
-   식 열을 만들고 테이블을 표시 합니다.  
  
 이 코드 샘플을 사용 하 여 C# 및 Visual Basic 프로젝트에서 찾을 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)합니다.  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 유형은 다중 스레드 읽기 작업에 안전 합니다. 모든 쓰기 작업을 동기화 해야 합니다.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>인수를 사용하지 않고 <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 속성에 대 한 초기 값을 설정 하는 생성자를 <xref:System.Data.DataTable> 개체입니다. 다음 표에서 속성 및 기본값을 보여 줍니다. 인스턴스가 <xref:System.Data.DataTable> 만들어지면 다음 읽기/쓰기 속성 초기 값으로 설정 됩니다.  
  
|속성|기본값|  
|--------------|-------------------|  
|**CaseSensitive**|부모와 동일한 <xref:System.Data.DataSet>이면 하나에 속합니다. 그렇지 않으면 `false`입니다.|  
|**DisplayExpression**|빈 문자열 ("")|  
|**로캘**|부모와 동일한 <xref:System.Data.DataSet> 개체의 <xref:System.Globalization.CultureInfo> (반환한 합니다 <xref:System.Data.DataSet.Locale%2A> 속성) 부모가 없으면; 기본값은 현재 시스템 <xref:System.Globalization.CultureInfo>입니다.|  
|**MinimumCapacity**|50 개 행입니다.|  
  
 속성에 별도 호출을 통해 이러한 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Data.DataTable> 사용 하 여 <xref:System.Data.DataColumn> 하 고 <xref:System.Data.DataRow>를 표시를 <xref:System.Windows.Forms.DataGridView> 컨트롤입니다.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">테이블에 지정할 이름입니다. <paramref name="tableName" />이 <see langword="null" /> 또는 빈 문자열이면 <see cref="T:System.Data.DataTableCollection" />에 테이블이 추가될 때 기본 이름이 지정됩니다.</param>
        <summary>지정된 테이블 이름을 사용하여 <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 한 <xref:System.Data.DataTable> 에 표시를 <xref:System.Windows.Forms.DataGridView> 컨트롤입니다.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">개체를 serialize 또는 deserialize하는 데 필요한 데이터입니다.</param>
        <param name="context">serialize된 특정 스트림의 소스와 대상입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />와 <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 사용하여 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현의 합니다 <xref:System.Data.DataTable> 생성자에 필요 <xref:System.Runtime.Serialization.ISerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">테이블에 지정할 이름입니다. <paramref name="tableName" />이 <see langword="null" /> 또는 빈 문자열이면 <see cref="T:System.Data.DataTableCollection" />에 테이블이 추가될 때 기본 이름이 지정됩니다.</param>
        <param name="tableNamespace">
          <see langword="DataTable" />에 저장된 데이터의 XML 표현에 대한 네임스페이스입니다.</param>
        <summary>지정된 테이블 이름과 네임스페이스를 사용하여 <see cref="T:System.Data.DataTable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.Data.DataTable.AcceptChanges" />가 마지막으로 호출된 이후 이 테이블에서 변경된 내용을 모두 커밋합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Data.DataTable.AcceptChanges%2A> 가 호출 된 <xref:System.Data.DataRow> 아직 편집 모드에에서는 개체의 편집을 성공적으로 종료 합니다. 합니다 <xref:System.Data.DataRowState> 도 변경: 모든 `Added` 하 고 `Modified` 될 행 `Unchanged`, 및 `Deleted` 행이 제거 됩니다.  
  
 <xref:System.Data.DataTable.AcceptChanges%2A> 메서드를 일반적으로 호출을 <xref:System.Data.DataTable> 업데이트 하려고 하면 후 합니다 <xref:System.Data.DataSet> 를 사용 하 여를 <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 각 테이블의 오류를 테스트합니다. (전달 하 여 정의 되지 않은 함수), 테이블의 오류를 해결할 수 있으면 <xref:System.Data.DataTable.AcceptChanges%2A> 이 고, 그렇지 않으면 호출 <xref:System.Data.DataTable.RejectChanges%2A> 라고 합니다.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataTable" />의 초기화를 시작합니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소의 초기화를 시작 합니다. <xref:System.Data.DataTable.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하는 <xref:System.Data.DataTable.BeginInit%2A> 및 <xref:System.Data.DataTable.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>데이터를 로드하는 동안 알림, 인덱스 유지 관리 및 제약 조건 기능을 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Data.DataTable.BeginLoadData%2A> 와 함께에서 <xref:System.Data.DataTable.LoadDataRow%2A> 고 <xref:System.Data.DataTable.EndLoadData%2A>입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블 내의 문자열을 비교할 때 대/소문자를 구분할지 여부를 나타냅니다.</summary>
        <value>비교할 때 대/소문자를 구분하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 부모 <see cref="T:System.Data.DataSet" /> 개체의 <see cref="P:System.Data.DataSet.CaseSensitive" /> 속성으로 설정되거나, <see cref="T:System.Data.DataTable" />과 별도로 만들어진 <see cref="T:System.Data.DataSet" />의 경우 <see langword="false" />로 설정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A> 문자열 정렬, 검색 및 필터링을 비교 하는 속성에 영향을 줍니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataTable.Select%2A> 메서드를 두 번을 <xref:System.Data.DataTable>입니다. 처음으로는 <xref:System.Data.DataTable.CaseSensitive%2A> 속성이 `false`를 두 번째 `true`입니다.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Data.DataTable" />에 대한 자식 관계 컬렉션을 가져옵니다.</summary>
        <value>테이블의 자식 관계가 포함된 <see cref="T:System.Data.DataRelationCollection" />입니다. <see cref="T:System.Data.DataRelation" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataRelation> 두 테이블 간의 관계를 정의 합니다. 일반적으로 두 테이블은 동일한 데이터를 포함 하는 단일 필드를 통해 연결 됩니다. 예를 들어 주소 데이터를 포함 하는 테이블에는 국가/지역을 나타내는 코드를 포함 하는 단일 필드가 있을 수 있습니다. 국가/지역 데이터를 포함 하는 두 번째 테이블에서 국가/지역을 식별 하는 코드를 포함 하는 단일 필드로 있고이 코드가 첫 번째 테이블의 해당 필드에 삽입 됩니다. <xref:System.Data.DataRelation>, 적어도 4 가지 정보를 포함 한: (1) 첫 번째 테이블의 이름, 첫 번째 테이블의 열 이름 (2), (3) 두 번째 테이블의 이름 및 (4) 두 번째 테이블의 열 이름입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataTable.ChildRelations%2A> 각 자식에 반환할 속성 <xref:System.Data.DataRelation> 에 <xref:System.Data.DataTable>합니다. 각 관계에 대 한 인수로 사용 됩니다는 <xref:System.Data.DataRow.GetChildRows%2A> 메서드는 <xref:System.Data.DataRow> 행의 배열을 반환 하도록 합니다. 행의 각 열 값이 출력 합니다.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />의 모든 데이터를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 테이블의 모든 행이 제거 됩니다. 테이블에 자식 관계가 적용된는 자식 행이 분리 될 경우 예외가 생성 됩니다.  
  
 경우는 <xref:System.Data.DataSet> 바인딩되는 <xref:System.Xml.XmlDataDocument>를 호출 <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> 또는 <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> 발생 시킵니다는 <xref:System.NotSupportedException>합니다. 이 상황을 방지 하려면 한 번에 하나씩 행을 제거 하는 각 테이블에 트래버스 합니다. 사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A> 새 행을 만들려면는 행을 처리 해야 호출 하기 전에 <xref:System.Data.DataTable.Clear%2A>입니다.  
  
   
  
## Examples  
 다음 예제에서는 모든 데이터의 테이블을 지웁니다.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 <see cref="T:System.Data.DataTable" /> 스키마, 관계 및 제약 조건을 포함하여 <see cref="T:System.Data.DataTable" />의 구조를 복제합니다.</summary>
        <returns>현재 <see cref="T:System.Data.DataTable" />과 동일한 스키마를 갖는 새 <see cref="T:System.Data.DataTable" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 클래스를 파생 된 경우 동일한 파생된 클래스가 복제가 됩니다.  
  
 복제를 만듭니다 <xref:System.Data.DataTable> 와 동일한 구조로 원래 <xref:System.Data.DataTable>, 모든 데이터를 복사 하지 않습니다 (새 <xref:System.Data.DataTable> 포함 되지 것입니다 `DataRows`). 새 구조와 데이터를 복사할 <xref:System.Data.DataTable>를 사용 하 여 <xref:System.Data.DataTable.Copy%2A>입니다.  
  
   
  
## Examples  
 다음 샘플 DataTable.Clone 실행 한 후 대상 테이블의 제약 조건을 확인 하 고 구조를 업데이트 하는 방법에 설명 합니다. 대상 테이블을 반환 하 고 모든 업데이트 이벤트를 포함 하는 ClonedDataTable 클래스. 복제 후 원본 테이블의 구조 변경 내용은 대상 테이블에 반영 되지 않습니다. 특히이 샘플은:  
  
-   원본 테이블의 열 변경 내용을 업데이트 합니다.  
  
-   원본 테이블에서 UniqueConstraint의 변경 내용을 업데이트 합니다.  
  
-   원본 테이블의 외래 키의 변경 내용을 업데이트 합니다.  
  
 이 코드 샘플을 사용 하 여 C# 및 Visual Basic 프로젝트에서 찾을 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)합니다.  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 이 샘플에서는 DataTable에서 데이터를 수정 하 고 데이터 소스를 업데이트 하는 방법을 보여 줍니다.  
  
 먼저 데이터베이스를 만듭니다.  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 이제 컴파일 및 샘플을 실행할 수 있습니다. [DataTable에 데이터 원본에 대 한 업데이트는 데이터를 수정 하는 방법](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) 이 샘플의 Visual Basic 및 C# 프로젝트가 있습니다.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataColumn" />에 있는 지정된 <see cref="T:System.Data.DataRow" />의 값이 변경된 후 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataColumn" />에 있는 지정된 <see cref="T:System.Data.DataRow" />의 값이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 테이블에 속한 열의 컬렉션을 가져옵니다.</summary>
        <value>테이블의 <see cref="T:System.Data.DataColumnCollection" /> 개체 컬렉션이 포함된 <see cref="T:System.Data.DataColumn" />입니다. <see cref="T:System.Data.DataColumn" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection> 각 열의 데이터 형식을 정의 하 여 테이블의 스키마를 결정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하 여 테이블의 각 행의 값을 출력 합니다 <xref:System.Data.DataTable.Columns%2A> 속성입니다.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">계산할 식입니다.</param>
        <param name="filter">식에서 계산하는 행을 제한할 필터입니다.</param>
        <summary>필터 조건을 전달하는 현재 행에서 지정된 식을 계산합니다.</summary>
        <returns>계산 결과로 설정된 <see cref="T:System.Object" />를 반환합니다. 식이 null로 평가되는 경우 반환 값은 <see cref="F:System.DBNull.Value" />가 됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression` 매개 변수는 집계 함수가 필요 합니다. 예를 들어, 다음은 올바른 식입니다.  
  
 `Count(Quantity)`  
  
 하지만이 식이 아닙니다.  
  
 `Sum (Quantity * UnitPrice)`  
  
 두 개 이상의 열에 대 한 작업을 수행 해야 하는 경우 만든를 <xref:System.Data.DataColumn>설정, 해당 <xref:System.Data.DataColumn.Expression%2A> 속성을 적절 한 식 및 결과 열에 집계 식 사용 합니다. 지정 된 경우에 <xref:System.Data.DataColumn> 이름 "합계"를 사용 하 여 및 <xref:System.Data.DataColumn.Expression%2A> 이 설정 된 속성:  
  
 `"Quantity * UnitPrice"`  
  
 에 대 한 expression 인수는 <xref:System.Data.DataTable.Compute%2A> 메서드 같게 됩니다.이:  
  
 `Sum(total)`  
  
 두 번째 매개 변수를 `filter`, 식에 사용 될 행을 결정 합니다. 예를 들어, 테이블 "colDate" 라는 날짜 열에 있으면 다음 식 사용 하 여 행을 제한할 수 있습니다.  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 두 매개 변수에 대 한 식 작성에서 규칙에 대 한 참조를 <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 id 번호는 5 개 판매 직원에 대 한 "Total" 이라는 열 값을 합산 합니다.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 테이블이 유지하는 제약 조건의 컬렉션을 가져옵니다.</summary>
        <value>테이블의 <see cref="T:System.Data.ConstraintCollection" /> 개체 컬렉션이 포함된 <see cref="T:System.Data.Constraint" />입니다. <see cref="T:System.Data.Constraint" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.ForeignKeyConstraint> 열 (또는 열)의 값이 삭제 되거나 업데이트 될 때 수행 하는 작업을 제한 합니다. 이러한 제약 조건이 기본 키 열과 함께 사용할 것입니다. 두 테이블 간에 부모/자식 관계에서 부모 테이블에서 값을 삭제할 영향을 줄 수 자식 행에서 다음 방법 중 하나입니다.  
  
-   자식 행 수도 있습니다 (연계 동작)를 삭제 합니다.  
  
-   자식 열 (또는 열)의 값은 null 값으로 설정할 수 있습니다.  
  
-   자식 열 (또는 열)의 값을 기본값으로 설정할 수 있습니다.  
  
-   예외를 생성할 수 있습니다.  
  
 <xref:System.Data.UniqueConstraint> 고유 하지 않은 값으로 기본 키에 값을 설정 하려고 할 때 활성화 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 추가 <xref:System.Data.ForeignKeyConstraint> 제약 조건의 컬렉션입니다.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Data.DataTable" />의 구조와 데이터를 모두 복사합니다.</summary>
        <returns>이 <see cref="T:System.Data.DataTable" />과 같은 구조(테이블 스키마, 관계, 제약 조건)와 데이터를 가진 새 <see cref="T:System.Data.DataTable" />을 반환합니다.  
  
이 클래스가 파생된 경우 동일한 파생 클래스가 복사됩니다.  
  
 <see cref="M:System.Data.DataTable.Copy" />는 원래 <see cref="T:System.Data.DataTable" />과 동일한 구조 및 데이터로 새 <see cref="T:System.Data.DataTable" />를 만듭니다. 구조체를 새 <see cref="T:System.Data.DataTable" />로 복사하고 데이터는 복사하지 않으려면 <see cref="M:System.Data.DataTable.Clone" />을 사용하십시오.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataTable.Copy%2A> 원래 복사본을 만드는 방법을 <xref:System.Data.DataTable>합니다. 부모 로부터 상속 되는 경우에 네임 스페이스 이름을 유지 되지 않습니다 <xref:System.Data.DataTable> 또는 <xref:System.Data.DataSet>합니다.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Data.DataTableReader" />의 데이터에 해당하는 <see cref="T:System.Data.DataTable" />를 반환합니다.</summary>
        <returns>결과 집합 하나를 포함하고 소스 <see cref="T:System.Data.DataTableReader" /> 인스턴스에 해당하는 <see cref="T:System.Data.DataTable" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 콘솔 응용 프로그램에서는 <xref:System.Data.DataTable> 인스턴스를 만듭니다. 예제는 다음 채워진 전달 <xref:System.Data.DataTable> 호출 된 프로시저에는 <xref:System.Data.DataTable.CreateDataReader%2A> 내에 포함 된 결과 반복 하는 메서드를 <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />의 새 인스턴스를 만듭니다.</summary>
        <returns>새 식입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 테이블이 속한 <see cref="T:System.Data.DataSet" />을 가져옵니다.</summary>
        <value>이 테이블이 속한 <see cref="T:System.Data.DataSet" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤은 데이터 바인딩할를 <xref:System.Data.DataTable>, 테이블에 속해를 <xref:System.Data.DataSet>를 가져올 수 있습니다는 <xref:System.Data.DataSet> 이 속성을 통해.  
  
   
  
## Examples  
 다음 예제에서는 부모를 반환 합니다. <xref:System.Data.DataSet> 를 통해 지정된 된 테이블의는 <xref:System.Data.DataTable.DataSet%2A> 속성입니다.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>필터링된 뷰를 포함할 수 있는 테이블의 사용자 지정 뷰 또는 커서 위치를 가져옵니다.</summary>
        <value>
          <see cref="T:System.Data.DataView" />와 연결된 <see cref="T:System.Data.DataTable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A> 속성에서 반환을 <xref:System.Data.DataView> 정렬, 필터 및 검색에 사용할 수는 <xref:System.Data.DataTable>합니다.  
  
   
  
## Examples  
 속성을 설정 하는 다음 예제는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataView> 를 통해를 <xref:System.Data.DataTable.DefaultView%2A> 속성입니다. 또한이 예에서는 바인딩을 <xref:System.Windows.Forms.DataGridView> 컨트롤을 <xref:System.Data.DataTable> "CompanyName." 라는 열이 포함 된 "공급자" 라는  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 테이블을 사용자 인터페이스에 나타내는 데 사용되는 값을 반환하는 식을 가져오거나 설정합니다. <see langword="DisplayExpression" /> 속성을 사용하여 이 테이블의 이름을 사용자 인터페이스에 표시할 수 있습니다.</summary>
        <value>표시 문자열입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼에 사용되거나 다른 구성 요소에서 사용하는 <see cref="T:System.Data.DataTable" />의 초기화를 끝냅니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio 디자인 환경이이 메서드를 사용 하 여 폼에 사용 되거나 다른 구성 요소에서 사용 하는 구성 요소의 초기화를 끝냅니다. <xref:System.Data.DataTable.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Data.DataTable.BeginInit%2A> 및 <xref:System.Data.DataTable.EndInit%2A> 메서드 컨트롤을 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>데이터를 로드한 후 알림, 인덱스 유지 관리 및 제약 조건 기능을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Data.DataTable.EndLoadData%2A> 와 함께에서 <xref:System.Data.DataTable.LoadDataRow%2A> 고 <xref:System.Data.DataTable.BeginLoadData%2A>입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자 지정 사용자 정보 컬렉션을 가져옵니다.</summary>
        <value>사용자 지정 사용자 정보가 들어 있는 <see cref="T:System.Data.PropertyCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.ExtendedProperties%2A> 사용자 지정 정보를 추가 하는 <xref:System.Data.DataTable>합니다. 추가 정보는 `Add` 메서드. 사용 하 여 정보를 검색 합니다 `Item` 메서드.  
  
 확장된 속성 유형 이어야 <xref:System.String>합니다. 문자열 형식이 아닌 속성 유지 되지 않습니다 경우는 <xref:System.Data.DataTable> XML로 작성 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 타임 스탬프 값을 추가 합니다 <xref:System.Data.DataTable> 를 통해를 <xref:System.Data.DataTable.ExtendedProperties%2A> 속성.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>초기화가 진행 중인지 여부를 확인합니다. 초기화는 런타임에 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>마지막으로 로드되거나 <see cref="T:System.Data.DataTable" />가 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataTable.AcceptChanges" />의 복사본을 가져옵니다.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>로드되거나 <see cref="T:System.Data.DataTable" />가 마지막으로 호출된 후에 변경된 내용이 모두 들어 있는 <see cref="M:System.Data.DataTable.AcceptChanges" />의 복사본을 가져옵니다.</summary>
        <returns>이 <see cref="T:System.Data.DataTable" />의 변경 내용의 복사본을 반환하거나, 변경 내용이 없으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새로 만듭니다 <xref:System.Data.DataSet> 원래의 모든 행의 복사본이 포함 된 <xref:System.Data.DataSet> 보류 중인 변경 내용이 있는 합니다. 관계 제약 조건을 추가할 새 변경 되지 않은 행을 추가 하면 <xref:System.Data.DataSet> 경우 변경 되지 않은 행 변경된 된 행에서 외래 키에 해당 하는 기본 키를 포함 합니다. 메서드는 반환 `null` (`Nothing` Visual basic에서) 원본에서 행이 없는 경우 <xref:System.Data.DataSet> 사용 하 여 보류 중인 변경 내용입니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 값 중 하나입니다.</param>
        <summary>마지막으로 로드되거나 <see cref="T:System.Data.DataTable" />가 호출된 후에 변경되어 <see cref="M:System.Data.DataTable.AcceptChanges" />를 기준으로 필터링된 내용이 모두 들어 있는 <see cref="T:System.Data.DataRowState" />의 복사본을 가져옵니다.</summary>
        <returns>작업을 수행한 다음 <see cref="T:System.Data.DataTable" />를 사용하여 다시 <see cref="T:System.Data.DataTable" />에 병합할 수 있는 경우 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />의 필터링된 복사본을 반환합니다. 원하는 <see cref="T:System.Data.DataRowState" /> 행이 없으면 이 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.GetChanges%2A> 메서드는 두 번째 생성 데 <xref:System.Data.DataTable> 원래에 도입 된 변경 내용만 포함 하는 개체입니다. 사용 된 `rowStates` 새 개체에 포함 될 변경 유형을 지정 하는 인수입니다.  
  
 관계 제약 조건에는 변경 되지 않은 부모 행이 포함 되도록 발생할 수 있습니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 인스턴스입니다.</param>
        <summary>이 메서드는 웹 서비스의 <see cref="T:System.Xml.Schema.XmlSchemaSet" />을 설명하는 WSDL(Web Services Description Language)이 포함된 <see cref="T:System.Data.DataTable" /> 인스턴스를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>오류가 있는 <see cref="T:System.Data.DataRow" /> 개체로 이루어진 배열을 가져옵니다.</summary>
        <returns>오류가 있는 <see cref="T:System.Data.DataRow" /> 개체로 이루어진 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 목록을 반환 <xref:System.Data.DataRow> 이 있는 개체 <xref:System.Data.DataRow.RowError%2A> 설정 합니다. 호출할 때 오류가 발생할 수 있습니다 예를 들어 <xref:System.Data.Common.DataAdapter.Update%2A> 사용 하 여 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 로 `true`합니다. 호출 하지 마십시오 <xref:System.Data.DataTable.AcceptChanges%2A> 에 <xref:System.Data.DataTable> 모든 오류를 해결 하 고 다시 전송 될 때까지 <xref:System.Data.DataSet> 업데이트 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataTable.GetErrors%2A> 배열을 반환 하는 방법 <xref:System.Data.DataRow> 오류가 있는 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">DataTable(ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" />과 관련된 serialize된 개체가 들어 있는 <see cref="T:System.Data.DataTable" /> 개체입니다.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" />과 관련된 serialize된 스트림의 소스와 대상이 들어 있는 <see cref="T:System.Data.DataTable" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 매개 변수가 null 참조(Visual Basic의 경우 <see langword="Nothing" />)입니다.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>행 형식을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Data.DataRow" />의 형식을 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</summary>
        <returns>
          <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 메서드에 의해 생성되고 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> 메서드가 사용하는 개체의 XML 표현을 설명하는 <see cref="T:System.Xml.Schema.XmlSchema" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 테이블이 속하는 <see cref="T:System.Data.DataSet" />의 테이블에 있는 행에 오류가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>오류가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 작업에 포함 된 데이터 집합에는 <xref:System.Data.DataTable>, 변경으로 인해 일부 유효성 검사 실패 하는 경우 각 변경에 오류를 표시할 수 있습니다. 전체를 표시할 수 있습니다 <xref:System.Data.DataRow> 사용 하 여 오류 메시지는 <xref:System.Data.DataRow.RowError%2A> 속성입니다. 오류가 있는 행의 각 열에 설정할 수도 있습니다는 <xref:System.Data.DataRow.SetColumnError%2A> 메서드.  
  
 데이터 소스를 업데이트 하기 전에 <xref:System.Data.DataSet>를 먼저 호출 하는 것이 좋습니다는 <xref:System.Data.DataSet.GetChanges%2A> 대상 메서드 <xref:System.Data.DataSet>합니다. 메서드 결과 <xref:System.Data.DataSet> 원본에 대 한 변경 내용만 포함 하는 합니다. 보내기 전에 <xref:System.Data.DataSet> 업데이트에 대 한 데이터 원본에 확인을 <xref:System.Data.DataTable.HasErrors%2A> 오류 행 이나 행의 열에 연결 되는 경우를 확인 하려면 각 테이블의 속성입니다.  
  
 각 오류를 해결 한 후 사용 하 여 오류를 지울 합니다 <xref:System.Data.DataRow.ClearErrors%2A> 메서드는 `DataRow`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.HasErrors%2A> 속성을 테이블에 오류가 포함 되어 있는지 확인 합니다.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">가져올 <see cref="T:System.Data.DataRow" />입니다.</param>
        <summary>원래 값 및 현재 값과 모든 속성 설정을 그대로 유지한 상태로 <see cref="T:System.Data.DataRow" />를 <see cref="T:System.Data.DataTable" />에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Data.DataTable.NewRow%2A> 기존 테이블 스키마를 사용 하 여 테이블에 있지만 행에 대 한 기본값을 사용 하 여 행을 추가 하 고 설정 합니다 <xref:System.Data.DataRowState> 에 `Detached`입니다. 호출 <xref:System.Data.DataTable.ImportRow%2A> 기존 유지 <xref:System.Data.DataRowState> 행의 다른 값과 함께 합니다. 경우는 `DataRow` 전달 된 분리 된 상태의 매개 변수는는 무시 되 고 예외가 throw 되지 않습니다.  
  
 새 행을 데이터 테이블의 끝에 추가 됩니다.  
  
 새 행에는 제약 조건을 위반 하는 경우에 데이터 테이블에 추가할 수 없습니다.  
  
 DataTable.Rows.Find DataTable.Rows.IndexOf로 사용 하 여 새 행의 인덱스를 가져올 수 있습니다. 자세한 내용은 <xref:System.Data.DataRowCollection> 및 <xref:System.Data.DataTable.Rows%2A>를 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5cb86d48-a987-4af4-80e0-8cc2c8373d62">DataTable (ADO.NET)에서 데이터를 조작합니다.</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />이 초기화된 후 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Data.DataTable.IsInitialized%2A>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />이 초기화되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>구성 요소의 초기화가 완료되었음을 나타내려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태를 반환 하는 <xref:System.Data.DataTable> 이 생성 되, 예를 들어 Visual Studio에서 하는 동안. 합니다 <xref:System.Data.DataTable.BeginInit%2A> 메서드를 설정 `false` 하 고 <xref:System.Data.DataTable.EndInit%2A> 메서드를 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다. <see langword="DataTable" />에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` 몇 가지 일반적인 시나리오는 지정 된 데이터 원본에서 데이터 가져오기 및 현재 데이터 컨테이너에 추가에서 메서드를 사용할 수 있습니다 (이 경우에 `DataTable`). 에 대 한 일반 사용법을 설명 하는 이러한 시나리오는 `DataTable`, 해당 업데이트를 설명 하 고 병합 동작입니다.  
  
 `DataTable` 동기화 하거나 단일 기본 데이터 원본을 업데이트 합니다. `DataTable` 기본 데이터 소스와 동기화 할 수 있도록 변경 내용을 추적 합니다. 또한는 `DataTable` 하나 이상의 보조 데이터 원본의 증분 데이터를 허용할 수 있습니다. `DataTable` 보조 데이터 원본과 동기화를 허용 하기 위해 변경 내용 추적에 대 한 책임을 지지 않습니다.  
  
 이러한 두 가상 데이터 원본 지정 되 면 사용자가 다음 동작 중 하나 필요로 할:  
  
-   초기화 `DataTable` 주 데이터 원본에서 합니다. 이 시나리오에서는 사용자가 빈 초기화 `DataTable` 주 데이터 원본에서 값을 사용 하 여 합니다. 사용자는 나중에 다시 기본 데이터 소스에 변경 내용을 전파 하는입니다.  
  
-   변경 내용을 유지 하 고 기본 데이터 원본에서 다시 동기화 합니다. 이 시나리오에서는 사용자가 수행 합니다 `DataTable` 이전 시나리오에서 입력 하 고 기본 데이터 원본에서 변경 내용을 유지를 사용 하 여 증분 동기화를 수행 합니다 `DataTable`합니다.  
  
-   증분 데이터를 보조 데이터 원본에서 제공 합니다. 이 시나리오에서는 사용자가 하나 이상의 보조 데이터 원본에서 변경 내용을 병합 하 여 이러한 변경 내용을 주 데이터 원본에 다시 전파 합니다.  
  
 `Load` 메서드 수 있게 이러한 모든 시나리오입니다. 하나를 제외한 모든 오버 로드 중에이 메서드를 사용 하면 부하 옵션 매개 변수를 지정할 수 있습니다를 나타내는 방법에 있는 행을 <xref:System.Data.DataTable> 로드 중인 행과 결합 합니다. (오버 로드의 동작을 지정할 수는 기본 로드 옵션을 사용 합니다.) 다음 표에에서 제공 하는 다음 세 가지 로드 옵션은 <xref:System.Data.LoadOption> 열거형입니다. 각 예에서 설명 들어오는 데이터의 행의 기본 키가 기존 행의 기본 키와 일치 하는 경우 동작을 나타냅니다.  
  
|로드 옵션|설명|  
|-----------------|-----------------|  
|`PreserveChanges`(기본값)|들어오는 행의 값을 사용 하 여 행의 원래 버전을 업데이트합니다.|  
|`OverwriteChanges`|들어오는 행의 값을 사용 하 여 행의 현재 버전과 원래 버전을 업데이트합니다.|  
|`Upsert`|들어오는 행의 값을 사용 하 여 행의 현재 버전을 업데이트합니다.|  
  
 일반적으로 `PreserveChanges` 하 고 `OverwriteChanges` 사용자를 동기화 해야 하는 시나리오에 대 한 옵션은는 `DataSet` 및 기본 데이터 소스를 사용 하 여 해당 변경 합니다. `Upsert` 옵션에 하나 이상의 보조 데이터 원본에서 집계 변경 용이 하 게 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 호출을 사용 하 여 관련 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드. 예제에서 로드 된 스키마를 유추 등의 스키마 문제에 집중 하는 먼저 <xref:System.Data.IDataReader>, 및 다음 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다. 이 예제에서는 다음 데이터 문제를 포함 하 여 다양 한 로드 옵션에 중점을 둡니다.  
  
> [!NOTE]
>  이 예제에서는 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다 `Load`합니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <summary>제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다. <see cref="T:System.Data.DataTable" />에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터가 기존 행과 병합됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.Load%2A> 첫 번째 결과 집합의 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>를 성공적으로 완료 한 후 설정 판독기의 위치를 다음 결과 집합에 있는 경우. 데이터를 변환 하는 경우는 `Load` 와 같은 변환 규칙을 사용 하는 메서드를 <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> 메서드.  
  
 합니다 <xref:System.Data.DataTable.Load%2A> 메서드를 고려해 야 합니다 세 가지 특정 문제에서 데이터를 로드 하는 경우는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다. 스키마를 사용 하 여 작업 하는 경우는 <xref:System.Data.DataTable.Load%2A> 메서드는 다음 표에 설명 된 대로 조건이 발생할 수 있습니다. 스키마 작업 수행도 포함 하는 데이터가 없는 모든 가져온된 결과 집합에 대 한 합니다.  
  
|조건|동작|  
|---------------|--------------|  
|<xref:System.Data.DataTable> 에 스키마가 없는 합니다.|합니다 <xref:System.Data.DataTable.Load%2A> 메서드는 가져온에서 결과 집합에 따라 스키마를 유추 <xref:System.Data.IDataReader>합니다.|  
|<xref:System.Data.DataTable> 스키마를 갖지만 로드 된 스키마와 호환 되지 않습니다.|<xref:System.Data.DataTable.Load%2A> 메서드 호환 되지 않는 스키마로 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.|  
|스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 된 <xref:System.Data.DataTable>합니다.|합니다 <xref:System.Data.DataTable.Load%2A> 추가 열을 추가 하는 메서드 `DataTable`의 스키마입니다. 메서드는 해당 하는 경우 예외를 throw에서 열을 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 합니다. 또한 메서드는 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다. Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보는 경우에 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.|  
|스키마가 호환 되지만 보다 적은 개수의 열을 포함 하는 로드 된 결과 집합 스키마에는 `DataTable`합니다.|누락 된 열에 기본값이 정의 또는 열의 데이터 형식이 null을 허용 하는 경우는 <xref:System.Data.DataTable.Load%2A> 메서드를 사용 하면 행에 추가 하려면 기본 대체 또는 `null` 는 누락 된 열에 대 한 값입니다. 경우 기본값은 없습니다 또는 `null` 사용할 수는 `Load` 메서드에서 예외가 throw 됩니다. 특정 기본 값을 제공 하는 경우는 `Load` 메서드는 `null` 암시 된 기본값으로 값입니다.|  
  
 동작을 고려 하기 전에 합니다 `Load` 데이터 작업을 기준으로 메서드는 것이 좋습니다 각 내에서 행을 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값을 유지 관리 합니다. 이러한 값 같을 수도 있지만, 또는 행의 데이터를 채운 이후에 변경 된 경우에 다를 수 여 `DataTable`.  자세한 내용은 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.  
  
 이 버전의는 `Load` 메서드는 원래 값을 그대로 두고 각 행의 현재 값을 유지 하려고 합니다. (들어오는 데이터의 동작을 보다 세부적으로 제어를 원한다 면 참조 <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) 기존 행과 들어오는 행에 해당 기본 키 값이 없으면 행의 현재 행 상태 값을 사용 하 여 처리 됩니다, 그리고 그렇지 않으면 새 행으로 처리 됩니다.  
  
 이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트가 발생 하며 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다. 각각의 경우에서는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성의는 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 연결 된 특정 작업에 대 한 정보를 포함 합니다. 동작 값이 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다. 각각의 경우에서 두 이벤트가 발생 하 고 작업을 각각에 대해 동일 합니다. 작업은 각 행의 현재 또는 원래 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.  
  
 다음 표에서 동작을 보여 줍니다는 `Load` 메서드. ("(없음)" 라는) 마지막 행을 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작을 설명 합니다. 이 테이블의 각 셀과 함께 행의 필드에 대 한 현재 및 원래 값을 설명 합니다는 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다. 메서드 로드 옵션을 지정할 수 없습니다 및 기본값을 사용 하 여이 예제의 경우 `PreserveChanges`합니다.  
  
|기존 DataRowState|값 `Load` 메서드 및 이벤트 작업|  
|---------------------------|--------------------------------------------------|  
|추가됨|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|수정한 날짜|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|삭제됨|현재 = \<없음 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<삭제 ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(없음)|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 값을 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한할 수 있습니다 <xref:System.Data.DataColumn.ReadOnly%2A> 고 <xref:System.Data.DataColumn.AutoIncrement%2A>입니다. `Load` 메서드 열의 속성에 의해 정의 된 동작을 사용 하 여 일치 하는 방식으로 해당 열을 처리 합니다. 읽기 전용 제약을 <xref:System.Data.DataColumn> 메모리에서 발생 하는 변경에만 적용 됩니다. `Load` 메서드는 필요한 경우 읽기 전용으로 열 값을 덮어씁니다.  
  
 현재 행과 들어오는 행을 비교 하는 데 사용 하 여 기본 키 필드의 버전을 확인 하는 `Load` 메서드 존재 하는 경우 행의 기본 키 값의 원래 버전을 사용 합니다. 이 고, 그렇지는 `Load` 메서드는 기본 키 필드의 현재 버전을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 호출을 사용 하 여 관련 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드. 예제에서 로드 된 스키마를 유추 등의 스키마 문제에 집중 하는 먼저 <xref:System.Data.IDataReader>, 및 다음 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다. 호출 예제는 `Load` 메서드를 로드 작업 전후에 데이터를 표시 합니다.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">하나 이상의 결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <summary>제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다. <see langword="DataTable" />에 이미 행이 포함되어 있으면 데이터 소스에서 들어오는 데이터는 <paramref name="loadOption" /> 매개 변수의 값에 따라 기존 행과 병합됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Load` 첫 번째 결과 집합의 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>를 성공적으로 완료 한 후 설정 판독기의 위치를 다음 결과 집합에 있는 경우. 데이터를 변환 하는 경우는 `Load` 와 같은 변환 규칙을 사용 하는 메서드를 <xref:System.Data.Common.DbDataAdapter.Fill%2A> 메서드.  
  
 합니다 `Load` 메서드를 고려해 야 합니다 세 가지 특정 문제에서 데이터를 로드 하는 경우는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다. 스키마를 사용 하 여 작업 하는 경우는 `Load` 메서드는 다음 표에 설명 된 대로 조건이 발생할 수 있습니다. 스키마 작업 수행도 포함 하는 데이터가 없는 모든 가져온된 결과 집합에 대 한 합니다.  
  
|조건|동작|  
|---------------|--------------|  
|<xref:System.Data.DataTable> 에 스키마가 없는 합니다.|합니다 `Load` 메서드는 가져온에서 결과 집합에 따라 스키마를 유추 <xref:System.Data.IDataReader>합니다.|  
|<xref:System.Data.DataTable> 스키마를 갖지만 로드 된 스키마와 호환 되지 않습니다.|`Load` 메서드 호환 되지 않는 스키마로 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.|  
|스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 된 `DataTable`합니다.|합니다 `Load` 추가 열을 추가 하는 메서드 `DataTable`의 스키마입니다. 메서드는 해당 하는 경우 예외를 throw에서 열을 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 합니다. 또한 메서드는 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다. Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보는 경우에 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.|  
|스키마가 호환 되지만 보다 적은 개수의 열을 포함 하는 로드 된 결과 집합 스키마에는 `DataTable`합니다.|누락 된 열에 기본값이 정의 또는 열의 데이터 형식이 null을 허용 하는 경우는 `Load` 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다. 기본값 또는 null 없습니다 사용할 수 있습니다 하는 경우 해당 `Load` 메서드에서 예외가 throw 됩니다. 특정 기본 값을 제공 하는 경우는 `Load` 메서드 묵시적된 기본 값으로 null 값을 사용 합니다.|  
  
 동작을 고려 하기 전에 합니다 `Load` 데이터 작업을 기준으로 메서드는 것이 좋습니다 각 내에서 행을 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값을 유지 관리 합니다. 이러한 값 같을 수도 있지만, 또는 행의 데이터를 채운 이후에 변경 된 경우에 다를 수 여 `DataTable`. 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) 자세한 내용은 합니다.  
  
 이 메서드 호출에서 지정 된 <xref:System.Data.LoadOption> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다. Load 메서드는 기존 행으로 동일한 기본 키가 있는 행을 로드할을 처리 하는 방법 현재 값, 원래 값 또는 둘 다 수정 해야? 이러한 문제 및 자세한에 의해 제어 되는 `loadOption` 매개 변수입니다.  
  
 기존 행과 들어오는 행에 해당 기본 키 값이 없으면 행의 현재 행 상태 값을 사용 하 여 처리 됩니다, 그리고 그렇지 않으면 새 행으로 처리 됩니다.  
  
 이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트가 발생 하며 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다. 각각의 경우에서는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성의는 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 연결 된 특정 작업에 대 한 정보를 포함 합니다. 동작 값이 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다. 각각의 경우에서 두 이벤트가 발생 하 고 작업을 각각에 대해 동일 합니다. 작업은 각 행의 현재 또는 원래 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.  
  
 다음 표에 각를 사용 하 여 호출 하는 경우 Load 메서드에 대 한 동작을 `LoadOption` 값 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다. ("(없음)" 라는) 마지막 행을 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작을 설명 합니다. 이 테이블의 각 셀과 함께 행의 필드에 대 한 현재 및 원래 값을 설명 합니다는 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.  
  
|기존 DataRowState|Upsert|OverwriteChanges|PreserveChanges (기본 동작)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|추가됨|현재 = \<들어오는 ><br /><br /> 원래 =-\<없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|수정한 날짜|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction =ChangeOriginal|  
파일과|(부하는 행을 삭제 하는 영향을 하지 않습니다)<br /><br /> 현재 =--<br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<삭제 ><br /><br /> (다음 특징을 가진 새 행이 추가 됨)<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|삭제 취소 하 고<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<없음 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<삭제 ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 새 값 이면 기존 값과 같은 경우<br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
없음)|현재 = \<들어오는 ><br /><br /> 원래 = \<없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 값을 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한할 수 있습니다 <xref:System.Data.DataColumn.ReadOnly%2A> 고 <xref:System.Data.DataColumn.AutoIncrement%2A>입니다. `Load` 메서드 열의 속성에 의해 정의 된 동작을 사용 하 여 일치 하는 방식으로 해당 열을 처리 합니다. 읽기 전용 제약을 <xref:System.Data.DataColumn> 메모리에서 발생 하는 변경에만 적용 됩니다. `Load` 메서드는 필요한 경우 읽기 전용으로 열 값을 덮어씁니다.  
  
 호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 `Load` 메서드를 다음 가정에서 들어오는 데이터가 제공 되는 수행 되는 `DataTable`의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 및 전파 될 수 있습니다 변경 내용을 다시 데이터 원본입니다. Upsert 옵션을 선택 하면 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 데이터가 제공 되는 가정 합니다. 가정에서 하나 이상의 데이터 원본에서 데이터를 집계 하기 위한 것은 예제의 경우는 `DataTable`, 다음 아마도 주 데이터 원본에 데이터를 전파 합니다. <xref:System.Data.LoadOption> 매개 변수는 기본 키 비교에 사용할 행의 특정 버전을 결정 하는 데 사용 됩니다. 아래 표에서 세부 정보를 제공 합니다.  
  
|로드 옵션|기본 키 비교에 사용 되는 DataRow 버전|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|원래 버전에 있는 경우, 그렇지 않으면 현재 버전|  
|`PreserveChanges`|원래 버전에 있는 경우, 그렇지 않으면 현재 버전|  
|`Upsert`|현재 버전에 있는 경우, 그렇지 않으면 원래 버전|  
  
   
  
## Examples  
 다음 예제에서는 다양 한 호출을 사용 하 여 관련 된 문제는 <xref:System.Data.DataTable.Load%2A> 메서드. 예제에서 로드 된 스키마를 유추 등의 스키마 문제에 집중 하는 먼저 <xref:System.Data.IDataReader>, 및 다음 호환 되지 않는 스키마 및 열이 누락 되거나 추가 된 스키마를 처리 합니다. 이 예제에서는 다음 데이터 문제를 포함 하 여 다양 한 로드 옵션에 중점을 둡니다.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">결과 집합을 제공하는 <see cref="T:System.Data.IDataReader" />입니다.</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 열거형의 값으로서, 이미 <see cref="T:System.Data.DataTable" />에 있는 행이 동일한 기본 키를 공유하는 들어오는 행과 결합되는 방식을 나타냅니다.</param>
        <param name="errorHandler">데이터를 로드하는 동안 오류가 발생하면 호출할 <see cref="T:System.Data.FillErrorEventHandler" /> 대리자입니다.</param>
        <summary>오류 처리 대리자를 사용하는 제공된 <see cref="T:System.Data.DataTable" />를 사용해서 <see cref="T:System.Data.IDataReader" />을 데이터 소스의 값으로 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Load` 첫 번째 결과 집합의 로드를 사용 하는 메서드 <xref:System.Data.IDataReader>를 성공적으로 완료 한 후 설정 판독기의 위치를 다음 결과 집합에 있는 경우. 데이터를 변환 하는 경우는 `Load` 와 같은 변환 규칙을 사용 하는 메서드를 <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> 메서드.  
  
 합니다 `Load` 메서드를 고려해 야 합니다 세 가지 특정 문제에서 데이터를 로드 하는 경우는 <xref:System.Data.IDataReader> 인스턴스: 스키마, 데이터 및 이벤트 작업 합니다. 스키마를 사용 하 여 작업 하는 경우는 `Load` 메서드는 다음 표에 설명 된 대로 조건이 발생할 수 있습니다. 스키마 작업 수행도 포함 하는 데이터가 없는 모든 가져온된 결과 집합에 대 한 합니다.  
  
|조건|동작|  
|---------------|--------------|  
|<xref:System.Data.DataTable> 에 스키마가 없는 합니다.|합니다 `Load` 메서드는 가져온에서 결과 집합에 따라 스키마를 유추 <xref:System.Data.IDataReader>합니다.|  
|<xref:System.Data.DataTable> 스키마를 갖지만 로드 된 스키마와 호환 되지 않습니다.|`Load` 메서드 호환 되지 않는 스키마로 데이터를 로드 하려고 할 때 발생 하는 특정 오류에 해당 하는 예외를 throw 합니다.|  
|스키마가 호환 되지만 로드 된 결과 집합 스키마에 존재 하지 않는 열이 포함 된 `DataTable`합니다.|합니다 `Load` 추가 열을 추가 하는 메서드 `DataTable`의 스키마입니다. 메서드는 해당 하는 경우 예외를 throw에서 열을 <xref:System.Data.DataTable> 로드 된 결과 집합 값이 서로 호환 되지 합니다. 또한 메서드는 결과 집합에 추가 된 모든 열에서에서 제약 조건 정보를 검색 합니다. Primary Key 제약 조건의 경우를 제외 하 고이 제약 조건 정보는 경우에 현재 <xref:System.Data.DataTable> 로드 작업의 시작 부분에 열이 포함 되지 않습니다.|  
|스키마가 호환 되지만 보다 적은 개수의 열을 포함 하는 로드 된 결과 집합 스키마에는 `DataTable`합니다.|누락 된 열에 기본값이 정의 또는 열의 데이터 형식이 null을 허용 하는 경우는 `Load` 메서드를 사용 하면 행을 추가할 수는 누락 된 열에 대 한 default 또는 null 값을 대체 합니다. 기본값 또는 null 없습니다 사용할 수 있습니다 하는 경우 해당 `Load` 메서드에서 예외가 throw 됩니다. 특정 기본 값을 제공 하는 경우는 `Load` 메서드 묵시적된 기본 값으로 null 값을 사용 합니다.|  
  
 동작을 고려 하기 전에 합니다 `Load` 데이터 작업을 기준으로 메서드는 것이 좋습니다 각 내에서 행을 <xref:System.Data.DataTable> 현재 값과 각 열에 대 한 원래 값을 유지 관리 합니다. 이러한 값 같을 수도 있지만, 또는 행의 데이터를 채운 이후에 변경 된 경우에 다를 수 여 `DataTable`. 참조 [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) 자세한 내용은 합니다.  
  
 이 메서드 호출에서 지정 된 <xref:System.Data.LoadOption> 매개 변수는 들어오는 데이터의 처리에 영향을 줍니다. Load 메서드는 기존 행으로 동일한 기본 키가 있는 행을 로드할을 처리 하는 방법 현재 값, 원래 값 또는 둘 다 수정 해야? 이러한 문제 및 자세한에 의해 제어 되는 `loadOption` 매개 변수입니다.  
  
 기존 행과 들어오는 행에 해당 기본 키 값이 없으면 행의 현재 행 상태 값을 사용 하 여 처리 됩니다, 그리고 그렇지 않으면 새 행으로 처리 됩니다.  
  
 이벤트 작업의 경우는 <xref:System.Data.DataTable.RowChanging> 각 행이 변경 되기 전에 이벤트가 발생 하며 <xref:System.Data.DataTable.RowChanged> 이벤트는 각 행이 변경 된 후 발생 합니다. 각각의 경우에서는 <xref:System.Data.DataRowChangeEventArgs.Action%2A> 속성의는 <xref:System.Data.DataRowChangeEventArgs> 이벤트 처리기에 전달 된 인스턴스가 이벤트와 연결 된 특정 작업에 대 한 정보를 포함 합니다. 동작 값이 로드 작업 앞에 있는 행의 상태에 따라 달라 집니다. 각각의 경우에서 두 이벤트가 발생 하 고 작업을 각각에 대해 동일 합니다. 작업은 각 행의 현재 또는 원래 버전 또는 현재 행 상태에 따라 둘 다에 적용할 수 있습니다.  
  
 다음 표에 각를 사용 하 여 호출 하는 경우 Load 메서드에 대 한 동작을 `LoadOption` 값 및 값 로드 중인 행에 대 한 행 상태와 상호 작용 하는 방법을 보여 줍니다. ("(없음)" 라는) 마지막 행을 기존 행과 일치 하지 않는 들어오는 행에 대 한 동작을 설명 합니다. 이 테이블의 각 셀과 함께 행의 필드에 대 한 현재 및 원래 값을 설명 합니다는 <xref:System.Data.DataRowState> 후의 값에 대 한는 `Load` 메서드가 완료 합니다.  
  
|기존 DataRowState|Upsert|OverwriteChanges|PreserveChanges (기본 동작)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|추가됨|현재 = \<들어오는 ><br /><br /> 원래 =-\<없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = ChangeOriginal|  
|수정한 날짜|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<기존 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<수정 ><br /><br /> RowAction =ChangeOriginal|  
파일과|(부하는 행을 삭제 하는 영향을 하지 않습니다)<br /><br /> 현재 =--<br /><br /> 원래 = \<기존 ><br /><br /> 상태 = \<삭제 ><br /><br /> (다음 특징을 가진 새 행이 추가 됨)<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|삭제 취소 하 고<br /><br /> 현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<없음 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<삭제 ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|현재 = \<들어오는 ><br /><br /> 원래 = \<기존 ><br /><br /> 새 값 이면 기존 값과 같은 경우<br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> 상태 = \<수정 ><br /><br /> RowAction = 변경|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
없음)|현재 = \<들어오는 ><br /><br /> 원래 = \<없음 ><br /><br /> 상태 = \<추가 ><br /><br /> RowAction = 추가|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|현재 = \<들어오는 ><br /><br /> 원래 = \<들어오는 ><br /><br /> 상태 = \<변경 되지 않은 ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 값을 <xref:System.Data.DataColumn> 와 같은 속성을 사용 하 여 제한할 수 있습니다 <xref:System.Data.DataColumn.ReadOnly%2A> 고 <xref:System.Data.DataColumn.AutoIncrement%2A>입니다. `Load` 메서드 열의 속성에 의해 정의 된 동작을 사용 하 여 일치 하는 방식으로 해당 열을 처리 합니다. 읽기 전용 제약을 <xref:System.Data.DataColumn> 메모리에서 발생 하는 변경에만 적용 됩니다. `Load` 메서드는 필요한 경우 읽기 전용으로 열 값을 덮어씁니다.  
  
 호출할 때 OverwriteChanges 또는 PreserveChanges 옵션을 지정 하는 경우는 `Load` 메서드를 다음 가정에서 들어오는 데이터가 제공 되는 수행 되는 `DataTable`의 주 데이터 원본 및 데이터 테이블의 변경 내용을 추적 및 전파 될 수 있습니다 변경 내용을 다시 데이터 원본입니다. Upsert 옵션을 선택 하면 사용자에 의해 변경 된 중간 계층 구성 요소에서 제공 하는 데이터와 같은 보조 데이터 원본 중 하나에서 데이터가 제공 되는 가정 합니다. 가정에서 하나 이상의 데이터 원본에서 데이터를 집계 하기 위한 것은 예제의 경우는 `DataTable`, 다음 아마도 주 데이터 원본에 데이터를 전파 합니다. <xref:System.Data.LoadOption> 매개 변수는 기본 키 비교에 사용할 행의 특정 버전을 결정 하는 데 사용 됩니다. 아래 표에서 세부 정보를 제공 합니다.  
  
|로드 옵션|기본 키 비교에 사용 되는 DataRow 버전|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|원래 버전에 있는 경우, 그렇지 않으면 현재 버전|  
|`PreserveChanges`|원래 버전에 있는 경우, 그렇지 않으면 현재 버전|  
|`Upsert`|현재 버전에 있는 경우, 그렇지 않으면 원래 버전|  
  
 합니다 `errorHandler` 매개 변수는 한 <xref:System.Data.FillErrorEventHandler> 데이터를 로드 하는 동안 오류가 발생 하면 호출 되는 프로시저를 참조 하는 대리자입니다. 합니다 <xref:System.Data.FillErrorEventArgs> 발생 한 오류, 데이터의 현재 행에 대 한 정보를 검색할 수 있는 속성을 제공 하는 프로시저에 전달 된 매개 변수 및 <xref:System.Data.DataTable> 채워지고 있습니다. 이 대리자 메커니즘을 사용 하 여, 대신 간단한 try/catch 블록을 오류를 확인할 수 있습니다 상황을 처리 한 원하는 경우 처리를 계속 합니다. 합니다 <xref:System.Data.FillErrorEventArgs> 매개 변수를 제공을 <xref:System.Data.FillErrorEventArgs.Continue%2A> 속성:이 속성을 설정 `true` 오류를 처리 하 고 처리를 계속 하려면. 속성을 설정 `false` 처리를 중단 하려는 나타냅니다. 주의 해당 속성을 설정 `false` 예외를 throw 하려면 문제를 트리거한 코드를 사용 하면 됩니다.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>특정 행을 찾아 업데이트합니다. 일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">새 행을 만드는 데 사용되는 값 배열입니다.</param>
        <param name="fAcceptChanges">변경 사항을 적용하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>특정 행을 찾아 업데이트합니다. 일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Data.DataRow" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> 메서드 값의 배열을 사용 하 고 기본 키 열에서 일치 하는 값을 찾습니다.  
  
 열에 기본값이 있으면 해당 열에 대 한 기본 값을 설정 하려면 배열에 null 값을 전달 합니다. 마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A> 설정을 true로 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다.  
  
 경우는 `fAcceptChanges` 매개 변수는 `true` 지정 하지 않으면 새 데이터가 추가 됩니다 또는 차례로 <xref:System.Data.DataTable.AcceptChanges%2A> 에서 모든 변경 내용을 적용 하기 위해 호출 됩니다는 <xref:System.Data.DataTable>인수가; `false`, 새로 추가 된 행이 삽입 및 변경 내용으로 표시 된 기존 행 수정으로 표시 됩니다.  
  
 예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging> 또는 <xref:System.Data.DataTable.RowChanging> 이벤트입니다. 예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.  
  
 사용 하 여 <xref:System.Data.DataTable.LoadDataRow%2A> 와 함께에서 <xref:System.Data.DataTable.BeginLoadData%2A> 고 <xref:System.Data.DataTable.EndLoadData%2A>입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable.LoadDataRow%2A> 행을 찾으려고 시도 하는 방법입니다. 이러한 행에 없으면 새 행을 만들고 값이 사용 됩니다.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">배열이 테이블의 열 수보다 큰 경우</exception>
        <exception cref="T:System.InvalidCastException">값이 해당 열 형식과 일치하지 않는 경우</exception>
        <exception cref="T:System.Data.ConstraintException">행을 추가하여 제약 조건을 무효화한 경우</exception>
        <exception cref="T:System.Data.NoNullAllowedException">
          <see cref="P:System.Data.DataColumn.AllowDBNull" />이 false인 열에 null을 설정하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">새 행을 만드는 데 사용되는 값 배열입니다.</param>
        <param name="loadOption">배열 값이 기존 행의 해당 값에 적용되는 방식을 결정하는 데 사용됩니다.</param>
        <summary>특정 행을 찾아 업데이트합니다. 일치하는 행을 찾지 못하면 지정된 값을 사용하여 새 행을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Data.DataRow" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> 메서드 값의 배열을 사용 하 고 기본 키 열에서 일치 하는 값을 찾습니다.  
  
 열에 기본값이 있으면 해당 열에 대 한 기본 값을 설정 하려면 배열에 null 값을 전달 합니다. 마찬가지로, 열에 있으면 해당 <xref:System.Data.DataColumn.AutoIncrement%2A> 설정을 true로 행에 대해 자동으로 생성 된 값을 설정 하는 배열에 null 값을 전달 합니다.  
  
 값을 `loadOption` 매개 변수는 배열에 값이 기존 행에 적용 되는 방식을 확인 하려면 사용 합니다. 예를 들어 경우 `loadOption` 로 설정 된 `OverwriteChanges`의 `Original` 및 `Current` 각 열의 값은 들어오는 행의 값으로 바뀝니다 및 `RowState` 속성이 `Unchanged`합니다.  
  
 예외도 수행 하는 동안 발생할 수 있습니다는 <xref:System.Data.DataTable.ColumnChanging> 또는 <xref:System.Data.DataTable.RowChanging> 이벤트입니다. 예외가 발생 하는 경우 테이블에 행 추가 되지 않습니다.  
  
 사용 하 여 <xref:System.Data.DataTable.LoadDataRow%2A> 와 함께에서 <xref:System.Data.DataTable.BeginLoadData%2A> 고 <xref:System.Data.DataTable.EndLoadData%2A>입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블 내의 문자열을 비교하는 데 사용되는 로캘 정보를 가져오거나 설정합니다.</summary>
        <value>사용자의 컴퓨터 로캘에 대한 데이터가 들어 있는 <see cref="T:System.Globalization.CultureInfo" />입니다. 기본값은 <see cref="T:System.Data.DataSet" />이 속해 있으며 <see cref="T:System.Globalization.CultureInfo" /> 속성에 의해 반환되는 <see cref="P:System.Data.DataSet.Locale" /> 개체의 <see cref="T:System.Data.DataTable" />이거나, 테이블이 <see cref="T:System.Data.DataSet" />에 속하지 않은 경우 현재 시스템의 <see cref="T:System.Globalization.CultureInfo" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> 는 특정 문화권 또는 커뮤니티의 소프트웨어 기본 설정을 나타냅니다.  
  
 문자열 비교에 사용 되는 경우는 <xref:System.Globalization.CultureInfo> 비교, 정렬 및 필터링에 영향을 줍니다.  
  
> [!NOTE]
>  식이 포함 된 열에는 <xref:System.StringComparison.InvariantCulture> 사용 됩니다. <xref:System.StringComparison.CurrentCulture> 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Globalization.CultureInfo> 를 통해를 <xref:System.Data.DataTable.Locale%2A> ISO 언어 이름을 출력 합니다.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 <see cref="T:System.Data.DataTable" />을 현재 <see cref="T:System.Data.DataTable" />과 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Merge` 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다. 자식 테이블을 받는 되지 않거나 포함 합니다. 테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 `missingSchemaAction` 의 매개 변수는 <xref:System.Data.DataTable.Merge%2A> 메서드. 이 예제에서는 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블의 두 버전을 만듭니다. 코드를 첫 번째 두 번째 테이블을 병합 하려고 시도 합니다.  
  
> [!NOTE]
>  이 예에서는 병합의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">현재 <see cref="T:System.Data.DataTable" />과 병합할 <see cref="T:System.Data.DataTable" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />을 현재 <see cref="T:System.Data.DataTable" />과 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다. 자식 테이블을 받는 되지 않거나 포함 합니다. 테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.  
  
 합니다 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.  
  
 병합을 수행할 때 기존 데이터를 병합 하기 전에 변경 내용은 병합 작업 하는 동안 기본적으로 유지 됩니다. 개발자는이 메서드에 대 한 다른 두 개의 오버 로드 중 하나를 호출 하 고 false 값을 지정 하 여이 동작을 수정할 수는 `preserveChanges` 매개 변수입니다.  
  
 클라이언트 응용 프로그램에서는 단일 하는 단추가 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 데 평소 됩니다. 이 시나리오에서는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataTable> 개체만 포함 된 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다. 이 하위 집합은 일반적으로 크기가 작기 때문에 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataTable> 사용 하 여는 <xref:System.Data.DataTable.Merge%2A> 메서드.  
  
 새 소스를 병합할 때 <xref:System.Data.DataTable> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted`, 동일한 기본 키 값을 사용 하 여 대상 행과 일치 하는 합니다. 소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만드는 간단한 <xref:System.Data.DataTable> 데이터 테이블에 추가 합니다. 다음 예제에서는 행 복사본에 추가 테이블의 복사본을 만듭니다. 마지막으로 호출 하 여는 <xref:System.Data.DataTable.Merge%2A> 첫 번째 테이블의 데이터를 사용 하 여 두 번째 테이블의 데이터를 병합 하는 방법입니다.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">현재 <see langword="DataTable" />과 병합할 <see langword="DataTable" />입니다.</param>
        <param name="preserveChanges">현재 <see langword="true" />의 변경 내용을 유지하려면 <see langword="DataTable" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />을 현재 <see langword="DataTable" />과 병합하여 현재 <see langword="DataTable" />에서 변경 내용을 유지할지 여부를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다. 자식 테이블을 받는 되지 않거나 포함 합니다. 테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.  
  
 합니다 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.  
  
 개발자에 대해서는 false를 지정 하지 않은 경우 병합 하기 전에 기존 데이터에 대 한 변경 내용을 병합 작업 동안 유지 됩니다 병합을 수행 하는 경우는 `preserveChanges` 매개 변수입니다. 경우는 `preserveChanges` 매개 변수는 설정 `true`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다. 경우는 `preserveChanges` 매개 변수는 설정 `false`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어씁니다. 행 버전에 대 한 자세한 내용은 참조 하세요. [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.  
  
 클라이언트 응용 프로그램에서는 단일 하는 단추가 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 데 평소 됩니다. 이 시나리오에서는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataTable> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다. 이 하위 집합은 일반적으로 작은 및 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataTable> 사용 하 여는 <xref:System.Data.DataTable.Merge%2A> 메서드.  
  
 새 소스를 병합할 때 <xref:System.Data.DataTable> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만듭니다는 <xref:System.Data.DataTable> 해당 행의 데이터 중 일부를 수정 행을 포함 하 고 다른 데이터를 병합 하려고 <xref:System.Data.DataTable>합니다. 예제에 대 한 다양 한 동작에는 `preserveChanges` 매개 변수입니다.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">현재 <see cref="T:System.Data.DataTable" />과 병합할 <see cref="T:System.Data.DataTable" />입니다.</param>
        <param name="preserveChanges">현재 <see langword="true" />의 변경 내용을 유지하려면 <see cref="T:System.Data.DataTable" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />을 현재 <see langword="DataTable" />과 병합하여, 변경 내용을 유지할지 여부와 현재 <see langword="DataTable" />의 누락된 스키마 처리 방식을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Merge` 메서드는 두 개의 병합 데 <xref:System.Data.DataTable> 아주 비슷한 스키마가 포함 된 개체입니다. 병합을 일반적으로 사용 됩니다 클라이언트 응용 프로그램에서 데이터 원본에서 최신 변경 내용을 기존 통합할 <xref:System.Data.DataTable>합니다. 이렇게 하면 클라이언트 응용 프로그램을 새로 고칠 수 있습니다. <xref:System.Data.DataTable> 데이터 원본의 최신 데이터를 사용 하 여 합니다.  
  
 병합 작업은 원래 테이블만 및 병합할 테이블 고려 합니다. 자식 테이블을 받는 되지 않거나 포함 합니다. 테이블 관계의 일부로 정의 된 하나 이상의 자식 테이블에 각 자식 테이블을 개별적으로 병합 되어야 합니다.  
  
 합니다 `Merge` 메서드는 일반적으로 일련의 변경 내용의 유효성 검사, 오류 조정, 변경 내용을 사용 하 여 데이터 소스를 업데이트 및 마지막으로 기존 새로 고침을 포함 하는 절차의 끝에 호출 <xref:System.Data.DataTable>합니다.  
  
 개발자에 대해서는 false를 지정 하지 않은 경우 병합 하기 전에 기존 데이터에 대 한 변경 내용을 병합 작업 동안 유지 됩니다 병합을 수행 하는 경우는 `preserveChanges` 매개 변수입니다. 경우는 `preserveChanges` 매개 변수는 설정 `true`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어쓰지 않습니다. 경우는 `preserveChanges` 매개 변수는 설정 `false`을 들어오는 값이 기존 행의 현재 행 버전의 기존 값을 덮어씁니다. 행 버전에 대 한 자세한 내용은 참조 하세요. [행 상태 및 행 버전](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.  
  
 클라이언트 응용 프로그램에서는 단일 하는 단추가 사용자가 클릭할 수 있는 변경된 된 데이터를 수집 하 고 중간 계층 구성 요소를 다시 보내기 전에 유효성 검사를 수행 하는 데 평소 됩니다. 이 시나리오에서는 <xref:System.Data.DataTable.GetChanges%2A> 메서드가 먼저 호출 됩니다. 이 메서드는 두 번째 <xref:System.Data.DataTable> 유효성 검사 및 병합에 대해 최적화 합니다. 이 두 번째 <xref:System.Data.DataTable> 개체만 포함 된 <xref:System.Data.DataTable> 및 <xref:System.Data.DataRow> 원래의 하위 집합에 변경 된 개체 <xref:System.Data.DataTable>합니다. 이 하위 집합은 일반적으로 작은 및 따라서이 하위 집합은 보다 효율적으로 중간 계층 구성 요소에 다시 전달 합니다. 중간 계층 구성 요소는 다음 저장된 프로시저를 통해 변경 내용을 사용 하 여 원본 데이터 소스를 업데이트합니다. 중간 계층을 새 다시 보낼 수 있습니다 <xref:System.Data.DataTable> 포함 하는 원본 데이터와 데이터 원본의 최신 데이터를 (다시 실행 하 여 원래 쿼리), 또는 데이터 원본에서 변경 된 내용이 있는 하위 집합을 클라이언트로 보낼 수 있습니다. (예를 들어, 데이터 원본에서 자동으로 고유 기본 키 값을 만드는 경우 이러한 값에 전파할 수 다시 클라이언트 응용 프로그램입니다.) 두 경우 모두 반환 된 <xref:System.Data.DataTable> 클라이언트 응용 프로그램의 원본에 다시 병합할 수 있게 <xref:System.Data.DataTable> 사용 하 여는 <xref:System.Data.DataTable.Merge%2A> 메서드.  
  
 경우는 <xref:System.Data.DataTable.Merge%2A> 메서드가 호출 되는 두 스키마 <xref:System.Data.DataTable> 개체는 스키마 변경 수 있기 때문에 비교 됩니다. 예를 들어, 기업 간 시나리오에서 새 열 추가한 XML 스키마에 자동화 된 프로세스에 의해 합니다. 하는 경우 원본 <xref:System.Data.DataTable> 스키마 요소를 포함 (추가 <xref:System.Data.DataColumn> 개체) 대상에 누락 된를 설정 하 여 대상 스키마 요소를 추가할 수 있습니다 합니다 `missingSchemaAction` 인수를 `MissingSchemaAction.Add`입니다. 병합 된 경우에서 <xref:System.Data.DataTable> 추가 된 스키마 및 데이터를 포함 합니다.  
  
 스키마를 병합 한 후 데이터를 병합 합니다.  
  
 새 소스를 병합할 때 <xref:System.Data.DataTable> 을 대상으로 사용 하 여 모든 원본 행을 <xref:System.Data.DataRowState> 의 값 `Unchanged`를 `Modified`, 또는 `Deleted` 동일한 기본 키 값을 사용 하 여 대상 행에 일치 하는 합니다. 소스 행을 <xref:System.Data.DataRowState> 의 값 `Added` 새 원본 행과 동일한 기본 키 값을 사용 하 여 새 대상 행에 대응 됩니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램의 동작을 보여 줍니다.는 `missingSchemaAction` 의 매개 변수는 <xref:System.Data.DataTable.Merge%2A> 메서드. 이 예제에서는 두 번째 버전에 대 한 스키마를 수정 하는 동일한 테이블의 두 버전을 만듭니다. 코드를 첫 번째 두 번째 테이블을 병합 하려고 시도 합니다.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 테이블에 대한 초기 시작 크기를 가져오거나 설정합니다.</summary>
        <value>이 테이블에 있는 행의 초기 시작 크기입니다. 기본값은 50입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A> 시스템에 데이터를 인출 하기 전에 적절 한 리소스 집합을 만들 수 있습니다. 상황에서이 속성을 설정할 성능이 중요 한 경우 성능을 최적화할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataTable.MinimumCapacity%2A> 의 한 <xref:System.Data.DataTable>합니다.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />에 저장된 데이터의 XML 표현에 대한 네임스페이스를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataTable" />의 네임스페이스입니다.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>테이블과 동일한 스키마를 갖는 새 <see cref="T:System.Data.DataRow" />를 만듭니다.</summary>
        <returns>
          <see cref="T:System.Data.DataRow" />과 동일한 스키마를 갖는 <see cref="T:System.Data.DataTable" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 새로 만들기 방법 <xref:System.Data.DataRow> 와 동일한 스키마를 사용 하 여 개체를 <xref:System.Data.DataTable>입니다. 만든 후는 <xref:System.Data.DataRow>를 추가할 수 있습니다는 <xref:System.Data.DataRowCollection>을 통해 합니다 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataTable.Rows%2A> 속성. 사용 하는 경우 <xref:System.Data.DataTable.NewRow%2A> 새 행을 만들려면 행에 추가 하거나 삭제 해야 데이터 테이블에서 호출 하기 전에 <xref:System.Data.DataTable.Clear%2A>입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable>, 두 개 더한 <xref:System.Data.DataColumn> 개체는 테이블의 스키마를 확인 하 고 여러 만듭니다 <xref:System.Data.DataRow> 사용 하 여 개체를 <xref:System.Data.DataTable.NewRow%2A> 메서드. 이러한 <xref:System.Data.DataRow> 개체에 추가 됩니다 합니다 <xref:System.Data.DataRowCollection> 사용 하 여를 <xref:System.Data.DataRowCollection.Add%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">배열의 크기를 설명하는 <see cref="T:System.Int32" /> 값입니다.</param>
        <summary>
          <see cref="T:System.Data.DataRow" />의 배열을 반환합니다.</summary>
        <returns>새 배열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">
          <see cref="T:System.Data.DataRowBuilder" /> 개체입니다.</param>
        <summary>기존 행에서 새 행을 만듭니다.</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> 파생 클래스입니다.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataColumnChangeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.ColumnChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataColumnChangeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.ColumnChanging" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">제거 중인 <see cref="T:System.Data.DataColumn" />입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />이 제거 중임을 <see cref="T:System.Data.DataColumn" />에 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowChanging" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowDeleted" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataRowChangeEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.RowDeleting" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>재정의 하는 경우 <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> 메서드.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataTableClearEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.TableCleared" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생 합니다 <xref:System.Data.DataTable.TableCleared> 모든 행이 성공적으로 지워진 전에 직후 발생 하는 이벤트를 <xref:System.Data.DataTable.Clear%2A> 메서드 호출자에 게 컨트롤을 반환 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataTableClearEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.TableClearing" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생 합니다 <xref:System.Data.DataTable.TableClearing> 처리 되기 전에 발생 하는 이벤트를 <xref:System.Data.DataTable.Clear%2A> 작업이 시작 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Data.DataTableNewRowEventArgs" />입니다.</param>
        <summary>
          <see cref="E:System.Data.DataTable.TableNewRow" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 발생 합니다 <xref:System.Data.DataTable.TableNewRow> 새 후 발생 하는 이벤트 <xref:System.Data.DataRow> 사용 하 여 만든 <xref:System.Data.DataTable.NewRow%2A>.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Data.DataTable" />에 대한 부모 관계 컬렉션을 가져옵니다.</summary>
        <value>테이블의 부모 관계가 포함된 <see cref="T:System.Data.DataRelationCollection" />입니다. <see cref="T:System.Data.DataRelation" /> 개체가 없으면 빈 컬렉션이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Data.DataTable.ParentRelations%2A> 각 부모를 반환 하도록 속성 <xref:System.Data.DataRelation> 에 <xref:System.Data.DataTable>합니다. 각 관계에 대 한 인수로 사용 됩니다는 <xref:System.Data.DataRow.GetParentRows%2A> 메서드는 <xref:System.Data.DataRow> 행의 배열을 반환 하도록 합니다. 행의 각 열 값이 출력 합니다.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />에 저장된 데이터의 XML 표현에 대한 네임스페이스를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataTable" />의 접두사입니다.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>데이터 테이블에 대한 기본 키로 사용되는 열의 배열을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataColumn" /> 개체의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 테이블의 기본 키 테이블의 레코드를 식별 하는 고유 해야 합니다. 두 개 이상의 열으로 구성 하는 기본 키를 사용 하 여 테이블을 가질 수 이기도 합니다. 이 단일 열 충분 한 고유 값을 포함할 수 없는 경우 발생 합니다. 예를 들어 두 개의 열 기본 키를 "FirstName" 및 "LastName" 열의 구성 될 수 있습니다. 기본 키 둘 이상의 열을 구성할 수 있으므로 합니다 <xref:System.Data.DataTable.PrimaryKey%2A> 속성의 배열로 구성 됩니다 <xref:System.Data.DataColumn> 개체입니다.  
  
   
  
## Examples  
 첫 번째 예제에 대 한 기본 키 열을 반환 하는 방법을 보여 줍니다는 <xref:System.Data.DataTable> 에 표시 되는 `DataGrid`합니다. 두 번째 예제에 대 한 기본 키 열을 설정 하는 방법에 설명 된 <xref:System.Data.DataTable>합니다.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">해당 키가 외래 키인 경우</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 스키마와 데이터를 <see cref="T:System.Data.DataTable" />으로 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다. 읽기 데이터와 스키마 중 하나를 사용 합니다 `ReadXML` 포함 하는 오버 로드는 `XmlReadMode` 매개 변수를 해당 값을 설정 하 고 `ReadSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" />에서 파생되는 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.Stream" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 제공 된 데이터를 사용 하 여 해당 하위 항목이 로드 되 고 <xref:System.IO.Stream>입니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다. 이 예제에서는 기록 합니다 <xref:System.Data.DataTable> 스키마 및 데이터를 메모리 스트림으로 호출 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드. 이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마 및 데이터를 사용 하 여 입력 하는 방법입니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">데이터를 읽는 데 사용할 <see cref="T:System.IO.TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.IO.TextReader" />으로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 제공 된 데이터를 사용 하 여 해당 하위 항목이 로드 되 고 <xref:System.IO.TextReader>입니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다. 이 예제에서는 기록 합니다 <xref:System.Data.DataTable> 스키마 및 데이터를 메모리 스트림으로 호출 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 메서드. 이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마 및 데이터를 사용 하 여 입력 하는 방법입니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">데이터를 읽을 파일의 이름입니다.</param>
        <summary>지정된 파일로부터 XML 스키마와 데이터를 <see cref="T:System.Data.DataTable" />로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 해당 하위 항목에 제공 된 명명 된 파일에서 데이터를 사용 하 여 로드 되 고 <xref:System.String>입니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다. 예제에서는 기록 된 <xref:System.Data.DataTable> 스키마와 데이터 디스크를 합니다. 이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마 및 데이터를 사용 하 여 입력 하는 방법입니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">데이터를 읽는 데 사용할 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마와 데이터를 <see cref="T:System.Xml.XmlReader" />로 읽어옵니다.</summary>
        <returns>데이터를 읽는 데 사용되는 <see cref="T:System.Data.XmlReadMode" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Data.DataTable> 해당 하위 항목에 제공 된 명명 된 파일에서 데이터를 사용 하 여 로드 되 고 <xref:System.Xml.XmlReader>입니다. 이 메서드의 동작은 동일 합니다는 <xref:System.Data.DataTable.ReadXml%2A> 이 경우에 데이터를 제외 하 고 메서드는 현재 테이블 및 해당 하위 항목에 대해서만 로드 됩니다.  
  
 합니다 <xref:System.Data.DataTable.ReadXml%2A> 메서드는 데이터와 스키마를를 모두만 데이터를 읽을 수 있는 방법을 제공을 <xref:System.Data.DataTable> XML 문서에서 반면는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드는 스키마만 읽습니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.WriteXml%2A> 및 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 작성 하는 `DataTable`를 사용 하 여를 `WriteXml` 메서드. 스키마만를 작성 하려면 사용 된 `WriteXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 인라인 스키마를 지정 된 경우 데이터를 로드 하기 전에 기존 관계형 구조를 확장 하는 인라인 스키마 사용 됩니다. 모든 충돌 (예를 들어 다른 데이터 형식으로 정의 된 동일한 테이블에 동일한 열)이 없으면 예외가 발생 합니다.  
  
 없는 인라인 스키마를 지정 하는 경우에 XML 문서의 구조에 따라 관계형 구조 필요에 따라 유추를 통해 확장 됩니다. 스키마를 확장할 수 없으므로 유추를 통해 모든 데이터를 노출 하기 위해 예외가 발생 합니다.  
  
> [!NOTE]
>  합니다 `DataSet` 해당 XML 요소를 연결 하지 않으며 `DataColumn` 또는 `DataTable` serialize 된 xml에서 ("_")와 같은 유효한 XML 문자는 이스케이프 하는 경우. `DataSet` 자체만 XML 요소 이름에 잘못 된 XML 문자를 이스케이프 하며 따라서 사용할 수 있습니다만 동일 합니다. XML 요소 이름에 유효한 문자는 이스케이프 처리 하는 동안 요소가 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Data.DataTable> 두 개의 열과 10 개의 행을 포함 합니다. 이 예제에서는 기록 합니다 <xref:System.Data.DataTable> 스키마와 데이터를는 <xref:System.Xml.XmlReader>합니다. 이 예에서는 두 번째를 만듭니다 <xref:System.Data.DataTable> 호출을 <xref:System.Data.DataTable.ReadXml%2A> 스키마와 데이터로 채우는 방법은 <xref:System.Xml.XmlReader> 인스턴스.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 스키마를 <see cref="T:System.Data.DataTable" />으로 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 `ReadXmlSchema` 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">스키마를 읽는 데 사용되는 스트림입니다.</param>
        <summary>지정된 스트림을 사용하여 XML 스키마를 <see cref="T:System.Data.DataTable" />로 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
 XML 스키마를 사용 하 여 중첩 된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 또한 명시적 열 이름을 사용 하 여 중첩 된 관계를 구성할 수 있습니다. 요소 중첩된 관계에 참여 하려면 해당 Datatable에서 암시적으로 중첩 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만듭니다 <xref:System.Data.DataTable>에 쓰고 해당 테이블에 대 한 스키마를 <xref:System.IO.MemoryStream>합니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">스키마 정보를 읽는 데 사용되는 <see cref="T:System.IO.TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마를 <see cref="T:System.IO.TextReader" />로 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
 XML 스키마를 사용 하 여 중첩 된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 또한 명시적 열 이름을 사용 하 여 중첩 된 관계를 재구성할 수 있습니다. 요소 중첩된 관계에 참여 하려면 해당 Datatable에서 암시적으로 중첩 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만듭니다 <xref:System.Data.DataTable>에 쓰고 해당 테이블에 대 한 스키마를 <xref:System.IO.MemoryStream>합니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 하 고 저장된 된 XML 스키마에서 해당 스키마를 읽고 사용 하는 <xref:System.IO.StreamReader> (에서 상속 하는 <xref:System.IO.TextReader>) 해당 원본으로 합니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">스키마 정보를 읽을 파일의 이름입니다.</param>
        <summary>지정된 파일로부터 XML 스키마를 <see cref="T:System.Data.DataTable" />로 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 `DataTable`합니다.  
  
 XML 스키마를 사용 하 여 중첩 된 관계를 만들려면 암시적 중첩 된 요소를 사용 합니다. 또한 명시적 열 이름을 사용 하 여 중첩 된 관계를 재구성할 수 있습니다. 요소 중첩된 관계에 참여 하려면 해당 Datatable에서 암시적으로 중첩 되어야 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램에서는 새 <xref:System.Data.DataTable>, 파일을 해당 테이블의 스키마를 씁니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 및 파일을 사용 하 여 해당 원본으로 저장된 된 XML 스키마에서 해당 스키마를 읽습니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">스키마 정보를 읽는 데 사용되는 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 XML 스키마를 <see cref="T:System.Xml.XmlReader" />로 읽어옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Data.DataTable.ReadXmlSchema%2A> 에 대 한 스키마를 만드는 메서드를 <xref:System.Data.DataTable>입니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 스키마는 XML 문서를 작성 하려면 사용 된 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드.  
  
 XML 스키마는 XSD 표준에 따라 해석 됩니다.  
  
 Xs:type 형식과 msdata:DataType 일치 하지 않는 경우 데이터 손상이 발생할 수 있습니다. 예외가 throw 됩니다.  
  
 합니다 `ReadXmlSchema` 일반적으로 메서드를 호출 하기 전에 <xref:System.Data.DataTable.ReadXml%2A> 채우는 데 사용 되는 메서드는 <xref:System.Data.DataTable>합니다.  
  
> [!NOTE]
>  XML 스키마를 사용 하 여 중첩 된 관계를 만드는 방법은 암시적 중첩 된 요소입니다. 또한 중첩된 관계 명시적 열 이름을 사용 하도록 다시 연결할 수 있습니다. 요소가 중첩된 관계에 참여 하려면 해당 Datatable에 대 한 암시적으로 중첩 될 수는 것이 반드시 합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램을 만듭니다 <xref:System.Data.DataTable>에 쓰고 해당 테이블에 대 한 스키마를 <xref:System.IO.MemoryStream>합니다. 그런 다음 예제에서는 새 <xref:System.Data.DataTable> 하 고 저장된 된 XML 스키마에서 해당 스키마를 읽고 사용 하는 <xref:System.Xml.XmlTextReader> (에서 상속 하는 <xref:System.Xml.XmlReader>) 해당 원본으로 합니다.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 개체입니다.</param>
        <summary>XML 스트림에서 읽습니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>테이블이 로드된 이후 또는 <see cref="M:System.Data.DataTable.AcceptChanges" />가 마지막으로 호출된 이후에 변경된 내용을 모두 롤백합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Data.DataTable.RejectChanges%2A> 가 호출 된 <xref:System.Data.DataRow> 아직 편집 모드에에서 있는 개체의 편집이 취소 합니다. 새 행이 제거 됩니다. 사용 하 여 행을 <xref:System.Data.DataRowState> 로 설정 `Modified` 또는 `Deleted` 원래 상태로 다시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 몇 가지 변경 내용에는 <xref:System.Data.DataTable>, 하지만 호출 하 여 변경 내용을 거부를 <xref:System.Data.DataTable.RejectChanges%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>serialization 형식을 가져오거나 설정합니다.</summary>
        <value>
          <see langword="Binary" /> 또는 <see langword="Xml" /> serialization을 지정하는 <see cref="T:System.Data.SerializationFormat" /> 열거형입니다.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />을 원래 상태로 다시 설정합니다. 다시 설정은 테이블의 모든 데이터, 인덱스, 관계 및 열을 제거합니다. DataSet에 DataTable이 포함된 경우 테이블을 다시 설정한 후 테이블은 DataSet의 일부가 됩니다.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataRow" />가 변경된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataRow" />가 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블의 행이 삭제된 후 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테이블의 행이 삭제되기 직전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [DataTable 이벤트 처리](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)합니다.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 테이블에 속한 행의 컬렉션을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Data.DataRowCollection" /> 개체가 포함된 <see cref="T:System.Data.DataRow" />이거나, <see cref="T:System.Data.DataRow" /> 개체가 없으면 null 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새로 만들 <xref:System.Data.DataRow>를 사용 해야 합니다는 <xref:System.Data.DataTable.NewRow%2A> 새 개체를 반환 하는 방법입니다. 이러한 개체에 대해 정의 된 스키마에 따라 자동으로 구성 됩니다 합니다 <xref:System.Data.DataTable> 의 컬렉션을 통해 <xref:System.Data.DataColumn> 개체입니다. 새 행을 만들고 행의 각 열에 대 한 값을 설정 후 행을 추가 합니다 <xref:System.Data.DataRowCollection> 를 사용 하 여를 `Add` 메서드.  
  
 각 <xref:System.Data.DataRow> 컬렉션에 있는 테이블의 데이터 행을 나타냅니다. 행의 열 값으로 변경 내용을 커밋합니다을 호출 해야 합니다 <xref:System.Data.DataTable.AcceptChanges%2A> 메서드.  
  
   
  
## Examples  
 다음 반환 하 고 행을 설정 하는 두 가지 예를 보여 줍니다. 사용 하 여 첫 번째 예제는 <xref:System.Data.DataTable.Rows%2A> 속성 하 고 모든 행에 대 한 각 열의 값을 출력 합니다. 사용 하 여 두 번째 예제는 <xref:System.Data.DataTable> 개체의 <xref:System.Data.DataTable.NewRow%2A> 새 메서드 <xref:System.Data.DataRow> 의 스키마를 사용 하 여 개체를 <xref:System.Data.DataTable>합니다. 행 값으로 설정한 후에 행이 추가 된 <xref:System.Data.DataRowCollection> 를 통해를 `Add` 메서드.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataRow" /> 개체의 배열을 가져옵니다.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 적절 한 정렬 순서를 지정 정렬 조건 <xref:System.Data.DataTable.Select(System.String,System.String)> 또는 <xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 반환 <xref:System.Data.DataRow> 를 통해 개체를 <xref:System.Data.DataTable.Select%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 값</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">행을 필터링하기 위해 사용하는 조건입니다. 예를 들어, 행을 필터링하는 방법은 [DataView RowFilter 구문 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)을 참조하세요.</param>
        <summary>필터 조건에 맞는 모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들려면를 `filterExpression` 인수에 적용 되는 동일한 규칙을 사용 합니다 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 필터 만들기에 대 한 속성 값.  
  
적절 한 정렬 순서를 지정 정렬 조건 <xref:System.Data.DataTable.Select(System.String,System.String)> 또는 <xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>합니다.
  
 열 필터에 null 값이 있으면 결과 포함 되지 않습니다.  
  
   
  
## Examples  
 배열을 반환 하도록 필터 식을 사용 하는 다음 예제에서는 <xref:System.Data.DataRow> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 값</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">행을 필터링하기 위해 사용하는 조건입니다. 예를 들어, 행을 필터링하는 방법은 [DataView RowFilter 구문 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)을 참조하세요.</param>
        <param name="sort">열과 정렬 방향을 지정하는 문자열입니다.</param>
        <summary>필터 조건에 맞는 모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 지정된 정렬 순서대로 가져옵니다.</summary>
        <returns>필터 식에 맞는 <see cref="T:System.Data.DataRow" /> 개체의 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼에는 `filterExpression` 인수를 만들기에 대 한 동일한 규칙을 사용 합니다 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 속성 값입니다. 합니다 `Sort` 클래스의 만들기에 대 한 인수 또한 사용 하 여 동일한 규칙 <xref:System.Data.DataColumn.Expression%2A> 문자열입니다.  
  
 열 필터에 null 값이 있으면 결과 포함 되지 않습니다.  
  
   
  
## Examples  
 배열을 반환 하도록 필터 식을 사용 하는 다음 예제에서는 <xref:System.Data.DataRow> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 값</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">행을 필터링하기 위해 사용하는 조건입니다. 예를 들어, 행을 필터링하는 방법은 [DataView RowFilter 구문 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)을 참조하세요.</param>
        <param name="sort">열과 정렬 방향을 지정하는 문자열입니다.</param>
        <param name="recordStates">
          <see cref="T:System.Data.DataViewRowState" /> 값 중 하나입니다.</param>
        <summary>필터와 일치하는 모든 <see cref="T:System.Data.DataRow" /> 개체의 배열을 지정된 상태와 일치하는 정렬 순서대로 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 폼에는 `filterExpression` 인수를 만들기에 대 한 동일한 규칙을 사용 합니다 <xref:System.Data.DataColumn> 클래스의 <xref:System.Data.DataColumn.Expression%2A> 속성 값입니다. 합니다 `Sort` 클래스의 만들기에 대 한 인수 또한 사용 하 여 동일한 규칙 <xref:System.Data.DataColumn.Expression%2A> 문자열입니다.  
  
 열 필터에 null 값이 있으면 결과 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 필터 식과 레코드 상태를 사용 하 여 배열을 반환할 <xref:System.Data.DataRow> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 값</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataTable" />를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" />에 대한 <see cref="T:System.Data.DataTable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사이트 바인딩를 <xref:System.ComponentModel.Component> 에 <xref:System.ComponentModel.Container> 서로 통신할 수 있도록 할 뿐만 아니라 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />를 참조하세요.</summary>
        <value>해당 컬렉션이 <see cref="T:System.Collections.IList" /> 개체의 컬렉션이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataTable> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.ComponentModel.IListSource.GetList" />를 참조하세요.</summary>
        <returns>해당 개체에서 데이터 소스에 바인딩될 수 있는 <see cref="T:System.Collections.IList" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataTable> 인스턴스가 <xref:System.ComponentModel.IListSource> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />을 serialize하는 데 필요한 데이터로 serialization 정보 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />를 참조하세요.</summary>
        <returns>
          <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 메서드에 의해 생성되고 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> 메서드가 사용하는 개체의 XML 표현을 설명하는 <see cref="T:System.Xml.Schema.XmlSchema" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XmlReader입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">XmlWriter입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Data.DataSet> 인스턴스가 <xref:System.Xml.Serialization.IXmlSerializable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />이 지워진 다음 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.TableCleared> 이벤트는 모든 행이 성공적으로 지워진 전에 직후 발생 합니다.는 <xref:System.Data.DataTable.Clear%2A> 메서드 호출자에 게 컨트롤을 반환 합니다. <xref:System.Data.DataTable.TableCleared> 지우기 작업 하는 동안 모든 예외가 있는 경우 이벤트가 발생 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />이 지워질 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing> 이벤트가 처리 되기 전에 <xref:System.Data.DataTable.Clear%2A> 작업이 시작 합니다. 이 이벤트는 때를 <xref:System.Data.DataTable.Clear%2A> 테이블 0 개의 행을 포함 하는 경우에 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />의 이름을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Data.DataTable" />의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.TableName%2A> 부모에서이 테이블을 반환 하는 데 사용 됩니다 <xref:System.Data.DataSet> 개체의 <xref:System.Data.DataTableCollection> (반환한는 <xref:System.Data.DataSet.Tables%2A> 속성).  
  
   
  
## Examples  
 다음 예제에서는 인쇄 합니다 <xref:System.Data.DataTable.TableName%2A> 컬렉션의 각 테이블에 대해 <xref:System.Data.DataTable> 개체입니다.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> 또는 빈 문자열("")이 전달되고 이 테이블이 컬렉션에 속하는 경우</exception>
        <exception cref="T:System.Data.DuplicateNameException">같은 이름을 가진 테이블이 이미 들어 있는 컬렉션에 테이블이 속한 경우. 비교 시 대/소문자가 구분됩니다.</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>새 <see cref="T:System.Data.DataRow" />가 삽입될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 한 후에 발생 <xref:System.Data.DataRow> 사용 하 여 만들어진 <xref:System.Data.DataTable.NewRow%2A>합니다. 이 이벤트가 발생 하기 전에 호출 된 `NewRow` 메서드 반환 합니다. 새 <xref:System.Data.DataRow> 인스턴스는 분리 되어; 컬렉션에 추가하지 없습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">DataTable 이벤트 사용</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>연결된 문자열이 있는 경우 <see cref="P:System.Data.DataTable.TableName" /> 및 <see cref="P:System.Data.DataTable.DisplayExpression" />을 가져옵니다.</summary>
        <returns>
          <see cref="P:System.Data.DataTable.TableName" /> 및 <see cref="P:System.Data.DataTable.DisplayExpression" /> 값으로 구성된 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가져옵니다 합니다 <xref:System.Data.DataTable.TableName%2A> 하 고 <xref:System.Data.DataTable.DisplayExpression%2A> 에 대 한는 <xref:System.Data.DataTable>합니다.  
  
   
  
## Examples  
 다음 예제에서는 반환 된 <xref:System.Data.DataTable.TableName%2A> 및 <xref:System.Data.DataTable.DisplayExpression%2A> 사용 하 여를 <xref:System.Data.DataTable.ToString%2A> 메서드.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />의 현재 내용을 XML로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>. 이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
> [!NOTE]
>  이 예제에서는 WriteXml의 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다. 사용할 수 있는 다른 예제를 오버 로드 개별 항목을 참조 하십시오.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">데이터가 기록될 스트림입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Stream" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">콘텐츠를 쓰는 데 사용할 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">XML 데이터를 기록할 파일입니다.</param>
        <summary>지정된 파일을 사용하여 <see cref="T:System.Data.DataTable" />의 현재 내용을 XML로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">내용을 기록하는 데 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">데이터가 기록될 스트림입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 <see cref="T:System.IO.Stream" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">데이터가 기록될 스트림입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 지정된 파일에 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">콘텐츠를 쓰는 데 사용할 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 현재 테이블과 모든 하위 항목, 관련 테이블에 대 한 데이터를 작성 하려면 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>. 이 예제에서는 설정 하는 경우 동작을 보여 줍니다 합니다 `writeHierarchy` 매개 변수를 `true`입니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 쓰는 데 사용되는 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">XML 데이터를 기록할 파일입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 파일을 사용하여 <see cref="T:System.Data.DataTable" />의 현재 내용을 XML로 씁니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">데이터가 기록될 파일의 이름입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 파일과 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />에 대해 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">내용을 기록하는 데 사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.DataTable" />의 현재 콘텐츠를 XML로 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체 데이터를 작성 하려면 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 쓰는 데 사용되는 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">데이터가 기록될 스트림입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 지정된 파일에 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 `DataTable` XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터만 저장 합니다. 합니다 `WriteXml` 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 `DataTable` XML 문서로 반면는 `WriteXmlSchema` 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 `XmlWriteMode` 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 쓰는 데 사용되는 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.IO.TextWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터만 저장 합니다. 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 관련 테이블이 현재 테이블과 모든 하위 항목에 대 한 데이터를 쓰는 데 사용 하 여 메서드를 호출 합니다는 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXml%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>. 이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">데이터가 기록될 파일의 이름입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 파일과 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />에 대해 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에 대 한 데이터만 저장 합니다. 현재 테이블 및 스키마의 모든 데이터를 저장 하려는 경우는 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 에 현재 테이블과 모든 하위 항목, 관련 테이블에 대 한 데이터 쓰기를 사용 하 여 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 쓰는 데 사용되는 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 값 중 하나입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 내용을 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 데이터만 씁니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />와 <see cref="T:System.Xml.XmlWriter" />를 사용하여 <see cref="T:System.Data.XmlWriteMode" />의 현재 데이터를 쓰고 선택적으로 스키마를 씁니다. 스키마를 쓰려면 <paramref name="mode" /> 매개 변수 값을 <see langword="WriteSchema" />로 설정합니다. 테이블과 모든 하위 항목의 데이터를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Data.DataTable.WriteXml%2A> 메서드 제공 데이터와 스키마를 모두만 데이터를 작성 하는 방법을 <xref:System.Data.DataTable> XML 문서로 반면는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 메서드는 스키마만 씁니다. 데이터와 스키마를 작성 하려면 포함 하는 오버 로드 중 하나를 사용 합니다 <xref:System.Data.XmlWriteMode> 매개 변수를 해당 값을 설정 하 고 `WriteSchema`입니다.  
  
 True는 동일 합니다 <xref:System.Data.DataTable.ReadXml%2A> 및 <xref:System.Data.DataTable.ReadXmlSchema%2A> 메서드를 각각. XML 데이터 또는 스키마와 데이터를 읽을 수는 `DataTable`를 사용 하 여를 `ReadXml` 메서드. 스키마만을 읽으려면 사용 된 `ReadXmlSchema` 메서드.  
  
 일반적으로 `WriteXml` 메서드는 현재 테이블에만 데이터를 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체 데이터를 작성 하려면 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 경우의 열 형식에 throw 됩니다 합니다 `DataRow` 에서 읽거나 쓴 구현 되 <xref:System.Dynamic.IDynamicMetaObjectProvider> 구현 하지 않습니다 <xref:System.Xml.Serialization.IXmlSerializable>합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>. 이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
> [!NOTE]
>  이 예제에서는 오버 로드 된 버전 중 하나를 사용 하는 방법을 보여 줍니다 `WriteXmlSchema` 다른 예제를 사용할 수 있는 오버 로드 개별 항목을 참조 합니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XML 스키마가 기록될 스트림입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 스트림에 XMl 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.IO.TextWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">사용할 파일의 이름입니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 파일에 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">사용할 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Xml.XmlWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">XML 스키마가 기록될 스트림입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 스트림에 XMl 스키마로 씁니다. 테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">쓰기에 사용할 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.IO.TextWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다. 테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
   
  
## Examples  
 다음 콘솔 응용 프로그램 두 개를 만듭니다 <xref:System.Data.DataTable> 인스턴스, 각 추가 <xref:System.Data.DataSet>를 만듭니다를 <xref:System.Data.DataRelation> 두 관련 테이블을 선택한 다음 사용 하 여는 <xref:System.Data.DataTable.WriteXmlSchema%2A> 는부모테이블내에포함된데이터를쓸메서드<xref:System.IO.TextWriter>. 이 예제에서는 설정 하는 경우 동작을 보여 줍니다는 `writeHierarchy` 매개 변수를 각각의 값입니다.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 이 예제에서는 콘솔 창에 다음 출력을 표시합니다.  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">사용할 파일의 이름입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</param>
        <summary>
          <see cref="T:System.Data.DataTable" />의 현재 데이터 구조를 지정된 파일에 XML 스키마로 씁니다. 테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">문서를 쓰는 데 사용되는 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <param name="writeHierarchy">
          <see langword="true" />이면 현재 테이블과 모든 하위 항목의 스키마를 씁니다. <see langword="false" />(기본값)이면 현재 테이블의 스키마만 씁니다.</param>
        <summary>지정된 <see cref="T:System.Data.DataTable" />를 사용하여 <see cref="T:System.Xml.XmlWriter" />의 현재 데이터 구조를 XML 스키마로 씁니다. 테이블과 모든 하위 항목의 스키마를 저장하려면 <paramref name="writeHierarchy" /> 매개 변수를 <see langword="true" />로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Data.DataTable.WriteXmlSchema%2A> 에 대 한 스키마를 작성 하는 메서드를 <xref:System.Data.DataTable> XML 문서에 합니다. 스키마는 테이블, 관계 및 제약 조건 정의가 포함 되어 있습니다.  
  
 XML 스키마는 XSD 표준을 사용 하 여 기록 됩니다.  
  
 XML 문서에 데이터 쓰기를 사용 하 여를 <xref:System.Data.DataTable.WriteXml%2A> 메서드.  
  
 일반적으로 `WriteXmlSchema` 메서드는 현재 테이블의 스키마만 씁니다. 현재 테이블 및 해당 하위 항목, 관련 테이블을 전체에 대 한 스키마를 작성 하려면이 메서드를 호출 합니다 `writeHierarchy` 매개 변수 설정 `true`합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Creating and Using DataTables</related>
      </Docs>
    </Member>
  </Members>
</Type>