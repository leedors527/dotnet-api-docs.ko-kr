<Type Name="IsolationLevel" FullName="System.Data.IsolationLevel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a81755246b82208ae2abfae05212bd7c9466fab1" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58745439" /></Metadata><TypeSignature Language="C#" Value="public enum IsolationLevel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed IsolationLevel extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Data.IsolationLevel" />
  <TypeSignature Language="VB.NET" Value="Public Enum IsolationLevel" />
  <TypeSignature Language="C++ CLI" Value="public enum class IsolationLevel" />
  <TypeSignature Language="F#" Value="type IsolationLevel = " />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b19f7-101">연결에 대한 트랜잭션 잠금 동작을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-101">Specifies the transaction locking behavior for the connection.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b19f7-102"><xref:System.Data.IsolationLevel> 트랜잭션을 수행 하는 경우 값이.NET Framework 데이터 공급자가 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-102">The <xref:System.Data.IsolationLevel> values are used by a .NET Framework data provider when performing a transaction.</span></span>  
  
 <span data-ttu-id="b19f7-103"><xref:System.Data.IsolationLevel> 계속 적용 될 때까지 명시적으로 변경 하지만 언제 든 지 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-103">The <xref:System.Data.IsolationLevel> remains in effect until explicitly changed, but it can be changed at any time.</span></span> <span data-ttu-id="b19f7-104">새 값을 구문 분석 시간이 아닌 실행 시 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-104">The new value is used at execution time, not parse time.</span></span> <span data-ttu-id="b19f7-105">트랜잭션 중 변경 된 경우 서버의 예상 되는 동작에 나머지 모든 문은 새 잠금 수준을 적용할 경우</span><span class="sxs-lookup"><span data-stu-id="b19f7-105">If changed during a transaction, the expected behavior of the server is to apply the new locking level to all statements remaining.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b19f7-106">이 응용 프로그램을 사용 하는 방법을 보여 줍니다 <xref:System.Data.IsolationLevel> 에서 <xref:System.Data.Common.DbTransaction>합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-106">This application demonstrates how to use <xref:System.Data.IsolationLevel> in <xref:System.Data.Common.DbTransaction>.</span></span> <span data-ttu-id="b19f7-107">샘플은 다른 격리 수준에 있는 수는 다음 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-107">The sample will demonstrate which of the following behaviors are allowed in the different isolation levels:</span></span>  
  
-   <span data-ttu-id="b19f7-108">더티 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-108">Dirty reads.</span></span>  
  
-   <span data-ttu-id="b19f7-109">반복 불가능 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-109">Non-repeatable reads.</span></span>  
  
-   <span data-ttu-id="b19f7-110">가상입니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-110">Phantoms.</span></span>  
  
 <span data-ttu-id="b19f7-111">이 응용 프로그램은 다음 격리 수준에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-111">This application will execute in the following isolation levels:</span></span>  
  
-   <span data-ttu-id="b19f7-112">ReadUncommitted</span><span class="sxs-lookup"><span data-stu-id="b19f7-112">ReadUncommitted</span></span>  
  
-   <span data-ttu-id="b19f7-113">ReadCommitted</span><span class="sxs-lookup"><span data-stu-id="b19f7-113">ReadCommitted</span></span>  
  
-   <span data-ttu-id="b19f7-114">RepeatableRead</span><span class="sxs-lookup"><span data-stu-id="b19f7-114">RepeatableRead</span></span>  
  
-   <span data-ttu-id="b19f7-115">직렬화 가능</span><span class="sxs-lookup"><span data-stu-id="b19f7-115">Serializable</span></span>  
  
-   <span data-ttu-id="b19f7-116">스냅숏</span><span class="sxs-lookup"><span data-stu-id="b19f7-116">Snapshot</span></span>  
  
 <span data-ttu-id="b19f7-117">PhantomReadThreads 클래스 특정 트랜잭션이 Phantom 읽기 동작을 허용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-117">The PhantomReadThreads class demonstrates if the specific transaction allows the Phantom Read behavior.</span></span> <span data-ttu-id="b19f7-118">트랜잭션 동작을 허용 하는 경우 다음 순서 대로 스레드 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-118">If the transaction allows the behavior, the threads will operate in the following order:</span></span>  
  
-   <span data-ttu-id="b19f7-119">첫 번째 스레드는 products(All)를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-119">In first thread, select the products(All).</span></span>  
  
-   <span data-ttu-id="b19f7-120">두 번째 스레드에서 새 제품을 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-120">In the second thread, insert a new product.</span></span>  
  
-   <span data-ttu-id="b19f7-121">두 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-121">Commit the transaction in second thread.</span></span>  
  
-   <span data-ttu-id="b19f7-122">제품을 다시 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-122">Select the products again.</span></span>  
  
-   <span data-ttu-id="b19f7-123">첫 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-123">Commit the transaction in first thread.</span></span>  
  
 <span data-ttu-id="b19f7-124">트랜잭션 동작을 허용 하는 경우 두 개의 Select 작업은 다른 결과를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-124">If the transaction allows the behavior, the two Select operations will get the different results.</span></span>  
  
 <span data-ttu-id="b19f7-125">NonrepeatableReadThreads 클래스 특정 트랜잭션이 반복 하지 않는 읽기 동작을 허용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-125">The NonrepeatableReadThreads class demonstrates if the specific transaction allows the Nonrepeatable Read behavior.</span></span> <span data-ttu-id="b19f7-126">트랜잭션 동작을 허용 하는 경우 다음 순서 대로 스레드 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-126">If the transaction allows the behavior, the threads will operate in the following order:</span></span>  
  
-   <span data-ttu-id="b19f7-127">첫 번째 스레드는 product(ProductId=1)를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-127">In first thread, select the product(ProductId=1).</span></span>  
  
-   <span data-ttu-id="b19f7-128">두 번째 스레드에서 수량 value(ProductId=1)를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-128">In the second thread, update the Quantity value(ProductId=1).</span></span>  
  
-   <span data-ttu-id="b19f7-129">두 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-129">Commit the transaction in second thread.</span></span>  
  
-   <span data-ttu-id="b19f7-130">제품을 다시 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-130">Select the product again.</span></span>  
  
-   <span data-ttu-id="b19f7-131">첫 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-131">Commit the transaction in first thread.</span></span>  
  
 <span data-ttu-id="b19f7-132">트랜잭션 동작을 허용 하는 경우 두 개의 Select 작업은 다른 결과를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-132">If the transaction allows the behavior, the two Select operations will get the different results.</span></span>  
  
 <span data-ttu-id="b19f7-133">ExchangeValuesThreads 클래스 Serializable 및 Snapshot 트랜잭션 간의 차이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-133">The ExchangeValuesThreads class demonstrates the difference between the Serializable and Snapshot transaction.</span></span> <span data-ttu-id="b19f7-134">직렬화 가능 트랜잭션의 스레드 다음 순서 대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-134">For the Serializable transaction, threads will operate in the following order:</span></span>  
  
-   <span data-ttu-id="b19f7-135">첫 번째 스레드에서 변수에 product(ProductId=2) 및 저장소의 가격을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-135">In first thread, get the Price of product(ProductId=2) and store in the variable.</span></span>  
  
-   <span data-ttu-id="b19f7-136">첫 번째 스레드에서 product(ProductId=2)의 가격을 사용 하 여 product(ProductId=1)의 가격을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-136">In first thread, update the Price of product(ProductId=1) with the price of product(ProductId=2).</span></span>  
  
-   <span data-ttu-id="b19f7-137">첫 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-137">Commit the transaction in first thread.</span></span>  
  
-   <span data-ttu-id="b19f7-138">두 번째 스레드에서 변수에 product(ProductId=1) 및 저장소의 가격을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-138">In second thread, get the Price of product(ProductId=1) and store in the variable.</span></span>  
  
-   <span data-ttu-id="b19f7-139">두 번째 스레드에서 product(ProductId=1)의 가격을 사용 하 여 product(ProductId=2)의 가격을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-139">In second thread, update the Price of product(ProductId=2) with the price of product(ProductId=1).</span></span>  
  
-   <span data-ttu-id="b19f7-140">두 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-140">Commit the transaction in second thread.</span></span>  
  
 <span data-ttu-id="b19f7-141">이제 가격의 값 (ProductId = 1 및 ProductId = 2)는 원래 Product(ProductId=2) 가격은 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-141">Now the values of the Price(ProductId=1 and ProductId=2) are as same as the original Price of Product(ProductId=2).</span></span>  
  
 <span data-ttu-id="b19f7-142">스냅숏 트랜잭션에 대 한 스레드 다음 순서 대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-142">For the Snapshot transaction, threads will operate in the following order:</span></span>  
  
-   <span data-ttu-id="b19f7-143">첫 번째 스레드에서 변수에; product(ProductId=2) 및 저장소의 가격 가져오기</span><span class="sxs-lookup"><span data-stu-id="b19f7-143">In first thread, get the Price of product(ProductId=2) and store in the variable;</span></span>  
  
-   <span data-ttu-id="b19f7-144">첫 번째 스레드에서 product(ProductId=2)의 가격을 사용 하 여 product(ProductId=1)의 가격을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-144">In first thread, update the Price of product(ProductId=1) with the price of product(ProductId=2).</span></span>  
  
-   <span data-ttu-id="b19f7-145">두 번째 스레드에서 스냅숏에서 product(ProductId=1)의 가격을 가져와서 변수에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-145">In second thread, get the Price of product(ProductId=1) from the snapshot and store in the variable.</span></span>  
  
-   <span data-ttu-id="b19f7-146">두 번째 스레드에서 product(ProductId=1)의 가격을 사용 하 여 product(ProductId=2)의 가격을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-146">In second thread, update the Price of product(ProductId=2) with the price of product(ProductId=1).</span></span>  
  
-   <span data-ttu-id="b19f7-147">두 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-147">Commit the transaction in second thread.</span></span>  
  
-   <span data-ttu-id="b19f7-148">첫 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-148">Commit the transaction in first thread.</span></span>  
  
 <span data-ttu-id="b19f7-149">이제 제품의 가격을 교환 (ProductId = 1 및 ProductId = 2).</span><span class="sxs-lookup"><span data-stu-id="b19f7-149">Now exchange the Price of products(ProductId=1 and ProductId=2).</span></span>  
  
 <span data-ttu-id="b19f7-150">DirtyReadThreads 클래스 특정 트랜잭션이 커밋되지 않은 읽기 동작을 허용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-150">The DirtyReadThreads class demonstrates if the specific transaction allows the Dirty Read behavior.</span></span> <span data-ttu-id="b19f7-151">트랜잭션 동작을 허용 하는 경우 다음 순서 대로 스레드 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-151">If the transaction allows the behavior, the threads will operate in the following order:</span></span>  
  
-   <span data-ttu-id="b19f7-152">첫 번째 스레드에서 트랜잭션을 시작 하 고 수량 value(ProductId=1)를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-152">In first thread, begin a transaction and add the Quantity value(ProductId=1).</span></span>  
  
-   <span data-ttu-id="b19f7-153">두 번째 스레드에서 수량 값을 읽고 값을 다시 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-153">In the second thread, read the Quantity value and add the value again.</span></span>  
  
-   <span data-ttu-id="b19f7-154">두 번째 스레드에서 트랜잭션을 커밋하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-154">Commit the transaction in second thread.</span></span>  
  
-   <span data-ttu-id="b19f7-155">첫 번째 스레드에서 트랜잭션을 롤백하십시오.</span><span class="sxs-lookup"><span data-stu-id="b19f7-155">Roll back the transaction in first thread.</span></span>  
  
 <span data-ttu-id="b19f7-156">트랜잭션 동작을 허용 하는 경우 수량 값을 두 번 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-156">If the transaction allows the behavior, the Quantity value will be added twice.</span></span>  
  
 <span data-ttu-id="b19f7-157">이 코드 샘플을 사용 하 여 C# 및 Visual Basic 프로젝트에서 찾을 수 있습니다 [개발자 코드 샘플](https://code.msdn.microsoft.com/site/search?query=How%20to%20use%20IsolationLevel%20Enumeration%20in%20DbTransaction&f%5B0%5D.Value=How%20to%20use%20IsolationLevel%20Enumeration%20in%20DbTransaction&f%5B0%5D.Type=SearchText&ac=4)합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-157">C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](https://code.msdn.microsoft.com/site/search?query=How%20to%20use%20IsolationLevel%20Enumeration%20in%20DbTransaction&f%5B0%5D.Value=How%20to%20use%20IsolationLevel%20Enumeration%20in%20DbTransaction&f%5B0%5D.Type=SearchText&ac=4).</span></span>  
  
 [!code-csharp[system_data_IsolationLevel#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/system_data_isolationlevel/cs/source.cs#1)]
 [!code-vb[system_data_IsolationLevel#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/system_data_isolationlevel/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Chaos">
      <MemberSignature Language="C#" Value="Chaos" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel Chaos = int32(16)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.Chaos" />
      <MemberSignature Language="VB.NET" Value="Chaos" />
      <MemberSignature Language="C++ CLI" Value="Chaos" />
      <MemberSignature Language="F#" Value="Chaos = 16" Usage="System.Data.IsolationLevel.Chaos" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-158">격리 수준이 높은 트랜잭션에서 보류 중인 변경은 덮어쓸 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-158">The pending changes from more highly isolated transactions cannot be overwritten.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ReadCommitted">
      <MemberSignature Language="C#" Value="ReadCommitted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel ReadCommitted = int32(4096)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.ReadCommitted" />
      <MemberSignature Language="VB.NET" Value="ReadCommitted" />
      <MemberSignature Language="C++ CLI" Value="ReadCommitted" />
      <MemberSignature Language="F#" Value="ReadCommitted = 4096" Usage="System.Data.IsolationLevel.ReadCommitted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>4096</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-159">공유 잠금은 커밋되지 않은 읽기를 방지하기 위해 데이터를 읽는 동안 유지되지만 트랜잭션이 끝나기 전에 데이터가 변경되어 반복되지 않은 읽기나 팬텀 데이터가 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-159">Shared locks are held while the data is being read to avoid dirty reads, but the data can be changed before the end of the transaction, resulting in non-repeatable reads or phantom data.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ReadUncommitted">
      <MemberSignature Language="C#" Value="ReadUncommitted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel ReadUncommitted = int32(256)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.ReadUncommitted" />
      <MemberSignature Language="VB.NET" Value="ReadUncommitted" />
      <MemberSignature Language="C++ CLI" Value="ReadUncommitted" />
      <MemberSignature Language="F#" Value="ReadUncommitted = 256" Usage="System.Data.IsolationLevel.ReadUncommitted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>256</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-160">공유 잠금이 발행되지 않았고 단독 잠금이 부여되지 않았음을 의미하는 더티 읽기가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-160">A dirty read is possible, meaning that no shared locks are issued and no exclusive locks are honored.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="RepeatableRead">
      <MemberSignature Language="C#" Value="RepeatableRead" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel RepeatableRead = int32(65536)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.RepeatableRead" />
      <MemberSignature Language="VB.NET" Value="RepeatableRead" />
      <MemberSignature Language="C++ CLI" Value="RepeatableRead" />
      <MemberSignature Language="F#" Value="RepeatableRead = 65536" Usage="System.Data.IsolationLevel.RepeatableRead" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>65536</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-161">잠금은 쿼리에서 사용되는 모든 데이터에 적용되어 데이터를 다른 사용자가 업데이트할 수 없게 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-161">Locks are placed on all data that is used in a query, preventing other users from updating the data.</span></span> <span data-ttu-id="b19f7-162">반복되지 않은 읽기를 금지하지만 팬텀 행의 경우는 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-162">Prevents non-repeatable reads but phantom rows are still possible.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="Serializable">
      <MemberSignature Language="C#" Value="Serializable" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel Serializable = int32(1048576)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.Serializable" />
      <MemberSignature Language="VB.NET" Value="Serializable" />
      <MemberSignature Language="C++ CLI" Value="Serializable" />
      <MemberSignature Language="F#" Value="Serializable = 1048576" Usage="System.Data.IsolationLevel.Serializable" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>1048576</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-163">범위 잠금을 <see cref="T:System.Data.DataSet" />에 적용하여 트랜잭션이 완료될 때까지 다른 사용자가 데이터 세트에 행을 삽입하거나 업데이트할 수 없게 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-163">A range lock is placed on the <see cref="T:System.Data.DataSet" />, preventing other users from updating or inserting rows into the dataset until the transaction is complete.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="Snapshot">
      <MemberSignature Language="C#" Value="Snapshot" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel Snapshot = int32(16777216)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.Snapshot" />
      <MemberSignature Language="VB.NET" Value="Snapshot" />
      <MemberSignature Language="C++ CLI" Value="Snapshot" />
      <MemberSignature Language="F#" Value="Snapshot = 16777216" Usage="System.Data.IsolationLevel.Snapshot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>16777216</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-164">동일한 데이터에 대해 한 응용 프로그램에서 데이터를 수정하고 있을 때 또 다른 응용 프로그램에서 읽을 수 있는 데이터 버전을 저장하여 차단을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-164">Reduces blocking by storing a version of data that one application can read while another is modifying the same data.</span></span> <span data-ttu-id="b19f7-165">다시 쿼리해도 한 트랜잭션에서 다른 트랜잭션의 변경 내용을 볼 수 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-165">Indicates that from one transaction you cannot see changes made in other transactions, even if you requery.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="Unspecified">
      <MemberSignature Language="C#" Value="Unspecified" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Data.IsolationLevel Unspecified = int32(-1)" />
      <MemberSignature Language="DocId" Value="F:System.Data.IsolationLevel.Unspecified" />
      <MemberSignature Language="VB.NET" Value="Unspecified" />
      <MemberSignature Language="C++ CLI" Value="Unspecified" />
      <MemberSignature Language="F#" Value="Unspecified = -1" Usage="System.Data.IsolationLevel.Unspecified" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IsolationLevel</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="b19f7-166">지정된 격리 수준과 다른 수준이 사용되지만 수준을 결정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-166">A different isolation level than the one specified is being used, but the level cannot be determined.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b19f7-167">사용 하는 경우 <xref:System.Data.Odbc.OdbcTransaction>설정 하지 않은 경우 <xref:System.Data.IsolationLevel> 설정한 또는 <xref:System.Data.IsolationLevel> 하려면 `Unspecified`, 트랜잭션이 실행 되는 드라이버에 의해 결정 되는 격리 수준에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="b19f7-167">When using <xref:System.Data.Odbc.OdbcTransaction>, if you do not set <xref:System.Data.IsolationLevel> or you set <xref:System.Data.IsolationLevel> to `Unspecified`, the transaction executes according to the isolation level that is determined by the driver that is being used.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>