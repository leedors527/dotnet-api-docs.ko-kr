<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d47684b994c25f668409bc728450e90e28479cfa" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52913483" /></Metadata><TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows NT 성능 카운터 구성 요소를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter> 미리 정의 된 기존 또는 사용자 지정 카운터 읽기와 게시 (쓰기) 성능에 대 한 구성 요소를 사용할 수 데이터를 사용자 지정 카운터입니다.  
  
 Windows 성능 모니터에 나열 된 다양 한 미리 정의 된 카운터가 [카운터 추가 대화 상자](https://go.microsoft.com/fwlink/p/?LinkId=257854)합니다. .NET Framework 성능 카운터를 알아보려면 [성능 카운터](~/docs/framework/debug-trace-profile/performance-counters.md)합니다.  
  
 이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면 직접 또는 간접적으로의 삭제 해야 있습니다. 직접 형식의 dispose 호출 해당 <xref:System.IDisposable.Dispose%2A> 의 메서드를 `try` / `catch` 블록입니다. 삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는). 자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
> [!IMPORTANT]
>  버전 1.0 및 1.1의.NET Framework에서는이 클래스는 완전히 신뢰 된 코드로 직접 실행 호출자가 필요 합니다. 이 클래스에 필요한.NET Framework 버전 2.0부터 <xref:System.Diagnostics.PerformanceCounterPermission> 특정 작업에 대 한 합니다. 것이 좋습니다는 <xref:System.Diagnostics.PerformanceCounterPermission> 부분 신뢰 코드에 부여 되지 않습니다.  읽기 및 쓰기 성능 카운터 수에는 코드를를 실행 중인 프로세스 및 가져오는 데 정보를 열거 하는 등 작업을 수행할 수 있습니다.  
>   
>  또한 전달 된 <xref:System.Diagnostics.PerformanceCounter> 개체 신뢰할 수 없는 코드를 보안 문제가 발생할 수 있습니다. 전달 하지 성능 카운터 개체와 같은 <xref:System.Diagnostics.PerformanceCounterCategory> 또는 <xref:System.Diagnostics.PerformanceCounter>를 신뢰할 수 있는 작은 코드입니다.  
  
 성능 카운터를 읽어올 수의 인스턴스를 만듭니다는 <xref:System.Diagnostics.PerformanceCounter> 클래스에서 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 필요에 따라를 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 또는 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 속성 및 호출은 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 성능 수행 하는 방법 카운터를 읽습니다.  
  
 성능 카운터 데이터를 게시 하려면 사용 하 여 하나 이상의 사용자 지정 카운터를 만듭니다는 <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> 메서드를의 인스턴스를 만듭니다를 <xref:System.Diagnostics.PerformanceCounter> 클래스에서 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 및 필요에 따라 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 또는 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 속성 호출을 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, 또는 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 메서드 또는 집합을 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 속성을 사용자 지정 카운터의 값을 변경 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 메서드 상호 잠금을 사용 하 여 카운터 값을 업데이트 합니다. 이렇게 하면 다중 스레드 또는 다중 프로세스 시나리오 뿐만 아니라 성능 저하에서는 결과의 카운터 값을 정확 하 게 유지 합니다. 연동 하는 정확도 필요 하지 않은 경우 작업을 제공, 업데이트할 수 있습니다는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 5까지 속성에 직접 시간 성능 향상.  그러나 다중 스레드 시나리오에서 몇 가지 업데이트 카운터 값을 무시 될 수 있습니다, 잘못 된 데이터가 생성 합니다.  
  
 카운터는 성능에서 데이터가 수집 되는 메커니즘입니다. 레지스트리는 시스템 기능의 특정 영역 관련이 있으며 각 모든 카운터의 이름을 저장 합니다. 프로세서의 사용량이 많은 시간, 메모리 사용량 또는 네트워크 연결을 통해 수신 된 바이트 수가 예로 들 수 있습니다.  
  
 각 카운터의 이름 및 해당 위치를 통해 고유 하 게 식별 됩니다. 파일 경로 드라이브, 디렉터리, 하나 이상의 하위 디렉터리 및 파일 이름을 포함 하는 동일한 방법으로 네 가지 요소로 구성 됩니다 카운터 정보: 컴퓨터, 범주, 범주 인스턴스 및 카운터 이름입니다.  
  
 범주 또는 성능 개체, 카운터에 대 한 데이터를 측정 하는 카운터 정보를 포함 해야 합니다. 프로세서, 디스크 및 메모리와 같은 물리적 구성 요소를 포함 하는 컴퓨터의 범주입니다. 프로세스 및 스레드와 같은 시스템 범주도 있습니다. 각 범주의 컴퓨터에서 기능 요소와 관련 되며 및 표준 카운터 집합을 할당 합니다. 이러한 개체는 Windows 2000 시스템 모니터 내에서 카운터 추가 대화 상자의 성능 개체 드롭다운 목록에서 나열 하 고 카운터 경로에 포함 해야 합니다. 성능 데이터를 범주는 관련 하 여 그룹화 됩니다.  
  
 경우에 따라 동일한 범주의 여러 복사본이 있을 수 있습니다. 예를 들어, 여러 프로세스 및 스레드 동시에 실행 하 고 일부 컴퓨터는 둘 이상의 프로세서를 포함 합니다. 범주 복사본은 범주 인스턴스를 호출 하 고 각 인스턴스에 할당 된 표준 카운터 집합이 키를 누릅니다. 범주 둘 이상의 인스턴스 수 있으면 인스턴스 사양 카운터 정보에 포함 되어야 합니다.  
  
 초기 또는 이전 값을 필요한 계산을 수행 하는 데 필요한 카운터에 대 한 성능 데이터를 가져오려면 호출을 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 메서드를 두 번 및 사용 하 여 응용 프로그램에 필요한 정보를 반환 합니다.  
  
> [!NOTE]
>  성능 카운터 범주와 함께 설치 된 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 자체 메모리가 있는 각 성능 카운터 범주를 사용 하 여 별도 공유 메모리를 사용 합니다. 레지스트리 키 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services FileMappingSize 라는 DWORD를 만들어 별도 공유 메모리의 크기를 지정할 수 있습니다\\*\<범주 이름 >* \ 성능을 제공 합니다. FileMappingSize 값 범주의 공유 메모리 크기 설정 됩니다. 기본 크기는 10 진수 131072입니다. FileMappingSize 값 없는 경우는 `fileMappingSize` 특성에 대 한 값을 `performanceCounters` 합니다 Machine.config 파일에 지정 된 요소를 사용할 구성 파일을 처리에 대 한 추가 오버 헤드를 유발 합니다. 레지스트리에서 파일 매핑 크기를 설정 하 여 응용 프로그램 시작에 대 한 성능 향상을 이룰 수 있습니다. 파일 매핑 크기에 대 한 자세한 내용은 참조 하세요. [ &lt;performanceCounters&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Diagnostics.PerformanceCounter> 만들고 사용 하는 클래스는 <xref:System.Diagnostics.PerformanceCounterType.AverageCount64> 카운터 형식과 합니다. 예제 범주, 카운터를 설정, 카운터 및 호출에서 데이터를 수집 합니다 <xref:System.Diagnostics.CounterSampleCalculator> 성능 카운터 데이터를 해석 하는 클래스입니다. 중간 및 최종 결과 콘솔 창에 표시 됩니다. 다른 성능 카운터 형식의 추가 예 참조는 <xref:System.Diagnostics.PerformanceCounterType> 열거형입니다.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 클래스는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <summary><see cref="T:System.Diagnostics.PerformanceCounter" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>새 읽기 전용 인스턴스를 초기화 합니다 <see cref="T:System.Diagnostics.PerformanceCounter" /> 모든 시스템이 나 사용자 지정 성능 카운터를 사용 하 여 인스턴스를 연결 하지 않고 클래스입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자의 오버이 로드는 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성을 빈 문자열 (""), 설정 및는 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 속성을 로컬 컴퓨터 (".").  
  
 이 생성자를 로컬 컴퓨터의 기존 카운터 인스턴스를 연결 하지 않습니다 있도록 성능 카운터를 초기화 하지 않습니다. 특정 성능 카운터를 가리키도록 설정 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 필요에 따라는 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 및 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 다른 속성을 읽거나 카운터를 읽는 동안 하기 전에 속성입니다. 성능 카운터를 작성 하려면 설정 합니다 <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> 속성을 `false`입니다.  
  
> [!NOTE]
>  합니다 <xref:System.Security.Permissions.HostProtectionAttribute> 이 멤버에 적용 된 특성에는 다음과 같은 <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A> 속성 값: <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>합니다. <xref:System.Security.Permissions.HostProtectionAttribute>는 대개 아이콘을 두 번 클릭하거나, 명령을 입력하거나, 브라우저에서 URL을 입력하여 시작되는 데스크톱 응용 프로그램에 영향을 미치지 않습니다. 자세한 내용은 참조는 <xref:System.Security.Permissions.HostProtectionAttribute> 클래스 또는 [SQL Server 프로그래밍 및 호스트 보호 특성](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 기본 인스턴스를 만듭니다를 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다. 인스턴스가 만들어진 후 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성 값은 집합 및에 대 한 호출의 결과 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 메서드가 표시 됩니다.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">이 성능 카운터와 관련 된 성능 카운터 범주 (성능 개체)의 이름입니다.</param>
        <param name="counterName">성능 카운터의 이름입니다.</param>
        <summary>새 읽기 전용 인스턴스를 초기화 합니다 <see cref="T:System.Diagnostics.PerformanceCounter" /> 클래스의 지정된 시스템이 나 로컬 컴퓨터의 사용자 지정 성능 카운터를 사용 하 여 연결 합니다. 이 생성자 범주가 단일 인스턴스가 있어야 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수 문자열 대/소문자 구분 없는 합니다.  
  
 이 오버 로드를 사용 하 여 로컬 컴퓨터의 단일 성능 카운터 범주 인스턴스를 포함 하는 범주에 속하는 카운터에 액세스. 이 가리키도록이 생성자를 사용 하려고 하면 <xref:System.Diagnostics.PerformanceCounter> 생성자 예외를 throw 하는 여러 인스턴스를 포함 하는 범주 인스턴스입니다. 이 오버 로드 수 읽기 전용 액세스 또는 읽기/쓰기 카운터, 하지만 읽기 전용 모드에서입니다. <xref:System.Diagnostics.PerformanceCounter> 카운터 자체는 읽기/쓰기 경우에이 오버 로드를 사용 하 여 만든 인스턴스 카운터를 쓸 수 없습니다.  
  
 이 생성자의 오버이 로드를 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 및 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 속성 값을 있습니다 전달, 설정 합니다 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 로컬 컴퓨터에 대 한 속성 ".", 설정 및를 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성을 빈 문자열로 ("").  
  
 이 생성자는 성능 카운터를 초기화 하 고 로컬 컴퓨터의 기존 카운터 (시스템 또는 사용자 지정 카운터) 인스턴스를 연결 합니다. 에 대 한에 전달 하는 값을 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 및 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 속성은 로컬 컴퓨터의 기존 성능 카운터를 가리켜야 합니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="counterName" />가 빈 문자열("")인 경우  
  
또는 
지정 된 범주 존재 하지 않습니다.  
  
또는 
지정한 범주가 다중 인스턴스로 표시 되 고 필요한 성능 카운터 인스턴스 이름을 사용 하 여 만들어집니다.  
  
또는 
 <paramref name="categoryName" /> 및 <paramref name="counterName" /> 다른 언어로 지역화 된 합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 또는 <paramref name="counterName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">이 성능 카운터와 관련 된 성능 카운터 범주 (성능 개체)의 이름입니다.</param>
        <param name="counterName">성능 카운터의 이름입니다.</param>
        <param name="readOnly"><see langword="true" /> (카운터 자체는 읽기/쓰기 수 있음) 되지만 읽기 전용 모드로 카운터에 액세스할 수 있습니다. <see langword="false" /> 읽기/쓰기 모드로 카운터에 액세스할 수 있습니다.</param>
        <summary>초기화 하 여 새로 만들기, 읽기 전용 또는 읽기/쓰기 인스턴스를 <see cref="T:System.Diagnostics.PerformanceCounter" /> 클래스의 지정된 시스템이 나 로컬 컴퓨터의 사용자 지정 성능 카운터를 사용 하 여 연결 합니다. 이 생성자에 단일 인스턴스가 포함 된 범주는 필요 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수 문자열 대/소문자 구분 없는 합니다.  
  
 이 오버 로드를 사용 하 여 읽기 전용 액세스 또는 읽기/쓰기 단일 성능 카운터 범주 인스턴스를 포함 하는 범주에 속하는 로컬 컴퓨터에서 카운터. 이 가리키도록이 생성자를 사용 하려고 하면 <xref:System.Diagnostics.PerformanceCounter> 생성자 예외를 throw 하는 여러 인스턴스를 포함 하는 범주 인스턴스입니다.  
  
 이 생성자의 오버이 로드는 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> 속성 값을 있습니다 전달, 설정를 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 속성을 로컬 컴퓨터 ".", 설정 및는 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성을 빈 문자열로 ("").  
  
 이 생성자는 성능 카운터를 초기화 하 고 로컬 컴퓨터의 기존 카운터 (시스템 또는 사용자 지정 카운터) 인스턴스를 연결 합니다. 에 대 한에 전달 하는 값을 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 및 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 속성은 로컬 컴퓨터의 기존 성능 카운터를 가리켜야 합니다. 성능 카운터 인스턴스를 가리키는 올바르지 않으면 예외를 throw 생성자를 호출 합니다.  
  
> [!NOTE]
>  이 오버 로드를 사용 하 여 시스템 카운터에 연결할 수 있지만 시스템 카운터에 쓸 수 없습니다. 따라서 설정 `readOnly` 에 `false` 경우 생성자에서 예외를 throw 하면 시스템 카운터에 연결 합니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
   
  
## Examples  
 인스턴스를 만들고 다음 코드 예제는 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다. 이 예제에서는 범주 이름, 카운터 이름 및 카운터는 읽기 전용으로 나타내는 플래그 값을 전달 합니다. 이 코드 예제는에 대 한 보다 큰 예제의 일부는 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" /> 은 빈 문자열 ("").  
  
또는 
<paramref name="counterName" /> 은 빈 문자열 ("").  
  
또는 
지정 된 범주 존재 하지 않습니다. (경우 <paramref name="readOnly" /> 는 <see langword="true" />).  
  
또는 
지정한 범주가.NET Framework 사용자 지정 범주가 아닙니다. (하는 경우 <paramref name="readOnly" /> 는 <see langword="false" />).  
  
또는 
지정한 범주가 다중 인스턴스로 표시 되 고 필요한 성능 카운터 인스턴스 이름을 사용 하 여 만들어집니다.  
  
또는 
 <paramref name="categoryName" /> 및 <paramref name="counterName" /> 다른 언어로 지역화 된 합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 또는 <paramref name="counterName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">이 성능 카운터와 관련 된 성능 카운터 범주 (성능 개체)의 이름입니다.</param>
        <param name="counterName">성능 카운터의 이름입니다.</param>
        <param name="instanceName">성능 카운터 범주 인스턴스의 또는 빈 문자열의 이름 ("") 이면 범주에는 단일 인스턴스를 포함 합니다.</param>
        <summary>새 읽기 전용 인스턴스를 초기화 합니다 <see cref="T:System.Diagnostics.PerformanceCounter" /> 클래스와 지정 된 시스템 또는 로컬 컴퓨터의 사용자 지정 성능 카운터 및 범주 인스턴스에 연결 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수 문자열 대/소문자 구분 없는 합니다.  
  
 이 생성자의 오버이 로드는 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성 값을 전달할 하 설정는 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 로컬 컴퓨터에 대 한 속성 "."입니다.  
  
 이 생성자는 성능 카운터를 초기화 하 고 로컬 컴퓨터의 기존 카운터 (시스템 또는 사용자 지정 카운터) 인스턴스를 연결 합니다. 에 대 한에 전달 하는 값을 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성은 로컬 컴퓨터의 기존 성능 카운터를 가리켜야 합니다. 성능 카운터 인스턴스를 가리키는 올바르지 않으면 예외를 throw 생성자를 호출 합니다.  
  
 이 오버 로드 수 읽기 전용 액세스 또는 읽기/쓰기 카운터, 하지만 읽기 전용 모드에서입니다. <xref:System.Diagnostics.PerformanceCounter> 카운터 자체는 읽기/쓰기 경우에이 오버 로드를 사용 하 여 만든 인스턴스 카운터를 쓸 수 없습니다.  
  
 성능 범주 인스턴스를 만들려면 지정는 `instanceName` 에 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 생성자입니다. 으로 지정 된 범주 인스턴스 `instanceName` 이미 새 개체는 기존 범주 인스턴스를 참조 합니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="counterName" />가 빈 문자열("")인 경우  
  
또는 
지정 된 범주에 유효 하지 않습니다.  
  
또는 
지정한 범주가 다중 인스턴스로 표시 되 고 필요한 성능 카운터 인스턴스 이름을 사용 하 여 만들어집니다.  
  
또는 
 <paramref name="instanceName" /> 127 자 보다 깁니다.  
  
또는 
 <paramref name="categoryName" /> 및 <paramref name="counterName" /> 다른 언어로 지역화 된 합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 또는 <paramref name="counterName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">이 성능 카운터와 관련 된 성능 카운터 범주 (성능 개체)의 이름입니다.</param>
        <param name="counterName">성능 카운터의 이름입니다.</param>
        <param name="instanceName">성능 카운터 범주 인스턴스의 또는 빈 문자열의 이름 ("") 이면 범주에는 단일 인스턴스를 포함 합니다.</param>
        <param name="readOnly"><see langword="true" /> 읽기 전용 모드에 있는 카운터에 액세스 하려면 <see langword="false" /> 읽기/쓰기 모드로 카운터에 액세스할 수 있습니다.</param>
        <summary>초기화 하 여 새로 만들기, 읽기 전용 또는 읽기/쓰기 인스턴스를 <see cref="T:System.Diagnostics.PerformanceCounter" /> 클래스와 지정 된 시스템 또는 로컬 컴퓨터의 사용자 지정 성능 카운터 및 범주 인스턴스에 연결 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수 문자열 대/소문자 구분 없는 합니다.  
  
 이 오버 로드를 사용 하 여 성능 카운터 중 하나에 액세스 하려면 읽기 전용 또는 읽기/쓰기 모드입니다.  
  
 이 생성자의 오버이 로드는 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 전달 하 고 집합의 속성 값을는 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 로컬 컴퓨터에 대 한 속성 "."입니다.  
  
 이 생성자는 성능 카운터를 초기화 하 고 로컬 컴퓨터의 기존 카운터 (시스템 또는 사용자 지정 카운터) 인스턴스를 연결 합니다. 에 대 한에 전달 하는 값을 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성은 로컬 컴퓨터의 기존 성능 카운터를 가리켜야 합니다. 성능 카운터 인스턴스를 가리키는 올바르지 않으면 예외를 throw 생성자를 호출 합니다.  
  
> [!NOTE]
>  이 오버 로드를 사용 하 여 시스템 카운터에 연결할 수 있지만 시스템 카운터에 쓸 수 없습니다. 따라서 설정 `readOnly` 에 `false` 경우 생성자에서 예외를 throw 하면 시스템 카운터에 연결 합니다.  
  
 성능 범주 인스턴스를 만들려면 지정는 `instanceName` 에 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 생성자입니다. 으로 지정 된 범주 인스턴스 `instanceName` 이미 새 개체는 기존 범주 인스턴스를 참조 합니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="counterName" />가 빈 문자열("")인 경우  
  
또는 
읽기/쓰기 권한 설정을 요청한이 카운터에 대해 올바르지 않습니다.  
  
또는 
지정한 범주가 없습니다 (하는 경우 <paramref name="readOnly" /> 는 <see langword="true" />).  
  
또는 
지정한 범주가.NET Framework 사용자 지정 범주가 아닙니다. (하는 경우 <paramref name="readOnly" /> 는 <see langword="false" />).  
  
또는 
지정한 범주가 다중 인스턴스로 표시 되 고 필요한 성능 카운터 인스턴스 이름을 사용 하 여 만들어집니다.  
  
또는 
 <paramref name="instanceName" /> 127 자 보다 깁니다.  
  
또는 
 <paramref name="categoryName" /> 및 <paramref name="counterName" /> 다른 언어로 지역화 된 합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 또는 <paramref name="counterName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">이 성능 카운터와 관련 된 성능 카운터 범주 (성능 개체)의 이름입니다.</param>
        <param name="counterName">성능 카운터의 이름입니다.</param>
        <param name="instanceName">성능 카운터 범주 인스턴스의 또는 빈 문자열의 이름 ("") 이면 범주에는 단일 인스턴스를 포함 합니다.</param>
        <param name="machineName">성능 카운터와 관련된 범주가 있는 컴퓨터입니다.</param>
        <summary>새 읽기 전용 인스턴스를 초기화 합니다 <see cref="T:System.Diagnostics.PerformanceCounter" /> 클래스의 지정된 시스템이 나 사용자 지정 성능 카운터 및 범주 인스턴스를 지정된 된 컴퓨터에 연결 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수 문자열 대/소문자 구분 없는 합니다.  
  
 이 생성자의 오버이 로드는 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 에서 전달 된 값으로 속성입니다.  
  
 이 생성자는 성능 카운터를 초기화 하 고 기존 카운터 (시스템 또는 사용자 지정 카운터) 지정한 컴퓨터의 인스턴스를 연결 합니다. 에 대 한에 전달 하는 값을 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 및 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 속성은 기존 성능 카운터를 가리켜야 합니다. 성능 카운터 인스턴스를 가리키는 올바르지 않으면 예외를 throw 생성자를 호출 합니다. 이 오버 로드 수 읽기 전용 액세스 또는 읽기/쓰기 카운터, 하지만 읽기 전용 모드에서입니다. <xref:System.Diagnostics.PerformanceCounter> 카운터 자체는 읽기/쓰기 경우에이 오버 로드를 사용 하 여 만든 인스턴스 카운터를 쓸 수 없습니다.  
  
> [!NOTE]
>  원격 성능 카운터를 쓸 수 없습니다. 읽기/쓰기 인스턴스를 지정할 수 있는 오버 로드가 없는 <xref:System.Diagnostics.PerformanceCounter> 원격 컴퓨터에 연결 하는 클래스입니다.  
  
 성능 범주 인스턴스를 만들려면 지정는 `instanceName` 에 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 생성자입니다. 으로 지정 된 범주 인스턴스 `instanceName` 이미 새 개체는 기존 범주 인스턴스를 참조 합니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
> [!NOTE]
>  Windows vista에서는 원격 컴퓨터를 작업 그룹의 멤버인 경우 해야 로컬 사용자 계정 필터링 하지 않은 하 고 관리자 계정으로 승격 될 수 있도록 UAC를 사용 하지 않도록 설정 합니다. 보안상의 이유로 UAC를 사용 하지 않도록 설정 마지막 수단으로 사용 해야 합니다. UAC를 사용 하지 않도록 설정에 대 한 내용은 참조 하세요 [사용자 계정 컨트롤 및 WMI](https://go.microsoft.com/fwlink/?LinkId=91617)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="categoryName" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="counterName" />가 빈 문자열("")인 경우  
  
또는 
읽기/쓰기 권한 설정을 요청한이 카운터에 대해 올바르지 않습니다.  
  
또는 
카운터가 지정한 컴퓨터에 존재 하지 않습니다.  
  
또는 
지정한 범주가 다중 인스턴스로 표시 되 고 필요한 성능 카운터 인스턴스 이름을 사용 하 여 만들어집니다.  
  
또는 
 <paramref name="instanceName" /> 127 자 보다 깁니다.  
  
또는 
 <paramref name="categoryName" /> 및 <paramref name="counterName" /> 다른 언어로 지역화 된 합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 매개 변수가 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="categoryName" /> 또는 <paramref name="counterName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>초기화를 시작을 <see cref="T:System.Diagnostics.PerformanceCounter" /> 되거나 다른 구성 요소를 폼에 사용 되는 인스턴스. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼 또는 다른 구성 요소에서 사용 되는 구성 요소의 초기화를 시작 합니다. <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> 메서드 초기화를 끝냅니다. 사용 하는 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> 및 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> 메서드 구성 요소를 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 성능 카운터에 대 한 성능 카운터 범주의 이름을 가져오거나 설정 합니다.</summary>
        <value>이 성능 카운터와 관련 된 성능 카운터 범주 (성능 개체)의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> 에 표시 되는 `Performance Object` 성능 카운터 관리자 MMC 스냅인의 필드에서 `Add Counter` 대화 상자.  
  
 성능 카운터 범주 또는 컴퓨터의 성능 개체의 동작을 모니터링 합니다. 범주 (예: 프로세서, 디스크 및 메모리) 물리적 구성 요소 및 시스템 개체 (예: 프로세스, 스레드)에 포함 됩니다. 시스템 카운터 같은 성능 개체와 관련 된 일반적인 중점을 나타내는 범주에 그룹화 됩니다. 인스턴스를 만들 때의 <xref:System.Diagnostics.PerformanceCounter> 클래스를 먼저 지정할 범주는 구성 요소를 상호 작용 하 고 다음 범주에서 카운터를 선택 합니다.  
  
 예를 들어, 하나의 Windows 카운터 범주는 메모리 범주입니다. 이 범주 내의 시스템 카운터는 사용 가능한 바이트의 수 및 캐시 하는 바이트 수와 같은 메모리 내 데이터를 추적 합니다. 응용 프로그램에서 캐시 된 바이트를 사용 하려는 경우 인스턴스의 만듭니다는 <xref:System.Diagnostics.PerformanceCounter> 구성 요소를 Memory 범주에 연결 하 고 해당 범주 (이 예제의 경우 캐시 된 바이트)에 적절 한 카운터를 선택 합니다.  
  
 시스템에서 카운터 범주를 추가로 사용할 수 있습니다, 있지만 수는 아마도 상호 작용 하는 가장 자주 범주에는 캐시, 메모리, 개체, 실제 디스크, 프로세스, 프로세서, 서버, 시스템 및 스레드 범주는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 기본 인스턴스를 만듭니다를 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다. 인스턴스가 만들어진 후 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성 값은 집합 및에 대 한 호출의 결과 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 메서드가 표시 됩니다.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>성능 카운터를 닫고이 성능 카운터 인스턴스에 의해 할당 된 모든 리소스를 해제 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 연결 하는 경우 <xref:System.Diagnostics.PerformanceCounter> 서버 시스템에 상주 하는 성능 카운터 인스턴스와 인스턴스를 초기화 하 고 카운터 샘플 정보를 포함 하는 메모리를 할당 합니다. <xref:System.Diagnostics.PerformanceCounter.Close%2A> 메서드는 개체에 의해 할당 된 리소스를 해제 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>카운터에서 할당 된 성능 카운터 라이브러리의 공유 상태를 해제 합니다.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 읽는 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterHelp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 성능 카운터에 대 한 설명을 가져옵니다.</summary>
        <value>이 성능 카운터를 측정 하는 수량을 항목의 설명입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표시에서 성능 카운터 관리자 MMC 스냅인의 카운터 추가 대화 상자는 <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> 텍스트 사용자 카운터 목록에서 카운터를 선택 하 고 설명 단추를 클릭 합니다.  
  
 새 카운터를 만들 때 사용 된 <xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A> 카운터 모니터의 기능을 설명 하는 텍스트를 사용 하도록 설정할 사용자는 시스템 모니터의 디스플레이에 카운터를 추가할지 여부를 확인할 수 있습니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.PerformanceCounter" /> 인스턴스가 성능 카운터를 사용 하 여 연결 합니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 읽는 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 사용 하 여 연결 된 성능 카운터의 이름을 가져오거나 설정 합니다. <see cref="T:System.Diagnostics.PerformanceCounter" /> 인스턴스.</summary>
        <value>일반적으로 계산 되 고 있는 수량을 설명 하는 카운터의 이름입니다. 이 이름은 성능 카운터 관리자 MMC의 카운터 목록에서 스냅인의 카운터 추가 대화 상자.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 성능 관리자의 사용 가능한 기존 카운터의 목록을 가져올 수 있습니다 [카운터 추가 대화 상자](https://go.microsoft.com/fwlink/p/?LinkId=257854)합니다.  
  
   
  
## Examples  
 다음 코드 예제를 설정 하는 방법을 보여 줍니다는 <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> 속성을 일반적인 카운터 이름입니다.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.PerformanceCounter.CounterName" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>관련된 성능 카운터의 카운터 형식을 가져옵니다.</summary>
        <value><see cref="T:System.Diagnostics.PerformanceCounterType" /> 모두 설명 하는 카운터가 모니터링 응용 프로그램 및 특성에 포함 된 값과 상호 작용 하는 방식 (예를 들어, 계산 또는 계산 되지 않은).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType> 열거형 형식을 상호 작용할 수 있는 성능 카운터를 포함 합니다. 일부 카운터 형식은 시스템 되었고 카운터 측정값의 평균 등 계산된 값을 나타냅니다. 다른 형식은 원시 또는 계산 되지 않은 값을 나타냅니다. 다음 표에서 자주와 상호 작용할 수 있는 카운터 형식을 보여 줍니다.  
  
|카운터의 책임|PerformanceCounterType 값|예제|  
|------------------------------|----------------------------------|-------------|  
|항목 또는 연산의 단순한 수를 유지 합니다.|`NumberOfItems32`|32 비트 정수를 수신 하는 주문의 수를 추적 합니다.|  
|더 높은 용량 단순한 수를 유지 합니다.|`NumberOfItems64`|64 비트 정수로 저장 매우 높은 볼륨을 사용 하 여 사이트에 대 한 주문의 수를 추적 합니다.|  
|항목 또는 초당 작업 수를 추적 합니다.|`RateOfCountsPerSecond32`|사이트에서 초당 받은 주문 수를 추적 합니다.|  
|항목 또는 초당 작업 수 용량이 더 큰 수를 추적 합니다.|`RateOfCountsPerSecond64`|매우 높은 볼륨을 사용 하 여 사이트에서 초당 받은 주문 수를 추적 합니다.|  
|프로세스를 수행 하거나 항목을 처리 하는 평균 시간을 계산 합니다.|`AverageTimer32`|주문을 처리 하는 데 걸리는 평균 시간을 계산 합니다.|  
  
 형식이 해당 기본 카운터를 사용 해야 하는 카운터를 만들 경우 카운터와 기본 선언 해야 합니다 <xref:System.Diagnostics.CounterCreationDataCollection> 전달 하는 <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType> 메서드.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 읽는 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" /></permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>감소 씩 효율적인 원자 단위 연산을 통해 관련된 성능 카운터입니다.</summary>
        <returns>감소 된 카운터 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 카운터에만 작성할 수 있습니다. 모든 시스템 카운터는 읽기 전용입니다.  
  
> [!NOTE]
>  합니다 <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 메서드 상호 잠금을 사용 하 여 카운터 값을 업데이트 합니다. 이렇게 하면 다중 스레드 또는 다중 프로세스 시나리오 뿐만 아니라 성능 저하에서는 결과의 카운터 값을 정확 하 게 유지 합니다. 연동 하는 정확도 필요 하지 않은 경우 작업을 제공, 업데이트할 수 있습니다는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 5까지 속성에 직접 시간 성능 향상.  그러나 다중 스레드 시나리오에서 몇 가지 업데이트 카운터 값을 무시 될 수 있습니다, 잘못 된 데이터가 생성 합니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">카운터 이므로 읽기 전용 응용 프로그램 감소 시킬 수 없습니다.  
  
또는 
인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
        <threadsafe>이 메서드는 스레드로부터 안전 합니다.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>성능 카운터에서 공유 하는 전역 메모리의 바이트에서 크기를 지정 합니다. 기본 크기는 524,288 바이트입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>초기화를 끝냅니다는 <see cref="T:System.Diagnostics.PerformanceCounter" /> 되거나 다른 구성 요소를 폼에 사용 되는 인스턴스. 초기화는 런타임에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 디자인 환경에서이 메서드를 사용 하 여 폼 또는 다른 구성 요소에서 사용 되는 구성 요소의 초기화를 끝냅니다. <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> 메서드 초기화를 시작 합니다. 사용 하는 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> 및 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A> 메서드 구성 요소를 완전히 초기화 되기 전에 사용 되지 않도록 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>효율적인 원자 단위 연산을 통해 씩 관련된 성능 카운터를 증가 시킵니다.</summary>
        <returns>증가 된 카운터 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 카운터에만 작성할 수 있습니다. 모든 시스템 카운터는 읽기 전용입니다.  
  
> [!NOTE]
>  합니다 <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 메서드 상호 잠금을 사용 하 여 카운터 값을 업데이트 합니다. 이렇게 하면 다중 스레드 또는 다중 프로세스 시나리오 뿐만 아니라 성능 저하에서는 결과의 카운터 값을 정확 하 게 유지 합니다. 연동 하는 정확도 필요 하지 않은 경우 작업을 제공, 업데이트할 수 있습니다는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 5까지 속성에 직접 시간 성능 향상.  그러나 다중 스레드 시나리오에서 몇 가지 업데이트 카운터 값을 무시 될 수 있습니다, 잘못 된 데이터가 생성 합니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">카운터 이므로 읽기 전용 응용 프로그램 증가 시킬 수 없습니다.  
  
또는 
인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
        <threadsafe>이 메서드는 스레드로부터 안전 합니다.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">증가 시킬 값입니다. (음수 값으로 감소 시킵니다 카운터입니다.)</param>
        <summary>증가 또는 감소는 지정 된 크기 만큼 효율적인 원자 단위 연산을 통해 관련된 성능 카운터의 값입니다.</summary>
        <returns>새 카운터 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 카운터에만 작성할 수 있습니다. 모든 시스템 카운터는 읽기 전용입니다.  
  
> [!NOTE]
>  합니다 <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 메서드 상호 잠금을 사용 하 여 카운터 값을 업데이트 합니다. 이렇게 하면 다중 스레드 또는 다중 프로세스 시나리오 뿐만 아니라 성능 저하에서는 결과의 카운터 값을 정확 하 게 유지 합니다. 연동 하는 정확도 필요 하지 않은 경우 작업을 제공, 업데이트할 수 있습니다는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 5까지 속성에 직접 시간 성능 향상.  그러나 다중 스레드 시나리오에서 몇 가지 업데이트 카운터 값을 무시 될 수 있습니다, 잘못 된 데이터가 생성 합니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> 메서드 카운터를 증가 합니다. 이 코드 예제는에 대 한 보다 큰 예제의 일부는 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">카운터 이므로 읽기 전용 응용 프로그램 증가 시킬 수 없습니다.  
  
또는 
인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">경우에 성능 카운터 범주를 작성 하기 위한 합니다 <see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" /> 속성은 <see langword="false" />합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
        <threadsafe>이 메서드는 스레드로부터 안전 합니다.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스의 수명을 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 성능 카운터 범주를.NET Framework 버전 1.0 또는 1.1을 사용 하 여 만든 경우 사용 하 여 전역 공유 메모리를 값 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
> [!NOTE]
>  경우의 값을 <xref:System.Diagnostics.PerformanceCounter.CounterType%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>의 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 성능 카운터에 대해 값 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값 집합의 멤버인 되지를 <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 열거형입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 한 후 설정 됩니다는 <see cref="T:System.Diagnostics.PerformanceCounter" /> 활성화 되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 성능 카운터에 대 한 인스턴스 이름을 가져오거나 설정 합니다.</summary>
        <value>성능 카운터 범주 인스턴스의 또는 빈 문자열의 이름 ("") 이면이 카운터는 단일 인스턴스 카운터입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  인스턴스 이름은 128 자 이내 여야 합니다.  
  
 상황에 따라 범주는 범주와 관련 된 개체의 여러 항목에 대 한 데이터를 추적 하는 인스턴스도 세분화 됩니다. 인스턴스는 개별 카운터 대신 전체적으로 범주에 적용 됩니다. 모든 카운터 범주 내에 범주에 대해 정의 된 각 인스턴스가 있습니다. 예를 들어 프로세스 범주 유휴 상태 및 시스템을 명명 된 인스턴스를 포함 합니다. 프로세스 범주 내의 모든 카운터는 따라서 유휴 프로세스 또는 시스템 프로세스에 대 한 정보를 보여 주는 각 인스턴스에 대 한 데이터를 포함 합니다.  
  
 범주는 비워둘 수 있습니다이 속성 범주를 사용 하 여 연결 된 인스턴스가 없으면 임을 하므로 여러 인스턴스를 포함 되지 않습니다.  
  
 이 경우 <xref:System.Diagnostics.PerformanceCounter> 인스턴스 비 사용자 정의 범주를 지점에서 기존 범주 인스턴스만 선택할 수 있습니다. 인스턴스를 정의할 수 카운터 범주와 필요에 따라 할 수 있는 사용자 지정 범주에만 새 범주 인스턴스를 만들 수 있습니다.  
  
 성능 범주 인스턴스를 만들려면 지정는 `instanceName` 에 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 생성자입니다. 으로 지정 된 범주 인스턴스 `instanceName` 이미 새 개체는 기존 범주 인스턴스를 참조 합니다.  
  
> [!NOTE]
>  문자를 사용 하지 않는 "(",")", "#", "\\", 또는 인스턴스 이름에 "/"입니다. 이러한 문자 중 하나를 사용 하면 성능 콘솔 (참조 [런타임 프로 파일링](~/docs/framework/debug-trace-profile/runtime-profiling.md)) 인스턴스 값을 올바르게 표시 하지 않을 수 있습니다.  
  
 인스턴스 이름이 자동으로 생성 되 고 문자를 포함할 수 있습니다 "(",")", "#", "\\", 또는 "/"를 다음 표의 문자 매핑을 사용 합니다.  
  
|문자|매핑된 문자|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 <xref:System.AppDomain.FriendlyName%2A> 의 속성을 <xref:System.AppDomain> 개체에서 가져온는 <xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType> 속성이 잘못 된 문자를 포함할 수 있는 인스턴스 이름의 공용 원본.  
  
   
  
## Examples  
 다음 코드 예제에서는의 기본 인스턴스를 만듭니다를 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다. 인스턴스가 만들어진 후 합니다 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> 속성 값은 집합 및에 대 한 호출의 결과 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 메서드가 표시 됩니다.  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 성능 카운터에 대 한 컴퓨터 이름을 가져오거나 설정 합니다.</summary>
        <value>성능 카운터와 관련된 범주가 있는 서버.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로컬 컴퓨터에 있는 카운터에만 값을 작성할 수 있습니다. 그러나 수 있는 액세스 권한이 있는 엔터프라이즈의 컴퓨터에서 카운터 값을 읽을 수 있습니다.  
  
 설정한 경우 합니다 <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> 원격 컴퓨터를 가리키도록 속성을 <xref:System.Diagnostics.PerformanceCounter> 인스턴스가 해당 컴퓨터에서 카운터를 엽니다. 카운터가 존재 하지 않는 경우 예외를 throw이 속성을 설정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> 형식이 올바르지 않습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>카운터 샘플을 가져와 하 고에 대 한 원시 또는 계산 되지 않은 값을 반환 합니다.</summary>
        <returns><see cref="T:System.Diagnostics.CounterSample" /> 이 카운터에 대 한 시스템을 가져오는 다음 원시 값을 나타내는입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 계산 되지 않은 값을 포함 하는 카운터에 대 한 일반적으로 사용 됩니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> 메서드 카운터의 다음 계산 되지 않은 값을 가져옵니다. 이 코드 예제는에 대 한 보다 큰 예제의 일부는 <xref:System.Diagnostics.PerformanceCounter> 클래스입니다.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 읽는 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>카운터 샘플을 가져와 하 고에 대 한 계산 된 값을 반환 합니다.</summary>
        <returns>다음 계산된 된 값이이 카운터에 대 한 시스템을 가져옵니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  카운터의 계산 된 값을 두 개의 카운터 읽기에 종속 하는 경우 첫 번째 읽기 작업이 0.0을 반환 합니다. 새 성능 카운터를 만드는 것과 같습니다는 다른 카운터를 지정 하려면 성능 카운터 속성 다시 설정 하 고 새 속성을 사용 하 여 첫 번째 읽기 작업이 0.0를 반환 합니다. 권장 되는 지연 시간에 대 한 호출 사이 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 메서드 1 초 이며, 다음 증분 읽기를 수행 하는 카운터 수 있도록 합니다.  
  
> [!NOTE]
>  성능 카운터를 읽으려면 관리자 권한이 있어야 합니다. Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Diagnostics.PerformanceCounterType.ElapsedTime> 사용 하 여 카운터를 <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> 기간 동안 카운터의 값을 표시 하는 방법.  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 읽는 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_RawValue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 카운터의 원시 또는 계산 되지 않은 값을 가져오거나 설정 합니다.</summary>
        <value>카운터의 원시 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 카운터 형식은 32 비트 크기에 맞게 너무 큰 값으로이 속성을 설정 하려는 경우 속성에서 32 비트 값을 잘립니다. 로컬 컴퓨터의 사용자 지정 카운터를 읽을 때 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 계산된 된 값 대신 속성의 원시 값이 충분 한 시나리오에서 성능이 크게 향상을 생성할 수 있습니다.  
  
 현재 읽고 있는 카운터가 읽기 전용인 지, 들어오는지는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 속성 속성이 호출 되는 시간에 카운터를 샘플링 합니다. 이 작업은 해당 하는 초기 호출 하 여 <xref:System.Diagnostics.PerformanceCounter.NextSample%2A> 메서드. 이후에 호출 하는 경우 <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>, 두 호출에서 반환 값에서 계산을 수행할 수 있습니다.  
  
 시스템 카운터 읽기 전용 이기 때문에 가져올 수 있지만 해당 원시 값을 설정 하지.  
  
> [!NOTE]
>  합니다 <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, 및 <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> 메서드 상호 잠금을 사용 하 여 카운터 값을 업데이트 합니다. 이렇게 하면 다중 스레드 또는 다중 프로세스 시나리오 뿐만 아니라 성능 저하에서는 결과의 카운터 값을 정확 하 게 유지 합니다. 연동 하는 정확도 필요 하지 않은 경우 작업을 제공, 업데이트할 수 있습니다는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 5까지 속성에 직접 시간 성능 향상.  그러나 다중 스레드 시나리오에서 몇 가지 업데이트 카운터 값을 무시 될 수 있습니다, 잘못 된 데이터가 생성 합니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
> [!NOTE]
>  Windows Vista, Windows XP Professional x64 Edition 또는 Windows Server 2003에서 성능 카운터를 읽으려면 Performance Monitor Users 그룹의 구성원 이어야 하거나 관리자 권한이 있어야 합니다.  
>   
>  Windows Vista의 성능 카운터에 액세스 하 여 권한을 상승 시킬 것을 방지 하려면 직접를 Performance Monitor Users 그룹에 추가 합니다.  
>   
>  Windows Vista에서는 UAC(사용자 계정 컨트롤)가 사용자 권한을 결정합니다. 기본 제공 Administrators 그룹의 멤버인 경우 두 개의 런타임 액세스 토큰(표준 사용자 액세스 토큰 및 관리자 액세스 토큰)이 할당됩니다. 기본적으로 표준 사용자 역할이 지정됩니다. 성능 카운터에 액세스 하는 코드를 실행 하려면 먼저 높여야 권한을 표준 사용자에서 관리자에 게 합니다. 응용 프로그램 아이콘을 마우스 오른쪽 단추로 클릭하고 관리자로 실행하도록 지정하여 응용 프로그램을 시작하면 이 작업을 수행할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Diagnostics.CounterSample> 의 값을 표시 하는 클래스는 <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> 카운터에 대 한 속성입니다.  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">카운터의 원시 값을 설정 하려고 하지만 카운터는 읽기 전용입니다.  
  
또는 
인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">관리자 권한 없이 실행 되는 코드 성능 카운터를 읽으려고 합니다.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 작성 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_ReadOnly")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>나타내는 값을 가져오거나 여부를이 <see cref="T:System.Diagnostics.PerformanceCounter" /> 인스턴스가 읽기 전용 모드에서입니다.</summary>
        <value><see langword="true" />를 하는 경우는 <see cref="T:System.Diagnostics.PerformanceCounter" /> 인스턴스가 읽기 전용 모드에서 (경우에 마찬가지 카운터 자체 사용자 지정.NET Framework 카운터) <see langword="false" /> 읽기/쓰기 모드에 있으면 됩니다. 기본값은 생성자에 의해 설정 된 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 시스템 카운터에 대 한 <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> 가 언제 든 지 `true`합니다. 시스템 카운터에 쓸 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>지정 된 범주 인스턴스를 삭제 합니다 <see cref="T:System.Diagnostics.PerformanceCounter" /> 개체 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" /> 속성입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 카운터에 대해서만 인스턴스를 제거할 수 있습니다. 그 중 하나를 제거 하는 동안 예외를 throw 하므로 모든 시스템 카운터는 읽기 전용입니다.  
  
> [!NOTE]
>  크기를 성능 카운터 공유 메모리를 놓을 때 가능한 경합을 방지 하는 것이 좋습니다는 <xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A> 메서드를 호출할 수는 <xref:System.AppDomain.DomainUnload> 이벤트 처리기입니다.  
  
 성능 범주 인스턴스를 만들려면 지정는 `instanceName` 에 <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> 생성자입니다. 으로 지정 된 범주 인스턴스 `instanceName` 이미 새 개체는 기존 범주 인스턴스를 참조 합니다.  
  
> [!NOTE]
>  경우에 대 한 값을 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 속성은 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process> 성능 카운터 범주는.NET Framework 버전 1.0 또는 1.1을 사용 하 여 생성 된는 <xref:System.InvalidOperationException> throw 됩니다. 이전 버전을 사용 하 여 만든 성능 카운터 범주 전역 공유 메모리, 및의 값을 사용 하 여 <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> 있어야 <xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>합니다. 버전 1.0 또는 1.1의.NET Framework에서 실행 중인 응용 프로그램 범주를 사용 하지 않으면 삭제 하 고 범주를 다시 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 카운터 이므로 읽기 전용으로 범주와 연결 된 모든 인스턴스를 제거할 수 없습니다.  
  
또는 
인스턴스가 성능 카운터와 제대로 연결 되지 않습니다.  
  
또는 
전역 공유 메모리를 사용할 때 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 속성이 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />로 설정되어 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 API에 액세스할 때 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼이는 Windows 98 또는 Windows Millennium Edition (me), 성능 카운터를 지원 하지 않는 경우</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">성능 카운터 범주를 작성 합니다. 연관된 열거형: <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>