<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67628b4e8ee5ca6153c80b553dc136354165e028" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52598956" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>로컬 및 원격 프로세스에 대한 액세스를 제공하고 로컬 시스템 프로세스를 시작하고 중지할 수 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> 구성 요소는 컴퓨터에서 실행 중인 프로세스에 대 한 액세스를 제공 합니다. 프로세스를 간단히 말해에서는 실행 중인 앱입니다. 스레드는 운영 체제는 프로세서 시간을 할당 하는 기본 단위입니다. 스레드가 다른 스레드에 의해 현재 실행 중인 부분을 포함 하 여 프로세스의 코드의 일부를 실행할 수 있습니다.  
  
 <xref:System.Diagnostics.Process> 구성 요소는 시작, 중지, 제어 및 앱 모니터링을 위한 유용한 도구입니다. 사용할 수는 <xref:System.Diagnostics.Process> 구성 요소를 실행 중인 프로세스 목록을 가져올 수 있거나 새 프로세스를 시작할 수 있습니다. <xref:System.Diagnostics.Process> 시스템 프로세스 액세스 구성 요소를 사용 합니다. 이후에 <xref:System.Diagnostics.Process> 구성 요소가 초기화 되었는지, 실행 중인 프로세스에 대 한 정보를 가져오기 위해 사용할 수 있습니다. 이러한 정보는 스레드 로드 된 모듈 (.dll 및.exe 파일)의 집합을 포함 하 고 프로세스 메모리 양 등 성능 정보를 사용 하 여 합니다.  
  
 이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면 직접 또는 간접적으로의 삭제 해야 있습니다. 직접 형식의 dispose 호출 해당 <xref:System.IDisposable.Dispose%2A> 의 메서드를 `try` / `finally` 블록입니다. 삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는). 자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
> [!NOTE]
>  32 비트 프로세스는 64 비트 프로세스의 모듈에 액세스할 수 없습니다. 32 비트 프로세스에서 64 비트 프로세스에 대 한 정보를 가져오려고 하는 경우는 <xref:System.ComponentModel.Win32Exception> 예외입니다. 다른 한편으로 64 비트 프로세스를 32 비트 프로세스의 모듈을 액세스할 수 있습니다.  
  
 프로세스 구성 요소 속성의 그룹에 대 한 정보를 한 번에 가져옵니다. 후 합니다 <xref:System.Diagnostics.Process> 구성 요소 그룹의 한 멤버에 대 한 정보 획득, 해당 그룹의 다른 속성에 대 한 값을 캐시 하 고 호출할 때까지 그룹의 다른 멤버에 대 한 새 정보를 가져올는 <xref:System.Diagnostics.Process.Refresh%2A> 메서드. 따라서 속성 값에 대 한 마지막 호출 이후의 모든 되도록 보장 되지 않습니다는 <xref:System.Diagnostics.Process.Refresh%2A> 메서드. 그룹 분석은 운영 체제에 종속적입니다.  
  
 경로 변수를 선언한 따옴표를 사용 하 여 시스템의 경우 정규화 해야 해당 경로 위치에 있는 프로세스를 시작 하는 경우. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` path에 없는 따옴표를 사용 하 여 추가한: `path = %path%;"c:\mypath"`에서 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때.  
  
 시스템 프로세스를 고유 하 게 시스템에서 해당 프로세스 id로 식별 됩니다. 많은 Windows 리소스와 마찬가지로 프로세스 또한 컴퓨터의 고유 하지 않을 해당 핸들로 식별 됩니다. 핸들은 리소스의 식별자에 대 한 일반 용어입니다. 운영 체제를 통해 액세스할 수 있는 프로세스 핸들을 유지 합니다 <xref:System.Diagnostics.Process.Handle%2A> 의 속성을 <xref:System.Diagnostics.Process> 된 프로세스가 종료 된 경우에 구성 요소. 와 같은 프로세스의 관리 정보를 가져올 수는 따라서 합니다 <xref:System.Diagnostics.Process.ExitCode%2A> (일반적으로 하거나 0의 성공 또는 0이 아닌 오류 코드) 및 <xref:System.Diagnostics.Process.ExitTime%2A>합니다. 처리는 매우 중요 한 리소스 되므로 핸들 누수가 발생 하는 것은 메모리 누수 보다 더 심각 합니다.  
  
> [!NOTE]
>  이 클래스는 모든 멤버에 적용 되는 클래스 수준에서 상속 요청과 링크 요청을 포함 합니다. <xref:System.Security.SecurityException> 직접 실행 호출자 또는 파생된 클래스에 완전 신뢰 권한이 없는 경우 throw 됩니다. 보안 요청에 대 한 자세한 내용은 참조 하세요 [링크 요구가](~/docs/framework/misc/link-demands.md)합니다.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 참고 사항  
 .NET Framework에는 <xref:System.Diagnostics.Process> 기본적으로 클래스 <xref:System.Console> 인코딩 되는 코드 페이지 인코딩을 입력, 출력 및 오류 스트림에 대 한 합니다. 예를 들어 코드는 문화권이 영어 (미국) 인 시스템에서 코드 페이지 437의 기본 인코딩는 <xref:System.Console> 클래스입니다. 그러나 [!INCLUDE[net_core](~/includes/net-core-md.md)] 이러한 인코딩의 제한 된 하위 집합만 사용할 수 있습니다. 이 경우 사용 하 여 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 기본 인코딩.  
  
 경우는 <xref:System.Diagnostics.Process> 개체에서 특정 코드 페이지 인코딩에 따라 달라 집니다, 있습니다 수 여전히 사용할 수 있도록 다음을 수행 하 여 *하기 전에* 호출할 있습니다 <xref:System.Diagnostics.Process> 메서드:  
  
1.  프로젝트에 System.Text.Encoding.CodePages.dll 어셈블리에 대 한 참조를 추가 합니다.  
  
2.  검색 된 <xref:System.Text.EncodingProvider> 에서 개체를 <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> 속성입니다.  
  
3.  전달 된 <xref:System.Text.EncodingProvider> 개체를 <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> 메서드를 사용할 수 있는 인코딩 공급자가 지 원하는 추가 인코딩.  
  
 합니다 <xref:System.Diagnostics.Process> 클래스 자동으로 사용 하 여 기본 시스템 인코딩이 UTF8 대신 호출 하기 전에 인코딩 공급자를 등록 된 <xref:System.Diagnostics.Process> 메서드.  
  
   
  
## Examples  
 다음 예에서는 인스턴스의 <xref:System.Diagnostics.Process> 클래스는 프로세스를 시작 합니다.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 다음 예제에서는 합니다 <xref:System.Diagnostics.Process> 자체와 정적 클래스 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하는 방법입니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 다음 F# 예제에서는 정의 `runProc` 함수는 프로세스를 시작 하는 모든 출력 및 오류 정보를 캡처하고 프로세스를 실행 한 시간 (밀리초)의 수를 기록 합니다.  `runProc` 함수에 세 개의 매개 변수가: 응용 프로그램을 시작 디렉터리를 제공 하는 인수를 시작 하려면 응용 프로그램의 이름입니다.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 에 대 한 코드를 `runProc` 함수를 통해 작성 했습니다 [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) 에서 사용할 수는 [Microsoft Public License](https://opensource.org/licenses/ms-pl)합니다.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 클래스는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">상속자에 대 한 완전 신뢰 합니다. 부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">.NET Process 클래스를 사용 하 여</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.Process" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하지 않으면 경우는 <xref:System.Diagnostics.Process.MachineName%2A> 속성 기본값은 로컬 컴퓨터 (".").  
  
 새 연결에 대 한 두 가지 옵션이 있습니다 <xref:System.Diagnostics.Process> 컴퓨터의 프로세스를 사용 하 여 구성 요소입니다. 만들려면 생성자를 사용 하는 첫 번째 옵션은는 <xref:System.Diagnostics.Process> 의 적절 한 멤버를 설정 하는 구성 요소를 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 연결할는 <xref:System.Diagnostics.Process> 새 시스템 프로세스를 사용 하 여 합니다. 두 번째 옵션은 연결 합니다 <xref:System.Diagnostics.Process> 를 사용 하 여 실행 중인 시스템 프로세스를 사용 하 여 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 중 하나는 <xref:System.Diagnostics.Process.GetProcesses%2A> 값을 반환 합니다.  
  
 사용 하는 경우는 `static` 오버 로드는 <xref:System.Diagnostics.Process.Start%2A> 메서드는 새 시스템 프로세스를 시작 하는 메서드를 만듭니다 <xref:System.Diagnostics.Process> 구성 요소 프로세스에 연결 합니다.  
  
 경우는 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 속성이 해당 기본값으로 `true`를 사용 하 여 유사한 방식으로 응용 프로그램 및 문서를 시작할 수 있습니다는 `Run` 는 Windows 대화 상자 `Start` 메뉴. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 는 `false`에 실행을 시작할 수 있습니다.  
  
 명령줄에서 호출할 수 있는 모든 실행 파일을 두 가지 방법 중 하나로 시작할 수 있습니다:의 적절 한 멤버를 설정 하 여 합니다 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 호출 합니다 <xref:System.Diagnostics.Process.Start%2A> 메서드 매개 변수 없이 또는 적절 한 매개 변수를 전달 하 여는 `static` <xref:System.Diagnostics.Process.Start%2A> 멤버입니다.  
  
 만들 수 있습니다는 <xref:System.Diagnostics.Process> 생성자는 정적 중 하나를 사용 하 여 구성 요소 <xref:System.Diagnostics.Process.Start%2A> 오버 로드 또는 합니다 <xref:System.Diagnostics.Process.GetProcessById%2A>를 <xref:System.Diagnostics.Process.GetProcesses%2A>, 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드. 이 작업을 수행한 후 연결된 된 프로세스를 볼 수 있습니다. 프로세스 속성은 메모리에 변경 될 때 자동으로 업데이트 하는 동적인 보기 아닙니다. 대신 호출 해야 합니다 <xref:System.Diagnostics.Process.Refresh%2A> 업데이트에 따라 구성 된 <xref:System.Diagnostics.Process> 응용 프로그램에서 속성 정보입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 기본 우선 순위를 가져옵니다.</summary>
        <value>연결된 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityClass" />에서 계산되는 기본 우선 순위입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A> 프로세스는 연결된 된 프로세스 내에서 생성 된 스레드의 우선 순위를 시작 합니다. 시스템 모니터의 기본 우선 순위 카운터를 통해 기본 우선 순위에 대 한 정보를 볼 수 있습니다.  
  
 시간을 기준으로 경과 된 또는 기타 상승이, 운영 체제 프로세스를 다른 사용자가 앞에 배치 되어야 하는 경우 기본 우선 순위를 변경할 수 있습니다.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> 속성을 사용 하면 프로세스에 할당 된 우선 순위를 볼 수 있습니다. 그러나 읽기 전용 이므로 사용할 수 없습니다는 <xref:System.Diagnostics.Process.BasePriority%2A> 프로세스의 우선 순위를 설정 합니다. 우선 순위를 변경 하려면 사용 된 <xref:System.Diagnostics.Process.PriorityClass%2A> 속성입니다. <xref:System.Diagnostics.Process.BasePriority%2A> 을 볼 수 있습니다 하지만 시스템 모니터를 사용 하는 <xref:System.Diagnostics.Process.PriorityClass%2A> 아닙니다. 모두를 <xref:System.Diagnostics.Process.BasePriority%2A> 하며 <xref:System.Diagnostics.Process.PriorityClass%2A> 프로그래밍 방식으로 볼 수 있습니다. 다음 표에서 간의 관계를 보여 줍니다 <xref:System.Diagnostics.Process.BasePriority%2A> 값 및 <xref:System.Diagnostics.Process.PriorityClass%2A> 값입니다.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 종료되었습니다.  
  
또는 
프로세스가 시작되지 않아서 프로세스 ID가 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에 대해 비동기 읽기 작업을 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A> 동기적 또는 비동기적으로 스트림을 읽을 수 있습니다. 와 같은 메서드와 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓸 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반대로 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. 이 메서드 스트림 출력에 대 한 지정 된 이벤트 처리기를 사용 하도록 설정 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 비동기 읽기 작업을 수행 하려면 다음이 단계를 따릅니다 <xref:System.Diagnostics.Process.StandardError%2A> 에 대 한는 <xref:System.Diagnostics.Process> :  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false`로 설정합니다.  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>를 `true`로 설정합니다.  
  
3.  이벤트 처리기를 추가 합니다 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트입니다. 이벤트 처리기가 일치 해야 합니다 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 대리자 시그니처입니다.  
  
4.  시작 된 <xref:System.Diagnostics.Process>합니다.  
  
5.  호출 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process>합니다. 이 호출에 비동기 읽기 작업을 시작 <xref:System.Diagnostics.Process.StandardError%2A>합니다.  
  
 때마다 연결 된 비동기 읽기 작업 시작, 이벤트 처리기가 호출 될 때 <xref:System.Diagnostics.Process> 텍스트 줄을 쓰는 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 비동기 읽기 작업을 호출 하 여 취소할 수 있습니다 <xref:System.Diagnostics.Process.CancelErrorRead%2A>합니다. 이벤트 처리기 또는 호출자가 읽기 작업을 취소할 수 있습니다. 취소 후 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업을 다시 시작을 다시 합니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 한 번 리디렉션된 스트림을 <xref:System.Diagnostics.Process> 열려 비동기 또는 동기 모드에서 모든 이후 읽기 동일한 모드에서 해당 스트림의 작업 이어야 합니다. 예를 들어 따르지 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 에 대 한 호출을 사용 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `net view` 명령은 원격 컴퓨터에서 사용 가능한 네트워크 리소스를 나열 합니다. 사용자를 명령줄 인수 형태로 대상 컴퓨터 이름을 제공합니다. 사용자 오류 출력에 대 한 파일 이름을 제공할 수도 있습니다. 이 예제에서는 net 명령, 그 다음으로 프로세스가 끝날 때까지 쓰기 출력 결과 콘솔에 대 한 대기 작업의 출력을 수집 합니다. 사용자가 선택적 오류 파일을 제공 하는 경우이 예제에서는 파일에 오류를 씁니다.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 속성은 <see langword="false" />입니다.  
  
\- 또는 - 
<see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에서 비동기 읽기 작업이 이미 진행 중입니다.  
  
\- 또는 - 
<see cref="P:System.Diagnostics.Process.StandardError" /> 스트림이 동기적 읽기 작업에 사용되었습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에 대해 비동기 읽기 작업을 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A> 동기적 또는 비동기적으로 스트림을 읽을 수 있습니다. 와 같은 메서드와 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓸 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반대로 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 이 메서드는 지정 된 이벤트 처리기가 스트림 출력 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 비동기 읽기 작업을 수행 하려면 다음이 단계를 따릅니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 에 대 한는 <xref:System.Diagnostics.Process> :  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>를 `false`로 설정합니다.  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>를 `true`로 설정합니다.  
  
3.  이벤트 처리기를 추가 합니다 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트입니다. 이벤트 처리기가 일치 해야 합니다 <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> 대리자 시그니처입니다.  
  
4.  시작 된 <xref:System.Diagnostics.Process>합니다.  
  
5.  호출 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process>합니다. 이 호출에 비동기 읽기 작업을 시작 <xref:System.Diagnostics.Process.StandardOutput%2A>합니다.  
  
 때마다 연결 된 비동기 읽기 작업 시작, 이벤트 처리기가 호출 될 때 <xref:System.Diagnostics.Process> 텍스트 줄을 쓰는 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
 비동기 읽기 작업을 호출 하 여 취소할 수 있습니다 <xref:System.Diagnostics.Process.CancelOutputRead%2A>합니다. 이벤트 처리기 또는 호출자가 읽기 작업을 취소할 수 있습니다. 취소 후 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업을 다시 시작을 다시 합니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 한 번 리디렉션된 스트림을 <xref:System.Diagnostics.Process> 열려 비동기 또는 동기 모드에서 모든 이후 읽기 동일한 모드에서 해당 스트림의 작업 이어야 합니다. 예를 들어 따르지 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 에 대 한 호출을 사용 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 리디렉션된에 대해 비동기 읽기 작업을 수행 하는 방법을 보여 줍니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림의 `sort` 명령입니다. `sort` 명령 읽고 텍스트 입력을 정렬 하는 콘솔 응용 프로그램입니다.  
  
 예제에 대 한 이벤트 대리자를 만듭니다는 `SortOutputHandler` 이벤트 처리기에 연결 된 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트. 이벤트 처리기에서 리디렉션된 텍스트 줄을 받아서 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림에 텍스트의 서식을 지정 하 고 화면에 텍스트를 씁니다.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 속성은 <see langword="false" />입니다.  
  
\- 또는 - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에서 비동기 읽기 작업이 이미 진행 중입니다.  
  
\- 또는 - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림이 동기적 읽기 작업에 사용되었습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에 대해 비동기 읽기 작업을 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업이 시작 된 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. <xref:System.Diagnostics.Process.CancelErrorRead%2A> end 비동기 읽기 작업.  
  
 취소 후 호출 하 여 비동기 읽기 작업을 재개할 수 있습니다 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 다시 합니다.  
  
 호출 하는 경우 <xref:System.Diagnostics.Process.CancelErrorRead%2A>모든 진행 중인 읽기 작업에 대 한 <xref:System.Diagnostics.Process.StandardError%2A> 완료 된 다음 이벤트 처리기에는 사용할 수 없게 됩니다. 모든 추가 리디렉션된 출력 <xref:System.Diagnostics.Process.StandardError%2A> 버퍼에 저장 됩니다. 호출 하 여 이벤트 처리기를 다시 사용 하는 경우 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, 저장 된 출력은 이벤트 처리기로 전송 및 비동기 읽기 작업을 다시 시작 합니다. 비동기 읽기 작업을 다시 시작 하기 전에 이벤트 처리기를 변경 하려는 경우에 새 이벤트 처리기를 추가 하기 전에 기존 이벤트 처리기를 제거 해야 합니다.  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  리디렉션된에서 비동기 및 동기 읽기 작업을 혼합할 수 없습니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. 한 번 리디렉션된 스트림을 <xref:System.Diagnostics.Process> 열려 비동기 또는 동기 모드에서 모든 이후 읽기 동일한 모드에서 해당 스트림의 작업 이어야 합니다. 취소 하면 비동기 읽기 작업에서 <xref:System.Diagnostics.Process.StandardError%2A> 를 사용 해야 다시 스트림에서 읽을 필요가 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 비동기 읽기 작업을 재개 합니다. 따르지 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 동기 호출의 메서드를 읽을 <xref:System.Diagnostics.Process.StandardError%2A> 와 같은 <xref:System.IO.StreamReader.Read%2A>를 <xref:System.IO.StreamReader.ReadLine%2A>, 또는 <xref:System.IO.StreamReader.ReadToEnd%2A>합니다.  
  
   
  
## Examples  
 다음 예에서는 시작을 `nmake` 사용자를 사용 하 여 명령 인수를 제공 합니다. 오류 및 출력 스트림은 읽기가 비동기적으로; 수집 된 텍스트 줄은 콘솔에 표시 뿐만 아니라 로그 파일에 기록 합니다. 명령 출력은 지정 된 개수의 줄을 초과 하는 경우 비동기 읽기 작업이 취소 됩니다.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림을 비동기 읽기 작업용으로 사용할 수 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램의 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에 대해 비동기 읽기 작업을 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업이 시작 된 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. <xref:System.Diagnostics.Process.CancelOutputRead%2A> end 비동기 읽기 작업.  
  
 취소 후 다시 시작할 수 있습니다 비동기 읽기 작업을 호출 하 여 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 다시 합니다.  
  
 호출 하는 경우 <xref:System.Diagnostics.Process.CancelOutputRead%2A>모든 진행 중인 읽기 작업에 대 한 <xref:System.Diagnostics.Process.StandardOutput%2A> 완료 된 다음 이벤트 처리기에는 사용할 수 없게 됩니다. 모든 추가 리디렉션된 출력 <xref:System.Diagnostics.Process.StandardOutput%2A> 버퍼에 저장 됩니다. 호출 하 여 이벤트 처리기를 다시 사용 하는 경우 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, 저장 된 출력은 이벤트 처리기로 전송 및 비동기 읽기 작업을 다시 시작 합니다. 비동기 읽기 작업을 다시 시작 하기 전에 이벤트 처리기를 변경 하려는 경우에 새 이벤트 처리기를 추가 하기 전에 기존 이벤트 처리기를 제거 해야 합니다.  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  리디렉션된에서 비동기 및 동기 읽기 작업을 혼합할 수 없습니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 한 번 리디렉션된 스트림을 <xref:System.Diagnostics.Process> 열려 비동기 또는 동기 모드에서 모든 이후 읽기 동일한 모드에서 해당 스트림의 작업 이어야 합니다. 취소 하면 비동기 읽기 작업에서 <xref:System.Diagnostics.Process.StandardOutput%2A> 를 사용 해야 다시 스트림에서 읽을 필요가 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 비동기 읽기 작업을 재개 합니다. 따르지 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 동기 호출의 메서드를 읽을 <xref:System.Diagnostics.Process.StandardOutput%2A> 와 같은 <xref:System.IO.StreamReader.Read%2A>를 <xref:System.IO.StreamReader.ReadLine%2A>, 또는 <xref:System.IO.StreamReader.ReadToEnd%2A>합니다.  
  
   
  
## Examples  
 다음 예에서는 시작을 `nmake` 사용자를 사용 하 여 명령 인수를 제공 합니다. 오류 및 출력 스트림은 읽기가 비동기적으로; 수집 된 텍스트 줄은 콘솔에 표시 뿐만 아니라 로그 파일에 기록 합니다. 명령 출력은 지정 된 개수의 줄을 초과 하는 경우 비동기 읽기 작업이 취소 됩니다.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림을 비동기 읽기 작업용으로 사용할 수 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 구성 요소에 연결된 리소스를 모두 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A> 메서드 exit, 대기 프로세스 핸들을 닫고 및 프로세스 관련 속성을 지웁니다에 대 한 대기를 중지 하는 프로세스를 사용 하면 됩니다. <xref:System.Diagnostics.Process.Close%2A> 닫지 않습니다 표준 출력과 입력 오류 판독기 및 작성기 외부에서 참조 하는 경우.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 메서드는 <xref:System.Diagnostics.Process.Close%2A>를 호출합니다. 배치 된 <xref:System.Diagnostics.Process> 개체를 `using` 블록 호출 하지 않고도 리소스를 삭제 <xref:System.Diagnostics.Process.Close%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 10 초 동안 최대 2 초 간격으로 연결된 된 프로세스의 실제 메모리 사용량을 검색합니다. 이 예제에서는 10 초 경과 되기 전에 프로세스가 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 경우 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>주 창에 닫기 메시지를 보내 사용자 인터페이스가 있는 프로세스를 닫습니다.</summary>
        <returns>닫기 메시지를 보낸 경우에는 <see langword="true" />이고 연결된 프로세스에 주 창이 없거나 모달 대화 상자가 표시된 때 같이 주 창을 사용할 수 없는 경우에는 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스를 실행할 때 해당 메시지 루프는 대기 상태입니다. 운영 체제에서 프로세스에 Windows 메시지를 보낼 때마다 메시지 루프를 실행 합니다. 호출 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 는 잘 구성 된 응용 프로그램에서 자식 창을 닫고 응용 프로그램에 대 한 실행 중인 모든 메시지 루프를 취소 주 창에 가까운 요청을 보냅니다. 호출 하 여 프로세스를 종료 하는 요청 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 종료 하도록 응용 프로그램을 강제 적용 되지 않습니다. 응용 프로그램을 끝내기 전에 사용자 확인 요청 또는 종료를 거부할 수 있습니다. 종료 하도록 응용 프로그램을 강제로 사용 하 여를 <xref:System.Diagnostics.Process.Kill%2A> 메서드. 동작 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 시스템 메뉴를 사용 하 여 응용 프로그램의 주 창을 닫으면 사용자와 동일 합니다. 따라서 주 창을 닫으면 프로세스를 종료 하는 요청은 즉시 취소 하려면 응용 프로그램을 강제로 되지 않습니다.  
  
 프로세스에 의해 편집 하는 데이터 또는 프로세스에 할당 된 리소스 손실 될 수 있습니다를 호출 하면 <xref:System.Diagnostics.Process.Kill%2A>합니다. <xref:System.Diagnostics.Process.Kill%2A> 비정상적인 프로세스 종료를 사용 하면 필요한 경우에 사용 해야 합니다. <xref:System.Diagnostics.Process.CloseMainWindow%2A> 과정을 순서 대로 종료 있으며 인터페이스를 사용 하 여 응용 프로그램에 대 한 것이 좋습니다 이므로 모든 창을 닫습니다. 하는 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 사용할 수 있습니다 실패 <xref:System.Diagnostics.Process.Kill%2A> 프로세스를 종료 하려면. <xref:System.Diagnostics.Process.Kill%2A> 그래픽 인터페이스를 갖지 않는 프로세스를 종료 하는 유일한 방법이입니다.  
  
 호출할 수 있습니다 <xref:System.Diagnostics.Process.Kill%2A> 고 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 합니다. 종료 하려면 원격 컴퓨터에서 프로세스 할 수 없습니다. 원격 컴퓨터에서 실행 중인 프로세스에 대 한 정보를 보기만 할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 10 초 동안 최대 2 초 간격 연결된 된 프로세스의 실제 메모리 사용량을 검색합니다. 이 예제에서는 10 초 경과 되기 전에 프로세스가 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 경우 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 이미 종료되었습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>이 프로세스에서 사용하는 리소스를 모두 해제합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스가 종료될 때 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트를 발생시켜야 하는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>종료 명령 또는 <see cref="M:System.Diagnostics.Process.Kill" /> 호출을 통해 연결된 프로세스가 종료될 때 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트가 발생해야 한다면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다. <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트는 경우에 값 <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> 는 <see langword="false" /> 중 프로세스가 종료 될 때 또는 사용자가 연산을 수행 하기 전에 <see cref="P:System.Diagnostics.Process.HasExited" /> 확인 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성 운영 체제 프로세스를 종료 하는 경우 구성 요소 알림을 받을지 여부를 제안 합니다. <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 프로세스를 종료 하는 응용 프로그램에 알리기 위해 속성은 비동기 처리에 사용 합니다. 강제 종료 이벤트 (종료 이벤트가 발생 될 때까지 응용 프로그램의 프로세스를 중단)에 대 한 동기적으로 대기 하는 응용 프로그램을 사용 하는 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드.

> [!NOTE]
> Visual Studio를 사용 중이 고 두 번 클릭 하는 경우는 <xref:System.Diagnostics.Process> 프로젝트에서 구성 요소는 <xref:System.Diagnostics.Process.Exited> 이벤트 대리자 및 이벤트 처리기는 자동으로 생성 합니다. 추가 코드 집합을 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성을 `false`입니다. 이 속성을 변경 해야 `true` 때 실행할 이벤트 처리기에 대 한 연결된 된 프로세스가 종료 됩니다.

경우 구성 요소의 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 값이 `true`, 때나 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 됩니다 `false` 및 <xref:System.Diagnostics.Process.HasExited%2A> 검사 구성 요소에 의해 호출 되 면 구성 요소는 상태로 남아 있는 연결된 된 프로세스에 대 한 관리 정보에 액세스할 수 운영 체제에 의해 저장 됩니다. 이러한 정보를 포함 합니다 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.ExitCode%2A>합니다.

연결 된 프로세스가 종료 된 후, <xref:System.Diagnostics.Process.Handle%2A> 요소의 더 이상 기존 프로세스 리소스를 가리킵니다. 대신,만 사용할 수 프로세스 리소스에 대 한 운영 체제의 정보에 액세스할 수 있습니다. 운영 체제가 있다는 사실을 인식 하 여 릴리스된 아직 종료 된 프로세스에 대 한 핸들 <xref:System.Diagnostics.Process> 구성 요소를 유지할 수 있도록 합니다 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 메모리에 대 한 정보입니다.

종료 하는 프로세스에 대 한 감시 하는 비용이 발생 합니다. 하는 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 됩니다 `true`는 <xref:System.Diagnostics.Process.Exited> 연결된 된 프로세스가 종료 될 때 이벤트가 발생 합니다. 에 대 한 프로시저는 <xref:System.Diagnostics.Process.Exited> 해당 시간에 실행 하는 이벤트입니다.

경우에 따라 응용 프로그램 프로세스를 시작 하지만 종료 되는 알림이 필요 하지 않습니다. 예를 들어, 응용 프로그램 사용자가 텍스트 편집을 수행 하지만 더 이상 하 게 메모장 응용 프로그램을 사용 하도록 허용 하려면 메모장을 시작 수 있습니다. 응용 프로그램의 지속적인된 작업에 관련 되지 않기 때문에 프로세스가 종료 될 때 알림을 방지할 수 있습니다. 설정 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 에 `false` 시스템 리소스를 저장할 수 있습니다.

## Examples  
다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 만듭니다. 설정 합니다 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성을 발생 시키는 프로세스를 <xref:System.Diagnostics.Process.Exited> 이 종료 될 때 이벤트입니다. <xref:System.Diagnostics.Process.Exited> 프로세스 정보를 표시 하는 이벤트 처리기입니다.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드에서 네이티브 속성 <see langword="SeDebugPrivilege" />를 활성화하여 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 특수 모드에서 실행되는 운영 체제 프로세스와 상호 작용하는 상태로 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 운영 체제 프로세스를 특수 모드에서 실행합니다. 속성을 읽거나 이러한 프로세스에 연결 하려고 하지 않는 가능한 호출한 <xref:System.Diagnostics.Process.EnterDebugMode%2A> 구성 요소입니다. 호출 <xref:System.Diagnostics.Process.LeaveDebugMode%2A> 특수 모드에서 실행 되는 이러한 프로세스에 대 한 액세스를 더 이상 필요 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림에 쓸 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트는 연결된 된 프로세스에 쓸 리디렉션된 나타냅니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 이벤트는 런타임에만 발생 비동기 읽기 작업 중에 <xref:System.Diagnostics.Process.StandardError%2A>입니다. 비동기 읽기 작업을 시작 하려면 리디렉션해야 합니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림의 <xref:System.Diagnostics.Process>, 이벤트 처리기를 추가 합니다 <xref:System.Diagnostics.Process.ErrorDataReceived> 이벤트 및 호출 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>합니다. 그 후는 <xref:System.Diagnostics.Process.ErrorDataReceived> 프로세스에서는 리디렉션된 줄 기록 될 때마다 이벤트 신호 <xref:System.Diagnostics.Process.StandardError%2A> 스트림, 프로세스 종료 되거나 호출할 때까지 <xref:System.Diagnostics.Process.CancelErrorRead%2A>입니다.  
  
> [!NOTE]
>  비동기 출력을 처리 하는 응용 프로그램을 호출 해야 합니다 <xref:System.Diagnostics.Process.WaitForExit> 메서드를 출력 버퍼를 플러시 했습니다. 지정 하면 제한 시간을 사용 하 여는 <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> 오버 로드 않습니다 *하지* 출력 버퍼 플러시 되었습니다.
  
   
  
## Examples  
 다음 예제에서는 `net view` 명령은 원격 컴퓨터에서 사용 가능한 네트워크 리소스를 나열 합니다. 사용자를 명령줄 인수 형태로 대상 컴퓨터 이름을 제공합니다. 사용자 오류 출력에 대 한 파일 이름을 제공할 수도 있습니다. 이 예제에서는 net 명령, 그 다음으로 프로세스가 끝날 때까지 쓰기 출력 결과 콘솔에 대 한 대기 작업의 출력을 수집 합니다. 사용자가 선택적 오류 파일을 제공 하는 경우이 예제에서는 파일에 오류를 씁니다.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스가 종료될 때 연결된 프로세스에서 지정한 값을 가져옵니다.</summary>
        <value>연결된 프로세스가 종료될 때 연결된 프로세스에서 지정한 코드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.Process.ExitCode%2A> 시스템 프로세스 종료 될 때 반환 되는 상태를 가져옵니다. 정수 값을 반환 하는 등의 종료 코드를 훨씬 사용할 수 있습니다는 `main()` 프로시저입니다.  
  
 <xref:System.Diagnostics.Process.ExitCode%2A> 해당 프로세스에 대 한 응용 프로그램 개발자가 구현한 특정 규칙을 반영 하는 프로세스에 대 한 값입니다. 종료 코드 값을 사용 하 여 코드에서 결정을 내릴 수 하는 경우 응용 프로그램 프로세스에서 사용 하는 종료 코드 규칙을 알고 있다고 해야 합니다.  
  
 개발자는 일반적으로 성공적으로 종료 나타냅니다는 <xref:System.Diagnostics.Process.ExitCode%2A> 호출 메서드가 않은 비정상적인 프로세스가 종료의 원인을 식별 하는 데 사용할 수 있는 0이 아닌 값으로 0을 지정 하는 오류 값입니다. 다음이 지침을 따라야 필요는 없습니다 되지만 규칙.  
  
 가져오려고 시도 하는 경우는 <xref:System.Diagnostics.Process.ExitCode%2A> 예외가 throw 전에 프로세스가 종료 되었습니다. 검사는 <xref:System.Diagnostics.Process.HasExited%2A> 연결 된 프로세스가 종료 여부를 확인 하려면 먼저 속성입니다.  
  
> [!NOTE]
>  비동기 이벤트 처리기에 표준 출력이 리디렉션 되었는지 경우에 출력 처리 완료 되지 않을 때 가능한 <xref:System.Diagnostics.Process.HasExited%2A> 반환 `true`합니다. 비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출을 <xref:System.Diagnostics.Process.WaitForExit> 체크 인하기 전에 매개 변수가 없는 오버 로드 <xref:System.Diagnostics.Process.HasExited%2A>합니다.  
  
 사용할 수는 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A> 연결 된 프로세스를 종료 하는 방법입니다.  
  
 연결된 된 프로세스가 종료 될 때 알림을 보내는 두 가지 방법이 있습니다: 동기적 및 비동기적으로 합니다. 동기 알림 호출에 의존 합니다 <xref:System.Diagnostics.Process.WaitForExit%2A> 연결된 구성 요소가 종료 될 때까지 응용 프로그램의 처리를 일시 중지 하는 방법입니다. 비동기 알림 의존 합니다 <xref:System.Diagnostics.Process.Exited> 이벤트입니다. 비동기 알림을 사용 하는 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 으로 설정 되어 있어야 `true` 에 대 한는 <xref:System.Diagnostics.Process> 프로세스 종료 되었다는 알림을 수신 하도록 구성 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스가 끝나지 않았습니다.  
  
또는 
프로세스 <see cref="P:System.Diagnostics.Process.Handle" />이 유효하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.ExitCode" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스가 종료될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited> 이벤트는 연결된 된 프로세스가 종료 되었음을 나타냅니다. 이 나타나는 것을 의미 하는 프로세스 종료 (중단) 또는 종결 했습니다. 경우에이 이벤트는 발생의 값을 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 속성은 `true`합니다.  
  
 연결된 된 프로세스가 종료 될 때 알림을 보내는 두 가지 방법이 있습니다: 동기적 및 비동기적으로 합니다. 동기 알림 호출을 의미 합니다 <xref:System.Diagnostics.Process.WaitForExit%2A> 프로세스가 종료 될 때까지 현재 스레드를 차단 하는 방법입니다. 비동기 알림이 사용 하 여 <xref:System.Diagnostics.Process.Exited> 그동안 실행을 계속 호출 스레드를 허용 하는 경우. 후자의 경우 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 로 설정 되어야 합니다 `true` 호출 응용 프로그램이 종료 되었습니다. 이벤트를 수신 합니다.  
  
 운영 체제 프로세스를 종료할 때 종료 되었습니다. 이벤트 처리기를 등록 하는 다른 모든 프로세스를 알립니다. 이번에 종료 하는 프로세스의 핸들을 사용할 수와 같은 일부 속성에 액세스 하려면 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.HasExited%2A> 해당 핸들을 완전히 해제 될 때까지 운영 체제에서 유지 관리는 합니다.  
  
> [!NOTE]
>  호출할 수 없습니다 종료 된 프로세스에 대 한 핸들에 있는 경우에 <xref:System.Diagnostics.Process.Start%2A> 다시 동일한 프로세스에 연결 하려면. 호출 <xref:System.Diagnostics.Process.Start%2A> 자동으로 연결된 된 프로세스를 해제 하 고 동일한 파일이 있지만 완전히 새로운 프로세스에 연결 <xref:System.Diagnostics.Process.Handle%2A>합니다.  
  
 사용에 대 한 자세한 합니다 <xref:System.Diagnostics.Process.Exited> Windows Forms 응용 프로그램에서 이벤트 참조를 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 만듭니다. 발생 시킵니다 합니다 <xref:System.Diagnostics.Process.Exited> 때문에 프로세스가 종료 될 때 이벤트를 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> 프로세스를 만들 때 설정 되었습니다. <xref:System.Diagnostics.Process.Exited> 프로세스 정보를 표시 하는 이벤트 처리기입니다.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스가 종료된 시간을 가져옵니다.</summary>
        <value>연결된 프로세스가 종료된 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 종료 되지 않은 경우 검색을 시도 하는 <xref:System.Diagnostics.Process.ExitTime%2A> 속성 예외를 throw 합니다. 사용 하 여 <xref:System.Diagnostics.Process.HasExited%2A> 시작 하기 전에 <xref:System.Diagnostics.Process.ExitTime%2A> 연결 된 프로세스가 종료 여부를 결정 하는 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파일을 인쇄 하는 프로세스를 만듭니다. 프로세스가 발생 시키는 합니다 <xref:System.Diagnostics.Process.Exited> 이 종료 될 때 이벤트 및 이벤트 처리기 표시를 <xref:System.Diagnostics.Process.ExitTime%2A> 속성 및 기타 정보를 처리 합니다.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.ExitTime" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 가져온 후 현재 활성화되어 있는 프로세스에 연결합니다.</summary>
        <returns>호출하는 응용 프로그램에서 실행 중인 프로세스 리소스에 연결된 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 인스턴스 및 로컬 컴퓨터의 프로세스 리소스를 사용 하 여 연결 합니다.  
  
 마찬가지로 <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, 및 <xref:System.Diagnostics.Process.GetProcesses%2A> 메서드 <xref:System.Diagnostics.Process.GetCurrentProcess%2A> 기존 리소스를 새 연결 <xref:System.Diagnostics.Process> 구성 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 만들어 사용자가 지정한 기존 프로세스 리소스에 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">프로세스 리소스의 시스템 고유 식별자입니다.</param>
        <summary>로컬 컴퓨터의 프로세서에 대한 식별자가 주어지면 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 반환합니다.</summary>
        <returns>
          <paramref name="processId" /> 매개 변수에 의해 식별되는 로컬 프로세스 리소스에 연결된 <see cref="T:System.Diagnostics.Process" /> 구성 요소입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 구성 요소와 로컬 컴퓨터의 프로세스 리소스를 연결 합니다. 때문에 컴퓨터의 프로세스 리소스 이미 존재 해야 합니다 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 시스템 리소스를 만들지는 않지만 대신 응용 프로그램에서 생성 된 리소스를 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. 프로세스 <xref:System.Diagnostics.Process.Id%2A> 컴퓨터의 현재 실행 중인 프로세스에만 검색할 수 있습니다. 프로세스가 종료 된 후 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 만료 된 식별자를 전달 하는 경우 예외를 throw 합니다.  
  
 특정 컴퓨터에는 프로세스의 식별자는 고유 합니다. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 최대 하나의 프로세스를 반환합니다. 특정 응용 프로그램을 사용 하 여 실행 중인 모든 프로세스를 가져오려는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>합니다. 지정된 된 응용 프로그램을 실행 하는 컴퓨터에 여러 프로세스가 있는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 연결 된 모든 프로세스를 포함 하는 배열을 반환 합니다. 이러한 각 프로세스에서 해당 식별자에 대 한를 쿼리할 수 있습니다. 프로세스 식별자를 볼 수 있습니다는 `Processes` Windows 작업 관리자의 창. `PID` 열 프로세스에 할당 되는 프로세스 식별자를 표시 합니다.  
  
 합니다 `processId` 매개 변수는는 <xref:System.Int32> (32 비트 부호 있는 정수), 기본 Windows API를 사용 하지만 `DWORD` (부호 없는 32 비트 정수) 비슷한 Api에 대 한 합니다. 이 이유 때문입니다.
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 매개 변수로 지정된 프로세스가 실행되고 있지 않습니다. 식별자가 만료되었을 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 이 개체에 의해 시작되지 않았습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">프로세스 리소스의 시스템 고유 식별자입니다.</param>
        <param name="machineName">네트워크에 있는 컴퓨터 이름입니다.</param>
        <summary>프로세스 식별자 및 네트워크에 있는 컴퓨터의 이름이 주어지면 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 반환합니다.</summary>
        <returns>
          <paramref name="processId" /> 매개 변수에 의해 식별되는 원격 프로세스 리소스에 연결된 <see cref="T:System.Diagnostics.Process" /> 구성 요소입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 <xref:System.Diagnostics.Process> 구성 요소와 네트워크의 원격 컴퓨터에서 프로세스 리소스를 연결 합니다. 때문에 지정한 컴퓨터의 프로세스 리소스 이미 존재 해야 합니다 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 시스템 리소스를 만들지는 않지만 대신 응용 프로그램에서 생성 된 리소스를 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. 프로세스 <xref:System.Diagnostics.Process.Id%2A> 컴퓨터의 현재 실행 중인 프로세스에만 검색할 수 있습니다. 프로세스가 종료 된 후 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 만료 된 식별자를 전달 하는 경우 예외를 throw 합니다.  
  
 특정 컴퓨터에는 프로세스의 식별자는 고유 합니다. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 최대 하나의 프로세스를 반환합니다. 특정 응용 프로그램을 사용 하 여 실행 중인 모든 프로세스를 가져오려는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>합니다. 지정된 된 응용 프로그램을 실행 하는 컴퓨터에 여러 프로세스가 있는 경우 <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> 연결 된 모든 프로세스를 포함 하는 배열을 반환 합니다. 이러한 각 프로세스에서 해당 식별자에 대 한를 쿼리할 수 있습니다. 프로세스 식별자를 볼 수 있습니다는 `Processes` Windows 작업 관리자의 창. `PID` 열 프로세스에 할당 되는 프로세스 식별자를 표시 합니다.  
  
 지정 하지 않으면 경우는 `machineName`, 로컬 컴퓨터가 사용 됩니다. 또는 설정 하 여 로컬 컴퓨터를 지정할 수 있습니다 `machineName` 값으로 "." 또는 빈 문자열 ("").  
  
 합니다 `processId` 매개 변수는는 <xref:System.Int32> (32 비트 부호 있는 정수), 기본 Windows API를 사용 하지만 `DWORD` (부호 없는 32 비트 정수) 비슷한 Api에 대 한 합니다. 이 이유 때문입니다.   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 매개 변수로 지정된 프로세스가 실행되고 있지 않습니다. 식별자가 만료되었을 수 있습니다.  
  
또는 
<paramref name="machineName" /> 매개 변수 구문이 잘못되었습니다. 이름의 길이가 0일 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 이 개체에 의해 시작되지 않았습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 배열을 만들어 기존 프로세스 리소스에 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>로컬 컴퓨터의 각 프로세스 리소스에 대해 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 만듭니다.</summary>
        <returns>로컬 컴퓨터에서 실행 중인 모든 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 배열을 만들려면 <xref:System.Diagnostics.Process> 구성 요소와 로컬 컴퓨터의 모든 프로세스 리소스를 사용 하 여 연결 합니다. 때문에 로컬 컴퓨터의 프로세스 리소스에 이미 존재 해야 합니다 <xref:System.Diagnostics.Process.GetProcesses%2A> 시스템 리소스를 만들지는 않지만 대신 응용 프로그램에서 생성 된 리소스를 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. 운영 체제 자체 백그라운드 프로세스를 실행 중 이므로이 배열은 비어 있지 않습니다.  
  
 모든 컴퓨터에서 실행 중인 프로세스를 검색 하려면 사용 하 여 해당 수를 제한할 수 있습니다 합니다 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드. <xref:System.Diagnostics.Process.GetProcessById%2A> 만듭니다는 <xref:System.Diagnostics.Process> 메서드에 전달 하는 프로세스 식별자 시스템에서 식별 하는 프로세스와 관련 된 구성 요소입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 배열을 만들고 <xref:System.Diagnostics.Process> 메서드에 전달 하면 해당 연결 된 프로세스 리소스에서 실행 파일을 공유 하는 구성 요소입니다.  
  
> [!NOTE]
>  서비스 호스트 프로세스 (svchost.exe)의 동일한 인스턴스 내에서 여러 Windows 서비스를 로드할 수 있습니다. GetProcesses 개별 서비스를 식별 하지 않습니다. 참조 하세요 <xref:System.ServiceProcess.ServiceController.GetServices%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">프로세스 목록을 읽어 올 컴퓨터입니다.</param>
        <summary>지정한 컴퓨터의 각 프로세스 리소스에 대해 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 만듭니다.</summary>
        <returns>지정된 컴퓨터에서 실행 중인 모든 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 배열을 만들려면 <xref:System.Diagnostics.Process> 구성 요소와 지정된 된 (일반적으로 원격) 컴퓨터에 있는 모든 프로세스 리소스를 사용 하 여 연결 합니다. 때문에 로컬 컴퓨터의 프로세스 리소스에 이미 존재 해야 합니다 <xref:System.Diagnostics.Process.GetProcesses%2A> 시스템 리소스를 만들지는 않지만 대신 응용 프로그램에서 생성 된 리소스를 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. 운영 체제 자체 백그라운드 프로세스를 실행 중 이므로이 배열은 비어 있지 않습니다.  
  
 모든 컴퓨터에서 실행 중인 프로세스를 검색 하려면 사용 하 여 해당 수를 제한할 수 있습니다 합니다 <xref:System.Diagnostics.Process.GetProcessById%2A> 또는 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 메서드. <xref:System.Diagnostics.Process.GetProcessById%2A> 만듭니다는 <xref:System.Diagnostics.Process> 메서드에 전달 하는 프로세스 식별자 시스템에서 식별 하는 프로세스와 관련 된 구성 요소입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 배열을 만들고 <xref:System.Diagnostics.Process> 메서드에 전달 하면 해당 연결 된 프로세스 리소스에서 실행 파일을 공유 하는 구성 요소입니다.  
  
 이 오버 로드는 <xref:System.Diagnostics.Process.GetProcesses%2A> 메서드는 네트워크에서 원격 컴퓨터에서 실행 중인 프로세스 리소스의 목록을 검색 하려면 일반적으로 사용 되지만 전달 하 여 로컬 컴퓨터를 지정할 수 있습니다 "."입니다.  
  
> [!NOTE]
>  서비스 호스트 프로세스 (svchost.exe)의 동일한 인스턴스 내에서 여러 Windows 서비스를 로드할 수 있습니다. GetProcesses 개별 서비스를 식별 하지 않습니다. 참조 하세요 <xref:System.ServiceProcess.ServiceController.GetServices%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 매개 변수 구문이 잘못되었습니다. 길이가 0일 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제 플랫폼이 원격 컴퓨터에서 이 작업을 지원하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스 정보를 가져오는 데 사용되는  성능 카운터 API에 액세스하는 데 문제가 있습니다. 이 예외는 Windows NT, Windows 2000 및 Windows XP에 해당됩니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">내부 시스템 API에 액세스하는 동안 문제가 발생했습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 새 배열을 만들어 지정한 프로세스 이름을 공유하는 모든 기존 프로세스 리소스에 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">프로세스의 이름입니다.</param>
        <summary>
          <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 새 배열을 만들어 지정한 프로세스 이름을 공유하는 로컬 컴퓨터의 모든 프로세스 리소스에 연결합니다.</summary>
        <returns>지정한 응용 프로그램 또는 파일을 실행 중인 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 배열을 만들려면 <xref:System.Diagnostics.Process> 구성 요소와 로컬 컴퓨터의 동일한 실행 파일을 실행 하는 모든 프로세스 리소스를 사용 하 여 연결 합니다. 때문에 컴퓨터의 프로세스 리소스에 이미 존재 해야 합니다 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 시스템 리소스를 만들지는 않지만 대신 응용 프로그램에서 생성 된 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. `processName` 메서드 배열이 비어 있을 수 있으므로 로컬 컴퓨터의 현재 실행 하지 않는 실행 파일에 지정할 수 있습니다.  
  
 프로세스 이름은.exe 확장명 또는 경로 포함 하지 않는 Outlook 같은 프로세스에 대 한 친숙 한 이름입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 가져오기 및 동일한 실행 파일을 사용 하 여 연결 된 모든 프로세스를 조작 하는 데 도움이 됩니다. 예를 들어 실행 파일 이름으로 전달할 수 있습니다는 `processName` 매개 변수는 실행 파일의 모든 실행 중인 인스턴스를 종료 합니다.  
  
 하지만 프로세스 <xref:System.Diagnostics.Process.Id%2A> 은 시스템에서 단일 프로세스 리소스에 고유한 로컬 컴퓨터의 여러 프로세스 실행 될 수 있습니다 지정 된 응용 프로그램과 `processName` 매개 변수입니다. 따라서 <xref:System.Diagnostics.Process.GetProcessById%2A> 최소한 하나의 프로세스를 반환 하지만 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 연결 된 모든 프로세스를 포함 하는 배열을 반환 합니다. 표준 API 호출을 사용 하는 프로세스를 조작 하는 경우 해당 식별자에서 이러한 프로세스 모두를 쿼리할 수 있습니다. 단독 프로세스 이름을 통해 하지만의 배열을 검색 한 후 프로세스 리소스에 액세스할 수 없는 <xref:System.Diagnostics.Process> 연관 된 구성 요소 프로세스 리소스를 사용 하 여 조작할 수 있습니다 시작, 종료 하 고, 그렇지 않으면 시스템 리소스입니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스 정보를 가져오는 데 사용되는  성능 카운터 API에 액세스하는 데 문제가 있습니다. 이 예외는 Windows NT, Windows 2000 및 Windows XP에 해당됩니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">프로세스의 이름입니다.</param>
        <param name="machineName">네트워크에 있는 컴퓨터 이름입니다.</param>
        <summary>
          <see cref="T:System.Diagnostics.Process" /> 구성 요소로 이루어진 새 배열을 만들어 지정한 프로세스 이름을 공유하는 원격 컴퓨터에 있는 모든 프로세스 리소스에 연결합니다.</summary>
        <returns>지정한 응용 프로그램 또는 파일을 실행 중인 프로세스 리소스를 나타내는 <see cref="T:System.Diagnostics.Process" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 새 배열을 만들려면 <xref:System.Diagnostics.Process> 구성 요소와 지정된 된 컴퓨터에서 동일한 실행 파일을 실행 하는 모든 프로세스 리소스를 사용 하 여 연결 합니다. 때문에 컴퓨터의 프로세스 리소스에 이미 존재 해야 합니다 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 시스템 리소스를 만들지는 않지만 대신 응용 프로그램에서 생성 된 연결 <xref:System.Diagnostics.Process> 구성 요소입니다. `processName` 메서드 배열이 비어 있을 수 있으므로 로컬 컴퓨터의 현재 실행 하지 않는 실행 파일에 지정할 수 있습니다.  
  
 프로세스 이름은.exe 확장명 또는 경로 포함 하지 않는 Outlook 같은 프로세스에 대 한 친숙 한 이름입니다. <xref:System.Diagnostics.Process.GetProcessesByName%2A> 가져오기 및 동일한 실행 파일을 사용 하 여 연결 된 모든 프로세스를 조작 하는 데 도움이 됩니다. 예를 들어 실행 파일 이름으로 전달할 수 있습니다는 `processName` 매개 변수는 실행 파일의 모든 실행 중인 인스턴스를 종료 합니다.  
  
 하지만 프로세스 <xref:System.Diagnostics.Process.Id%2A> 은 시스템에서 단일 프로세스 리소스에 고유한 로컬 컴퓨터의 여러 프로세스 실행 될 수 있습니다 지정 된 응용 프로그램과 `processName` 매개 변수입니다. 따라서 <xref:System.Diagnostics.Process.GetProcessById%2A> 최소한 하나의 프로세스를 반환 하지만 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 연결 된 모든 프로세스를 포함 하는 배열을 반환 합니다. 표준 API 호출을 사용 하는 프로세스를 조작 하는 경우 해당 식별자에서 이러한 프로세스 모두를 쿼리할 수 있습니다. 단독 프로세스 이름을 통해 하지만의 배열을 검색 한 후 프로세스 리소스에 액세스할 수 없는 <xref:System.Diagnostics.Process> 연관 된 구성 요소 프로세스 리소스를 사용 하 여 조작할 수 있습니다 시작, 종료 하 고, 그렇지 않으면 시스템 리소스입니다.  
  
 원격 컴퓨터 에서도 로컬 컴퓨터의 프로세스를 가져오려면이 오버 로드를 사용할 수 있습니다. 사용 하 여 "." 로컬 컴퓨터를 지정 합니다. 기본적으로 로컬 컴퓨터를 사용 하 여 다른 오버 로드가 있습니다.  
  
 프로세스 통계와 같은 프로세스에 대 한 정보를 보기에 원격 컴퓨터에서 액세스할 수 있습니다. 종료를 닫고 수 없습니다 (사용 하 여 <xref:System.Diagnostics.Process.Kill%2A>), 또는 원격 컴퓨터에서 프로세스를 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로컬 컴퓨터 및 로컬 컴퓨터의 특정 프로세스에서 실행 중인 메모장의 모든 인스턴스는 로컬 컴퓨터에서 실행 중인 프로세스가 현재 프로세스의 정보를 검색 합니다. 다음 원격 컴퓨터에서 동일한 프로세스에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 매개 변수 구문이 잘못되었습니다. 길이가 0일 수 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제 플랫폼이 원격 컴퓨터에서 이 작업을 지원하지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="machineName" />에 연결하려는 시도가 실패했습니다.

또는 
프로세스 정보를 가져오는 데 사용되는  성능 카운터 API에 액세스하는 데 문제가 있습니다. 이 예외는 Windows NT, Windows 2000 및 Windows XP에 해당됩니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">내부 시스템 API에 액세스하는 동안 문제가 발생했습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 기본 핸들을 가져옵니다.</summary>
        <value>연결된 프로세스가 시작될 때 운영 체제에서 해당 프로세스에 할당한 핸들입니다. 시스템에서는 이 핸들을 사용하여 프로세스 특성을 추적합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램에는 여러 프로세스 정보 및 제어 함수를 매개 변수로 사용할 수 있는 프로세스에 핸들을 가져올 수 있습니다. 이 핸들을 사용 하 여 초기화를 <xref:System.Threading.WaitHandle> 하거나 호출 플랫폼과 네이티브 메서드를 호출 합니다.  
  
 이 프로세스 핸들은 전용 응용 프로그램 즉, 핸들을 공유할 수 없는 프로세스입니다. 프로세스에는 또한 프로세스에 <xref:System.Diagnostics.Process.Id%2A> 는 달리는 <xref:System.Diagnostics.Process.Handle%2A>, 고유한 이며, 따라서 시스템 전체에서 유효 합니다.  
  
 호출을 통해 시작 프로세스만 <xref:System.Diagnostics.Process.Start%2A> 설정 합니다 <xref:System.Diagnostics.Process.Handle%2A> 해당 속성 <xref:System.Diagnostics.Process> 인스턴스.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스가 시작되지 않았거나 종료되었습니다. 이 <see cref="P:System.Diagnostics.Process.Handle" /> 인스턴스에 연결된 프로세스가 없으므로 <see cref="T:System.Diagnostics.Process" /> 속성을 읽을 수 없습니다.  
  
또는 
<see cref="T:System.Diagnostics.Process" /> 인스턴스가 실행 프로세스에 연결되었지만 모든 액세스 권한을 가진 핸들을 가져오는 데 필요한 사용 권한이 없는 경우</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.Handle" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스에서 연 핸들 수를 가져옵니다.</summary>
        <value>프로세스에서 연 운영 체제 핸들의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들 개체를 참조 하는 프로세스에 대해 알아볼 수 있습니다. 프로세스는 파일, 리소스, 메시지 큐 및 기타 여러 운영 체제 개체에 대 한 핸들을 가져올 수 있습니다. 운영 체제 핸들 수가 0 일 경우에 프로세스와 연결 된 메모리를 회수 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스가 종료되었는지를 나타내는 값을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Diagnostics.Process" /> 구성 요소가 참조하는 운영 체제 프로세스가 종료되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값이 `true` 에 대 한 <xref:System.Diagnostics.Process.HasExited%2A> 정상 또는 비정상으로 연결된 된 프로세스는 종료를 나타냅니다. 요청 하거나 연결된 된 프로세스가 종료를 호출 하 여 강제로 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 핸들을 프로세스에 열려 있으면 프로세스 작업이 종료 하지만 핸들, 종료 코드 및 종료 시간과 같은 프로세스에 대 한 관리 정보는 유지 하는 경우 운영 체제는 프로세스 메모리를 해제 합니다. 이 정보를 얻으려면 사용할 수 있습니다 합니다 <xref:System.Diagnostics.Process.ExitCode%2A> 고 <xref:System.Diagnostics.Process.ExitTime%2A> 속성입니다. 이러한 속성은이 구성 요소에서 시작 된 프로세스에 대 한 자동으로 채워집니다. 관리 정보를 놓을 때 모든는 <xref:System.Diagnostics.Process> 시스템 프로세스와 연관 된 구성 요소 제거 되 고 종료 된 프로세스에 핸들이 더 이상 없을 합니다.  
  
 코드와 독립적으로 프로세스를 종료할 수 있습니다. 시스템 업데이트의 값이 구성이 요소를 사용 하는 프로세스를 시작한 경우 <xref:System.Diagnostics.Process.HasExited%2A> 자동으로 연결된 된 프로세스가 종료 하지 독립적으로 하는 경우에 합니다.  
  
> [!NOTE]
>  비동기 이벤트 처리기에 표준 출력이 리디렉션 되었는지 하는 경우는 출력 처리 완료 되지 않을 때이 속성은 반환 수 `true`입니다. 비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출을 <xref:System.Diagnostics.Process.WaitForExit> 체크 인하기 전에 매개 변수가 없는 오버 로드 <xref:System.Diagnostics.Process.HasExited%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 10 초 동안 최대 2 초 간격 연결된 된 프로세스의 실제 메모리 사용량을 검색합니다. 이 예제에서는 10 초 경과 되기 전에 프로세스가 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 경우 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">개체와 연결된 프로세스가 없습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">프로세스의 종료 코드를 검색할 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 고유 식별자를 가져옵니다.</summary>
        <value>이 <see cref="T:System.Diagnostics.Process" /> 인스턴스에서 참조하는 프로세스의 고유 식별자입니다. 이 식별자는 시스템에서 생성됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 <xref:System.Diagnostics.Process.Id%2A> 연결된 된 프로세스를 실행 하지 않는 경우에 올바르지 않습니다. 프로세스를 검색 하기 전에 실행 되 고 있는지 확인 해야 하므로 <xref:System.Diagnostics.Process.Id%2A> 속성입니다. 프로세스가 종료 될 때까지 프로세스 식별자입니다. 시스템 전체에서 프로세스를 고유 하 게 식별 합니다.  
  
 새 로컬 또는 원격 컴퓨터에서 실행 중인 프로세스에 연결할 수 있습니다 <xref:System.Diagnostics.Process> 프로세스 식별자를 전달 하 여 인스턴스를 <xref:System.Diagnostics.Process.GetProcessById%2A> 메서드. <xref:System.Diagnostics.Process.GetProcessById%2A> `static` 새 구성 요소를 만드는 메서드를 가져오거나 설정 합니다 <xref:System.Diagnostics.Process.Id%2A> 새 속성 <xref:System.Diagnostics.Process> 자동으로 인스턴스.  
  
 시스템에서 프로세스 식별자를 재사용할 수 있습니다. <xref:System.Diagnostics.Process.Id%2A> 연결된 된 프로세스가 실행 되는 동안에 속성 값은 고유 합니다. 시스템 프로세스 종료 한 후 다시 사용할 수는 <xref:System.Diagnostics.Process.Id%2A> 는 관련 되지 않은 프로세스에 대 한 속성 값입니다.  
  
 시스템에서 고유 식별자 이므로 전달할 수 있습니다 다른 스레드에 전달 하는 대신 한 <xref:System.Diagnostics.Process> 인스턴스. 이 작업은 시스템 리소스를 저장 하면서 프로세스는 올바르게 식별할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 가져오는 방법을 보여 줍니다는 <xref:System.Diagnostics.Process.Id%2A> 모든 응용 프로그램의 인스턴스를 실행 합니다. 메모장의 새 인스턴스를 만듭니다, 메모장의 인스턴스를 모두 나열 및 입력을 사용 하면 다음 코드는 <xref:System.Diagnostics.Process.Id%2A> 특정 인스턴스를 제거할 수 있습니다.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스의 <see cref="P:System.Diagnostics.Process.Id" /> 속성이 설정되어 있지 않습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성을 <see langword="false" />로 설정합니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>연결된 프로세스를 즉시 중지합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 프로세스의 종료를 강제로 수행 하는 동안 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 만 종료를 요청 합니다. 그래픽 인터페이스를 사용 하 여 프로세스를 실행할 때 해당 메시지 루프는 대기 상태입니다. 운영 체제에서 프로세스에 Windows 메시지를 보낼 때마다 메시지 루프를 실행 합니다. 호출 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 는 잘 구성 된 응용 프로그램에서 자식 창을 닫고 응용 프로그램에 대 한 실행 중인 모든 메시지 루프를 취소 주 창에 가까운 요청을 보냅니다. 호출 하 여 프로세스를 종료 하는 요청 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 종료 하도록 응용 프로그램을 강제 적용 되지 않습니다. 응용 프로그램을 끝내기 전에 사용자 확인 요청 또는 종료를 거부할 수 있습니다. 종료 하도록 응용 프로그램을 강제로 사용 하 여를 <xref:System.Diagnostics.Process.Kill%2A> 메서드. 동작 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 시스템 메뉴를 사용 하 여 응용 프로그램의 주 창을 닫으면 사용자와 동일 합니다. 따라서 주 창을 닫으면 프로세스를 종료 하는 요청은 즉시 취소 하려면 응용 프로그램을 강제로 되지 않습니다.  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A> 메서드를 비동기적으로 실행 합니다. 호출한 후는 <xref:System.Diagnostics.Process.Kill%2A> 메서드를 호출 합니다 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드를 종료 하거나 확인 하는 프로세스에 대 한 대기를 <xref:System.Diagnostics.Process.HasExited%2A> 된 프로세스가 종료 된 경우를 결정 하는 속성입니다.  
  
 프로세스에 의해 편집 하는 데이터 또는 프로세스에 할당 된 리소스 손실 될 수 있습니다를 호출 하면 <xref:System.Diagnostics.Process.Kill%2A>합니다. <xref:System.Diagnostics.Process.Kill%2A> 비정상적인 프로세스 종료를 사용 하면 필요한 경우에 사용 해야 합니다. <xref:System.Diagnostics.Process.CloseMainWindow%2A> 과정을 순서 대로 종료 있으며 인터페이스를 사용 하 여 응용 프로그램에 대 한 것이 좋습니다 이므로 모든 창을 닫습니다. 하는 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 사용할 수 있습니다 실패 <xref:System.Diagnostics.Process.Kill%2A> 프로세스를 종료 하려면. <xref:System.Diagnostics.Process.Kill%2A> 그래픽 인터페이스를 갖지 않는 프로세스를 종료 하는 유일한 방법이입니다.  
  
 호출할 수 있습니다 <xref:System.Diagnostics.Process.Kill%2A> 고 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 합니다. 종료 하려면 원격 컴퓨터에서 프로세스 할 수 없습니다. 원격 컴퓨터에서 실행 중인 프로세스에 대 한 정보를 보기만 할 수 있습니다.  
  
> [!NOTE]
>  경우에 대 한 호출을 <xref:System.Diagnostics.Process.Kill%2A> 메서드는 프로세스를 종료 하는 동안 만들어집니다는 <xref:System.ComponentModel.Win32Exception> 액세스가 거부에 대해 throw 되 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 프로세스를 종료할 수 없습니다.  
  
또는 
프로세스가 종료됩니다.  
  
또는 
연결된 프로세스가 Win16 실행 파일입니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="M:System.Diagnostics.Process.Kill" />를 호출하려고 합니다. 이 메서드는 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 이미 종료되었습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Diagnostics.Process" /> 구성 요소를 특수 모드에서 실행되는 운영 체제 프로세스와 상호 작용할 수 없는 상태로 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 운영 체제 프로세스를 특수 모드에서 실행합니다. 속성을 읽거나 이러한 프로세스에 연결 하려고 하지 않는 가능한 호출한 <xref:System.Diagnostics.Process.EnterDebugMode%2A> 구성 요소입니다. 호출 <xref:System.Diagnostics.Process.LeaveDebugMode%2A> 특수 모드에서 실행 되는 이러한 프로세스에 대 한 액세스를 더 이상 필요 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스가 실행 중인 컴퓨터 이름을 가져옵니다.</summary>
        <value>연결된 프로세스가 실행 중인 컴퓨터 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하지만 원격 컴퓨터에서 실행 중인 프로세스에 대 한 프로세스 정보를 호출할 수 없습니다 및 통계 데이터를 볼 수 있습니다 <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, 또는 <xref:System.Diagnostics.Process.Kill%2A> 원격 컴퓨터.  
  
> [!NOTE]
>  연결된 된 프로세스를 로컬 컴퓨터에서 실행 하는 경우 기간을 반환 (".")는 컴퓨터 이름입니다. 기능을 사용할지는 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 올바른 컴퓨터 이름을 가져올 속성입니다.  
  
   
  
## Examples  
 사용 하려면 먼저 다음 예제에서는 원격 컴퓨터에서 메모장의 인스턴스를 하나 이상를 시작 합니다. 이 예제에서는 요청 메모장 실행 되 고 각각을 표시 하는 원격 컴퓨터의 이름을 <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, 및 <xref:System.Diagnostics.Process.MachineName%2A> 각 인스턴스에 대 한 속성입니다.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 주 모듈을 가져옵니다.</summary>
        <value>프로세스를 시작하는 데 사용된 <see cref="T:System.Diagnostics.ProcessModule" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 모듈 특정 프로세스에 로드 되는.dll 또는.exe 파일을 나타냅니다. <xref:System.Diagnostics.Process.MainModule%2A> 속성을 통해 모듈 이름, 파일 이름 및 모듈 메모리 세부 정보를 포함 하 여 프로세스를 시작 하는 데 사용 하는 실행 파일에 대 한 정보를 볼 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MainModule" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32비트 프로세스가 64비트 프로세스의 모듈에 액세스하려고 합니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.  
  
또는 
프로세스가 종료되었습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 주 창에 대한 창 핸들을 가져옵니다.</summary>
        <value>연결된 프로세스의 주 창에 대한 창 핸들입니다. 이 창 핸들은 시스템에서 생성됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 기간은 현재 포커스를가지고 하는 프로세스에 의해 열린 창을 (의 <xref:System.Windows.Forms.Form.TopLevel%2A> 양식). 사용 해야 합니다는 <xref:System.Diagnostics.Process.Refresh%2A> 새로 고침 하는 방법의 <xref:System.Diagnostics.Process> 변경 된 경우 현재 주 창 핸들을 가져올 개체입니다. 창 핸들을 캐시 되므로 일반적으로 사용 <xref:System.Diagnostics.Process.Refresh%2A> 현재 핸들을 검색할 수 있다고 보장 하기 위해 미리 합니다.  
  
 가져올 수 있습니다는 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 로컬 컴퓨터에서 실행 중인 프로세스에 대해서만 속성입니다. <xref:System.Diagnostics.Process.MainWindowHandle%2A> 속성이 프로세스와 관련 된 창을 고유 하 게 식별 하는 값입니다.  
  
 프로세스에 프로세스 그래픽 인터페이스가 하는 경우에 연결 된 주 창이 있습니다. 연결된 된 프로세스에 주 창이 없는 경우는 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 값은 0입니다. 값 0 숨겨져 있는 경우는 프로세스, 작업 표시줄에 표시 되지 않는 처리 이기도 합니다. 이 작업 표시줄의 맨 오른쪽 알림 영역에서 아이콘으로 표시 되는 프로세스에 대 한 사례 수 있습니다.  
  
 프로세스를 방금 시작한 경우의 주 창 핸들을 사용 하려면 사용을 고려 합니다 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 주 창 핸들이 만들어졌는지 확인 시작이 완료 하는 프로세스를 허용 하는 방법입니다. 그렇지 않으면 예외가 throw됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스가 종료되었으므로 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />이 정의되지 않았습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스의 주 창에 대한 캡션을 가져옵니다.</summary>
        <value>프로세스의 주 창 제목입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스에 프로세스 그래픽 인터페이스가 하는 경우에 연결 된 주 창이 있습니다. 연결된 된 프로세스에 주 창이 없으면 (되도록 <xref:System.Diagnostics.Process.MainWindowHandle%2A> 가 0), <xref:System.Diagnostics.Process.MainWindowTitle%2A> 은 빈 문자열 (""). 프로세스를 방금 시작한 하 고 주 창 제목을 사용 하려고 할 경우 사용을 고려 합니다 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 주 창 핸들이 만들어졌는지 확인 시작이 완료 하는 프로세스를 허용 하는 방법입니다. 그렇지 않으면 시스템에서 예외가 throw됩니다.  
  
> [!NOTE]
>  현재 포커스가 있는; 창인지 주 창 프로세스에 대 한 기본 창 되지 않을 수 있습니다이 note 합니다. 사용 해야 합니다는 <xref:System.Diagnostics.Process.Refresh%2A> 새로 고침 하는 방법의 <xref:System.Diagnostics.Process> 변경 된 경우 현재 주 창 핸들을 가져올 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작한 프로세스의 주 창의 캡션을 검색 합니다.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스가 종료되었으므로 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 속성이 정의되지 않았습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 대한 최대 허용 작업 집합 크기(바이트)를 가져오거나 설정합니다.</summary>
        <value>프로세스에 대해 메모리에서 허용된 작업 집합의 최대 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스의 작업 집합은 실제 RAM 메모리의 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는 system.dll 파일과.dll 파일에서 페이지를 포함 하 여 응용 프로그램을 실행 하는 모든 지침을 포함 하는 페이지를 포함 합니다. 작업 집합 크기 증가, 메모리 수요가 증가 합니다.  
  
 프로세스에 최소 및 최대 작업 집합 크기입니다. 프로세스 리소스를 만들 때마다 시스템의 작업 집합 크기를 프로세스에 대 한 최소 같음 메모리 용량을 예약 합니다. 가상 메모리 관리자를 유지 하려고 적어도 최소 메모리 양을 상주 때 프로세스가 활성 상태 이지만 최대 크기 이상 유지 하지는 않습니다.  
  
 시스템 기본 작업 집합 크기를 설정 합니다. 사용 하 여 이러한 크기를 수정할 수는 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 및 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 멤버입니다. 그러나 이러한 값을 설정 보장 하지 않습니다 상주 또는 예약 된 메모리는 됩니다.  
  
> [!NOTE]
>  프로세스의 작업 집합 크기를 늘리는 경우 실제 메모리 시스템의 나머지 부분에서 수행 합니다. 최소 또는 최대 작업 집합 크기를 너무 많거나 시스템 성능을 떨어뜨릴 수 있으므로 요청 하지 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">최대 작업 집합 크기가 잘못 되었습니다. 최소 작업 집합 크기보다 크거나 같아야 합니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">작업 집합 정보를 연결된 프로세스 리소스에서 검색할 수 없습니다.  
  
또는 
프로세스가 시작되지 않아서 프로세스 식별자 또는 프로세스 핸들이 0입니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.  
  
또는 
프로세스가 종료되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 대해 허용되는 작업 집합의 최소 크기(바이트)를 가져오거나 설정합니다.</summary>
        <value>프로세스에 대해 메모리에서 필요로 하는 작업 집합의 최소 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스의 작업 집합은 실제 RAM 메모리의 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터에는 system.dll 파일과.dll 파일에서 페이지를 포함 하 여 응용 프로그램을 실행 하는 모든 지침을 포함 하는 페이지를 포함 합니다. 작업 집합 크기 증가, 메모리 수요가 증가 합니다.  
  
 프로세스에 최소 및 최대 작업 집합 크기입니다. 프로세스 리소스를 만들 때마다 시스템의 작업 집합 크기를 프로세스에 대 한 최소 같음 메모리 용량을 예약 합니다. 가상 메모리 관리자를 유지 하려고 적어도 최소 메모리 양을 상주 때 프로세스가 활성 상태 이지만 최대 크기 이상 유지 하지는 않습니다.  
  
 시스템 기본 작업 집합 크기를 설정 합니다. 사용 하 여 이러한 크기를 수정할 수는 <xref:System.Diagnostics.Process.MaxWorkingSet%2A> 및 <xref:System.Diagnostics.Process.MinWorkingSet%2A> 멤버입니다. 그러나 이러한 값을 설정 보장 하지 않습니다 상주 또는 예약 된 메모리는 됩니다.  
  
> [!NOTE]
>  프로세스의 작업 집합 크기를 늘리는 경우 실제 메모리 시스템의 나머지 부분에서 수행 합니다. 최소 또는 최대 작업 집합 크기를 너무 많거나 시스템 성능을 떨어뜨릴 수 있으므로 요청 하지 확인 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">최소 작업 집합 크기가 잘못되었습니다. 최대 작업 집합 크기와 작거나 같아야 합니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">작업 집합 정보를 연결된 프로세스 리소스에서 검색할 수 없습니다.  
  
또는 
프로세스가 시작되지 않아서 프로세스 식별자 또는 프로세스 핸들이 0입니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스에 대한 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.  
  
또는 
프로세스가 종료되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 의해 로드된 모듈을 가져옵니다.</summary>
        <value>연결된 프로세스에 의해 로드된 모듈을 나타내는 <see cref="T:System.Diagnostics.ProcessModule" /> 형식의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 모듈 특정 프로세스에 로드 되는.dll 또는.exe 파일을 나타냅니다. <xref:System.Diagnostics.ProcessModule> 인스턴스를 사용 하면 모듈 이름, 파일 이름 및 모듈 메모리 세부 정보를 포함 한 모듈에 대 한 정보를 볼 수 있습니다.  
  
 프로세스는 메모리에 여러 모듈을 로드할 수 있습니다. 예를 들어 추가.dll 파일을 로드 하는.exe 파일에는 여러 모듈이 있습니다.  
  
 프로세스를 시작한 후 시스템에서 프로세스를 로드할 때까지이 컬렉션은 비어 있습니다. 프로세스에 주 창 하는 경우에 호출 하면 <xref:System.Diagnostics.Process.WaitForInputIdle%2A> 목록 컬렉션에 비어 있지 않은 경우를 위해이 속성을 검색 하기 전에 표시 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.Modules" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">시스템 프로세스 또는 유휴 프로세스에 대한 <see cref="P:System.Diagnostics.Process.Modules" /> 속성에 액세스하려고 합니다. 이러한 프로세스에 모듈이 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 비페이징 시스템 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 없는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 비페이징 시스템 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 없는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 된 값 (바이트)에서 프로세스에 의해 사용 되는 비페이징된 시스템 메모리의 현재 크기를 나타냅니다. 시스템 메모리는 운영 체제에서 사용 하는 실제 메모리 및 페이징 및 비페이징 풀으로 나뉩니다. 비페이징된 메모리 할당 시스템 메모리에 유지 되 고 가상 메모리 페이징 파일에 페이징 아웃 되지 않습니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **Pool Nonpaged Bytes** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 발생 하는 API 메서드는 <xref:System.Diagnostics.Process.Exited> 이벤트입니다. 호출 <xref:System.Diagnostics.Process.OnExited%2A> 하면 합니다 <xref:System.Diagnostics.Process.Exited> 이벤트를 발생 하 여 이벤트를 발생 시키는 유일한 방법은 및을 <xref:System.Diagnostics.Process> 구성 요소. <xref:System.Diagnostics.Process.OnExited%2A> 구성 요소에서 클래스를 파생 하는 경우 주로 사용 됩니다.  
  
 대 안으로 <xref:System.Diagnostics.Process.OnExited%2A>, 고유한 이벤트 처리기를 작성할 수 있습니다. 고유한 이벤트 처리기 대리자 및 사용자 고유의 이벤트 처리 메서드를 만듭니다.  
  
> [!NOTE]
>  Visual Studio 환경을 사용 하는 경우 이벤트 처리기 대리자 (AddOnExited) 및 이벤트 처리 메서드 (Process1_Exited) 만들어집니다 끌면는 <xref:System.Diagnostics.Process> 폼으로 구성 요소 아이콘을 두 번 클릭 합니다. 다음과 같은 경우 실행 하기 위해 만든 코드는 <xref:System.Diagnostics.Process.Exited> Process1_Exited 프로시저에 입력 된 이벤트가 발생 합니다. 만들 필요가 없습니다를 <xref:System.Diagnostics.Process.OnExited%2A> 멤버를 구현 되므로 합니다.  
  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 개요를 보려면 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법의 <xref:System.Diagnostics.Process.OnExited%2A> 파생된 클래스에서 메서드.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 리디렉션된 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림에 쓸 때마다 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트는 연결 된 <xref:System.Diagnostics.Process> 리디렉션된 줄 바꿈 문자로 종료 코드 줄을 작성 했습니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
 비동기 읽기 작업 중에 이벤트를 사용할지 <xref:System.Diagnostics.Process.StandardOutput%2A>합니다. 비동기 읽기 작업을 시작 하려면 리디렉션해야 합니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림의 <xref:System.Diagnostics.Process>, 이벤트 처리기를 추가 합니다 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트 및 호출 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>합니다. 그 후는 <xref:System.Diagnostics.Process.OutputDataReceived> 프로세스에서는 리디렉션된 줄 기록 될 때마다 이벤트 신호 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림, 프로세스 종료 되거나 호출할 때까지 <xref:System.Diagnostics.Process.CancelOutputRead%2A>입니다.  
  
> [!NOTE]
>  비동기 출력을 처리 하는 응용 프로그램을 호출 해야 합니다 <xref:System.Diagnostics.Process.WaitForExit%2A> 메서드를 출력 버퍼를 플러시 했습니다.  
  
   
  
## Examples  
 다음 예제에서는 리디렉션된에 대해 비동기 읽기 작업을 수행 하는 방법을 보여 줍니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림의 `ipconfig` 명령입니다.  
  
 예제에 대 한 이벤트 대리자를 만듭니다는 `OutputHandler` 이벤트 처리기에 연결 된 <xref:System.Diagnostics.Process.OutputDataReceived> 이벤트. 이벤트 처리기에서 리디렉션된 텍스트 줄을 받아서 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림에 텍스트의 서식을 나중에 예제의 콘솔 창에 표시 되는 출력 문자열에 저장 합니다.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 페이징 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 의해 할당된 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 페이징 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스의 가상 메모리 페이징 파일에 할당된 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 된 값 (바이트)에서 프로세스에 의해 사용 되는 가상 메모리 페이징 파일에는 메모리의 현재 크기를 나타냅니다. 운영 체제 각 프로세스에 대 한 가상 주소 공간 관리를 위한 실제 메모리를 사용 하 여 함께에서 가상 메모리 페이징 파일을 사용 합니다. 사용 중인 페이징 가능한 메모리 없을 때 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다. 프로세스에 대 한 운영 체제에서 사용 되는 메모리의 크기를 가져오려면는 <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> 속성입니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **페이지 파일 바이트** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 된 다음 검색 및 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 페이징할 수 있는 시스템 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 대해 시스템에서 할당한 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 페이징할 수 있는 시스템 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 대해 할당된 시스템 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값으로 반환 되는 값 (바이트)에서 프로세스에 의해 사용 되는 페이징할 수 있는 시스템 메모리의 현재 크기를 나타냅니다. 시스템 메모리는 운영 체제에서 사용 하는 실제 메모리 및 페이징 및 비페이징 풀으로 나뉩니다. 사용 중인 페이징 가능한 메모리 없을 때 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다. 프로세스에서 사용 하는 응용 프로그램 메모리의 크기를 가져오려면는 <xref:System.Diagnostics.Process.PagedMemorySize64%2A> 속성입니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **Pool Paged Bytes** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에서 사용하는 가상 메모리 페이징 파일의 최대 메모리 양(바이트)을 가져옵니다.</summary>
        <value>가상 메모리 페이징 파일에 쓸 수 있는 연결된 프로세스에 의해 할당된 메모리의 최대 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에서 사용하는 가상 메모리 페이징 파일의 최대 메모리 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스가 시작된 이후 연결된 프로세스의 가상 메모리 페이징 파일에 할당된 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 값으로 반환 되는 값 (바이트)를 시작한 이후에 프로세스에서 사용 되는 가상 메모리 페이징 파일에는 메모리의 최대 크기를 나타냅니다. 운영 체제 각 프로세스에 대 한 가상 주소 공간 관리를 위한 실제 메모리를 사용 하 여 함께에서 가상 메모리 페이징 파일을 사용 합니다. 사용 중인 페이징 가능한 메모리 없을 때 디스크에 있는 가상 메모리 페이징 파일을 전송할 수 있습니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **페이지 파일 바이트 최대** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에서 사용되는 가상 메모리의 최대 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스에서 요청한 가상 메모리의 최대 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에서 사용되는 가상 메모리의 최대 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스가 시작된 이후 해당 프로세스에 할당된 가상 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 된 값 (바이트)를 시작한 이후에 프로세스에서 사용 되는 가상 메모리의 최대 크기를 나타냅니다. 운영 체제는 실제 메모리 또는 디스크에 있는 가상 메모리 페이징 파일에 저장 된 페이지를 로드 하거나 페이지 각 프로세스에 대 한 가상 주소 공간을 매핑합니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **가상 바이트 최대** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 최대 작업 집합 크기(바이트)를 가져옵니다.</summary>
        <value>연결된 프로세스에서 한 번에 요청한 실제 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스의 작업 집합은 실제 RAM 메모리의 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터 처리 모듈 및 시스템 라이브러리를 포함 하 여 프로세스 실행 한 모든 지침이 포함 된 페이지를 포함 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에서 사용되는 실제 메모리의 최대 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스가 시작된 이후 해당 프로세스에 할당된 실제 메모리의 최대 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 된 값 (바이트)를 시작한 이후에 프로세스에서 사용한 작업 집합 메모리의 최대 크기를 나타냅니다. 프로세스의 작업 집합은 실제 RAM 메모리의 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터 프로세스 모듈 및 시스템 라이브러리에서 지침을 포함 하 여 프로세스에서 실행 하는 모든 명령이 포함 된 페이지를 포함 합니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **Working Set Peak** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>포커스가 주 창에 있을 때 운영 체제가 연결된 프로세스의 우선 순위를 일시적으로 높일지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>프로세스가 대기 상태에서 빠져나올 때 프로세스의 우선 순위를 동적으로 높여야 하는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 우선 순위 클래스에 동적 우선 순위 열거형 값 중 하나는 프로세스에서 실행 되는 경우 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), 대기 상태에서 빠져 나올 때 스레드의 우선 순위를 일시적으로 향상 됩니다. 이렇게 하면 다른 프로세스에서 현재 스레드의 처리를 중단 합니다. <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 설정은 모든 기존 스레드 및 프로세스에서 만든 모든 스레드에 적용 합니다. 일반 동작을 복원 하려면 설정 합니다 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 속성을 `false`입니다.  
  
> [!NOTE]
>  우선 순위를 너무를 승격 합니다. 필수 운영 체제 및 네트워크 기능을 다른 운영 체제 태스크를 사용 하 여 문제를 일으키는 리소스를 비울 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 프로세스 리소스에서 우선순위 높임 정보를 검색할 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.  
  
또는 
프로세스 식별자 또는 프로세스 핸들이 0입니다. (프로세스가 시작되지 않았습니다.)</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 대한 전체 우선 순위 범주를 가져오거나 설정합니다.</summary>
        <value>연결된 프로세스에 대한 우선 순위 범주입니다. 이를 통해 해당 프로세스의 <see cref="P:System.Diagnostics.Process.BasePriority" />를 계산할 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스 우선 순위 클래스는 스레드 우선 순위 수준의 범위를 포함합니다. 스레드 우선 순위가 서로 다른 프로세스에서 실행 중인 프로세스의 우선 순위 클래스를 기준으로 실행 합니다. Win32는 클래스 별로 7 기본 우선 순위 수준을 사용 하 여 네 가지 우선 순위 클래스를 사용합니다. 이러한 프로세스 우선 순위 클래스에서 캡처되는 <xref:System.Diagnostics.ProcessPriorityClass> 열거형을 사용 하면 프로세스 우선 순위 설정 <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, 또는 <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. 시간을 기준으로 프로세스를 프로세서에 대 한 액세스에 대 한 다른 미리 설정 해야 하는 경우 운영 체제에서 경과 된 또는 기타 상승이, 기본 우선 순위 수준을 변경할 수 있습니다. 또한 설정할 수 있습니다는 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> 를 일시적으로 대기 상태에서 수행 된 스레드의 우선 순위 수준을 향상 합니다. 프로세스가 대기 상태를 반환할 때 우선 순위를 다시 설정 됩니다.  
  
 <xref:System.Diagnostics.Process.BasePriority%2A> 속성을 사용 하면 프로세스에 할당 된 우선 순위를 볼 수 있습니다. 그러나 읽기 전용 이므로 사용할 수 없습니다는 <xref:System.Diagnostics.Process.BasePriority%2A> 프로세스의 우선 순위를 설정 하는 속성입니다. 우선 순위를 변경 하려면 사용 된 <xref:System.Diagnostics.Process.PriorityClass%2A> 속성 프로세스에 대 한 전체 우선 순위 범주를 가져오거나 설정 합니다.  
  
 시스템 모니터를 사용 하 여 우선 순위 클래스를 볼 수 없습니다. 다음 표에서 간의 관계를 보여 줍니다.는 <xref:System.Diagnostics.Process.BasePriority%2A> 고 <xref:System.Diagnostics.Process.PriorityClass%2A> 값입니다.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">프로세스 우선 순위 정보를 연결된 프로세스 리소스에서 설정하거나 검색할 수 없습니다.  
  
또는 
프로세스 식별자 또는 프로세스 핸들이 0입니다. (프로세스가 시작되지 않았습니다.)</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 또는 Windows Me(Millennium Edition)를 사용하는 경우 <see cref="P:System.Diagnostics.Process.PriorityClass" />를 <see langword="AboveNormal" /> 또는 <see langword="BelowNormal" />로 설정했습니다. 이러한 플랫폼에서는 우선 순위 클래스에 대한 이러한 값을 지원하지 않습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 열거형에 정의된 유효한 값이 사용되지 않으므로 우선 순위 클래스를 설정할 수 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 전용 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스에서 할당하여 다른 프로세스에서는 공유할 수 없는 바이트 수입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 전용 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스에 할당되어 다른 프로세스와는 공유할 수 없는 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 된 값 (바이트)를 다른 프로세스와 공유할 수 없는 프로세스에 의해 사용 되는 메모리의 현재 크기를 나타냅니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **Private Bytes** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 프로세스의 권한 있는 프로세서 시간을 가져옵니다.</summary>
        <value>프로세스가 운영 체제 코어 내부에서 코드를 실행하는 데 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스의 이름을 가져옵니다.</summary>
        <value>사용자가 프로세스를 식별할 수 있도록 시스템에서 사용하는 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A> 속성, 예: Outlook.exe 확장명 또는 경로 포함 하지 않는 실행 파일 이름을 포함 합니다. 가져오기 및 동일한 실행 파일을 사용 하 여 연결 된 모든 프로세스를 조작 하기 위한 것이 유용 합니다.  
  
> [!NOTE]
>  온 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 운영 체제는 <xref:System.Diagnostics.Process.ProcessName%2A> 프로세스 모듈 정보를 가져올 수 없으면 15 자로 속성 잘릴 수 있습니다.  
  
 호출할 수 있습니다 <xref:System.Diagnostics.Process.GetProcessesByName%2A>, 지정된 된 컴퓨터에서 실행 중인 모든 인스턴스를 포함 하는 배열을 검색 하는 실행 파일 이름을 전달 합니다. 실행 파일의 모든 실행 중인 인스턴스를 종료 하려면 예를 들어이 배열에 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스에 식별자가 없거나 <see cref="T:System.Diagnostics.Process" />와 연결된 프로세스가 없습니다.  
  
또는 
연결된 프로세스가 종료되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <exception cref="T:System.NotSupportedException">이 컴퓨터에서 진행되는 프로세스가 아닙니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 프로세스에 포함된 스레드의 실행을 예약할 수 있는 프로세서를 가져오거나 설정합니다.</summary>
        <value>연결된 프로세스의 스레드가 실행될 수 있는 프로세서를 나타내는 비트 마스크입니다. 기본값은 컴퓨터의 프로세서 수에 따라 다릅니다. 기본값은 2 <sup>n</sup> -1로, 여기서 n은 프로세서의 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 이상 버전에서는 프로세스의 스레드가 프로세서 캐시 다시 로드 하는 각 마이그레이션을 사용 하 여 프로세서에서 마이그레이션할 수 있습니다. 시스템 로드가 프로세서를 특정 스레드에 실행할지 지정 성능을 향상 시킬 수 프로세서 캐시 다시 로드 되는 횟수를 줄여 합니다. 프로세서 및 스레드 간의 연결을 프로세서 선호도 라고 합니다.  
  
 각 프로세서 약간으로 표시 됩니다. 비트 0은 프로세서 1, 1 비트가 프로세서 2, 등입니다. 값: 1 비트를 설정 하는 경우 해당 프로세서가 스레드 할당에 대 한 선택 됩니다. 설정 하는 경우는 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 값을 0으로 운영 체제의 예약 알고리즘 집합 스레드의 선호도 합니다. 경우는 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 값 0이 아닌 값으로 설정 되 면 값은 선택 가능한 프로세서를 지정 하는 비트 마스크로 해석 됩니다.  
  
 다음 표에서 다양 한 <xref:System.Diagnostics.Process.ProcessorAffinity%2A> 는 프로세서가 8 개인 시스템에 대 한 값입니다.  
  
|비트 마스크|이진 값|사용할 수 있는 프로세서|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1과 2|  
|0x0007|00000000 00000111|1, 2 및 3|  
|0x0009|00000000 00001001|1 및 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 및 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 정보를 연결된 프로세스 리소스에서 설정하거나 검색할 수 없습니다.  
  
또는 
프로세스 식별자 또는 프로세스 핸들이 0입니다. (프로세스가 시작되지 않았습니다.)</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스를 사용할 수 없습니다.  
  
또는 
프로세스가 종료되었습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>프로세스 구성 요소 내에 캐시되어 있는 연결된 프로세스 정보를 모두 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 후 <xref:System.Diagnostics.Process.Refresh%2A> 라고, 첫 번째 요청은 각 속성에 대 한 내용은 하면 연결된 된 프로세스에서 새 값을 가져올 프로세스 구성 요소에 대 한 합니다.  
  
 경우는 <xref:System.Diagnostics.Process> 속성 값의 프로세스 리소스를 사용 하 여 연관 된 구성 요소는 <xref:System.Diagnostics.Process> 즉시 연결된 된 프로세스의 상태에 따라 채워집니다. 에 연결된 된 프로세스에 대 한 내용은 이후에 변경 되 면 해당 변경 내용을 반영 되지 않습니다는 <xref:System.Diagnostics.Process> 구성 요소의 값을 캐시 합니다. <xref:System.Diagnostics.Process> 구성 요소는 연결 된 시간에 프로세스 리소스의 스냅숏입니다. 연결된 된 프로세스에 대 한 현재 값을 보려면 호출을 <xref:System.Diagnostics.Process.Refresh%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 10 초 동안 최대 2 초 간격 연결된 된 프로세스의 실제 메모리 사용량을 검색합니다. 이 예제에서는 10 초 경과 되기 전에 프로세스가 종료 여부를 검색 합니다. 이 예제에서는 10 초 후 실행 중인 경우 프로세스를 닫습니다.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스의 사용자 인터페이스가 응답하는지를 나타내는 값을 가져옵니다.</summary>
        <value>연결된 프로세스의 사용자 인터페이스가 시스템에 응답하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 프로세스에 사용자 인터페이스는 <xref:System.Diagnostics.Process.Responding%2A> 프로세스 사용자 입력에 응답 하는지 여부를 확인 하는 사용자 인터페이스를 연결 하는 속성입니다. 인터페이스를 즉시 응답 하지 않으면 합니다 <xref:System.Diagnostics.Process.Responding%2A> 속성이 반환 `false`합니다. 연결된 된 프로세스의 인터페이스에서 응답을 중지 하는지 여부를 확인 하려면이 속성을 사용 합니다.  
  
 프로세스에 없는 경우는 <xref:System.Diagnostics.Process.MainWindowHandle%2A>,이 속성은 반환 `true`합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.Responding" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 프로세스에 대한 기본 핸들을 가져옵니다.</summary>
        <value>이 프로세스에 대한 기본 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들이 호출 하는 구성 요소 프로세스를 시작 하는 경우 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 터미널 서비스 세션 식별자를 가져옵니다.</summary>
        <value>연결된 프로세스의 터미널 서비스 세션 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A> 응용 프로그램이 현재 실행 되는 세션을 식별 하는 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">이 프로세스에 연결된 세션이 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 세션 식별자와 연결된 프로세스가 없습니다.  
  
또는 
연결된 프로세스가 이 컴퓨터에 있지 않습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="P:System.Diagnostics.Process.SessionId" /> 속성은 Windows 98에서 지원되지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 오류 출력을 읽는 데 사용되는 스트림을 가져옵니다.</summary>
        <value>응용 프로그램의 표준 오류 스트림을 읽는 데 사용할 수 있는 <see cref="T:System.IO.StreamReader" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Diagnostics.Process> 해당 텍스트는 일반적으로 콘솔에 표시 됩니다 해당 표준 오류 스트림에 텍스트를 씁니다. 리디렉션하여는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림을 조작 하거나 프로세스의 오류 출력을 표시 하지 않을 수 있습니다. 예를 들어, 텍스트를 필터링 하 고, 다르게 형식을 지정 하 하거나, 콘솔 및 지정 된 로그 파일 출력을 쓸 수 있습니다.  
  
> [!NOTE]
>  사용 하 <xref:System.Diagnostics.Process.StandardError%2A>를 설정 해야 합니다 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 에 `false`를 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> 에 `true`. 읽기이 고, 그렇지는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 예외를 throw 합니다.  
  
 리디렉션된 <xref:System.Diagnostics.Process.StandardError%2A> 동기적 또는 비동기적으로 스트림을 읽을 수 있습니다. 와 같은 메서드와 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 오류 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓸 해당 <xref:System.Diagnostics.Process.StandardError%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반대로 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다. 이 메서드는 지정 된 이벤트 처리기가 스트림 출력 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 동기 읽기 작업에서 읽는 호출자 간의 종속성을 유발 합니다 <xref:System.Diagnostics.Process.StandardError%2A> 스트림과 자식 해당 스트림에 대 한 쓰기를 처리 합니다. 이러한 종속성은 교착 상태가 발생할 수 있습니다. 호출자를 자식 프로세스의 리디렉션된 스트림에서 읽는 경우에 자식에 종속 되어 있습니다. 자식에서 스트림에 쓰려는 또는 스트림의 닫을 때까지 호출자가 읽기 작업에서 대기 합니다. 자식 프로세스 리디렉션된 스트림을 맞게 충분 한 데이터를 쓰면 때에 부모에 종속 됩니다. 자식 프로세스는 부모 전체 스트림에서 읽거나 스트림의 닫을 때까지 다음 쓰기 작업에서 대기 합니다. 교착 상태에는 호출자와 자식 프로세스 작업을 완료 하기 위해 서로 대기 하 고 진행할 수 있습니다 둘 때 발생 합니다. 호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.  
  
 예를 들어 다음 C# 코드에는 리디렉션된 스트림에서 읽고 자식 프로세스가 종료 될 때까지 기다리는 방법을 보여 줍니다.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 코드 예제에서는 호출 하 여 교착 상태를 방지 `p.StandardError.ReadToEnd` 하기 전에 `p.WaitForExit`입니다. 부모 프로세스에서 호출 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 하기 전에 `p.StandardError.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다. 자식 프로세스 전체를 읽을 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 표준 출력 및 표준 오류 스트림을에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다. 예를 들어 다음 C# 코드에서는 두 스트림이 읽기 작업을 수행합니다.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 부모 프로세스에서 호출 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 뒤에 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 닫고 자식 프로세스 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 자식 프로세스 전체를 읽을 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 이러한 종속성 및 잠재적인 해당 교착 상태 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다. 또는 두 개의 스레드를 만들고 각 스트림이 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 한 번 리디렉션된 스트림을 <xref:System.Diagnostics.Process> 열려 비동기 또는 동기 모드에서 모든 이후 읽기 동일한 모드에서 해당 스트림의 작업 이어야 합니다. 예를 들어 따르지 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 에 대 한 호출을 사용 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 `net use` 명령을 사용자와 함께 네트워크 리소스에 매핑할 인수를 제공 합니다. 그런 다음 net 명령 표준 오류 스트림을 읽는 하 고 콘솔에 씁니다.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardError" /> 스트림이 리디렉션에 대해 정의되지 않았습니다. <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />가 <see langword="true" />로 설정되고 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />가 <see langword="false" />로 설정되어 있는지 확인하세요.  
  
\- 또는 - 
<see cref="P:System.Diagnostics.Process.StandardError" /> 스트림이 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />을 사용한 비동기 읽기 작업을 위해 열려 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 입력을 쓰는 데 사용되는 스트림을 가져옵니다.</summary>
        <value>응용 프로그램의 표준 입력 스트림을 쓰는 데 사용할 수 있는 <see cref="T:System.IO.StreamWriter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> 해당 표준 입력된 스트림을 일반적으로 키보드에서 입력된 텍스트를 읽을 수 있습니다. 리디렉션하여는 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 입력을 프로그래밍 방식으로 지정할 수 있습니다. 예를 들어 키보드 입력을 사용 하는 대신 지정 된 파일의 내용에서 텍스트 또는 다른 응용 프로그램에서 출력을 제공할 수 있습니다.  
  
> [!NOTE]
>  사용 하 <xref:System.Diagnostics.Process.StandardInput%2A>를 설정 해야 합니다 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 에 `false`를 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> 에 `true`. 쓸이 고, 그렇지는 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 예외를 throw 합니다.  
  
   
  
## Examples  
 다음 예제에서는 리디렉션하는 방법을 보여 줍니다는 <xref:System.Diagnostics.Process.StandardInput%2A> 프로세스의 스트림입니다. 이 예제에서는 시작을 `sort` 리디렉션된 입력 명령을 합니다. 그런 다음 텍스트에 대 한 라는 메시지를 전달 합니다 `sort` 리디렉션된를 사용 하 여 프로세스 <xref:System.Diagnostics.Process.StandardInput%2A> 스트림 합니다. `sort` 결과가 콘솔에서 사용자에 게 표시 됩니다.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />이 <see langword="false" />로 설정되어 있어서 <see cref="P:System.Diagnostics.Process.StandardInput" /> 스트림이 정의되지 않았습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램의 텍스트 출력을 읽는 데 사용되는 스트림을 가져옵니다.</summary>
        <value>응용 프로그램의 표준 출력 스트림을 읽는 데 사용할 수 있는 <see cref="T:System.IO.StreamReader" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Diagnostics.Process> 해당 텍스트는 일반적으로 콘솔에 표시 됩니다는 표준 스트림에 텍스트를 씁니다. 리디렉션하여는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림을 조작 하거나 프로세스의 출력을 표시 하지 않을 수 있습니다. 예를 들어, 텍스트를 필터링 하 고, 다르게 형식을 지정 하 하거나, 콘솔 및 지정 된 로그 파일 출력을 쓸 수 있습니다.  
  
> [!NOTE]
>  사용 하 <xref:System.Diagnostics.Process.StandardOutput%2A>를 설정 해야 합니다 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> 에 `false`를 설정 해야 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> 에 `true`. 읽기이 고, 그렇지는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 예외를 throw 합니다.  
  
 리디렉션된 <xref:System.Diagnostics.Process.StandardOutput%2A> 동기적 또는 비동기적으로 스트림을 읽을 수 있습니다. 와 같은 메서드와 <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, 및 <xref:System.IO.StreamReader.ReadToEnd%2A> 프로세스의 출력 스트림에서 동기 읽기 작업을 수행 합니다. 이들 동기 읽기 작업이 연결 될 때까지 완료 되지 않고 <xref:System.Diagnostics.Process> 쓸 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트리밍하거나 스트림을 닫습니다.  
  
 반대로 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 시작 비동기 읽기 작업에는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 이 메서드는 지정 된 이벤트 처리기가 스트림 출력 하 고 이벤트 처리기에 스트림을 출력 하는 동안 다른 작업을 수행할 수 있는 호출자에 게 즉시 반환 합니다.  
  
 동기 읽기 작업에서 읽는 호출자 간의 종속성을 유발 합니다 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림과 자식 해당 스트림에 대 한 쓰기를 처리 합니다. 이러한 종속성은 교착 상태가 발생할 수 있습니다. 호출자를 자식 프로세스의 리디렉션된 스트림에서 읽는 경우에 자식에 종속 되어 있습니다. 자식에서 스트림에 쓰려는 또는 스트림의 닫을 때까지 호출자가 읽기 작업에서 대기 합니다. 자식 프로세스 리디렉션된 스트림을 맞게 충분 한 데이터를 쓰면 때에 부모에 종속 됩니다. 자식 프로세스는 부모 전체 스트림에서 읽거나 스트림의 닫을 때까지 다음 쓰기 작업에서 대기 합니다. 교착 상태에는 호출자와 자식 프로세스 작업을 완료 하기 위해 서로 대기 하 고 진행할 수 있습니다 둘 때 발생 합니다. 호출자와 자식 프로세스 간의 종속성을 평가 하 여 교착 상태를 방지할 수 있습니다.  
  
 예를 들어 다음 C# 코드에는 리디렉션된 스트림에서 읽고 자식 프로세스가 종료 될 때까지 기다리는 방법을 보여 줍니다.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 코드 예제에서는 호출 하 여 교착 상태를 방지 `p.StandardOutput.ReadToEnd` 하기 전에 `p.WaitForExit`입니다. 부모 프로세스에서 호출 하는 경우 교착 상태가 발생할 수 있습니다 `p.WaitForExit` 하기 전에 `p.StandardOutput.ReadToEnd` 자식 프로세스 리디렉션된 스트림에 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 종료 하는 자식 프로세스 무기한 대기 합니다. 자식 프로세스 전체를 읽을 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다.  
  
 표준 출력 및 표준 오류 스트림을에서 모든 텍스트를 읽을 때에 유사한 문제가 있습니다. 예를 들어 다음 C# 코드에서는 두 스트림이 읽기 작업을 수행합니다.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 비동기 읽기 작업에서 수행 하 여 교착 상태를 방지 하는 코드 예제는 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 부모 프로세스에서 호출 하는 경우 교착 상태가 발생 `p.StandardOutput.ReadToEnd` 뒤에 `p.StandardError.ReadToEnd` 자식 프로세스 오류 스트림을 맞게 충분 한 텍스트를 씁니다. 부모 프로세스를 닫고 자식 프로세스 무기한 대기 해당 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 합니다. 자식 프로세스 전체를 읽을 부모 무기한 대기 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
 이러한 종속성 및 잠재적인 해당 교착 상태 방지 하기 위해 비동기 읽기 작업을 사용할 수 있습니다. 또는 두 개의 스레드를 만들고 각 스트림이 별도 스레드에서 출력을 읽는 하 여 교착 상태를 방지할 수 있습니다.  
  
> [!NOTE]
>  리디렉션된 스트림에서 동기 및 비동기 읽기 작업을 혼합할 수 없습니다. 한 번 리디렉션된 스트림을 <xref:System.Diagnostics.Process> 열려 비동기 또는 동기 모드에서 모든 이후 읽기 동일한 모드에서 해당 스트림의 작업 이어야 합니다. 예를 들어 따르지 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 에 대 한 호출을 사용 하 여 <xref:System.IO.StreamReader.ReadLine%2A> 에 <xref:System.Diagnostics.Process.StandardOutput%2A> 스트림 또는 그 반대로 합니다. 그러나 서로 다른 모드에 두 개의 스트림을 읽을 수 있습니다. 예를 들어, 호출할 수 있습니다 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 호출 <xref:System.IO.StreamReader.ReadLine%2A> 에 대 한는 <xref:System.Diagnostics.Process.StandardError%2A> 스트림 합니다.  
  
   
  
## Examples  
 다음 예제에서는 ipconfig.exe 명령을 실행 하 고 예제의 콘솔 창에 해당 표준 출력을 리디렉션합니다.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림이 리디렉션에 대해 정의되지 않았습니다. <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />가 <see langword="true" />로 설정되고 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />가 <see langword="false" />로 설정되어 있는지 확인하세요.  
  
\- 또는 - 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> 스트림이 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />을 사용한 비동기 읽기 작업을 위해 열려 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>프로세스 리소스를 시작한 후 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="P:System.Diagnostics.Process.StartInfo" /> 구성 요소의 <see cref="T:System.Diagnostics.Process" /> 속성으로 지정된 프로세스 리소스를 시작하거나 다시 사용하여 구성 요소에 연결합니다.</summary>
        <returns>프로세스 리소스가 시작된 경우에는 <see langword="true" />이고 기존 프로세스를 다시 사용한 경우처럼 새 프로세스 리소스가 시작되지 않은 경우에는 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 프로세스 리소스를 시작 하 여 현재 연결를 <xref:System.Diagnostics.Process> 구성 요소입니다. 반환 값 `true` 는 새 프로세스 리소스가 시작 되었다는 것을 나타냅니다. 으로 지정 된 프로세스 리소스를 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 컴퓨터에서 이미 실행 중인, 추가 프로세스 리소스가 시작 되지 않은 합니다. 대신, 실행 중인 프로세스 리소스를 다시 사용 및 `false` 반환 됩니다.  
  
 원래 응용 프로그램 설치 위치 (예를 들어, 웹 주소)를 지정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다. 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
> [!NOTE]
>  Visual Studio의이 오버 로드를 사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 메서드는 끌어 놓고 코드를 삽입 하는 것을 <xref:System.Diagnostics.Process> 디자이너로 구성 요소입니다. 사용 하 여는 `Properties` 창이 확장 합니다 `StartInfo` 범주에 적절 한 값을 쓰고는 `FileName` 속성. 폼의 변경 내용을 나타납니다 `InitializeComponent` 프로시저입니다.  
  
 이 오버 로드 <xref:System.Diagnostics.Process.Start%2A> 아닙니다를 `static` 메서드. 인스턴스에서 호출 해야 합니다 <xref:System.Diagnostics.Process> 클래스입니다. 호출 하기 전에 <xref:System.Diagnostics.Process.Start%2A>를 먼저 지정 해야 <xref:System.Diagnostics.Process.StartInfo%2A> 이 대 한 속성 정보 <xref:System.Diagnostics.Process> 인스턴스 정보를 프로세스 리소스를 시작 하려면 확인에 사용 되기 때문입니다.  
  
 다른 오버 로드 된 <xref:System.Diagnostics.Process.Start%2A> 메서드는 `static` 멤버입니다. 인스턴스를 만들 필요가 없습니다를 <xref:System.Diagnostics.Process> 메서드의 오버 로드를 호출 하기 전에 구성 요소입니다. 대신, 호출할 수 있습니다 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 클래스 자체 및 새 <xref:System.Diagnostics.Process> 프로세스를 시작 하는 경우 구성 요소가 만들어집니다. 또는 `null` 프로세스를 다시 사용 된 경우 반환 됩니다. 프로세스 리소스를 자동으로 새 연결 <xref:System.Diagnostics.Process> 에서 반환 되는 구성 요소는 <xref:System.Diagnostics.Process.Start%2A> 메서드.  
  
 합니다 <xref:System.Diagnostics.Process.StartInfo%2A> 의 기능을 복제 하려면 멤버를 사용할 수 있습니다 합니다 `Run` 대화 상자는 Windows의 `Start` 메뉴. 명령줄에 입력할 수 있는 모든 항목 적절 한 값을 설정 하 여 시작할 수 있습니다는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성입니다. 유일한 <xref:System.Diagnostics.Process.StartInfo%2A> 설정 해야 하는 속성은는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 실행 파일 일 필요가 없습니다. 확장 시스템에 설치 된 응용 프로그램과 연결 된 모든 파일 형식의 수 있습니다. 예를 들어를 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성.doc 파일, Microsoft Word와 같은 워드 프로세서 도구를 사용 하 여 연결한 경우.doc 확장명을 가질 수 있습니다 또는 메모장과 같은 편집기를 사용 하 여 텍스트 파일을 연결한 경우.txt 확장명을 가질 수 있습니다.  
  
 명령줄에서 특정 형식의 파일에 대해 수행할 작업을 지정할 수 있습니다. 예를 들어, 문서 인쇄 하거나 텍스트 파일을 편집할 수 있습니다. 사용 하 여 이러한 동작을 지정 합니다 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성. 다른 형식의 파일을 지정할 수에서 파일을 시작할 때 명령줄 인수를 `Run` 대화 상자. 예를 들어, 전달할 수 있습니다 URL을 인수로 브라우저를 지정 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>합니다. 이러한 인수에 지정할 수는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성의 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 멤버입니다.  
  
 경로 변수를 선언한 따옴표를 사용 하 여 시스템의 경우 정규화 해야 해당 경로 위치에 있는 프로세스를 시작 하는 경우. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` path에 없는 따옴표를 사용 하 여 추가한: `path = %path%;"c:\mypath"`에서 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때.  
  
> [!NOTE]
>  ASP.NET 웹 페이지와 서버 컨트롤 코드는 웹 서버의 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 제한 된 권한으로 웹 서버에서 ASP.NET 웹 페이지 또는 서버 컨트롤에서 메서드를 새 프로세스를 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으며 사용자 데스크톱에 액세스할 수 없습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 닫아야 해야 하는 프로세스를 시작 하려면 또는 시스템 리소스가 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다 해당 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.  
  
 관리 되는 스레드의 아파트 상태에 대 한 정보는 여기 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 는 `true` 프로세스 구성 요소에 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램의 스레딩 모델을 설정 했는지 확인 하십시오 `[STAThread]` 에 `main()` 메서드. 관리 되는 스레드 수이 고, 그렇지는 `unknown` 상태 또는 합니다 `MTA` 는 후자와 충돌 하는 상태로 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 `true`합니다. 아파트 상태가 되지 않음이 필요한 방법도 `unknown`합니다. 기본적으로 상태를 설정 하지 않으면 명시적으로, 응용 프로그램에서 이러한 메서드를 발견 하는 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 스레드를 관리 하는 운영 체제 셸에서 경우 throw 되는 예외를 발생 합니다.  
  
   
  
## Examples  
 다음 예에서는 인스턴스의 <xref:System.Diagnostics.Process> 클래스는 프로세스를 시작 합니다.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.Process" /> 구성 요소의 <see cref="P:System.Diagnostics.Process.StartInfo" />에 파일 이름이 지정되지 않았습니다.
또는 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 또는 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />가 <see langword="true" />인 동안 <see cref="P:System.Diagnostics.Process.StartInfo" /> 속성의 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 멤버는 <see langword="true" />입니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 파일을 여는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">프로세스 개체가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">메서드는 Nano Server와 같은 셸 지원 없이 운영 체제에서 지원되지 않습니다(.NET Core에만 해당).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">파일 이름 및 모든 명령줄 인수를 포함하여 프로세스를 시작하는 데 사용되는 정보가 들어 있는 <see cref="T:System.Diagnostics.ProcessStartInfo" />입니다.</param>
        <summary>시작할 프로세스의 파일 이름 같은 프로세스 시작 정보가 포함된 매개 변수에 의해 지정된 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</summary>
        <returns>프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다. 같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다. 뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다. 이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 프로세스 리소스를 지정 하 여 시작을 <xref:System.Diagnostics.ProcessStartInfo> 인스턴스. 오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.  
  
> [!NOTE]
>  실행 파일 시작 주소의 URL 인 경우에 프로세스가 시작 되지 않습니다 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하면 첫 번째를 만들지 않고 새 프로세스를 시작할 <xref:System.Diagnostics.Process> 인스턴스. 이 오버 로드를 사용 하는 <xref:System.Diagnostics.ProcessStartInfo> 매개 변수는 명시적 단계 새 하지 않아도 됩니다 <xref:System.Diagnostics.Process> 인스턴스를 설정 해당 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 및 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 사용 하는 <xref:System.Diagnostics.ProcessStartInfo> 매개 변수를 사용 하면 호출 인스턴스 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하는 호출에 전달 될 항목을 가장 높은 제어를 사용 하 여 합니다. 새로 만들 필요 없는 파일 이름 또는 파일 이름 및 인수를 전달 해야 할 경우 <xref:System.Diagnostics.ProcessStartInfo> 옵션은 인스턴스. 유일한 <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> 설정 해야 하는 속성은는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다. <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 실행 파일을 나타낼 필요가 없습니다. 확장 시스템에 설치 된 응용 프로그램과 연결 된 모든 파일 형식의 수 있습니다. 예를 들어를 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성.doc 파일, Microsoft Word와 같은 워드 프로세서 도구를 사용 하 여 연결한 경우.doc 확장명을 가질 수 있습니다 또는 메모장과 같은 편집기를 사용 하 여 텍스트 파일을 연결한 경우.txt 확장명을 가질 수 있습니다.  
  
 원래 응용 프로그램 설치 위치 (예를 들어, 웹 주소)를 지정 하 여 ClickOnce 응용 프로그램을 시작할 수 있습니다. 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
 경우는 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 의 속성을 <xref:System.Diagnostics.Process.StartInfo%2A> 인스턴스에 설정 된 관리 되지 않는 `CreateProcessWithLogonW` 함수가 호출 됩니다는 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> 속성 값이 `true` 또는 합니다 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> 속성 값이 <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>합니다. 경우는 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> 속성은 `null`의 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 속성은 UPN 형식 이어야 *사용자*@*DNS_domain_name*합니다.   
  
 다른 오버 로드를 오버 로드와 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 아닙니다는 `static` 멤버입니다. 이미 만든 경우 오버 로드를 사용 하 여는 <xref:System.Diagnostics.Process> 인스턴스를 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스. 중 하나를 사용 합니다 `static` 새를 만들려고 할 때 오버 로드 <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다. 이 오버 로드와 매개 변수가 없는 오버 로드를 사용 하 여 프로세스 리소스에 대 한 시작 정보를 지정할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo> 인스턴스.  
  
 경로 변수를 선언한 따옴표를 사용 하 여 시스템의 경우 정규화 해야 해당 경로 위치에 있는 프로세스를 시작 하는 경우. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` path에 없는 따옴표를 사용 하 여 추가한: `path = %path%;"c:\mypath"`에서 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때.  
  
> [!NOTE]
>  ASP.NET 웹 페이지와 서버 컨트롤 코드는 웹 서버의 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 제한 된 권한으로 웹 서버에서 ASP.NET 웹 페이지 또는 서버 컨트롤에서 메서드를 새 프로세스를 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으며 사용자 데스크톱에 액세스할 수 없습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 닫아야 해야 하는 프로세스를 시작 하려면 또는 시스템 리소스가 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다 해당 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.  
  
 관리 되는 스레드의 아파트 상태에 대 한 정보는 여기 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 됩니다 `true` 에 `startInfo` 매개 변수를 특성을 설정 하 여 응용 프로그램의 스레딩 모델을 설정 했는지 확인 `[STAThread]` 에 `main()` 메서드. 관리 되는 스레드 수이 고, 그렇지는 `unknown` 상태 또는 합니다 `MTA` 는 후자와 충돌 하는 상태로 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 `true`합니다. 아파트 상태가 되지 않음이 필요한 방법도 `unknown`합니다. 기본적으로 상태를 설정 하지 않으면 명시적으로, 응용 프로그램에서 이러한 메서드를 발견 하는 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 스레드를 관리 하는 운영 체제 셸에서 경우 throw 되는 예외를 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 먼저 Internet Explorer의 인스턴스를 생성 하 고 브라우저에서 즐겨찾기 폴더의 내용을 표시 합니다. 그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지나 사이트를 표시 합니다. 마지막으로 특정 사이트를 탐색 하는 동안 최소화 되 고 창을 사용 하 여 Internet Explorer를 시작 합니다.  
  
 이 메서드의 다른 사용의 다른 예의 각 속성은 참조 된 <xref:System.Diagnostics.ProcessStartInfo> 클래스입니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 속성에 파일 이름이 지정되지 않았습니다.  
  
또는 
<paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성이 <see langword="true" /> 및 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />이고, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 또는 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 속성 또한 <see langword="true" />입니다.  
  
또는 
<paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 속성이 <see langword="true" />이고 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 속성이 <see langword="null" /> 또는 비어 있거나 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 속성이 <see langword="null" />이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startInfo" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ObjectDisposedException">프로세스 개체가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="startInfo" /> 매개 변수의 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 속성에 지정된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 파일을 열 때 오류가 발생합니다.  
  
또는 
인수의 길이와 프로세스에 대한 전체 경로 길이를 합하면 2080을 초과합니다. 이 예외와 관련된 오류 메시지는 다음 중 하나일 수 있습니다. "시스템 호출에 전달된 데이터 영역이 너무 작습니다." 또는 “액세스가 거부되었습니다.”</exception>
        <exception cref="T:System.PlatformNotSupportedException">메서드는 Nano Server와 같은 셸 지원 없이 운영 체제에서 지원되지 않습니다(.NET Core에만 해당).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">프로세스에서 실행될 문서 또는 응용 프로그램 파일의 이름입니다.</param>
        <summary>문서 또는 응용 프로그램 파일 이름을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</summary>
        <returns>프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다. 같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다. 뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다. 이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 해당 파일 이름을 지정 하 여 프로세스 리소스를 시작 합니다. 오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.  
  
> [!NOTE]
>  실행 파일 시작 주소의 URL 인 경우에 프로세스가 시작 되지 않습니다 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하면 첫 번째를 만들지 않고 새 프로세스를 시작할 <xref:System.Diagnostics.Process> 인스턴스. 오버 로드 하는 대신 새는 명시적 단계 <xref:System.Diagnostics.Process> 인스턴스를 설정 합니다 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 설정 하 여 ClickOnce 응용 프로그램을 시작할 수는 `fileName` 매개 변수는 원래 응용 프로그램을 설치한 위치 (예를 들어, 웹 주소). 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
 정보를 입력 하는 방법과 비슷합니다 해당 파일 이름을 지정 하는 프로세스를 시작 합니다 `Run` 대화 상자는 Windows의 `Start` 메뉴. 따라서 파일 이름을 실행 파일을 나타낼 필요가 없습니다. 확장에 연결 된 시스템에 설치 된 응용 프로그램 파일 형식의 수 있습니다. 예를 들어.doc 파일, Microsoft Word와 같은 워드 프로세서 도구를 사용 하 여 연결한 경우.doc 있을 수 있습니다 또는 메모장과 같은 편집기를 사용 하 여 텍스트 파일을 연결한 경우 파일 이름 확장명이.txt이 있습니다. 마찬가지로을 동일한 방식으로 `Run` .exe 확장명은 선택 사항, 대화 상자에는.exe 확장명 없이 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수 있습니다는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다.  
  
 이 오버 로드는 프로세스에 대 한 명령줄 인수를 허용 하지 않습니다. 프로세스에 대 한 하나 이상의 명령줄 인수를 지정 해야 할 경우 사용 합니다 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> 또는 <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> 오버 로드 합니다.  
  
 다른 오버 로드를 오버 로드와 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 아닙니다는 `static` 멤버입니다. 이미 만든 경우 오버 로드를 사용 하 여는 <xref:System.Diagnostics.Process> 인스턴스를 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스. 중 하나를 사용 합니다 `static` 새를 만들려고 할 때 오버 로드 <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다. 이 오버 로드와 매개 변수가 없는 오버 로드를 허용 하려면 프로세스 리소스의 파일 이름을 지정할 수 있습니다.  
  
 경로 변수를 선언한 따옴표를 사용 하 여 시스템의 경우 정규화 해야 해당 경로 위치에 있는 프로세스를 시작 하는 경우. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` path에 없는 따옴표를 사용 하 여 추가한: `path = %path%;"c:\mypath"`에서 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때.  
  
> [!NOTE]
>  ASP.NET 웹 페이지와 서버 컨트롤 코드는 웹 서버의 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 제한 된 권한으로 웹 서버에서 ASP.NET 웹 페이지 또는 서버 컨트롤에서 메서드를 새 프로세스를 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으며 사용자 데스크톱에 액세스할 수 없습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 닫아야 해야 하는 프로세스를 시작 하려면 또는 시스템 리소스가 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다 해당 <xref:System.Diagnostics.Process.HasExited%2A> 속성입니다.  
  
 관리 되는 스레드의 아파트 상태에 대 한 정보는 여기 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 는 `true` 프로세스 구성 요소에 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램의 스레딩 모델을 설정 했는지 확인 하십시오 `[STAThread]` 에 `main()` 메서드. 관리 되는 스레드 수이 고, 그렇지는 `unknown` 상태 또는 합니다 `MTA` 는 후자와 충돌 하는 상태로 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 `true`합니다. 아파트 상태가 되지 않음이 필요한 방법도 `unknown`합니다. 기본적으로 상태를 설정 하지 않으면 명시적으로, 응용 프로그램에서 이러한 메서드를 발견 하는 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 스레드를 관리 하는 운영 체제 셸에서 경우 throw 되는 예외를 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 먼저 Internet Explorer의 인스턴스를 생성 하 고 브라우저에서 즐겨찾기 폴더의 내용을 표시 합니다. 그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지나 사이트를 표시 합니다. 마지막으로 특정 사이트를 탐색 하는 동안 최소화 되 고 창을 사용 하 여 Internet Explorer를 시작 합니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 파일을 열 때 오류가 발생합니다.</exception>
        <exception cref="T:System.ObjectDisposedException">프로세스 개체가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 환경 변수에 따옴표를 포함하는 문자열이 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">프로세스에서 실행될 응용 프로그램 파일 이름입니다.</param>
        <param name="arguments">프로세스를 시작할 때 전달할 명령줄 인수입니다.</param>
        <summary>응용 프로그램 이름 및 명령줄 인수 집합을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</summary>
        <returns>프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다. 같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다. 뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다. 이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 해당 파일 이름 및 명령줄 인수를 지정 하 여 프로세스 리소스를 시작 합니다. 오버 로드를 새 리소스를 연결 <xref:System.Diagnostics.Process> 개체입니다.  
  
> [!NOTE]
>  실행 파일 시작 주소의 URL 인 경우에 프로세스가 시작 되지 않습니다 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하면 첫 번째를 만들지 않고 새 프로세스를 시작할 <xref:System.Diagnostics.Process> 인스턴스. 오버 로드 하는 대신 새는 명시적 단계 <xref:System.Diagnostics.Process> 인스턴스를 설정 합니다 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 및 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> 의 멤버는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성과 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 파일 이름 및 명령줄 인수를 입력 하는 방법과 비슷합니다 파일 이름과 인수를 지정 하 여 프로세스를 시작 합니다 `Run` 대화 상자는 Windows의 `Start` 메뉴. 따라서 파일 이름을 실행 파일을 나타낼 필요가 없습니다. 확장에 연결 된 시스템에 설치 된 응용 프로그램 파일 형식의 수 있습니다. 예를 들어.doc 파일, Microsoft Word와 같은 워드 프로세서 도구를 사용 하 여 연결한 경우.doc 있을 수 있습니다 또는 메모장과 같은 편집기를 사용 하 여 텍스트 파일을 연결한 경우 파일 이름 확장명이.txt이 있습니다. 마찬가지로을 동일한 방식으로 `Run` .exe 확장명은 선택 사항, 대화 상자에는.exe 확장명 없이 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수 있습니다는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다. 경우는 `fileName` 매개 변수는 실행 파일인 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다. 경우는 `fileName` 매개 변수 (.cmd) 명령 파일을 나타냅니다는 `arguments` 매개 변수 중 하나를 포함 해야 합니다는 "`/c`"또는"`/k`" 명령 창 종료 또는 완료 된 후 남아 있는지 여부를 지정 하는 인수입니다.  
  
 다른 오버 로드를 오버 로드와 달리 <xref:System.Diagnostics.Process.Start%2A> 매개 변수가 없는 아닙니다는 `static` 멤버입니다. 이미 만든 경우 오버 로드를 사용 하 여는 <xref:System.Diagnostics.Process> 인스턴스를 지정 된 시작 정보 (파일 이름 포함) 및 기존 연결을 프로세스 리소스를 시작 하려면 <xref:System.Diagnostics.Process> 인스턴스. 중 하나를 사용 합니다 `static` 새를 만들려고 할 때 오버 로드 <xref:System.Diagnostics.Process> 기존 구성 요소에 대 한 프로세스를 시작 하지 않고 구성 요소입니다. 이 오버 로드 및 매개 변수가 없는 오버 로드를 모두 전달할 명령줄 인수를 확인 하 고 시작 프로세스 리소스의 파일 이름을 지정할 수 있습니다.  
  
 경로 변수를 선언한 따옴표를 사용 하 여 시스템의 경우 정규화 해야 해당 경로 위치에 있는 프로세스를 시작 하는 경우. 그렇지 않으면 시스템 경로 찾지 않습니다. 예를 들어 경우 `c:\mypath` path에 없는 따옴표를 사용 하 여 추가한: `path = %path%;"c:\mypath"`에서 모든 프로세스를 정규화 해야 `c:\mypath` 시작할 때.  
  
> [!NOTE]
>  ASP.NET 웹 페이지와 서버 컨트롤 코드는 웹 서버의 ASP.NET 작업자 프로세스의 컨텍스트에서 실행 됩니다.  사용 하는 경우는 <xref:System.Diagnostics.Process.Start%2A> 제한 된 권한으로 웹 서버에서 ASP.NET 웹 페이지 또는 서버 컨트롤에서 메서드를 새 프로세스를 실행 합니다. 프로세스는 클라이언트 브라우저와 동일한 컨텍스트에서 시작 되지 않으며 사용자 데스크톱에 액세스할 수 없습니다.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 닫아야 해야 하는 프로세스를 시작 하려면 또는 시스템 리소스가 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다 해당 <xref:System.Diagnostics.Process.HasExited%2A> 속성...  
  
 관리 되는 스레드의 아파트 상태에 대 한 정보는 여기 필요 합니다. 때 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 는 `true` 프로세스 구성 요소에 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 특성을 설정 하 여 응용 프로그램의 스레딩 모델을 설정 했는지 확인 하십시오 `[STAThread]` 에 `main()` 메서드. 관리 되는 스레드 수이 고, 그렇지는 `unknown` 상태 또는 합니다 `MTA` 는 후자와 충돌 하는 상태로 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 되 `true`합니다. 아파트 상태가 되지 않음이 필요한 방법도 `unknown`합니다. 기본적으로 상태를 설정 하지 않으면 명시적으로, 응용 프로그램에서 이러한 메서드를 발견 하는 경우, `MTA`를 설정한 후에 아파트 상태를 변경할 수 없습니다. 그러나 `MTA` 스레드를 관리 하는 운영 체제 셸에서 경우 throw 되는 예외를 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 먼저 Internet Explorer의 인스턴스를 생성 하 고 브라우저에서 즐겨찾기 폴더의 내용을 표시 합니다. 그런 다음 Internet Explorer의 몇 가지 다른 인스턴스를 시작 하 고 몇 가지 특정 페이지나 사이트를 표시 합니다. 마지막으로 특정 사이트를 탐색 하는 동안 최소화 되 고 창을 사용 하 여 Internet Explorer를 시작 합니다.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="fileName" /> 또는 <paramref name="arguments" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 파일을 열 때 오류가 발생합니다.  
  
또는 
인수의 길이와 프로세스에 대한 전체 경로 길이를 합하면 2080을 초과합니다. 이 예외와 관련된 오류 메시지는 다음 중 하나일 수 있습니다. "시스템 호출에 전달된 데이터 영역이 너무 작습니다." 또는 “액세스가 거부되었습니다.”</exception>
        <exception cref="T:System.ObjectDisposedException">프로세스 개체가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 환경 변수에 따옴표를 포함하는 문자열이 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">프로세스에서 실행될 응용 프로그램 파일 이름입니다.</param>
        <param name="userName">프로세스를 시작할 때 사용할 사용자 이름입니다.</param>
        <param name="password">프로세스를 시작할 때 사용할 암호가 포함된 <see cref="T:System.Security.SecureString" />입니다.</param>
        <param name="domain">프로세스를 시작할 때 사용할 도메인입니다.</param>
        <summary>응용 프로그램 이름, 사용자 이름, 암호 및 도메인을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</summary>
        <returns>프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다. 같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다. 뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다. 이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일 이름, 사용자 이름, 암호 및 도메인을 지정 하 여 새 프로세스와 해당 주 스레드를 만들이 오버 로드를 사용 합니다. 새 프로세스는 다음 지정 된 자격 증명 (사용자, 도메인 및 암호)의 보안 컨텍스트에서 지정된 된 실행 파일을 실행 합니다.  
  
> [!NOTE]
>  실행 파일을 원격 드라이브에 있는 경우에 연결 된 드라이브 문자가 아닌 uniform resource identifier (URI)를 사용 하 여 네트워크 공유를 식별 해야 합니다.  
  
> [!NOTE]
>  실행 파일 시작 주소의 URL 인 경우에 프로세스가 시작 되지 않습니다 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하면 첫 번째를 만들지 않고 새 프로세스를 시작할 <xref:System.Diagnostics.Process> 인스턴스. 오버 로드 하는 대신 새는 명시적 단계 <xref:System.Diagnostics.Process> 인스턴스를 설정 합니다 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 의 속성을 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한 <xref:System.Diagnostics.Process> 인스턴스.  
  
 마찬가지로을 동일한 방식으로 **실행** .exe 확장명은 선택 사항, 대화 상자에는.exe 확장명 없이 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수 있습니다는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다. 경우는 `fileName` 매개 변수는 실행 파일인 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.  
  
> [!NOTE]
>  파일 이름을 실행 파일을 나타내야 합니다 <xref:System.Diagnostics.Process.Start%2A> 오버 로드의 경우 `userName`, `password`, 및 `domain` 매개 변수.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 닫아야 해야 하는 프로세스를 시작 하려면 또는 시스템 리소스가 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다 해당 <xref:System.Diagnostics.Process.HasExited%2A> 속성...  
  
   
  
## Examples  
 다음 코드 예제는 실행 파일을 시작 하려면이 오버 로드의 사용을 보여 줍니다 및 throw 보여 줍니다는 <xref:System.ComponentModel.Win32Exception> 실행 불가능 한 파일과 연결 된 응용 프로그램을 시작 하려고 할 때입니다.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파일 이름을 지정하지 않았습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 파일을 여는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">프로세스 개체가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">메서드는 Linux 또는 macOS에서 지원되지 않습니다(.NET Core에만 해당).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">프로세스에서 실행될 응용 프로그램 파일 이름입니다.</param>
        <param name="arguments">프로세스를 시작할 때 전달할 명령줄 인수입니다.</param>
        <param name="userName">프로세스를 시작할 때 사용할 사용자 이름입니다.</param>
        <param name="password">프로세스를 시작할 때 사용할 암호가 포함된 <see cref="T:System.Security.SecureString" />입니다.</param>
        <param name="domain">프로세스를 시작할 때 사용할 도메인입니다.</param>
        <summary>응용 프로그램 이름, 명령줄 인수 집합, 사용자 이름, 암호 및 도메인을 지정하여 프로세스 리소스를 시작하고 해당 리소스를 새 <see cref="T:System.Diagnostics.Process" /> 구성 요소에 연결합니다.</summary>
        <returns>프로세스 리소스와 연결되거나 시작된 프로세스가 없는 경우 <see langword="null" />에 연결되는 새 <see cref="T:System.Diagnostics.Process" />입니다. 같은 프로세스에서 이미 실행 중인 인스턴스와 함께 시작되는 새 프로세스는 서로 독립적인 관계입니다. 뿐만 아니라 시작 시 <see cref="P:System.Diagnostics.Process.HasExited" /> 속성이 이미 <see langword="true" />로 설정되어 있는 null이 아닌 프로세스가 반환될 수 있습니다. 이 경우 시작된 프로세스가 자체의 기존 인스턴스를 활성화한 후 종료될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일 이름, 명령줄 인수, 사용자 이름, 암호 및 도메인을 지정 하 여 새 프로세스와 해당 주 스레드를 만들이 오버 로드를 사용 합니다. 새 프로세스는 다음 지정 된 자격 증명 (사용자, 도메인 및 암호)의 보안 컨텍스트에서 지정된 된 실행 파일을 실행 합니다.  
  
> [!NOTE]
>  실행 파일을 원격 드라이브에 있는 경우에 연결 된 드라이브 문자가 아닌 uniform resource identifier (URI)를 사용 하 여 네트워크 공유를 식별 해야 합니다.  
  
> [!NOTE]
>  실행 파일 시작 주소의 URL 인 경우에 프로세스가 시작 되지 않습니다 및 `null` 반환 됩니다.  
  
 이 오버 로드를 사용 하면 첫 번째를 만들지 않고 새 프로세스를 시작할 <xref:System.Diagnostics.Process> 인스턴스. 오버 로드 하는 대신 새는 명시적 단계 <xref:System.Diagnostics.Process> 인스턴스를 설정 합니다 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, 및 <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> 의 속성을 <xref:System.Diagnostics.Process.StartInfo%2A> 속성을 호출 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스.  
  
 마찬가지로을 동일한 방식으로 **실행** .exe 확장명은 선택 사항, 대화 상자에는.exe 확장명 없이 실행 파일 이름을 사용할 수는 `fileName` 매개 변수입니다. 예를 들어, 설정할 수 있습니다는 `fileName` "Notepad.exe" 또는 "Notepad" 매개 변수입니다. 경우는 `fileName` 매개 변수는 실행 파일인 나타냅니다는 `arguments` 매개 변수 파일의 텍스트 파일과 같은 동작이 수행 될을 나타낼 수 있습니다 `Notepad.exe myfile.txt`합니다.  
  
> [!NOTE]
>  파일 이름을 실행 파일을 나타내야 합니다 <xref:System.Diagnostics.Process.Start%2A> 오버 로드의 경우 `userName`, `password`, 및 `domain` 매개 변수.  
  
 사용할 때마다 <xref:System.Diagnostics.Process.Start%2A> 닫아야 해야 하는 프로세스를 시작 하려면 또는 시스템 리소스가 손실 될 위험이 있습니다. 사용 하 여 프로세스를 닫습니다 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 또는 <xref:System.Diagnostics.Process.Kill%2A>합니다. 프로세스를 사용 하 여 닫혀 이미 있는지 여부를 확인할 수 있습니다 해당 <xref:System.Diagnostics.Process.HasExited%2A> 속성...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파일 이름을 지정하지 않았습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">연결된 파일을 열 때 오류가 발생합니다.  
  
또는 
인수의 길이와 연결된 파일의 전체 경로 길이를 합하면 2080을 초과합니다. 이 예외와 관련된 오류 메시지는 다음 중 하나일 수 있습니다. "시스템 호출에 전달된 데이터 영역이 너무 작습니다." 또는 “액세스가 거부되었습니다.”</exception>
        <exception cref="T:System.ObjectDisposedException">프로세스 개체가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">메서드는 Linux 또는 macOS에서 지원되지 않습니다(.NET Core에만 해당).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Diagnostics.Process.Start" />의 <see cref="T:System.Diagnostics.Process" /> 메서드에 전달할 속성을 가져오거나 설정합니다.</summary>
        <value>프로세스를 시작하는 데 사용된 데이터를 나타내는 <see cref="T:System.Diagnostics.ProcessStartInfo" />입니다. 이러한 인수에는 프로세스를 시작하는 데 사용된 실행 파일이나 문서 이름이 포함됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 프로세스를 시작 하는 데 매개 변수 집합을 나타냅니다. 때 <xref:System.Diagnostics.Process.Start%2A> 가 호출 된 <xref:System.Diagnostics.Process.StartInfo%2A> 시작 하는 프로세스를 지정 하는 데 사용 됩니다. 만 필요한 <xref:System.Diagnostics.Process.StartInfo%2A> 설정 멤버는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성입니다. 지정 하 여 프로세스를 시작 합니다 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성에 정보를 입력 비슷합니다는 **실행** 는 Windows 대화 상자 **시작** 메뉴. 따라서는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성 실행 파일을 나타낼 필요가 없습니다. 확장에 연결 된 시스템에 설치 된 응용 프로그램 파일 형식의 수 있습니다. 예를 들어를 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 메모장과 같은 편집기를 사용 하 여 텍스트 파일을 연결한 또는.doc 파일, Microsoft Word와 같은 워드 프로세서 도구를 사용 하 여 연결한 경우.doc 있을 수 있습니다 하는 경우.txt 확장명을 가질 수 있습니다. 마찬가지로을 동일한 방식으로 **실행** .exe 확장명은 선택 사항, 대화 상자에는.exe 확장명 없이 실행 파일 이름을 사용할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 멤버입니다. 예를 들어, 설정할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성을 "Notepad.exe" 또는 "Notepad"입니다.  
  
 설정 하 여 ClickOnce 응용 프로그램을 시작할 수는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성을 원래 응용 프로그램 설치 위치 (예를 들어, 웹 주소). 하드 드라이브에 설치 된 위치를 지정 하 여 ClickOnce 응용 프로그램을 시작 하지 않습니다.  
  
 파일 이름을 실행 불가능 한 파일,.doc 파일 등을 포함 하는 경우에 파일에 수행할 동작을 지정 하는 동사를 포함할 수 있습니다. 예를 들어, 설정할 수 있습니다는 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> .doc 확장명으로 끝나는 파일에 대 한 "print"입니다. 파일 이름을 지정 합니다 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성에 대 한 값을 수동으로 입력할 경우 확장명을 가질 필요가 없습니다를 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> 속성. 그러나 사용 하는 경우는 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> 동사를 결정 하는 속성을 사용할 수 있는 확장명을 포함 해야 합니다.  
  
 지정 된 매개 변수를 변경할 수 있습니다 합니다 <xref:System.Diagnostics.Process.StartInfo%2A> 호출 하는 시간까지 속성은 <xref:System.Diagnostics.Process.Start%2A> 프로세스에는 메서드. 프로세스를 시작 하면 변경 된 <xref:System.Diagnostics.Process.StartInfo%2A> 값에 영향을 하거나 연결된 된 프로세스를 다시 시작 하지 않습니다. 호출 하는 경우는 <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> 메서드를 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> 속성이 설정, 관리 되지 않는 `CreateProcessWithLogonW` 함수가 호출 될 합니다 <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> 속성 값이 `true` 또는 합니다 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> 속성 값이 <xref:System.Diagnostics.ProcessWindowStyle.Hidden>합니다.  
  
 사용 하지 않은 경우는 <xref:System.Diagnostics.Process.Start%2A> 프로세스를 시작 하는 메서드는 <xref:System.Diagnostics.Process.StartInfo%2A> 속성 프로세스를 시작 하는 데 사용 하는 매개 변수를 반영 하지 않습니다. 예를 들어, 사용 하는 경우 <xref:System.Diagnostics.Process.GetProcesses%2A> 컴퓨터에서 실행 중인 프로세스의 배열을 가져오려면 합니다 <xref:System.Diagnostics.Process.StartInfo%2A> 각각의 속성 <xref:System.Diagnostics.Process> 원래 파일 이름 또는 프로세스를 시작 하는 데 사용 되는 인수를 포함 하지 않습니다.  
  
 프로세스가 시작 되 면 파일 이름은 파일 (읽기 전용)을 채우는 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다. 프로세스가 시작 된 후 프로세스와 관련 된 실행 파일을 검색, 사용 하려는 경우는 <xref:System.Diagnostics.Process.MainModule%2A> 속성입니다. 실행 파일을 설정 하려는 경우는 <xref:System.Diagnostics.Process> 는 연결된 된 프로세스가 시작 되지 않은 인스턴스를 사용 합니다 <xref:System.Diagnostics.Process.StartInfo%2A> 속성의 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 멤버입니다. 때문에의 멤버를 <xref:System.Diagnostics.Process.StartInfo%2A> 속성에 전달 되는 인수가 합니다 <xref:System.Diagnostics.Process.Start%2A> 변경 프로세스의 메서드는 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> 속성이 연결된 된 프로세스가 시작 된 후 다시 설정 되지 것입니다는 <xref:System.Diagnostics.Process.MainModule%2A> 속성. 이러한 속성은 연결된 된 프로세스 초기화에 사용 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Diagnostics.Process.StartInfo%2A> 실행할 파일을 사용 하 여 작업을 수행 하 고 사용자 인터페이스를 표시 해야 하는지 여부입니다. 추가 예제를 보려면 참조 페이지의 속성에 대 한 참조를 <xref:System.Diagnostics.ProcessStartInfo> 클래스입니다.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.Process.StartInfo" />를 지정하는 값이 <see langword="null" />입니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스가 시작된 시간을 가져옵니다.</summary>
        <value>해당 프로세스가 시작된 시간을 나타내는 개체입니다. 프로세스가 실행되고 있지 않으면 예외가 throw됩니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.StartTime" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">프로세스가 종료되었습니다.  
  
또는 
프로세스가 시작되지 않았습니다.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Windows 함수 호출 시 오류가 발생 했습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스 종료 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 개체를 가져오거나 설정합니다.</summary>
        <value>프로세스에서 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트의 결과로 발생하는 이벤트 처리기 호출을 마샬링하는 데 사용되는 <see cref="T:System.ComponentModel.ISynchronizeInvoke" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> 됩니다 `null`를 처리 하는 메서드는 <xref:System.Diagnostics.Process.Exited> 이벤트 시스템 스레드 풀의 스레드에서 호출 됩니다. 시스템 스레드 풀에 대 한 자세한 내용은 참조 하세요. <xref:System.Threading.ThreadPool>합니다.  
  
 경우는 <xref:System.Diagnostics.Process.Exited> 이벤트와 같은 visual Windows Forms 구성 요소에 의해 처리 됩니다는 <xref:System.Windows.Forms.Button>, 시스템 스레드 풀을 통해 구성 요소를 액세스 작동 하지 않을 수 있습니다 또는 예외가 발생할 수 있습니다. 설정 하 여이 문제를 방지 <xref:System.Diagnostics.Process.SynchronizingObject%2A> Windows Forms 구성 요소에 메서드가 처리는 <xref:System.Diagnostics.Process.Exited> 구성 요소를 만든 동일한 스레드에서 호출 되는 이벤트입니다.  
  
 경우는 <xref:System.Diagnostics.Process> 내에서 사용 되 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Windows Forms 디자이너에서 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 포함 된 컨트롤에 자동으로 설정 됩니다는 <xref:System.Diagnostics.Process>합니다. 예를 들어, 배치 하는 경우는 <xref:System.Diagnostics.Process> 에 대 한 디자이너에서 `Form1` (에서 상속 하는 <xref:System.Windows.Forms.Form>)는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성 <xref:System.Diagnostics.Process> 인스턴스의로 설정 되어 `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 일반적으로 이러한 구성 요소는 특정 스레드에 바인딩되어 있기 때문에 구성 요소 컨트롤 또는 폼에 배치 된 경우이 속성이 설정 됩니다.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에서 실행 중인 스레드를 가져오거나 설정합니다.</summary>
        <value>연결된 프로세스에서 현재 실행 중인 운영 체제 스레드를 나타내는 <see cref="T:System.Diagnostics.ProcessThread" /> 형식의 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드는 프로세스에서 코드를 실행합니다. 각 프로세스는 단일 스레드를 해당 주 스레드를 사용 하 여 시작 됩니다. 모든 스레드는 추가 스레드를 만들 수 있습니다. 프로세스 내에서 스레드 프로세스의 주소 공간을 공유합니다.  
  
 사용 하 여 <xref:System.Diagnostics.ProcessThread> 현재 프로세스와 관련 된 모든 스레드를 가져오려고 합니다. 주 스레드가 반드시 배열에서 인덱스 0에 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">프로세스에 <see cref="P:System.Diagnostics.Process.Id" />가 없거나 <see cref="T:System.Diagnostics.Process" /> 인스턴스와 연결된 프로세스가 없습니다.  
  
또는 
연결된 프로세스가 종료되었습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)입니다. Windows 98 및 Windows Me에서 이 속성에 액세스하려면 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />를 <see langword="false" />로 설정합니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가능한 경우 부모 구성 요소 형식을 결합하여 프로세스 이름을 문자열로 서식화합니다.</summary>
        <returns>기본 구성 요소의 <see cref="P:System.Diagnostics.Process.ProcessName" /> 반환 값과 결합된 <see cref="M:System.Object.ToString" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" />은 Windows 98에서 지원되지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 프로세스의 총 프로세서 시간을 가져옵니다.</summary>
        <value>연결된 프로세스에서 CPU를 사용해 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다. 이 값은 <see cref="P:System.Diagnostics.Process.UserProcessorTime" />과 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />의 합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 프로세스의 사용자 프로세서 시간을 가져옵니다.</summary>
        <value>연결된 프로세스가 운영 체제 코어 내부가 아닌 프로세스의 응용 프로그램 부분 내부에서 코드를 실행하는 데 소비한 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">원격 컴퓨터에서 실행 중인 프로세스의 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 속성에 액세스하려고 합니다. 이 속성은 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>프로세스의 가상 메모리 크기(바이트)를 가져옵니다.</summary>
        <value>연결된 프로세스에서 요청한 가상 메모리의 양(바이트)입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 가상 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스에 할당된 가상 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 된 값 (바이트)에서 프로세스에 의해 사용 된 가상 메모리의 현재 크기를 나타냅니다. 운영 체제는 실제 메모리 또는 디스크에 있는 가상 메모리 페이징 파일에 저장 된 페이지를 로드 하거나 페이지 각 프로세스에 대 한 가상 주소 공간을 매핑합니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **가상 바이트** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결된 프로세스가 종료될 때까지 대기하는 시간을 설정하고, 시간이 경과하거나 프로세스가 종료될 때까지 현재 실행의 스레드를 차단합니다. 현재 스레드가 차단되는 것을 방지하려면 <see cref="E:System.Diagnostics.Process.Exited" /> 이벤트를 사용합니다.  
  
코드 예제는 <see cref="P:System.Diagnostics.Process.StandardError" /> 및 <see cref="P:System.Diagnostics.Process.ExitCode" /> 속성 참조 페이지를 참조하세요.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>연결된 프로세스가 종료될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 무기한 대기하게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 현재 스레드에 연결된 된 프로세스가 종료 될 때까지 대기할 수 있습니다.  프로세스에 대 한 다른 모든 메서드는 호출 된 후 호출 되어야 합니다. 현재 스레드가 차단되는 것을 방지하려면 <xref:System.Diagnostics.Process.Exited> 이벤트를 사용합니다.  
  
 이 메서드는 <xref:System.Diagnostics.Process> 구성 요소를 종료 하려면 프로세스 및 이벤트 처리기에 대 한 시간 수가 무제한 대기 합니다. 이 인해 응답을 중지 하도록 응용 프로그램이 수 있습니다. 예를 들어, 호출 하는 경우 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 사용자 인터페이스가 있는 프로세스에 대 한 연결된 프로세스를 종료 하려면 운영 체제를 요청 하지 처리 될 수 있습니다 하는 프로세스의 메시지 루프에 진입 하지 않도록 작성 되는 경우.  
  
> [!NOTE]
>  에 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 및 이전 버전의 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드에 대 한 대기 <xref:System.Int32.MaxValue> 밀리초 (약 24 일), not 무기한. 또한 이전 버전 기다리지 않고 이벤트 처리기를 끝낼 전체 <xref:System.Int32.MaxValue> 시간에 도달 했습니다.  
  
 이 오버 로드는 모든 처리가 완료 되 면 리디렉션된 표준 출력에 대 한 비동기 이벤트 처리를 포함 하 여 확인 합니다. 호출한 후이 오버 로드를 사용 해야는 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 비동기 이벤트 처리기에 표준 출력 리디렉션된 경우 오버 로드 합니다.  
  
 시스템 프로세스에 대 한 관리 정보를 저장 하 고이 호출한는 구성 요소를 반환 (즉,이 종료 될 때 정상 또는 비정상 종료를 통해 운영 체제별) 연결된 된 프로세스가 종료 되 면 <xref:System.Diagnostics.Process.WaitForExit>합니다. <xref:System.Diagnostics.Process> 구성 요소 정보를 포함 하는 액세스할 수는 <xref:System.Diagnostics.Process.ExitTime%2A>를 사용 하 여는 <xref:System.Diagnostics.Process.Handle%2A> 종료 된 프로세스에.  
  
 연결된 된 프로세스가 종료 되었으므로 <xref:System.Diagnostics.Process.Handle%2A> 구성 요소의 속성은 더 이상 기존 프로세스 리소스를 가리킵니다. 대신, 핸들 프로세스 리소스에 대 한 운영 체제의 정보를 액세스할 때만 사용할 수 있습니다. 시스템에 의해 릴리스되지 않았거나 종료 된 프로세스에 대 한 핸들 인지 <xref:System.Diagnostics.Process> 구성 요소를 유지할 수 있도록를 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 까지 메모리에 대 한 정보를 <xref:System.Diagnostics.Process> 구성 요소에는 특히 한 리소스를 해제 합니다. 이러한 이유로 언제 든 지 호출할 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스를 호출 <xref:System.Diagnostics.Process.Close%2A> 연결 된 프로세스가 종료 시점과 모든 관리 정보가 더 이상 필요 합니다. <xref:System.Diagnostics.Process.Close%2A> 종료 된 프로세스에 할당 된 메모리를 해제 합니다.  
  
   
  
## Examples  
 설명 섹션을 참조 합니다 <xref:System.Diagnostics.Process.StandardError%2A> 속성 참조 페이지입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">대기 설정에 액세스할 수 없습니다.</exception>
        <exception cref="T:System.SystemException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스가 설정되지 않았으며, <see cref="P:System.Diagnostics.Process.Id" /> 속성을 파악할 수 있는 <see cref="P:System.Diagnostics.Process.Handle" />이 없습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.  
  
또는 
원격 컴퓨터에서 실행 중인 프로세스의 <see cref="M:System.Diagnostics.Process.WaitForExit" />를 호출하려고 합니다. 이 메서드는 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">연결된 프로세스가 종료될 때까지 대기하는 시간(밀리초)입니다. 최대값은 사용 가능한 가장 큰 32비트 정수 값이며, 이는 운영 체제에서 사실상 무기한 대기한다는 것을 나타냅니다.</param>
        <summary>연결된 프로세스가 종료되도록 지정한 밀리초 동안 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 대기하게 합니다.</summary>
        <returns>연결된 프로세스가 종료된 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 현재 스레드에 연결된 된 프로세스가 종료 될 때까지 대기할 수 있습니다. 프로세스에 대 한 다른 모든 메서드는 호출 된 후 호출 되어야 합니다. 현재 스레드가 차단되는 것을 방지하려면 <xref:System.Diagnostics.Process.Exited> 이벤트를 사용합니다.  
  
 이 메서드는 <xref:System.Diagnostics.Process> 구성 요소를 종료 하는 프로세스에 대 한 한정 된 기간을 대기 합니다. 연결된 된 프로세스가 종료 요청이 거부 되어 서 간격의 끝에서 종료 되지 않으면 `false` 호출 하는 프로시저로 반환 됩니다. 지정할 수 있습니다 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> 에 대 한 `milliseconds`, 및 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> 와 동일 하 게 동작 합니다 <xref:System.Diagnostics.Process.WaitForExit> 오버 로드 합니다. 반환 하는 경우에 0 (영) 메서드에 전달 합니다 `true` 프로세스가 이미 종료 되어; 경우에이 고, 그렇지 즉시 반환 `false`합니다.  
  
> [!NOTE]
>  에 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 및 이전 버전 경우 `milliseconds` 가-1를 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 오버 로드에 대 한 대기 <xref:System.Int32.MaxValue> 밀리초 (약 24 일), not 무기한 합니다.  
  
 비동기 이벤트 처리기에 표준 출력이 리디렉션 되었는지 경우에 출력 처리 완료 되지 않을이 메서드가 반환 될 수 있습니다. 비동기 이벤트 처리 완료 되었다는 것을 보장 하려면 호출을 <xref:System.Diagnostics.Process.WaitForExit> 받으면는 매개 변수가 없는 오버 로드는 `true` 이 오버 로드에서. 되도록 하려면 합니다 <xref:System.Diagnostics.Process.Exited> 설정, Windows Forms 응용 프로그램에서 이벤트가 올바르게 처리는 <xref:System.Diagnostics.Process.SynchronizingObject%2A> 속성입니다.  
  
 연결된 된 프로세스가 종료 되는 경우 (종료 된 정상 또는 비정상 종료를 통해 운영 체제에서) 프로세스에 대 한 관리 정보를 저장 하 고 호출한는 구성 요소를 반환 하는 시스템 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>입니다. <xref:System.Diagnostics.Process> 구성 요소 정보를 포함 하는 액세스할 수는 <xref:System.Diagnostics.Process.ExitTime%2A>를 사용 하 여는 <xref:System.Diagnostics.Process.Handle%2A> 종료 된 프로세스에.  
  
 연결된 된 프로세스가 종료 되었으므로 <xref:System.Diagnostics.Process.Handle%2A> 구성 요소의 속성은 더 이상 기존 프로세스 리소스를 가리킵니다. 대신, 핸들 프로세스 리소스에 대 한 운영 체제의 정보를 액세스할 때만 사용할 수 있습니다. 시스템에 의해 릴리스되지 않았거나 종료 된 프로세스에 대 한 핸들 인지 <xref:System.Diagnostics.Process> 구성 요소를 유지할 수 있도록를 <xref:System.Diagnostics.Process.ExitTime%2A> 및 <xref:System.Diagnostics.Process.Handle%2A> 까지 메모리에 대 한 정보를 <xref:System.Diagnostics.Process> 구성 요소에는 특히 한 리소스를 해제 합니다. 이러한 이유로 언제 든 지 호출할 <xref:System.Diagnostics.Process.Start%2A> 에 대 한는 <xref:System.Diagnostics.Process> 인스턴스를 호출 <xref:System.Diagnostics.Process.Close%2A> 연결 된 프로세스가 종료 시점과 모든 관리 정보가 더 이상 필요 합니다. <xref:System.Diagnostics.Process.Close%2A> 종료 된 프로세스에 할당 된 메모리를 해제 합니다.  
  
   
  
## Examples  
 에 대 한 코드 예제를 참조 합니다 <xref:System.Diagnostics.Process.ExitCode%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">대기 설정에 액세스할 수 없습니다.</exception>
        <exception cref="T:System.SystemException">
          <see cref="P:System.Diagnostics.Process.Id" /> 프로세스가 설정되지 않았으며, <see cref="P:System.Diagnostics.Process.Id" /> 속성을 파악할 수 있는 <see cref="P:System.Diagnostics.Process.Handle" />이 없습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.  
  
또는 
원격 컴퓨터에서 실행 중인 프로세스의 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />를 호출하려고 합니다. 이 메서드는 로컬 컴퓨터에서 실행되는 프로세스에만 사용할 수 있습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" />이 시간 제한 없음을 나타내는 -1 이외의 음수인 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결된 프로세스가 유휴 상태가 될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 대기하게 합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>연결된 프로세스가 유휴 상태가 될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 무기한 대기하도록 합니다. 이 오버로드는 사용자 인터페이스가 있는, 즉 메시지 루프가 있는 프로세스에만 적용됩니다.</summary>
        <returns>연결된 프로세스가 유휴 상태에 도달한 경우 <see langword="true" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.Process.WaitForInputIdle> 강제로 유휴 상태로 메시지 루프에 반환 될 때까지 대기 하는 응용 프로그램의 처리를 수행 합니다. 사용자 인터페이스를 사용 하 여 프로세스를 실행할 때 해당 메시지 루프 프로세스에 운영 체제에서 Windows 메시지를 보낼 때마다 실행 합니다. 메시지 루프 프로세스를 반환합니다. 메시지 루프 내에서 메시지를 대기 하는 경우 유휴 상태에 있어야 하는 프로세스 라고 합니다. 이 상태는 응용 프로그램이 해당 창을 사용 하 여 응용 프로그램 통신 하려면 먼저 해당 주 창 만들기를 완료 하려면 프로세스를 시작 하는 대기 해야 하는 경우 예를 들어 유용 합니다.  
  
 프로세스에 메시지 루프에 없으면 <xref:System.Diagnostics.Process.WaitForInputIdle> throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle> 오버 로드는 <xref:System.Diagnostics.Process> 구성 요소를 메시지 루프의 유휴 상태가 되 면 프로세스에 대 한 무기한 대기 합니다. 이 명령은 응용 프로그램 작동이 중지 될 수 있습니다. 예를 들어, 프로세스를 항상 작성 되는 경우 해당 메시지 루프 종료 즉시 코드 조각 에서처럼 `while(true)`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스에 그래픽 인터페이스가 없습니다.  
  
또는 
알 수 없는 오류가 발생했습니다. 프로세스가 유휴 상태로 전환하지 못했습니다.  
  
또는 
프로세스가 이미 종료되었습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">
          <see cref="F:System.Int32.MaxValue" />에 대한 값 1은 연결된 프로세스가 유휴 상태가 될 때까지 대기하는 시간(밀리초)입니다. 값이 0이면 즉시 반환이 이루어지고, 값이 -1이면 무기한 대기하게 됩니다.</param>
        <summary>연결된 프로세스가 유휴 상태가 될 때까지 <see cref="T:System.Diagnostics.Process" /> 구성 요소를 지정한 시간(밀리초) 동안 대기하도록 합니다. 이 오버로드는 사용자 인터페이스가 있는, 즉 메시지 루프가 있는 프로세스에만 적용됩니다.</summary>
        <returns>연결된 프로세스가 유휴 상태에 도달한 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 강제로 유휴 상태로 메시지 루프에 반환 될 때까지 대기 하는 응용 프로그램의 처리를 수행 합니다. 사용자 인터페이스를 사용 하 여 프로세스를 실행할 때 해당 메시지 루프 프로세스에 운영 체제에서 Windows 메시지를 보낼 때마다 실행 합니다. 메시지 루프 프로세스를 반환합니다. 메시지 루프 내에서 메시지를 대기 하는 경우 유휴 상태에 있어야 하는 프로세스 라고 합니다. 이 상태는 응용 프로그램이 해당 창을 사용 하 여 응용 프로그램 통신 하려면 먼저 해당 주 창 만들기를 완료 하려면 프로세스를 시작 하는 대기 해야 하는 경우 예를 들어 유용 합니다.  
  
 프로세스에 메시지 루프에 없으면 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throw는 <xref:System.InvalidOperationException>합니다.  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> 오버 로드는 <xref:System.Diagnostics.Process> 구성 요소를 메시지 루프의 유휴 상태가 되 면 프로세스에 대 한 한정 된 기간을 대기 합니다. 연결된 된 프로세스에 워크플로가 유효 상태가 되지 간격의 끝에서 루프 계속 메시지를 처리 하므로 경우 `false` 호출 하는 프로시저로 반환 됩니다.  
  
 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">프로세스에 그래픽 인터페이스가 없습니다.  
  
또는 
알 수 없는 오류가 발생했습니다. 프로세스가 유휴 상태로 전환하지 못했습니다.  
  
또는 
프로세스가 이미 종료되었습니다.  
  
또는 
이 <see cref="T:System.Diagnostics.Process" /> 개체와 연결된 프로세스가 없습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스의 실제 메모리 사용량(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스에서 사용 중인 실제 메모리의 총 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 되는 값 집합 메모리 (바이트)에서 프로세스에서 사용 하는 작업의 현재 크기를 나타냅니다. 프로세스의 작업 집합은 실제 RAM 메모리의 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터 처리 모듈 및 시스템 라이브러리를 포함 하 여 프로세스 실행 한 모든 지침이 포함 된 페이지를 포함 합니다.  
  
   
  
## Examples  
 다음 예제에서는 메모장의 인스턴스를 시작합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 프로세스의 종료 코드를 표시 합니다.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결된 프로세스에 할당된 실제 메모리의 양(바이트)을 가져옵니다.</summary>
        <value>연결된 프로세스에 할당된 실제 메모리의 양(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 의해 반환 되는 값 집합 메모리 (바이트)에서 프로세스에서 사용 하는 작업의 현재 크기를 나타냅니다. 프로세스의 작업 집합은 실제 RAM 메모리의 프로세스에 현재 표시 된 메모리 페이지의 집합. 이러한 페이지는 상주 하며 페이지 오류를 일으키지 않고 응용 프로그램에 사용할 수 있습니다.  
  
 작업 집합에는 공유 및 개인 데이터가 포함 됩니다. 공유 데이터 프로세스 모듈 및 시스템 라이브러리의 명령을 포함 하 여 프로세스에서 실행 하는 모든 명령이 포함 된 페이지를 포함 합니다.  
  
 32 비트 프로세서 또는 64 비트 프로세서를 사용 하 여 컴퓨터에서 메모리 사용량을 모니터링 하려면이 속성을 사용할 수 있습니다. 속성 값이 해당 하는 **Working Set** 프로세스에 대 한 성능 카운터입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메모장 응용 프로그램의 인스턴스를 시작 합니다. 그런 다음 예제에서는 검색 하 고 연결된 된 프로세스의 다양 한 속성이 표시 됩니다. 이 예제에서는 프로세스가 종료 하는 경우를 검색 합니다. 종료 코드 및 최대 메모리 통계를 표시 합니다.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">플랫폼은 Windows 98 또는 Windows Me(Windows Millennium Edition)로서, 이 속성을 지원하지 않습니다.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>