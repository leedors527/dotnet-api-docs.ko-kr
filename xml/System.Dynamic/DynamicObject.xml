<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="048b7221c8f650af7e40e1fc748386ee05216b4b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30410547" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>런타임에 동적 동작을 지정하기 위한 기본 클래스를 제공합니다. 이 클래스는 상속되어야 하며, 직접 인스턴스화할 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject` 클래스를 사용 하면 동적 개체에서 수행할 수 있는 작업 및 이러한 작업을 수행 하는 방법을 정의할 수 있습니다. 예를 들어 get 또는 개체 속성을 설정, 메서드 호출 또는 더하기, 곱하기 등 표준 수치 연산을 수행 하려고 할 때 수행 되는 작업을 정의할 수 있습니다.  
  
 이 클래스는 라이브러리에 대 한 보다 편리한 프로토콜을 만들려는 경우에 유용할 수 있습니다. 예를 들어, 라이브러리의 사용자가 같은 구문을 사용 해야 하는 경우 `Scriptobj.SetProperty("Count", 1)`, like 훨씬 간단한 구문을 사용 하는 기능을 제공할 수 있습니다 `scriptobj.Count = 1`합니다.  
  
 인스턴스를 직접 만들 수는 `DynamicObject` 클래스입니다. 동적 동작을 구현 하려면에서 상속 하려는 `DynamicObject` 클래스 및 필요한 메서드를 재정의 합니다. 예를 들어 한 설정 및 속성을 가져오기에 대 한 작업이 필요한 경우 재정의할 수 있습니다만 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 메서드.  
  
 C#에서는에서 파생 된 클래스의 인스턴스에 대해 동적 동작을 사용 하도록는 `DynamicObject` 사용 해야 클래스는 `dynamic` 키워드입니다. 자세한 내용은 [dynamic 형식 사용](~/docs/csharp/programming-guide/types/using-type-dynamic.md)을 참조하세요.  
  
 Visual Basic에서 런타임에 바인딩하여 동적 작업은 지원 됩니다. 자세한 내용은 참조 [초기 바인딩 및 런타임에 바인딩](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)합니다.  
  
 다음 코드 예제에서 파생 된 클래스의 인스턴스를 만드는 방법을 보여 줍니다는 `DynamicObject` 클래스입니다.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 파생 된 클래스에 직접 구성원을 추가할 수도 있습니다는 `DynamicObject` 클래스입니다. 클래스의 속성 정의 재정의 하는 경우는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 메서드, 동적 언어 런타임 (DLR) 먼저를 사용 하 여 언어 바인더 클래스의 속성에 대 한 정적 정의 찾습니다. 이러한 속성이 없으면 DLR 호출는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 메서드.  
  
 `DynamicObject` DLR 인터페이스를 구현 하는 클래스 <xref:System.Dynamic.IDynamicMetaObjectProvider>의 인스턴스를 공유할 수 있습니다는 `DynamicObject` DLR 상호 운용성 모델을 지 원하는 언어 간 클래스입니다. 예를 들어의 인스턴스를 만들 수 있습니다는 `DynamicObject` C#에서 클래스 및 IronPython 함수에 전달 합니다. 자세한 내용은 참조 [동적 언어 런타임 개요](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)합니다.  
  
> [!NOTE]
>  필요한 개체를 특정 작업을 정의 및 않습니다 하지 정적 멤버만, 사용 하 여 필요 하지 않은 있지만만 추가 하 고 런타임 시 멤버를 제거할 수 있는 간단한 시나리오가 있는 경우는 <xref:System.Dynamic.ExpandoObject> 클래스입니다.  
>   
>  동적 개체를 상호 운용성 프로토콜에 참여 하거나 DLR 동적 디스패치 캐싱을 관리 해야 할 방법을 정의 해야 하는 좀 더 고급 시나리오를 사용 하도록 설정한 경우의 구현을 만듭니다는 <xref:System.Dynamic.IDynamicMetaObjectProvider> 인터페이스입니다.  
  
   
  
## Examples  
 쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` Visual basic에서)를 작성할 수 있습니다 `sampleDictionary.Text = "Sample text"`합니다. 이 구문은 대/소문자 구분, 원하는 또한 있도록 `sampleDictionary.Text` 같습니다 `sampleDictionary.text`합니다.  
  
 다음 코드 예제는 `DynamicDictionary` 에서 파생 된 클래스는 `DynamicObject` 클래스입니다. `DynamicDictionary` 의 개체를 포함 하는 클래스는 `Dictionary<string, object>` 유형 (`Dictionary(Of String, Object)` Visual Basic의) 키-값 쌍 및 재정의 저장 하는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 새 구문을 지 원하는 메서드를 합니다. 또한 제공 된 `Count` 속성을 보여 주 수 동적 속성 사전에 포함 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 더 많은 예제를 참조 하십시오. [DynamicObject와 래퍼를 만드는](http://go.microsoft.com/fwlink/?LinkId=169008) C# 질문과 대답 블로그.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>파생 형식이 <see cref="T:System.Dynamic.DynamicObject" /> 형식의 새 인스턴스를 초기화할 수 있도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스를 직접 만들 수는 <xref:System.Dynamic.DynamicObject> 클래스입니다. 상속할 필요가 동적 동작을 구현 하려면는 <xref:System.Dynamic.DynamicObject> 클래스 및 필요한 메서드를 재정의 합니다.  
  
 C#에서는에서 파생 된 클래스의 인스턴스에 대해 동적 동작을 사용 하도록는 <xref:System.Dynamic.DynamicObject> 사용 해야 클래스는 `dynamic` 키워드입니다. 자세한 내용은 [dynamic 형식 사용](~/docs/csharp/programming-guide/types/using-type-dynamic.md)을 참조하세요.  
  
 Visual Basic에서 런타임에 바인딩하여 동적 작업은 지원 됩니다. 자세한 내용은 참조 [초기 바인딩 및 런타임에 바인딩](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 파생 된 클래스의 인스턴스를 만드는 방법을 보여 줍니다는 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 동적 멤버 이름의 열거형을 반환합니다.</summary>
        <returns>동적 멤버 이름이 들어 있는 시퀀스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 디버깅 목적 으로만 존재 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">동적 가상 메서드에 디스패치할 <see cref="T:System.Dynamic.DynamicMetaObject" />를 나타내는 식입니다.</param>
        <summary>동적 가상 메서드에 디스패치할 <see cref="T:System.Dynamic.DynamicMetaObject" />를 제공합니다. 개체를 다른 <see cref="T:System.Dynamic.DynamicMetaObject" /> 내에 캡슐화하여 개별 작업에 대해 사용자 지정 동작을 제공할 수 있습니다. 이 메서드는 언어 구현자에 대한 동적 언어 런타임 인프라를 지원하며 사용자 코드에서 직접 사용할 수 없습니다.</summary>
        <returns>
          <see cref="T:System.Dynamic.DynamicMetaObject" /> 형식의 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">이항 연산에 대한 정보를 제공합니다. <c>binder.Operation</c> 속성에서 <see cref="T:System.Linq.Expressions.ExpressionType" /> 개체를 반환합니다. 예를 들어, <c>합계 = 첫 번째 + 두 번째</c> 문의 경우 여기서 <c>첫 번째</c> 및 <c>두 번째</c>는 <see langword="DynamicObject" /> 클래스에서 파생됩니다. <c>binder.Operation</c>은 <c>ExpressionType.Add</c>를 반환합니다.</param>
        <param name="arg">이항 연산의 오른쪽 피연산자입니다. 예를 들어, <c>합계 = 첫 번째 + 두 번째</c> 문의 경우 여기서 <c>첫 번째</c> 및 <c>두 번째</c>는 <see langword="DynamicObject" /> 클래스에서 파생됩니다. <c>arg</c>는 <c>두 번째</c>를 반환합니다.</param>
        <param name="result">이항 연산의 결과입니다.</param>
        <summary>이항 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 더하기와 곱하기 같은 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 동적 개체에 대 한 이진 연산을 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 이 메서드는 더하기 나 빼기와 같은 이진 작업이 있을 때 호출 됩니다. 예를 들어 경우는 <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> 메서드는, 같은 문에 대해 자동으로 호출 `sum = first + second` 또는 `multiply = first*second`여기서 `first` 에서 파생 되는 `DynamicObject` 클래스입니다.  
  
 사용 하 여 이진 작업의 형식에 대 한 정보를 읽을 수는 `Operation` 속성은 `binder` 매개 변수입니다.  
  
 C# 및 Visual Basic의 경우에 동적 개체가 사용 되는 경우는 `binder.Operation` 속성에서 다음 값 중 하나일 수 있습니다는 <xref:System.Linq.Expressions.ExpressionType> 열거형입니다. 그러나, IronPython, IronRuby 등 다른 언어로 다른 값을 가질 수 있습니다.
  
|값|설명|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|숫자 피연산자에 대 한 오버플로 검사 하지 않고 더하기 연산입니다.|`a + b`|`a + b`|  
|`AddAssign`|숫자 피연산자에 대 한 오버플로 검사 하지 않고 더하기 복합 할당 작업.|`a += b`|지원되지 않습니다.|  
|`And`|비트 `AND` 작업 합니다.|`a & b`|`a And b`|  
|`AndAssign`|비트 `AND` 복합 할당 연산입니다.|`a &= b`|지원되지 않습니다.|  
|`Divide`|산술 나누기 연산을 합니다.|`a / b`|`a / b`|  
|`DivideAssign`|산술 나누기 복합 할당 작업입니다.|`a /= b`|지원되지 않습니다.|  
|`ExclusiveOr`|비트 `XOR` 작업 합니다.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|비트 `XOR` 복합 할당 연산입니다.|`a ^= b`|지원되지 않습니다.|  
|`GreaterThan`|"보다 큼" 비교 합니다.|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|"보다 크거나" 비교 합니다.|`a >= b`|지원되지 않습니다.|  
|`LeftShift`|비트 왼쪽 시프트 연산입니다.|`a << b`|`a << b`|  
|`LeftShiftAssign`|비트 왼쪽 시프트 복합 할당 작업입니다.|`a <<= b`|지원되지 않습니다.|  
|`LessThan`|"보다 작음" 비교 합니다.|`a < b`|`a < b`|  
|`LessThanOrEqual`|"보다 작거나 같음" 비교 합니다.|`a <= b`|지원되지 않습니다.|  
|`Modulo`|산술 나머지 연산을 합니다.|`a % b`|`a Mod b`|  
|`ModuloAssign`|산술 나머지 복합 할당 작업입니다.|`a %= b`|지원되지 않습니다.|  
|`Multiply`|숫자 피연산자에 대 한 오버플로 검사 하지 않는 곱하기 작업.|`a * b`|`a * b`|  
|`MultiplyAssign`|숫자 피연산자에 대 한 오버플로 검사 하지 않는 곱하기 복합 할당 작업.|`a *= b`|지원되지 않습니다.|  
|`NotEqual`|다름 비교 합니다.|`a != b`|`a <> b`|  
|`Or`|비트 또는 논리 `OR` 작업 합니다.|`a &#124; b`|`a Or b`|  
|`OrAssign`|비트 또는 논리 `OR` 복합 할당 합니다.|`a &#124;= b`|지원되지 않습니다.|  
|`Power`|숫자의 제곱을 구하는 동작 수학 연산입니다.|지원되지 않습니다.|`a ^ b`|  
|`RightShift`|비트 오른쪽 시프트 연산입니다.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|비트 오른쪽 시프트 복합 할당 작업입니다.|`a >>= b`|지원되지 않습니다.|  
|`Subtract`|숫자 피연산자에 대 한 오버플로 검사 하지 않는 빼기 작업.|`a - b`|`a - b`|  
|`SubtractAssign`|숫자 피연산자에 대 한 오버플로 검사 하지 않는 빼기 복합 할당 작업.|`a -= b`|지원되지 않습니다.|  
  
> [!NOTE]
>  구현 하려면 `OrElse` (`a || b`) 및 `AndAlso` (`a && b`) C# 동적 개체에 대 한 작업을 만들려는 경우 둘 다 구현는 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> 메서드 및 <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> 메서드.  
>   
>  `OrElse` 단항 연산 과정은 `IsTrue` 작업 및 이진 `Or` 작업 합니다. `Or` 경우에 작업이 수행의 결과 `IsTrue` 작업이 `false`합니다.  
>   
>  `AndAlso` 단항 연산 과정은 `IsFalse` 작업 및 이진 `And` 작업 합니다. `And` 경우에 작업이 수행의 결과 `IsFalse` 작업이 `false`합니다.  
  
   
  
## Examples  
 숫자의 텍스트 및 숫자 표현을 저장 하는 데이터 구조를 필요 하 고 더하기 및 빼기에 이러한 데이터에 대 한 같은 기본 수치 연산을 정의 하려는 가정 합니다.  
  
 다음 코드 예제는 `DynamicNumber` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicNumber` 재정의 <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> 메서드 수학 연산을 사용할 수 있도록 합니다. 또한 재정의 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 요소에 액세스할 수 있도록 하는 메서드.  
  
 이 예제에서는 더하기 및 빼기 작업 에서만 지원 됩니다. 같은 문을 작성 하려는 경우 `resultNumber = firstNumber*secondNumber`, 런타임에 예외가 throw 됩니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">변환 연산에 대한 정보를 제공합니다. <c>binder.Type</c> 속성은 개체가 변환되어야 하는 형식을 제공합니다. 예를 들어 C#에서 <c>(String)sampleObject</c>(Visual Basic에서 <c>CType(sampleObject, Type)</c>) 문의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스의 인스턴스입니다. <c>binder.Type</c>은 <see cref="T:System.String" /> 형식을 반환합니다. <c>binder.Explicit</c> 속성은 발생하는 변환의 종류에 대한 정보를 제공합니다. 명시적 변환의 경우 <see langword="true" />를 반환하고, 암시적 변환의 경우 <see langword="false" />를 반환합니다.</param>
        <param name="result">형식 변환 연산의 결과입니다.</param>
        <summary>형식 변환 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 개체를 한 형식에서 다른 형식으로 변환하는 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 동적 개체에 대 한 형식 변환을 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 C#에서는이 메서드를 재정의 하는 경우 자동으로 호출 됩니다는 명시적 또는 암시적 변환을 있으면 아래 코드 예제에 표시 된 대로.  
  
 Visual Basic의 경우 명시적 변환은 지원 됩니다. 사용 하 여 호출이 메서드를 재정의 하는 경우는 <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> 또는 <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> 함수입니다.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 문자열 및 정수에 변환 이러한 데이터 구조를 정의 하려면 및 숫자의 텍스트 및 숫자 표현을 저장 하는 데이터 구조 된다고 가정 합니다.  
  
 다음 코드 예제는 `DynamicNumber` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicNumber` 재정의 <xref:System.Dynamic.DynamicObject.TryConvert%2A> 메서드 형식 변환을 사용할 수 있도록 합니다. 또한 재정의 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 데이터 요소에 액세스할 수 있도록 하는 메서드.  
  
 이 예제에서는 문자열 및 정수에 변환만 지원 됩니다. 개체를 다른 형식으로 변환 하려고 하면 런타임 예외가 throw 됩니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">초기화 연산에 대한 정보를 제공합니다.</param>
        <param name="args">초기화하는 동안 개체에 전달되는 인수입니다. 예를 들어 <c>새 SampleType(100)</c> 작업의 경우 여기서 <c>SampleType</c>은 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생되는 형식입니다. <c>args[0]</c>는 100과 같습니다.</param>
        <param name="result">초기화의 결과입니다.</param>
        <summary>동적 개체의 새 인스턴스를 초기화하는 연산에 대한 구현을 제공합니다. 이 메서드는 C# 또는 Visual Basic에서 사용할 수 없습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 동적 개체의 새 인스턴스를 초기화 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 C# 및 Visual Basic 컴파일러는 첫 번째 클래스 형식을 지원 하지 않기 때문에이 메서드를 사용 하는 코드를 내보냅니다. 이 메서드를 같은 구문을 사용 하 여 동적 개체의 초기화를 지 원하는 언어에 사용 `dynamic new`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">삭제에 대한 정보를 제공합니다.</param>
        <param name="indexes">삭제할 인덱스입니다.</param>
        <summary>인덱스별로 개체를 삭제하는 연산에 대한 구현을 제공합니다. 이 메서드는 C# 또는 Visual Basic에서 사용할 수 없습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스는 지정 된 인덱스를 포함 하는 값을 삭제 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 C# 및 Visual Basic 컴파일러는 이런이 종류의 작업을 지원 하지 않으므로이 메서드를 사용 하는 코드를 내보냅니다. 인덱스로 같은 개체를 삭제 하기 위한 구문을 지 원하는 언어에이 메서드를 사용 하는 `del sampleObject[1,2]` Python에서 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">삭제에 대한 정보를 제공합니다.</param>
        <summary>개체 멤버를 삭제하는 연산에 대한 구현을 제공합니다. 이 메서드는 C# 또는 Visual Basic에서 사용할 수 없습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 개체 멤버를 삭제 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 이 메서드가 재정의 되지 않은 언어의 런타임 바인더 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 C# 및 Visual Basic 컴파일러는 이런이 종류의 작업을 지원 하지 않으므로이 메서드를 사용 하는 코드를 내보냅니다. 이 메서드를 같은 멤버를 삭제 하기 위한 구문을 지 원하는 언어에 사용 `del sampleObject.SampleMember` Python에서 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">연산에 대한 정보를 제공합니다.</param>
        <param name="indexes">연산에 사용되는 인덱스입니다. 예를 들어 C#에서 <c>sampleObject[3]</c>(Visual Basic에서 <c>sampleObject(3)</c>) 작업의 경우 여기서 <c>sampleObject</c>는 <see langword="DynamicObject" /> 클래스에서 파생됩니다. <c>indexes[0]</c>은 3과 같습니다.</param>
        <param name="result">인덱스 연산의 결과입니다.</param>
        <summary>인덱스별로 값을 가져오는 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 인덱싱 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 인덱스로 값을 가져올 수행 되는 방식을 동적 개체에 대해 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 런타임 예외가 throw됩니다.  
  
 같은 작업이 있을 때 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 `sampleObject[3]` C# 또는 `sampleObject(3)` Visual Basic, where에서 `sampleObject` 에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
   
  
## Examples  
 가정와 같은 이름을 사용 하거나 액세스할 속성 될 수 있는 개체를 만들 것인지 `Property0`, `Property1`등의 또는 인덱스 별로 있도록, 예를 들어 `sampleObject.Property0` 과 같습니다 `sampleObject[0]` C# 또는 `sampleObject(0)` Visual Basic의 합니다.  
  
 다음 코드 예제는 `SampleDynamicObject` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `SampleDynamicObject` 의 개체를 포함 하는 클래스는 `Dictionary<string, object>` 형식 (`Dictionary(Of String, Object)` Visual basic에서) 키-값 쌍을 저장 하 합니다. `SampleDynamicObject` 재정의 <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> 메서드 인덱스로 액세스할 수 있도록 합니다. 재정의 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 메서드 속성 이름으로 액세스할 수 있도록 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">동적 연산을 호출한 개체에 대한 정보를 제공합니다. <c>binder.Name</c> 속성은 동적 연산이 수행된 멤버의 이름을 제공합니다. 예를 들어 <c>Console.WriteLine(sampleObject.SampleProperty)</c> 문의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스의 인스턴스입니다. <c>binder.Name</c>은 "SampleProperty"를 반환합니다. <c>binder.IgnoreCase</c> 속성은 멤버 이름이 대/소문자를 구분하는지 여부를 지정합니다.</param>
        <param name="result">가져오기 연산의 결과입니다. 예를 들어 속성에 대한 메서드가 호출되면 <c>결과</c>에 속성 값을 할당할 수 있습니다.</param>
        <summary>멤버 값을 가져오는 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 속성 값 가져오기와 같은 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 멤버 값을 가져오는 작업을 동적 개체에 대해 수행 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 런타임 예외가 throw됩니다.  
  
 이 메서드는 같은 문이 있으면 `Console.WriteLine(sampleObject.SampleProperty)`여기서 `sampleObject` 에서 파생 된 클래스의 인스턴스가 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
 파생 된 클래스에 직접 구성원을 추가할 수도 있습니다는 `DynamicObject` 클래스입니다. 클래스의 속성 정의 재정의 하는 경우는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 메서드, 동적 언어 런타임 (DLR) 먼저를 사용 하 여 언어 바인더 클래스의 속성에 대 한 정적 정의 찾습니다. 이러한 속성이 없으면 DLR 호출는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 메서드.  
  
   
  
## Examples  
 쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` Visual basic에서)를 작성할 수 있습니다 `sampleDictionary.Text = "Sample text"`합니다. 또한이 구문은 대/소문자를 구분 해야 있도록 `sampleDictionary.Text` 같습니다 `sampleDictionary.text`합니다.  
  
 다음 코드 예제는 `DynamicDictionary` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicDictionary` 의 개체를 포함 하는 클래스는 `Dictionary<string, object>` 유형 (`Dictionary(Of String, Object)` Visual Basic의) 키-값 쌍 및 재정의 저장 하는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 새 구문을 지 원하는 메서드를 합니다. 또한 제공 된 `Count` 속성을 보여 주 수 동적 속성 사전에 포함 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">호출 연산에 대한 정보를 제공합니다.</param>
        <param name="args">호출 연산을 수행하는 동안 개체에 전달되는 인수입니다. 예를 들어 <c>sampleObject(100)</c> 작업의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생됩니다. <c>args[0]</c>은 100과 같습니다.</param>
        <param name="result">개체 호출의 결과입니다.</param>
        <summary>개체를 호출하는 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 개체 또는 대리자 호출과 같은 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 개체를 호출 하는 작업을 동적 개체에 대해 수행 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 런타임 예외가 throw됩니다.  
  
 같은 작업이 있을 때 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 `sampleObject(100)`여기서 `sampleObject` 에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
 C#에서 있지만 Visual Basic에는 없는 개체를 호출 하기 위한 작업은 지원 됩니다. Visual Basic 컴파일러에서이 메서드를 사용 하는 코드를 생성 하지 및 Visual Basic 언어 구문과 비슷한 구문을 지원 하지 않습니다 `sampleObject(100)`합니다.  
  
   
  
## Examples  
 숫자를 나타내는 텍스트 및 숫자를 저장 하는 데이터 구조 된다고 가정 합니다. 각 속성에 대 한 값을 개별적으로 지정 하 고 단일 문에서 모든 속성을 초기화할 수 있게 되기를 원하는 합니다.  
  
 다음 코드 예제는 `DynamicNumber` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicNumber` 재정의 <xref:System.Dynamic.DynamicObject.TryInvoke%2A> 메서드를 한 번에 모든 속성의 초기화를 사용 합니다. 또한 재정의 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 개별 개체 속성에 액세스할 수 있도록 하는 메서드.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">동적 연산에 대한 정보를 제공합니다. <c>binder.Name</c> 속성은 동적 연산이 수행된 멤버의 이름을 제공합니다. 예를 들어 <c>sampleObject.SampleMethod(100)</c> 문의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스의 인스턴스입니다. <c>binder.Name</c>은 "SampleMethod"를 반환합니다. <c>binder.IgnoreCase</c> 속성은 멤버 이름이 대/소문자를 구분하는지 여부를 지정합니다.</param>
        <param name="args">호출 연산을 수행하는 동안 개체 멤버에 전달되는 인수입니다. 예를 들어 <c>sampleObject.SampleMethod(100)</c> 문의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생됩니다. <c>args[0]</c>은 100과 같습니다.</param>
        <param name="result">멤버 호출의 결과입니다.</param>
        <summary>멤버를 호출하는 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 메서드 호출과 같은 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 개체 멤버를 호출 하는 작업을 동적 개체에 대해 수행 해야 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 같은 작업을 수행 하는 경우 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 `sampleObject.SampleMethod(100)`여기서 `sampleObject` 에서 파생 되는 `DynamicObject` 클래스입니다.  
  
 파생 된 클래스에 메서드를 추가할 수도 있습니다는 <xref:System.Dynamic.DynamicObject> 클래스입니다. 예를 들어, 재정의 하는 경우는 <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> 메서드를 동적 디스패치 시스템이 지정된 된 메서드는 클래스에 존재 하는지 확인 하려면 먼저 시도 합니다. 사용 하는 메서드를 찾지 못하면 경우는 <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> 구현 합니다.  
  
 이 방법은 지원 하지 않습니다 `ref` 및 `out` 매개 변수입니다. 모든 매개 변수에 `args` 배열 값으로 전달 됩니다.  
  
   
  
## Examples  
 쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` Visual basic에서)를 작성할 수 있습니다 `sampleDictionary.Text = "Sample text"`합니다. 또한이 사전에서 모든 표준 사전 메서드를 호출할 수 있게 되기를 원하는 합니다.  
  
 다음 코드 예제는 `DynamicDictionary` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicDictionary` 의 개체를 포함 하는 클래스는 `Dictionary<string, object>` 형식 (`Dictionary(Of String, Object)` Visual basic에서) 키-값 쌍을 저장 하 합니다. 재정의 <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> 의 메서드를 지원 하기 위해 메서드에 <xref:System.Collections.Generic.Dictionary%602> 클래스 및 재정의 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 새 구문을 지 원하는 메서드를 합니다. 또한 제공는 `Print` 메서드를 모든 사전 키와 값을 출력 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">연산에 대한 정보를 제공합니다.</param>
        <param name="indexes">연산에 사용되는 인덱스입니다. 예를 들어 C#에서 <c>sampleObject[3] = 10</c>(Visual Basic에서 <c>sampleObject(3) = 10</c>) 작업의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생됩니다. <c>indexes[0]</c>은 3과 같습니다.</param>
        <param name="value">지정된 인덱스를 가진 개체로 설정할 값입니다. 예를 들어 C#에서 <c>sampleObject[3] = 10</c>(Visual Basic에서 <c>sampleObject(3) = 10</c>) 작업의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생됩니다. <c>값</c>은 10과 같습니다.</param>
        <summary>인덱스별로 값을 설정하는 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 지정된 인덱스별로 개체에 액세스하는 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 동적 개체에 대 한 개체 인덱스로 액세스 하는 작업이 수행 되는 방식을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 같은 작업이 있을 때 자동으로 호출 됩니다이 메서드를 재정의 하는 경우 `sampleObject[3] = 10` C# 또는 `sampleObject(3) = 10` Visual Basic, where에서 `sampleObject` 에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
   
  
## Examples  
 가정와 같은 이름을 사용 하거나 액세스할 속성 될 수 있는 개체를 만들 것인지 `Property0`, `Property1`등의 또는 인덱스 별로 있도록, 예를 들어 `sampleObject.Property0` 과 같습니다 `sampleObject[0]` C# 또는 `sampleObject(0)` Visual Basic의 합니다.  
  
 다음 코드 예제는 `SampleDynamicObject` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `SampleDynamicObject` 의 개체를 포함 하는 클래스는 `Dictionary<string, object>` 형식 (`Dictionary(Of String, Object)` Visual basic에서) 키-값 쌍을 저장 하 합니다. `SampleDynamicObject` 재정의 <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> 메서드 인덱스로 액세스할 수 있도록 합니다. 재정의 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 메서드 속성 이름으로 액세스할 수 있도록 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">동적 연산을 호출한 개체에 대한 정보를 제공합니다. <c>binder.Name</c> 속성은 값이 할당될 멤버의 이름을 제공합니다. 예를 들어 <c>sampleObject.SampleProperty = "Test"</c> 문의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스의 인스턴스입니다. <c>binder.Name</c>은 "SampleProperty"를 반환합니다. <c>binder.IgnoreCase</c> 속성은 멤버 이름이 대/소문자를 구분하는지 여부를 지정합니다.</param>
        <param name="value">멤버에 설정할 값입니다. 예를 들어 <c>sampleObject.SampleProperty = "Test"</c>의 경우 여기서 <c>sampleObject</c>는 <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스의 인스턴스입니다. <c>값</c>은 "Test"를 반환합니다.</param>
        <summary>멤버 값을 설정하는 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 속성 값 설정과 같은 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 멤버에 값을 설정 하는 작업 동적 개체에 대해 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 이 메서드는 같은 문이 있으면 `sampleObject.SampleProperty = "Test"`여기서 `sampleObject` 에서 파생 된 클래스의 인스턴스가 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
 파생 된 클래스에 직접 구성원을 추가할 수도 있습니다는 `DynamicObject` 클래스입니다. 클래스의 속성 정의 재정의 하는 경우는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 메서드, 동적 언어 런타임 (DLR) 먼저를 사용 하 여 언어 바인더 클래스의 속성에 대 한 정적 정의 찾습니다. 이러한 속성이 없으면 DLR 호출는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 메서드.  
  
   
  
## Examples  
 쓰기는 대신의 사전에 값에 액세스 하기 위한 대체 구문을 제공 해야 한다고 가정해 보십시오 `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` Visual basic에서)를 작성할 수 있습니다 `sampleDictionary.Text = "Sample text"`합니다. 또한이 구문은 대/소문자를 구분 해야 있도록 `sampleDictionary.Text` 같습니다 `sampleDictionary.text`합니다.  
  
 다음 코드 예제는 `DynamicDictionary` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicDictionary` 의 개체를 포함 하는 클래스는 `Dictionary<string, object>` 유형 (`Dictionary(Of String, Object)` Visual Basic의) 키-값 쌍 및 재정의 저장 하는 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 새 구문을 지 원하는 메서드를 합니다. 또한 제공 된 `Count` 속성을 보여 주 수 동적 속성 사전에 포함 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">단항 연산에 대한 정보를 제공합니다. <c>binder.Operation</c> 속성에서 <see cref="T:System.Linq.Expressions.ExpressionType" /> 개체를 반환합니다. 예를 들어 <c>negativeNumber = -number</c> 문의 경우 여기서 <c>번호</c>는 <see langword="DynamicObject" /> 클래스에서 파생됩니다. <c>binder.Operation</c>은 "Negate"를 반환합니다.</param>
        <param name="result">단항 연산의 결과입니다.</param>
        <summary>단항 연산에 대한 구현을 제공합니다. <see cref="T:System.Dynamic.DynamicObject" /> 클래스에서 파생된 클래스로 이 메서드를 재정의하여 부정, 증가 또는 감소와 같은 연산의 동적 동작을 지정할 수 있습니다.</summary>
        <returns>
          작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 이 메서드가 <see langword="false" />를 반환하는 경우 언어의 런타임 바인더에 따라 동작이 결정됩니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클래스에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스 동적 개체에 대 한 단항 연산을 수행 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 메서드를 재정의 하지 않은 언어의 런타임 바인더의 동작을 결정 합니다. 대부분의 경우 언어별 런타임 예외가 throw됩니다.  
  
 이 메서드는 부정, 증분, 같은 단항 연산 했거나 감소 시킬 때 호출 됩니다. 예를 들어 경우는 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> 메서드는,이 메서드는 같은 문에 대해에 자동으로 호출 됩니다 `negativeNumber = -number`여기서 `number` 에서 파생 되는 <xref:System.Dynamic.DynamicObject> 클래스입니다.  
  
 사용 하 여 단항 연산의 유형에 대 한 정보를 가져올 수 있습니다는 `Operation` 의 속성은 `binder` 매개 변수입니다.  
  
 C# 및 Visual Basic의 경우에 동적 개체가 사용 되는 경우는 `binder.Operation` 속성에서 다음 값 중 하나일 수 있습니다는 <xref:System.Linq.Expressions.ExpressionType> 열거형입니다. 그러나, IronPython, IronRuby 등 다른 언어로 다른 값을 가질 수 있습니다.
  
|값|설명|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|단항 감소 작업입니다.|`a--`|지원되지 않습니다.|  
|`Increment`|단항 증가 연산입니다.|`a++`|지원되지 않습니다.|  
|`Negate`|산술 부정입니다.|`-a`|`-a`|  
|`Not`|논리 부정입니다.|`!a`|`Not a`|  
|`OnesComplement`|구성을 보완 합니다.|`~a`|지원되지 않습니다.|  
|`IsFalse`|False 조건 값입니다.|`a && b`|지원되지 않습니다.|  
|`IsTrue`|True 조건이 값입니다.|`a &#124;&#124; b`|지원되지 않습니다.|  
|`UnaryPlus`|단항 더하기입니다.|`+a`|`+a`|  
  
> [!NOTE]
>  구현 하려면 `OrElse` (`a || b`) 및 `AndAlso` (`a && b`) C# 동적 개체에 대 한 작업을 만들려는 경우 둘 다 구현는 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> 메서드 및 <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> 메서드.  
>   
>  `OrElse` 단항 연산 과정은 `IsTrue` 작업 및 이진 `Or` 작업 합니다. `Or` 경우에 작업이 수행의 결과 `IsTrue` 작업이 `false`합니다.  
>   
>  `AndAlso` 단항 연산 과정은 `IsFalse` 작업 및 이진 `And` 작업 합니다. `And` 경우에 작업이 수행의 결과 `IsFalse` 작업이 `false`합니다.  
  
   
  
## Examples  
 이러한 데이터에 대 한 산술 부정 연산을 정의 하려는 및 숫자의 텍스트 및 숫자 표현을 저장 하는 데이터 구조 된다고 가정 합니다.  
  
 다음 코드 예제는 `DynamicNumber` 에서 파생 된 클래스는 <xref:System.Dynamic.DynamicObject> 클래스입니다. `DynamicNumber` 재정의 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> 메서드 산술 부정 연산을 사용할 수 있도록 합니다. 재정의 이기도 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> 및 <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 요소에 액세스할 수 있도록 하는 메서드.  
  
 이 예제에서는 산술 부정 연산은 지원 됩니다. 같은 문을 작성 하려는 경우 `negativeNumber = +number`, 런타임 예외가 발생 합니다.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>