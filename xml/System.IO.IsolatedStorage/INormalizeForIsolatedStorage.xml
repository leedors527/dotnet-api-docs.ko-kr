<Type Name="INormalizeForIsolatedStorage" FullName="System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5989f7efbb70d9f50ece90e2339aa913b47c96b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37654169" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INormalizeForIsolatedStorage" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" />
  <TypeSignature Language="VB.NET" Value="Public Interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="C++ CLI" Value="public interface class INormalizeForIsolatedStorage" />
  <TypeSignature Language="F#" Value="type INormalizeForIsolatedStorage = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4484a-101">격리된 저장소와 응용 프로그램 도메인, 어셈블리의 증명 정보를 비교할 수 있게 합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4484a-101">Enables comparisons between an isolated store and an application domain and assembly's evidence.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4484a-102">격리 된 저장소 식별 하 고 고유한 파일 저장소 위치를 제공 하기 위해 어셈블리에 대 한 증거를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4484a-102">Isolated storage uses evidence about an assembly in order to identify it and provide it with a unique file storage location.</span></span> <span data-ttu-id="4484a-103">어셈블리에서 저장소를 요청 하는 경우 (로드 하는 호스트에서 제공) 처럼 증명 정보를 처리 하 고 기존 저장소를 만드는 데 사용한 증거를 사용 하 여 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4484a-103">When an assembly requests a store, its evidence (as presented by the host that loaded it) is processed and compared with the evidence used to create the existing stores.</span></span> <span data-ttu-id="4484a-104">새 저장소를 만들어야 하는 경우 또는 해당 어셈블리에 대 한 이미 있을 경우 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4484a-104">This determines if you need to create a new store or if one already exists for the assembly in question.</span></span> <span data-ttu-id="4484a-105">기능적으로 동일 하는 증거의 조각을 비교 기술을 사용으로 인해 하지 serialize 된 형식이 동일 하지 않은 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4484a-105">Due to the comparison technique used, pieces of evidence that are functionally equivalent might not result in a true comparison if the serialized forms are not identical.</span></span> <span data-ttu-id="4484a-106">사용자 지정 증명 정보를 구현 하는 경우이 증명 정보 클래스에 대 한 경우를 고려해, 그렇다면, 구현 <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>합니다.</span><span class="sxs-lookup"><span data-stu-id="4484a-106">When implementing custom evidence, consider whether this is the case for your evidence class and, if so, implement <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>.</span></span> <span data-ttu-id="4484a-107">이 인터페이스를 구현 하는 증거를 <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A> 메서드가 호출 되 고 비교는 해당 메서드에 의해 반환 되는 개체의 정규화 된 복사본을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="4484a-107">For evidence that implements this interface, the <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A> method is called and comparisons are based on the normalized copy of the object returned by that method.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="4484a-108">
        <para>사용자 지정 증명 정보를 구현 하 고 저장소를 이미 있는지 확인 해야 하는 경우에이 인터페이스를 구현 합니다. Serialize 된 개체를 비교는 대/소문자 구분 문자열 같은 일부 경우에 쓰일 수 없습니다. 예를 들어 www.MSN.com WWW.msn.com 같으면 돌아가서는 <see langword="true" /> 비교 했을 때. 만들려는 <see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /> 개체를 구현 해야 합니다 <see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /> 메서드.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="4484a-108">
          <para>Implement this interface when you are implementing custom evidence and need to determine if a store already exists. Serialized objects should not be used for comparisons in some instances, such as that of case sensitive strings. For example, www.MSN.com is equal to WWW.msn.com and will return a <see langword="true" /> when compared. To create an <see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /> object, you need to implement the <see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /> method.</para>
        </span>
      </span>
    </block>
    <block subset="none" type="usage">
      <span data-ttu-id="4484a-109">
        <para>격리 된 저장소 어셈블리의 증명 정보 및 현재 사용 중인 기존 간의 비교를 수행 하기 전에 인스턴스를 정규화 하기 위해이 인터페이스의 메서드를 호출 합니다.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="4484a-109">
          <para>Call the methods of this interface to normalize the instance before making comparisons between an assembly's evidence and currently existing isolated stores.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public object Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Normalize();" />
      <MemberSignature Language="F#" Value="abstract member Normalize : unit -&gt; obj" Usage="iNormalizeForIsolatedStorage.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4484a-110">파생 클래스에서 재정의할 경우 이 메서드를 호출한 개체의 정규화된 복사본을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4484a-110">When overridden in a derived class, returns a normalized copy of the object on which it is called.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4484a-111">이 메서드를 호출한 인스턴스를 나타내는 정규화된 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4484a-111">A normalized object that represents the instance on which this method was called.</span>
          </span>
          <span data-ttu-id="4484a-112">이 인스턴스는 문자열, 스트림 또는 serialize할 수 있는 모든 개체일 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4484a-112">This instance can be a string, stream, or any serializable object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="4484a-113">
            <para>이 메서드를 재정의 하 고는 스트림이 반환 된 개체를 serialize 할 것으로 간주 되 고 serialize 된 형식의 기존 저장소를 만드는 데 사용한 증거를 직접 비교 됩니다. 반환 되는 개체를 문자열로 격리 된 저장소의 이름으로 간주 되며 기존 저장소의 이름을 비교 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="4484a-113">
              <para>When you override this method and the object returned is a stream, it is assumed to be serialized and is compared directly to the serialized form of the evidence used to create existing stores. If the object returned is a string, it is considered the name of an isolated store and compared to the names of the existing stores.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="4484a-114">
            <para>일반적으로 격리 된 저장소에서 파생 된 클래스를 작성 하 고 격리 된 저장소는 현재 어셈블리에 대해 이미 존재 하는지 확인 해야 하는 경우이 메서드를 호출 합니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="4484a-114">
              <para>You typically call this method if you are writing a class derived from isolated storage and you need to check to see if isolated storage already exists for the current assembly.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>