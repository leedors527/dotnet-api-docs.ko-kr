<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="37759115" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>구조적 로그 저장소를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogRecordSequence> 클래스는 CLFS(Common Log File System) 로그 위에 레코드 시퀀스 인터페이스의 구현을 제공합니다. 이 클래스는 CLFS 로그 파일을 직접 조작하고 관리하는 데 필요한 인터페이스를 제공하는 <xref:System.IO.Log.LogStore> 클래스와 함께 작동합니다. 로그 저장소는 일련의 디스크 범위에서 추가 전용 저장소를 제공합니다. <xref:System.IO.Log.LogStore> 클래스는 이 저장소를 나타내며 컨테이너 추가 및 제거, 정책 설정 및 아카이브 생성을 위한 메서드를 제공합니다. 하지만 저장소에서 읽고 저장소에 쓰기 위한 메서드는 제공하지 않습니다. 이러한 메서드는 <xref:System.IO.Log.LogRecordSequence> 클래스에서 제공합니다.  
  
 <xref:System.IO.Log.LogStore> 클래스와 <xref:System.IO.Log.LogRecordSequence> 클래스의 관계는 디스크 파일과 <xref:System.IO.FileStream> 개체의 관계와 유사합니다. 디스크 파일은 실제 저장소를 제공하고 길이 및 마지막 액세스 시간과 같은 특성을 갖고 있으며, <xref:System.IO.FileStream> 개체는 파일에서 읽고 파일에 쓰는 데 사용할 수 있는 파일에 대한 뷰를 제공합니다. 이와 마찬가지로 <xref:System.IO.Log.LogStore> 클래스에는 디스크 범위의 컬렉션 및 정책과 같은 특성이 있으며, <xref:System.IO.Log.LogRecordSequence> 클래스는 데이터를 읽고 쓰기 위한 레코드 기반의 메커니즘을 제공합니다.  
  
 <xref:System.IO.Log.FileRecordSequence> 클래스가 나타내는 파일 레코드 시퀀스와 달리, <xref:System.IO.Log.LogStore> 인스턴스는 <xref:System.IO.Log.LogExtent> 인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장합니다. 지정된 <xref:System.IO.Log.LogStore> 인스턴스의 범위는 크기가 모두 동일하며 범위가 증가하면 <xref:System.IO.Log.LogStore> 인스턴스에서 공간이 추가되고 제거됩니다. 로그 범위를 추가하고 제거하려면 <xref:System.IO.Log.LogExtentCollection.Add%2A> 속성에서 반환할 수 있는 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 개체의 <xref:System.IO.Log.LogExtentCollection> 및 <xref:System.IO.Log.LogStore.Extents%2A> 메서드를 사용합니다.  
  
 <xref:System.IO.Log.LogStore> 인스턴스에는 정책이 연결되어 있을 수 있습니다. 이러한 정책은 <xref:System.IO.Log.LogPolicy> 속성에서 반환할 수 있는 <xref:System.IO.Log.LogStore.Policy%2A> 인스턴스로 나타냅니다. 정책에서는 로그에서 따라야 할 최대 범위 수 및 최소 크기, 특정 조건에서 <xref:System.IO.Log.LogStore>를 늘리거나 줄이는 지침 등의 규칙을 규정합니다. 또한 <xref:System.IO.Log.LogStore> 인스턴스를 보관할 수 있는지 여부를 지정할 수 있습니다. 정책은 로그별로 설정되고 일시적입니다. 즉, 로그에 대한 각 핸들이 닫히면 정책이 더 이상 존재하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">현재 <see cref="T:System.IO.Log.LogStore" /> 개체가 캡슐화하는 로그 파일에 대한 파일 핸들입니다.</param>
        <summary>지정된 핸들에 대한 <see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">로그 핸들을 스레드 풀에 바인딩할 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 메서드가 호출된 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</param>
        <param name="mode">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</param>
        <summary>지정된 경로 및 모드를 사용하여 <see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용하여 지정된 경로와 모드로 로그 저장소를 엽니다. 저장소는 읽기/쓰기 권한으로 열리고 읽기 권한을 공유합니다.  
  
 `path` 매개 변수는 다음 구문을 사용해야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="path" />에 공백만 포함된 경우  
  
또는 
 <paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />에 잘못된 값이 포함된 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.IOException">로그 저장소를 열 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우. 사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</param>
        <param name="mode">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</param>
        <param name="access"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</param>
        <summary>지정된 경로, 모드 및 액세스 권한을 사용하여 <see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용하여 지정된 경로, 모드 및 액세스 권한으로 새 로그 저장소를 엽니다. 저장소는 읽기 권한을 공유하여 열립니다.  
  
 `path` 매개 변수는 다음 구문을 사용해야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="path" />에 공백만 포함된 경우  
  
또는 
 <paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />에 잘못된 값이 포함된 경우  
  
-또는- 
 <paramref name="access" />에 잘못된 값이 포함된 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.IOException">로그 저장소를 열 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우. 사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</param>
        <param name="mode">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</param>
        <param name="access"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</param>
        <param name="share">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 <see cref="T:System.IO.FileShare" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 지정된 경로, 모드 및 액세스 권한을 사용하여 여는 새 <xref:System.IO.Log.LogStore> 개체를 초기화합니다. 저장소는 지정된 액세스 권한을 공유하여 열립니다.  
  
 `path` 매개 변수는 다음 구문을 사용해야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="path" />에 공백만 포함된 경우  
  
또는 
 <paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />에 잘못된 값이 포함된 경우  
  
-또는- 
 <paramref name="access" />에 잘못된 값이 포함된 경우  
  
또는 
 <paramref name="share" />에 잘못된 값이 포함된 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.IOException">로그 저장소를 열 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우. 사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">열려는 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</param>
        <param name="mode">저장소를 열거나 만드는 방법을 결정하는 <see cref="T:System.IO.FileMode" /> 값 중 하나입니다.</param>
        <param name="access"><see cref="T:System.IO.FileAccess" />에서 파일에 액세스할 수 있는 방법을 결정하는 <see cref="T:System.IO.Log.LogStore" /> 값 중 하나입니다.</param>
        <param name="share">로그 저장소가 프로세스 간에 공유되는 방법을 결정하는 <see cref="T:System.IO.FileShare" /> 값 중 하나입니다.</param>
        <param name="fileSecurity">저장소를 만들어야 하는 경우 새로 만든 저장소에서 설정할 보안을 지정하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.IO.Log.LogStore" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 지정된 경로, 모드 및 액세스 권한을 사용하여 여는 새 <xref:System.IO.Log.LogStore> 개체를 초기화합니다. 저장소는 지정된 액세스 권한을 공유하여 열립니다. `path` 매개 변수는 다음 구문을 따라야 합니다.  
  
 `log:<physical log name>[::<log client name>]`  
  
 여기서 `<physical log name>`은 로그 파일의 유효한 경로이고 `<log client name>`은 고유한 클라이언트 식별자입니다. 로그 저장소는 실제 로그 저장소나 가상 로그 저장소 중 하나여야 합니다. 로그 저장소를 실제로 만들거나 가상으로 만들면 로그 저장소의 수명이 끝날 때까지 만든 상태로 유지됩니다. 실제 로그 저장소는 실제 로그 이름만 지정하여 만들어지고, 가상 로그 저장소는 실제 로그 이름과 로그 클라이언트 이름을 모두 지정하여 만들어집니다.  
  
 동일한 실제 로그 이름을 공유하는 클라이언트는 동일한 범위 컬렉션과 정책을 공유합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />로 지정된 로그 저장소 파일 이름이 잘못된 경우  
  
또는 
 <paramref name="Mode" />가 쓰기 권한 없이 사용할 수 없는 <see langword="CreateNew" />인 경우  
  
또는 
 <paramref name="Mode" />가 쓰기 권한 없이 사용할 수 없는 <see langword="OpenOrCreate" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />에 잘못된 값이 포함된 경우  
  
-또는- 
 <paramref name="access" />에 잘못된 값이 포함된 경우  
  
또는 
 <paramref name="share" />에 잘못된 값이 포함된 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.IOException">로그 저장소를 열 때 I/O 오류가 발생한 경우  
  
<paramref name="path" />로 지정된 파일을 다른 프로세스에서 사용 중이기 때문에 액세스할 수 없는 경우  
  
또는 
<paramref name="path" />로 지정된 파일이나 디렉터리가 이미 있기 때문에 해당 파일을 만들 수 없는 경우  
  
또는 
로그 핸들을 스레드 풀에 바인딩할 수 없는 경우  
  
또는 
지정된 로그 파일 형식이나 버전이 잘못된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">필요한 CLFS(Common Log File System) 구성 요소가 설치되어 있지 않기 때문에 <see cref="T:System.IO.Log.LogStore" />를 사용할 수 없는 경우. 사용자 플랫폼에 CLFS 구성 요소를 사용할 수 있으면 설치하거나 <see cref="T:System.IO.Log.FileRecordSequence" /> 클래스를 대신 사용합니다.</exception>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 메서드가 호출된 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">레코드 시퀀스가 꽉 찼습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스를 보관할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 <see langword="true" /> 인스턴스를 보관할 수 있으면 <see cref="T:System.IO.Log.LogStore" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore>를 보관할 수 없는 경우 <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> 및 <xref:System.IO.Log.LogStore.SetArchiveTail%2A> 메서드를 호출하면 <xref:System.NotSupportedException>이 throw됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 속성에 액세스한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스에서 유효한 레코드에 해당하는 가장 작은 시퀀스 번호를 가져옵니다.</summary>
        <value>이 <see cref="T:System.IO.Log.LogStore" /> 인스턴스에서 유효한 레코드에 해당하는 가장 작은 시퀀스 번호입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유효한 시퀀스 번호는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>보다 작습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 속성에 액세스한 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>백업을 만드는 데 필요한 로그 저장소 상태의 스냅숏을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>백업을 만들기 위해 로그 저장소 상태의 스냅숏을 만듭니다.</summary>
        <returns>아카이브를 만드는 데 필요한 상태를 포함하는 <see cref="T:System.IO.Log.LogArchiveSnapshot" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">로그 저장소를 보관할 수 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 메서드가 호출된 경우</exception>
        <exception cref="T:System.IO.IOException">아카이브 스냅숏을 만들 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">인수가 잘못된 경우</exception>
        <exception cref="T:System.InvalidOperationException">잘못된 작업을 실행한 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">레코드 시퀀스가 꽉 찼습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first">보관할 범위의 시작 시퀀스 번호입니다.</param>
        <param name="last">보관할 범위의 종료 시퀀스 번호입니다.</param>
        <summary>백업을 만들기 위해 지정된 시퀀스 번호 간의 로그 저장소 상태에 대한 스냅숏을 만듭니다.</summary>
        <returns>아카이브를 만드는 데 필요한 상태를 포함하는 <see cref="T:System.IO.Log.LogArchiveSnapshot" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환된 아카이브 스냅숏은 기준 시퀀스 번호나 아카이브 시퀀스 번호 중 작은 번호부터 마지막 시퀀스 번호 사이의 정보를 포함합니다. 여기에서 마지막 시퀀스 번호는 포함되지 않습니다. 즉, 마지막 시퀀스 번호를 제외하고 그 이전 번호까지의 레코드만 아카이브에 포함됩니다. 또한 이 메서드를 사용할 때 아카이브가 일관성을 유지하려면 시작 SequenceNumber가 BaseSequenceNumber와 같아야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="first" /> 또는 <paramref name="last" />가 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="first" />가 <paramref name="last" />보다 큰 경우</exception>
        <exception cref="T:System.InvalidOperationException">잘못된 작업을 실행한 경우</exception>
        <exception cref="T:System.IO.IOException">아카이브 스냅숏을 만들 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.NotSupportedException">로그 저장소를 보관할 수 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 메서드가 호출된 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">레코드 시퀀스가 꽉 찼습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">제거할 로그 저장소의 기본 파일에 대한 상대 또는 절대 경로입니다.</param>
        <summary>로그 저장소를 제거합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />가 빈 문자열("")인 경우  
  
또는 
 <paramref name="path" />에 공백만 포함된 경우  
  
또는 
 <paramref name="path" />에 하나 이상의 잘못된 문자가 포함된 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.IOException">로그 저장소를 열 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.Log.LogStore" />에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore.Dispose%2A>를 사용한 후에 <xref:System.IO.Log.LogStore>를 호출합니다. <xref:System.IO.Log.LogStore.Dispose%2A> 메서드를 사용하면 <xref:System.IO.Log.LogStore>를 사용할 수 없게 됩니다. <xref:System.IO.Log.LogStore.Dispose%2A>를 호출한 후에 가비지 수집기가 <xref:System.IO.Log.LogStore>에서 차지한 메모리를 회수할 수 있도록 <xref:System.IO.Log.LogStore>에 대한 모든 참조를 해제해야 합니다.  
  
> [!NOTE]
>  <xref:System.IO.Log.LogStore.Dispose%2A>에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.IO.Log.LogStore>를 호출하십시오. 이렇게 하지 않으면 가비지 수집기가 <xref:System.IO.Log.LogStore> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 메서드가 호출된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 로그 저장소에 대한 데이터를 포함하는 로그 범위의 컬렉션을 가져옵니다.</summary>
        <value>이 로그 저장소에 대한 데이터를 캡슐화하는 로그 범위의 컬렉션을 포함하는 <see cref="T:System.IO.Log.LogExtentCollection" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.LogStore> 인스턴스는 <xref:System.IO.Log.LogExtent> 인스턴스가 나타내는 디스크 범위의 컬렉션에 데이터를 저장합니다. 지정된 <xref:System.IO.Log.LogStore> 인스턴스의 범위는 크기가 모두 동일하며 범위가 증가하면 <xref:System.IO.Log.LogStore> 인스턴스에서 공간이 추가되고 제거됩니다. 로그 범위를 추가하고 제거하려면 이 속성에서 반환하는 <xref:System.IO.Log.LogExtentCollection.Add%2A> 개체의 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 및 <xref:System.IO.Log.LogExtentCollection> 메서드를 사용합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로그 저장소에서 사용 가능한 바이트의 수를 가져옵니다.</summary>
        <value>로그 저장소에서 사용 가능한 바이트의 수입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 속성에 액세스한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.IO.Log.LogStore" /> 인스턴스가 캡슐화하는 로그 파일에 대한 운영 체제 파일 핸들을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.IO.Log.LogStore" /> 인스턴스가 캡슐화하는 로그 파일에 대한 운영 체제 파일 핸들입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 로그 저장소에 추가할 다음 레코드의 시퀀스 번호를 가져옵니다.</summary>
        <value>로그 저장소에 추가할 다음 레코드의 시퀀스 번호입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유효한 시퀀스 번호는 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>보다 크거나 같고 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>보다 작습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 속성에 액세스한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로그 저장소의 크기(바이트)를 가져옵니다.</summary>
        <value>로그 저장소의 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로그 저장소의 크기는 로그 범위의 크기를 합한 것입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 속성에 액세스한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 로그 저장소와 연결된 정책을 가져옵니다.</summary>
        <value>이 로그 저장소와 연결된 정책을 나타내는 <see cref="T:System.IO.Log.LogPolicy" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 반환하는 <xref:System.IO.Log.LogPolicy> 인스턴스를 사용하여 이 <xref:System.IO.Log.LogStore>와 연결된 로그 정책을 검사하고 조작할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail">아카이브 테일의 시퀀스 번호입니다.</param>
        <summary>아카이브 테일의 시퀀스 번호를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기준 시퀀스 번호와 아카이브 테일 중 작은 값으로 로그의 테일이 결정됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.Log.LogStore>를 XML 문서에 보관하는 방법을 보여 줍니다.  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" />이 이 시퀀스의 기준 시퀀스 번호와 마지막 시퀀스 번호 사이에 있지 않은 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="archiveTail" />이 이 시퀀스에 유효하지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">잘못된 작업을 실행한 경우</exception>
        <exception cref="T:System.IO.IOException">아카이브 스냅숏을 만들 때 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.NotSupportedException">로그 저장소를 보관할 수 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">시퀀스가 삭제된 후 메서드가 호출된 경우</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족하여 프로그램을 계속 실행할 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">지정된 로그 저장소에 대한 액세스가 운영 체제에서 거부된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 로그 저장소의 로그 스트림 수를 가져옵니다.</summary>
        <value>이 로그 저장소의 로그 스트림 수입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>