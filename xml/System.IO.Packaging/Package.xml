<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="277b1344a360222f54b6cbd21a9f82498043593d" /><Meta Name="ms.sourcegitcommit" Value="c902e847cd05ac37d93eca981b0fb009aae0a790" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/28/2018" /><Meta Name="ms.locfileid" Value="52455045" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>여러 데이터 개체를 저장할 수 있는 컨테이너를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> 단일 엔터티로 이식성과 효율적인 액세스에 대 한 실제 정의 된 형식의 개체를 구성 하는 추상 클래스입니다.  
  
 ZIP 파일은 기본 실제 형식에 대 한는 <xref:System.IO.Packaging.Package>합니다.  다른 <xref:System.IO.Packaging.Package> 구현 XML 문서, 데이터베이스 등의 다른 실제 형식을 사용 하 여 또는 웹 서비스 수 있습니다.  
  
 같은 파일 시스템에 포함 된 항목을 <xref:System.IO.Packaging.Package> 파일과 폴더의 계층 구조에서 참조 됩니다.  
  
 하지만 <xref:System.IO.Packaging.Package> 자체는 추상 클래스는 <xref:System.IO.Packaging.ZipPackage> 파생된 클래스에서 기본적으로 사용 됩니다는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 A <xref:System.IO.Packaging.PackagePart> ("파트")에 저장 된 개체를 나타내는 추상 클래스는를 <xref:System.IO.Packaging.Package>입니다.  
  
 A <xref:System.IO.Packaging.PackageRelationship> ("관계")을 원본 간의 연결을 정의 <xref:System.IO.Packaging.Package> 또는 <xref:System.IO.Packaging.PackagePart> 와 대상 개체입니다.  <xref:System.IO.Packaging.PackageRelationship> 두 가지 형식 중 하나일 수 있습니다 각 두 형식 중 하나일 수 있습니다.  
  
-   패키지 수준 관계를 (만든 합니다 <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> 메서드) 연결을 <xref:System.IO.Packaging.Package> 를:  
  
    -   패키지의 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
-   파트 수준 관계 (만든 합니다 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> 메서드) 원본 관련 <xref:System.IO.Packaging.PackagePart> 에:  
  
    -   패키지의 다른 대상 부분입니다.  
  
    -   패키지 외부의 대상 리소스입니다.  
  
 관계의 원본 <xref:System.IO.Packaging.Package> 또는 원본 <xref:System.IO.Packaging.PackagePart> 관계의 "소유자"로 간주 됩니다.  원본 개체를 삭제 하는 경우 원본 개체를 소유한 모든 관계도 삭제 됩니다.  만들기 또는 관계를 삭제 하면 프로세스는 어떤 방식으로 원본 또는 대상 개체를 물리적으로 변경 되지 않습니다.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("디지털 시그니처")가 파트 및 관계에 포함 된 디지털 서명을 나타내는 결합을 <xref:System.IO.Packaging.Package>입니다.  디지털 서명은 송신자를 식별 하 고 서명 된 파트 및 관계에 포함 되도록의 유효성을 검사 합니다 <xref:System.IO.Packaging.Package> 수정 되지 않은 합니다.  
  
 패키지에도 관리 DRM (디지털 권한)의 콘텐츠 요소는 지원를 <xref:System.IO.Packaging.Package> 권한 있는 사용자에 게 부여 하는 특정 액세스 권한을 사용 하 여 암호화 되도록 합니다.  
  
 기반으로 합니다 <xref:System.IO.Packaging.Package> 아키텍처는 <xref:System.Windows.Xps.Packaging.XpsDocument> 열기를 기반으로 문서를 저장 하기 위한 패키지 형식인 [사양 XPS (XML Paper)](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework에서는 패키지 콘텐츠, 리소스 및 페이지 및 기본적으로 표준 ZIP 파일을 사용 하 여 문서에 대 한 관계를 저장 합니다. 모든 ZIP 파일을 사용 하 여 응용 프로그램 사용할 수는 <xref:System.IO.Packaging> 저장 하 고 필요에 따라 액세스를 효율적으로 하나의 컨테이너에 데이터 파일의 여러 또는 모든 형식을 보호 하는 클래스입니다.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 만드는 기본 단계는 <xref:System.IO.Packaging.Package>합니다.  이 예제에서는 문서의 일부로 표시 되는 그래픽 이미지와 함께 문서를 포함 하는 패키지가 만들어집니다.  (이 HTML 파일에 지정 된 경우 비슷합니다는 \<i m G > 외부 이미지 파일을 참조 하는 태그입니다.)  두 <xref:System.IO.Packaging.PackageRelationship> 요소 패키지에도 포함 됩니다.  첫 번째 "패키지 수준" 관계를 패키지의 루트 요소로 문서 파트를 정의합니다.  두 번째, "파트 수준" 관계 문서 파트 (파트 수준 관계의 "원본") 및 이미지 파트 (파트 수준 관계의 "대상")의 사용 간의 연결을 정의 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">패키징 규칙 (OPC) 사양 열기</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Open Packaging Conventions의 디지털 서명 프레임 워크</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.Packaging.Package" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">패키지의 파일 IO 권한입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Packaging.Package" />를 사용하는 <see cref="T:System.IO.FileAccess" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 protected 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="openFileAccess" />의 값이 올바르지 않은 경우</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">패키지의 파일 IO 권한입니다.</param>
        <param name="streaming">스트리밍을 위해 패키지를 여는 경우 <see langword="true" />, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.Packaging.Package" /> 및 스트리밍 옵션을 사용하는 <see cref="T:System.IO.FileAccess" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 protected 생성자는 <xref:System.IO.Packaging.Package> 추상 기본 추상 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <xref:System.IO.Packaging.Package.%23ctor%2A> 생성자는 파생된 클래스의 새 인스턴스를 초기화 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="openFileAccess" />의 값이 올바르지 않은 경우</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>패키지 및 모든 내부 파트 스트림을 저장하고 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Close%2A> 하 고 <xref:System.IO.Packaging.Package.Dispose%2A> 동일한 작업을 수행-호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대로 합니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
> [!NOTE]
>  `using` 문 (다릅니다 합니다 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다.  [패키지 예제 추가 정보를 작성](https://go.microsoft.com/fwlink/?LinkID=160055) 및 [는 패키지 예제 추가 정보를 읽는](https://go.microsoft.com/fwlink/?LinkID=160034) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여는 `using` 문.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 패키지 파트를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 파트에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 파트와 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.1 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 실제로 파트를 만드는 메서드를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">새 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="contentType">데이터 스트림의 콘텐츠 형식입니다.</param>
        <summary>지정된 URI 및 콘텐츠 형식으로 압축되지 않은 새 파트를 만듭니다.</summary>
        <returns>새로 만들어진 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 초기화 <xref:System.IO.Stream> 새 파트에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 파트와 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 파트 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 는 <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>합니다.  
  
 패키지 파트에 대 한 자세한 내용은 1.1 OPC Open Packaging Conventions () 사양의 섹션 다운로드할 수 있는 참조 하세요. <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> 또는 <paramref name="contentType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="partUri" />의 파트가 이미 패키지에 있는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 파트를 추가할 수 없습니다.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 실제로 파트를 만드는 메서드를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">새 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="contentType">데이터 스트림의 콘텐츠 형식입니다.</param>
        <param name="compressionOption">데이터 스트림의 압축 옵션으로 <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> 또는 <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> 압축입니다.</param>
        <summary>지정된 URI, 콘텐츠 형식 및 압축 옵션으로 새 파트를 만듭니다.</summary>
        <returns>새로 만들어진 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePart%2A> 메서드는 지원 두 `compressionOption` 값을 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 의 값 <xref:System.IO.Packaging.CompressionOption.Maximum>를 <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 하 여 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> 빈 만듭니다 <xref:System.IO.Stream> 새 파트에 대 한 합니다.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> 메서드 파트와 연결 된 스트림 인스턴스에 대 한 참조를 가져오는 데 사용할 수 있습니다.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.PackagePart> 다음 부분에 데이터를 저장 합니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> 또는 <paramref name="contentType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="partUri" />의 파트가 이미 패키지에 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="compressionOption" /> 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 파트를 추가할 수 없습니다.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 실제로 파트를 만드는 메서드를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">만들 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="contentType">데이터 스트림의 콘텐츠 형식입니다.</param>
        <param name="compressionOption">데이터 스트림의 압축 옵션입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 패키지에서 새 파트를 만듭니다.</summary>
        <returns>만들어진 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드를 호출 합니다 <xref:System.IO.Packaging.Package.CreatePart%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 파트를 만드는 방법.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.CreatePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에 새 파트를 만드는 클래스입니다.  
  
 기본 <xref:System.IO.Packaging.ZipPackage> 파생 클래스는 <xref:System.IO.Packaging.Package.CreatePartCore%2A> 메서드는 지원 두 `compressionOption` 값을 <xref:System.IO.Packaging.CompressionOption.NotCompressed> 또는 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  다른 <xref:System.IO.Packaging.CompressionOption> 의 값 <xref:System.IO.Packaging.CompressionOption.Maximum>를 <xref:System.IO.Packaging.CompressionOption.Fast>, 또는 <xref:System.IO.Packaging.CompressionOption.SuperFast> 사용 하 여 <xref:System.IO.Packaging.CompressionOption.Normal> 압축 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> 메서드를 호출 합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 파트에 대한 패키지 수준 관계를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간의 <xref:System.IO.Packaging.Package> 대상 <xref:System.IO.Packaging.PackagePart> 패키지에 포함 합니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 및 루트 문서 파트입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">대상 파트가 패키지에 <see cref="F:System.IO.Packaging.TargetMode.Internal" />인지 또는 <see cref="F:System.IO.Packaging.TargetMode.External" />인지를 나타냅니다.</param>
        <param name="relationshipType">관계의 역할을 고유하게 정의하는 URI입니다.</param>
        <summary>지정된 URI, 대상 모드 및 관계 형식을 가진 파트에 대한 패키지 수준 관계를 만듭니다.</summary>
        <returns>지정된 파트에 대한 패키지 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 실제로 변경 하지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스입니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 으로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 여야 합니다 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI로 시작 하는 슬래시 ("/") 문자 같은 중 하나는 절대 경로 수 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")에서 기본 URI로 확인 하는 합니다.  
  
 하는 경우 `targetMode` 로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 하거나 절대 또는 상대 URI에 따라 구성 합니다 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다. `http://www.microsoft.com/page2.xml` "page2.xml" 외부 대상 리소스를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"은 예를 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해 참조 되는 상대 URI입니다.  
  
 `relationshipType` 이어야 합니다는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형성 된 합니다 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` OPC Open Packaging Conventions () 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|디지털 서명|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|디지털 서명 인증서|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|디지털 서명 원본|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|미리 보기|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 패키징 및 패키지 관계에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려면를 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 및 루트 문서 파트입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="targetUri" /> 파트가 <see cref="T:System.IO.Packaging.PackageRelationship" />이거나 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />이고 <paramref name="targetUri" />가 절대 URI인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetMode" />의 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">대상 파트가 패키지에 <see cref="F:System.IO.Packaging.TargetMode.Internal" />인지 또는 <see cref="F:System.IO.Packaging.TargetMode.External" />인지를 나타냅니다.</param>
        <param name="relationshipType">관계의 역할을 고유하게 정의하는 URI입니다.</param>
        <param name="id">고유 XML 식별자입니다.</param>
        <summary>지정된 URI, 대상 모드, 관계 형식 및 [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)]를 가진 파트에 대한 패키지 수준 관계를 만듭니다.</summary>
        <returns>지정된 파트에 대한 패키지 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 실제로 변경 하지 않습니다 대상 파트 또는 어떤 방식으로든에서 리소스입니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 `id` 올바른 XML 식별자 여야 합니다.  `id` 형식은 xsd: id 이며 XML Schema Part 2에 설명 된 명명 규칙을 준수 해야 합니다: 데이터 형식 지정 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 하는 경우 `id` 으로 지정 된 `null` 고유 ID가 자동으로 생성 됩니다.  `id` 빈으로 지정 된 문자열이 올바르지 않습니다.  
  
 경우 `targetMode` 으로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 여야 합니다 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  내부 상대 URI로 시작 하는 슬래시 ("/") 문자 같은 중 하나는 절대 경로 수 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")에서 기본 URI로 확인 하는 합니다.  
  
 하는 경우 `targetMode` 로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 하거나 절대 또는 상대 URI에 따라 구성 합니다 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다. `http://www.microsoft.com/page2.xml` "page2.xml" 외부 대상 리소스를 참조 하는 절대 URI의 예시입니다.  "images/picture1.jpg"은 예를 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해 참조 되는 상대 URI입니다.  
  
 `relationshipType` 에 따라 구성 되는 URI 여야 합니다 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  다음 표에서 패키지 수준 `relationshipType` OPC Open Packaging Conventions () 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|디지털 서명|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|디지털 서명 인증서|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|디지털 서명 원본|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|미리 보기|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3을 참조 하세요. <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법 <xref:System.IO.Packaging.Package.CreateRelationship%2A> 만들려면를 <xref:System.IO.Packaging.PackageRelationship> 간에 <xref:System.IO.Packaging.Package> 및 루트 문서 파트입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="targetUri" /> 파트가 <see cref="T:System.IO.Packaging.PackageRelationship" />이거나 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />이고 <paramref name="targetUri" />가 절대 URI인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetMode" />의 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아니거나 지정된 <paramref name="id" />의 파트가 이미 패키지에 있는 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">삭제할 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <summary>패키지에서 지정된 URI의 파트를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 ("/") 문자로 시작 되는 절대 경로로 구성 된 상대 URI 여야 합니다.  패키지 루트에 상대적인 이며에 따라 형식이 절대 경로 [RFC 3986](https://tools.ietf.org/html/rfc3986) 제네릭 구문 식별자 URI (Uniform Resource) 사양입니다.  "/ page1.xaml" 및 "/ images/picture4.jpg"은 유효한 파트 Uri의 예입니다.  
  
 예외가 발생 하는 경우 지정 된 일부 `partUri` 패키지가 아닙니다.  (사용할 수는 <xref:System.IO.Packaging.Package.PartExists%2A> 하는지 여부 지정된 된 부분을 결정 하는 방법 `partUri` 패키지에 있습니다.)  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 실제로 파트를 삭제 하는 방법입니다.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">삭제할 <see cref="P:System.IO.Packaging.PackagePart.Uri" />의 <see cref="T:System.IO.Packaging.PackagePart" />입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 URI의 파트를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 추상 클래스 구현을 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.DeletePart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.DeletePartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> 실제 수행 하는 클래스 파생된 클래스에서 구현 된 실제 형식에 따라 작업을 삭제 합니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 구현을 호출 합니다 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 메서드는 지정 된 파트를 파생된 클래스에서 구현 된 실제 형식에 기반 합니다.  
  
파생 <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> 메서드를 호출 합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">삭제할 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />의 <see cref="T:System.IO.Packaging.PackageRelationship" />입니다.</param>
        <summary>패키지 수준 관계를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  
  
 예외가 발생 하는 경우 지정 된 관계 `id` 패키지가 아닙니다.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> 실제로 어떤 방식으로든에서 대상 파트를 변경 하지 않습니다.  
  
 패키지 관계에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary>모든 파트 및 관계의 콘텐츠를 플러시 및 저장하고, 패키지를 닫고, 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 변경 내용이 올바르게 저장는 되도록 <xref:System.IO.Packaging.Package.Dispose%2A> 도 종료, 플러시, 및 모든 파트 및 패키지에 포함 된 관계를 닫습니다.  
  
 에 대 한는 <xref:System.IO.Packaging.Package> 클래스 <xref:System.IO.Packaging.Package.Dispose%2A> 하 고 <xref:System.IO.Packaging.Package.Close%2A> 같은 작업을 수행할-호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Dispose%2A> 호출 하는 경우 <xref:System.IO.Packaging.Package.Close%2A>, 또는 그 반대로 합니다.  
  
 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.Flush%2A>합니다.  
  
 할당 및 메모리 내 리소스를 관리 하는 파생된 클래스에서 리소스를 해제 하려면이 메서드를 재정의 하는 경우 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 합니다. 파생 클래스 재정의 호출 해야 <xref:System.IO.Packaging.Package.Flush%2A> 기본 클래스 및 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드는 항상 해당 기본 클래스 정리를 수행 해야 합니다.  
  
> [!NOTE]
>  `using` 문 (다릅니다 합니다 `using` 네임 스페이스 지시문) 하는 권장 방법은 <xref:System.IO.Packaging.Package.Close%2A> 및 <xref:System.IO.Packaging.Package.Dispose%2A> 패키지 합니다. [패키지 예제 추가 정보를 작성](https://go.microsoft.com/fwlink/?LinkID=160055) 닫고를 사용 하 여 패키지를 삭제 하는 방법을 보여 줍니다는 `using` 문입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>패키지의 파일 액세스 설정을 가져옵니다.</summary>
        <value><see cref="T:System.IO.FileAccess" />의 <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, 또는 <see cref="F:System.IO.FileAccess.ReadWrite" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FileOpenAccess%2A> 속성에는 기본값이 없습니다.  에 지정 된 파일 액세스 설정을 <xref:System.IO.Packaging.Package.%23ctor%2A> 새 패키지를 만들 때 또는 생성자 호출을 <xref:System.IO.Packaging.Package.Open%2A> 기존 패키지를 열 때 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>패키지에 포함된 모든 파트 및 관계의 콘텐츠를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스의 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> 실제 형식에 따른 플러시 작업을 수행 하려면 구현 합니다.  파생된 클래스의 <xref:System.IO.Packaging.Package.FlushCore%2A> 메서드는 실제로 특정 파생된 클래스에서 실제 구현에 파트 및 관계 콘텐츠를 저장 하는 일을 담당 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다. 기본 작업에 <xref:System.IO.Packaging.Package.Flush%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.FlushCore%2A> ZIP 파일 패키지에 파트 및 관계를 저장 합니다.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> 자동으로 호출 되는 <xref:System.IO.Packaging.Package.Close%2A> 고 <xref:System.IO.Packaging.Package.Dispose%2A> 메서드.  때 <xref:System.IO.Packaging.Package.Close%2A> 나 <xref:System.IO.Packaging.Package.Dispose%2A> 라고 호출할 필요가 없습니다 <xref:System.IO.Packaging.Package.Flush%2A> 개별적으로 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용이며 수정할 수 없는 경우</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> 파생된 클래스의 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 파트를 플러시합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에 재정의되는 경우 모든 파트 및 관계의 콘텐츠를 파생 클래스 저장소에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> 호출한는 <xref:System.IO.Packaging.Package.Flush%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 실제 플러시 작업을 수행 하는 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 <see cref="M:System.IO.Packaging.Package.FlushCore" /> 구현에는 주문 또는 수행한 작업에 대 한 어떠한가 정도 사용 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.Flush" /> 메서드를 호출 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">반환할 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <summary>지정된 URI의 파트를 반환합니다.</summary>
        <returns>지정된 <paramref name="partUri" />의 파트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> 없으면 지정 된 일부 예외가 `partUri` 존재 하지 않습니다.  
  
 합니다 <xref:System.IO.Packaging.Package.PartExists%2A> 메서드를 결정할 수 있는지 여부를 `partUri` 기존 파트를 참조 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 요청 된 일부를 반환 하는 클래스입니다.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 찾기, 검색 및 패키지에 포함 된 부분을 읽는 방법을 보여 줍니다.  전체 샘플을 참조 하세요 [는 패키지 예제 추가 정보를 읽는](https://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="partUri" />의 파트가 패키지에 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 파트를 플러시합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">검색할 파트의 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 URI로 확인되는 파트를 반환합니다.</summary>
        <returns>요청된 파트, 또는 지정된 <paramref name="partUri" />의 파트가 패키지에 있지 않은 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetPart%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 파트를 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생된 클래스 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 구현을 호출 합니다 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 액세스 하 고 지정 된 부분을 반환 합니다.  
  
파생 <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> 메서드를 호출 합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>패키지에 있는 모든 파트의 컬렉션을 반환합니다.</summary>
        <returns>패키지에 포함된 모든 <see cref="T:System.IO.Packaging.PackagePart" /> 요소의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> 포함 하는 패키지에 포함 된 모든 파트의 컬렉션을 반환 <xref:System.IO.Packaging.PackageRelationship> 부분입니다.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> 반환 하지 것입니다 `null`있지만 반환된 된 컬렉션 패키지 파트가 없는 경우 요소가 포함 됩니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 기본 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetParts%2A> 호출을 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 메서드는 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 부분을 반환 하는 클래스입니다.  
  
 패키지와 패키지 파트에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.1 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 합니다 <xref:System.IO.Packaging.Package.GetParts%2A> 에 포함 된 파트의 컬렉션을 가져옵니다 메서드를 <xref:System.IO.Packaging.Package>입니다.  완성 된 프로그램 소스 코드를 참조 하세요 [디지털 서명 샘플을 사용 하 여 패키지를 만드는](https://go.microsoft.com/fwlink/?LinkID=159966)합니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> 파생된 클래스를 내부적으로 호출 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 파트를 플러시합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 패키지에 있는 모든 파트의 배열을 반환합니다.</summary>
        <returns>패키지에 포함된 모든 파트의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스 <xref:System.IO.Packaging.Package.GetPartsCore%2A> 구현을 호출 합니다 <xref:System.IO.Packaging.Package.GetParts%2A> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 액세스 하 고 파트의 배열을 반환 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.ZipPackage> 구현의 추상 파생 <xref:System.IO.Packaging.Package> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <xref:System.IO.Packaging.Package.GetParts%2A> 내부적으로 호출 <xref:System.IO.Packaging.Package.GetPartCore%2A> 의 <xref:System.IO.Packaging.ZipPackage> ZIP 파일에서 파트를 검색 하는 클래스입니다.  
  
 모델 패키지 및 패키지 파트에 대 한 자세한 내용은 OPC Open Packaging Conventions () 사양에서 다운로드할 수 있습니다 1 장 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="M:System.IO.Packaging.Package.GetParts" /> 메서드를 호출 합니다.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">반환할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 식별자를 가진 패키지 수준 관계를 반환합니다.</summary>
        <returns>지정된 <paramref name="id" />의 패키지 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 올바른 XML 식별자 여야 합니다. 합니다 `id` 형식은 xsd: id 이며에 지정 된 명명 규칙을 따라야 합니다 [3.3.8 XML Schema Part 2의 섹션: 데이터 형식 지정](https://www.w3.org/TR/xmlschema-2/#ID)합니다.  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3을 참조 하세요. <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 관계가 패키지에 없는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 패키지 수준 관계의 컬렉션을 반환합니다.</summary>
        <returns>패키지에 포함된 모든 패키지 수준 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 반환 하지 것입니다 `null`그러나 반환된 된 컬렉션 패키지에 패키지 수준 관계가 없는 경우 요소가 포함 될 수 있습니다.  
  
 패키지 수준 관계를 패키지와 연결 된 대상 파트 또는 리소스 간의 연결을 정의 합니다.  패키지 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지는 대상 파트.  
  
-   간에 <xref:System.IO.Packaging.Package> 패키지 외부의 대상 리소스에 있습니다.  
  
 패키지 관계를 패키지 관계의 "소유자"로 간주 됩니다.  패키지 삭제 되 면 패키지를 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 패키지 및 패키지 관계에 대 한 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양의 섹션 1.3을 참조 하세요. <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">컬렉션에서 일치하고 반환할 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />에 일치하는 모든 패키지 수준 관계의 컬렉션을 반환합니다.</summary>
        <returns>지정된 <paramref name="relationshipType" />에 일치하는 패키지 수준 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> 반환 하지 것입니다 `null`그러나 반환 된 컬렉션에 지정 된 일치 하는 패키지 수준 관계가 없는 경우 요소가 포함 될 수 있습니다 `relationshipType`합니다.  
  
 다음 표에서 패키지 수준 `relationshipType` OPC Open Packaging Conventions () 사양에 정의 된 Uri입니다.  
  
|패키지 수준 관계|관계 유형 URI|  
|---------------------------------|---------------------------|  
|핵심 속성|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|디지털 서명|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|디지털 서명 인증서|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|디지털 서명 원본|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|미리 보기|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 패키지에 대해 정의 된 관계를 검색 하는 방법을 보여 줍니다.  전체 샘플을 참조 하세요 [는 패키지 예제 추가 정보를 읽는](https://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>패키지를 엽니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">패키지를 열 IO 스트림입니다.</param>
        <summary>지정된 IO 스트림에서 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">열려는 패키지에 읽기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우 또는 열려는 패키지에 쓰기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <summary>지정된 경로 및 파일 이름에서 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 사용 하 여 패키지를 엽니다 <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, 및 <xref:System.IO.FileShare.None> (되도록 서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나).  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">패키지를 열 IO 스트림입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <summary>지정된 IO 스트림 및 파일 모드를 사용하여 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" /> 값이 잘못된 경우</exception>
        <exception cref="T:System.IO.IOException">열려는 패키지에 읽기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우 또는 열려는 패키지에 쓰기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <summary>지정된 경로의 패키지를 지정된 파일 모드를 사용하여 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이렇게 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본 특성을 사용 하 여 패키지를 엽니다 <xref:System.IO.FileAccess.ReadWrite> 및 <xref:System.IO.FileShare.None> (서로 다른 특성을 사용 하 여 다른 Open 메서드 오버 로드 중 하나를 지정) 하 합니다.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" />의 값이 올바르지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">패키지를 열 IO 스트림입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <param name="packageAccess">패키지를 열 때 사용할 파일 액세스 권한입니다.</param>
        <summary>지정된 IO 스트림, 파일 모드 및 파일 액세스 설정을 사용하여 패키지를 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" /> 또는 <paramref name="packageAccess" />의 값이 올바르지 않은 경우</exception>
        <exception cref="T:System.IO.IOException">열려는 패키지에 읽기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우 또는 열려는 패키지에 쓰기 또는 읽기/쓰기 권한이 필요하고 지정된 <paramref name="stream" />이 읽기 전용인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <param name="packageAccess">패키지를 열 때 사용할 파일 액세스 권한입니다.</param>
        <summary>지정된 경로의 패키지를 지정된 파일 모드 및 파일 액세스 설정을 사용하여 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 이 <xref:System.IO.Packaging.Package.Open%2A> 메서드는 기본값을 사용 하 여 패키지를 엽니다 <xref:System.IO.FileShare.None> 특성 (다른 특성 사용법을 지정 하는 <xref:System.IO.Packaging.Package.Open%2A> 메서드 오버 로드).  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 열고 읽는 방법을 <xref:System.IO.Packaging.Package> 포함 된 <xref:System.IO.Packaging.PackageRelationship> 및 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [는 패키지 예제 추가 정보를 읽는](https://go.microsoft.com/fwlink/?LinkID=160034)합니다.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" /> 또는 <paramref name="packageAccess" />의 값이 올바르지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">패키지의 경로 및 파일 이름입니다.</param>
        <param name="packageMode">패키지를 열 때 사용할 파일 모드입니다.</param>
        <param name="packageAccess">패키지를 열 때 사용할 파일 액세스 권한입니다.</param>
        <param name="packageShare">패키지를 열 때 사용할 파일 공유 모드입니다.</param>
        <summary>지정된 경로의 패키지를 지정된 파일 모드, 파일 액세스 및 파일 공유 설정을 사용하여 엽니다.</summary>
        <returns>열린 패키지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> 사용 되는 기본 패키지 형식는 <xref:System.IO.Packaging.Package.Open%2A> 메서드.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
   
  
## Examples  
 다음 예제에서는 새로 만드는 방법을 보여 줍니다 <xref:System.IO.Packaging.Package> 를 통합 하는 <xref:System.IO.Packaging.PackageRelationship> 고 <xref:System.IO.Packaging.PackagePart> 저장 된 데이터와 함께 요소입니다.  전체 샘플을 참조 하세요 [패키지 작성 샘플](https://go.microsoft.com/fwlink/?LinkID=160055)합니다.  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packageMode" />, <paramref name="packageAccess" /> 또는 <paramref name="packageShare" />의 값이 올바르지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>패키지의 핵심 속성을 가져옵니다.</summary>
        <value>패키지의 핵심 속성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핵심 패키지 속성에 대 한 자세한 내용은 참조에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양 단원 3.1 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">확인할 파트의 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 URI의 파트가 패키지에 있는지 여부를 나타냅니다.</summary>
        <returns>지정된 <paramref name="partUri" />의 파트가 패키지에 있으면 <see langword="true" />, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 슬래시 문자로 시작 해야 "/" 및 패키지의 루트에서 절대 경로 여야 합니다.  
  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 정보를 읽을 수 없습니다.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">확인할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 ID의 패키지 수준 관계가 패키지에 포함되어 있는지 여부를 나타냅니다.</summary>
        <returns>지정된 <paramref name="id" />의 패키지 수준 관계가 패키지에 있으면 <see langword="true" />, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은에서 다운로드할 수 있는 OPC Open Packaging Conventions () 사양을 참조 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.ObjectDisposedException">패키지가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 인프라를 지원하는 것으로 응용 프로그램에서는 사용하지 않는 것이 좋습니다.  형식이 안전한 <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 메서드를 대신 사용하세요.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>