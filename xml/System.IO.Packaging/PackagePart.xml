<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata><Meta Name="ms.openlocfilehash" Value="686c39d59573923eafb56ef7b811e4e911ac8496" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56774652" /></Metadata><TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <TypeSignature Language="F#" Value="type PackagePart = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><see cref="T:System.IO.Packaging.Package" />에 저장되는 파트에 대한 기본 클래스를 제공합니다.  이 클래스는 추상 클래스입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart> 세 가지 기본 요소로 구성 됩니다.  
  
|액세스|설명|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 파트입니다.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|[!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 스트림의 유형입니다.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|파트의 콘텐츠 데이터 스트림입니다.|  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.Packaging.PackagePart" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [WPF의 Pack URI](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [Open Packaging 규칙 사양](https://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">파트의 부모 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="partUri">부모 <see cref="T:System.IO.Packaging.Package" /> 루트에 상대적인 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <summary>지정된 부모 <see cref="T:System.IO.Packaging.PackagePart" /> 및 파트 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]를 사용하여 <see cref="P:System.IO.Packaging.PackagePart.Package" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 유효 해야 <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양 및 [Open Packaging 규칙](https://go.microsoft.com/fwlink/?LinkID=71255) 사양입니다.  
  
 이 생성자를 사용 하 여 때를 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 부분의 즉시 인식 되지 않으며 설정이 적용 됩니다 나중 경우 <xref:System.IO.Packaging.Package.CreatePart%2A> 라고 합니다.  
  
 기본적으로 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 파트의 속성은 초기화 <xref:System.IO.Packaging.CompressionOption.NotCompressed>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> 또는 <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">파트의 부모 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="partUri">부모 <see cref="T:System.IO.Packaging.Package" /> 루트에 상대적인 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="contentType">파트 데이터 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식입니다.</param>
        <summary>지정된 부모 <see cref="T:System.IO.Packaging.PackagePart" />, 파트 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 및 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식을 사용하여 <see cref="P:System.IO.Packaging.PackagePart.Package" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 유효 해야 <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양 및 [Open Packaging 규칙](https://go.microsoft.com/fwlink/?LinkID=71255) 사양입니다.  
  
 기본적으로 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 파트의 속성은 초기화 <xref:System.IO.Packaging.CompressionOption.NotCompressed>합니다.  
  
 `contentType` 이어야 합니다는 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 유형은 따라 형성 합니다 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-HTTP*, 섹션 3.7.  다음 표에서 콘텐츠의 예를 보여 줍니다 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 에서 사용 되는 형식 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] 문서.  
  
|설명|콘텐츠 형식|  
|-----------------|------------------|  
|글꼴|application/vnd.ms-opentype|  
|ICC 프로필|application/vnd.ms-color.iccprofile|  
|JPEG 이미지|이미지/jpeg|  
|난독 처리 된 글꼴|application/vnd.ms-package.obfuscated-opentype|  
|PNG 이미지|이미지/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|TIFF 이미지|tiff 이미지 /|  
|Windows 미디어 사진 이미지|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> 또는 <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType, compressionOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">파트의 부모 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="partUri">부모 <see cref="T:System.IO.Packaging.Package" /> 루트에 상대적인 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="contentType">파트 데이터 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식입니다.</param>
        <param name="compressionOption">파트 데이터 스트림의 압축 옵션입니다.</param>
        <summary>지정된 부모 <see cref="T:System.IO.Packaging.PackagePart" />, 파트 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식 및 <see cref="P:System.IO.Packaging.PackagePart.Package" />을 사용하여 <see cref="T:System.IO.Packaging.CompressionOption" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` 유효 해야 <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양 및 [Open Packaging 규칙](https://go.microsoft.com/fwlink/?LinkID=71255) 사양입니다.  
  
 `contentType` 이어야 합니다는 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 유형은 따라 형성 합니다 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-HTTP*, 섹션 3.7.  다음 표에서 콘텐츠의 예를 보여 줍니다 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 에서 사용 되는 형식 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] 문서.  
  
|설명|콘텐츠 형식|  
|-----------------|------------------|  
|글꼴|application/vnd.ms-opentype|  
|ICC 프로필|application/vnd.ms-color.iccprofile|  
|JPEG 이미지|이미지/jpeg|  
|난독 처리 된 글꼴|application/vnd.ms-package.obfuscated-opentype|  
|PNG 이미지|이미지/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|TIFF 이미지|tiff 이미지 /|  
|Windows 미디어 사진 이미지|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> 또는 <paramref name="partUri" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" />는 유효한 <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]가 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="compressionOption" /> 값이 올바르지 않은 경우</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberSignature Language="F#" Value="member this.CompressionOption : System.IO.Packaging.CompressionOption" Usage="System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파트 콘텐츠 스트림의 압축 옵션을 가져옵니다.</summary>
        <value>파트 콘텐츠 스트림의 압축 옵션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  생성자에 의해 설정 된 후의 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.IO.Packaging.PackagePart.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식을 가져옵니다.</summary>
        <value>파트에 대한 콘텐츠 데이터 스트림의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  생성자에 의해 설정 된 후의 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 변경할 수 없습니다.  
  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 속성은는 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식에 따라 구성 합니다 [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol-HTTP*, 섹션 3.7.  다음 표에서 콘텐츠의 예를 보여 줍니다 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 에서 사용 되는 형식 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] 문서.  
  
|설명|콘텐츠 형식|  
|-----------------|------------------|  
|글꼴|application/vnd.ms-opentype|  
|ICC 프로필|application/vnd.ms-color.iccprofile|  
|JPEG 이미지|이미지/jpeg|  
|난독 처리 된 글꼴|application/vnd.ms-package.obfuscated-opentype|  
|PNG 이미지|이미지/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|TIFF 이미지|tiff 이미지 /|  
|Windows 미디어 사진 이미지|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)  
  
또는 
파생 클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> 메서드에서 반환한 문자열이 비어 있는 경우</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 <see cref="T:System.IO.Packaging.PackagePart" />와 지정된 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파트 수준 관계를이 파트와 대상 파트 또는 리소스 간의 연결을 정의 합니다.  파트 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   원본 간의 <xref:System.IO.Packaging.PackagePart> 대상 <xref:System.IO.Packaging.PackagePart> 안에 <xref:System.IO.Packaging.Package>.  
  
-   원본 간 <xref:System.IO.Packaging.PackagePart> 패키지 외부의 대상 리소스에 있습니다.  
  
 파트 관계에서 원본 파트는 관계의 "소유자" 간주 됩니다.  소스 파트를 삭제 하면이 파트에서 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> 메서드 소스 파트 또는 대상 파트 또는 어떤 방식으로든에서 리소스 실제로 변경 하지 않습니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 패키지 관계에 대 한 자세한 내용은 1.3 섹션을 참조 합니다 *OPC Open Packaging Conventions ()* 사양에서 다운로드할 수 있습니다 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 자세한 내용은 XPS 문서 참조에 대 한 합니다 *오픈 사양 XPS (XML Paper)* 에서 다운로드할 수 있습니다 <https://go.microsoft.com/fwlink/?LinkID=67000>합니다.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">열거형 값 중 하나입니다. 예를 들어 대상 파트가 <see cref="F:System.IO.Packaging.TargetMode.Internal" /> 내부에 있으면 <see cref="T:System.IO.Packaging.Package" />이고, 대상이 <see cref="F:System.IO.Packaging.TargetMode.External" /> 외부의 리소스이면 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="relationshipType">관계의 역할입니다.</param>
        <summary>이 <see cref="T:System.IO.Packaging.PackagePart" />와 지정된 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계를 만듭니다.</summary>
        <returns>이 <see cref="T:System.IO.Packaging.PackagePart" />와 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파트 수준 관계를이 파트와 대상 파트 또는 리소스 간의 연결을 정의 합니다.  파트 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   원본 간의 <xref:System.IO.Packaging.PackagePart> 대상 <xref:System.IO.Packaging.PackagePart> 안에 <xref:System.IO.Packaging.Package>.  
  
-   원본 간 <xref:System.IO.Packaging.PackagePart> 패키지 외부의 대상 리소스에 있습니다.  
  
 파트 관계에서 원본 파트는 관계의 "소유자" 간주 됩니다.  소스 파트를 삭제 하면이 파트에서 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> 메서드 소스 파트 또는 대상 파트 또는 어떤 방식으로든에서 리소스 실제로 변경 하지 않습니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 여야 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양입니다.  내부 상대 URI로 시작 하는 슬래시 ("/") 문자 같은 중 하나는 절대 경로 수 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")에서 기본 URI로 확인 하는 합니다.  
  
 하는 경우 `targetMode` 으로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 하거나 절대 또는 상대 URI에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을*사양입니다.  "http://www.microsoft.com/page2.xml"은 "page2.xml" 외부 대상 리소스를 참조 하는 절대 URI의 예입니다.  "images/picture1.jpg"은 예를 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해 참조 되는 상대 URI입니다.  
  
 `relationshipType` 이어야 합니다는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형성 된 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양입니다.  다른 패키지 형식에는 다른 파트 수준 관계 유형을 정의할 수 있습니다.  다음 표에서 파트 수준 `relationshipType` 준수 하는 문서에 대해 정의 된 Uri는 *오픈 사양 XPS (XML Paper)* 합니다.  
  
|XPS 문서 파트 수준 관계|관계 유형 URI|  
|-------------------------------------------|---------------------------|  
|디지털 서명 정의|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](https://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|필요한 리소스|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|제한 된 글꼴|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 패키지 관계에 대 한 자세한 내용은 1.3 섹션을 참조 합니다 *OPC Open Packaging Conventions ()* 사양에서 다운로드할 수 있습니다 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 자세한 내용은 XPS 문서 참조에 대 한 합니다 *오픈 사양 XPS (XML Paper)* 에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=67000 ](https://go.microsoft.com/fwlink/?LinkID=67000)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetMode" /> 매개 변수가 유효한 <see cref="T:System.IO.Packaging.TargetMode" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="targetUri" />로 식별된 파트가 관계인 경우. 관계의 대상은 다른 관계가 될 수 없습니다.  
  
또는 
 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />로 지정되었지만 <paramref name="targetUri" />가 절대적인 외부 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 관계를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">대상 파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]입니다.</param>
        <param name="targetMode">열거형 값 중 하나입니다. 예를 들어 대상 파트가 <see cref="F:System.IO.Packaging.TargetMode.Internal" /> 내부에 있으면 <see cref="T:System.IO.Packaging.Package" />이고, 대상이 <see cref="F:System.IO.Packaging.TargetMode.External" /> 외부의 리소스이면 <see cref="T:System.IO.Packaging.Package" />입니다.</param>
        <param name="relationshipType">관계의 역할입니다.</param>
        <param name="id">관계의 고유 ID입니다.</param>
        <summary>이 <see cref="T:System.IO.Packaging.PackagePart" />와 지정된 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계를 만듭니다.</summary>
        <returns>이 <see cref="T:System.IO.Packaging.PackagePart" />와 대상 <see cref="T:System.IO.Packaging.PackagePart" /> 또는 외부 리소스 간의 파트 수준 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파트 수준 관계를이 파트와 대상 파트 또는 리소스 간의 연결을 정의 합니다.  파트 수준 관계는 두 가지 형식 중 하나일 수 있습니다.  
  
-   원본 간의 <xref:System.IO.Packaging.PackagePart> 대상 <xref:System.IO.Packaging.PackagePart> 안에 <xref:System.IO.Packaging.Package>.  
  
-   원본 간 <xref:System.IO.Packaging.PackagePart> 패키지 외부의 대상 리소스에 있습니다.  
  
 파트 관계에서 원본 파트는 관계의 "소유자" 간주 됩니다.  소스 파트를 삭제 하면이 파트에서 소유한 모든 관계도 삭제 됩니다.  대상 파트 또는 어떤 방식으로 리소스 만들기 또는 관계를 삭제 프로세스를 물리적으로 변경 되지 않습니다.  
  
 `id` 올바른 XML 식별자 여야 합니다.  합니다 `id` 형식은 xsd: id 이며에 지정 된 명명 규칙을 따라야 합니다 *XML Schema Part 2: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> 메서드 소스 파트 또는 대상 파트 또는 어떤 방식으로든에서 리소스 실제로 변경 하지 않습니다.  
  
 관계의 대상 다른 관계를 지정할 수 없습니다.  
  
 경우 `targetMode` 로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` 에 따라 구성 되는 상대 URI 여야 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양입니다.  내부 상대 URI로 시작 하는 슬래시 ("/") 문자 같은 중 하나는 절대 경로 수 "/ page1.xaml" 또는 "/ images/picture4.jpg", 또는 상대 경로와 같은 "... / imagespicture1.jpg "패키지 루트에 대해 ("/ ")에서 기본 URI로 확인 하는 합니다.  
  
 하는 경우 `targetMode` 으로 지정 됩니다 <xref:System.IO.Packaging.TargetMode.External>, `targetUri` 하거나 절대 또는 상대 URI에 따라 구성 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을*사양입니다.  "http://www.microsoft.com/page2.xml"은 "page2.xml" 외부 대상 리소스를 참조 하는 절대 URI의 예입니다.  "images/picture1.jpg"은 예를 외부 대상 리소스 "1.jpg"는 해결 되지만 패키지 자체의 URI에 대해 참조 되는 상대 URI입니다.  
  
 `relationshipType` 이어야 합니다는 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 에 따라 형성 된 합니다 [RFC 3986](http://tools.ietf.org/html/rfc3986) *리소스 URI (Uniform Identifier) 일반 구문을* 사양입니다.  다른 패키지 형식에는 다른 파트 수준 관계 유형을 정의할 수 있습니다.  다음 표에서 파트 수준 `relationshipType` 준수 하는 문서에 대해 정의 된 Uri는 *오픈 사양 XPS (XML Paper)* 합니다.  
  
|XPS 문서 파트 수준 관계|관계 유형 URI|  
|-------------------------------------------|---------------------------|  
|디지털 서명 정의|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|필요한 리소스|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|제한 된 글꼴|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 패키지 관계에 대 한 자세한 내용은 1.3 섹션을 참조 합니다 *OPC Open Packaging Conventions ()* 사양에서 다운로드할 수 있습니다 <https://go.microsoft.com/fwlink/?LinkID=71255>합니다.  
  
 자세한 내용은 XPS 문서 참조에 대 한 합니다 *오픈 사양 XPS (XML Paper)* 에서 다운로드할 수 있습니다 [ http://go.microsoft.com/fwlink/?LinkID=67000 ](https://go.microsoft.com/fwlink/?LinkID=67000)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> 또는 <paramref name="relationshipType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetMode" /> 매개 변수가 유효한 <see cref="T:System.IO.Packaging.TargetMode" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="targetUri" />로 식별된 파트가 관계인 경우. 관계의 대상은 다른 관계가 될 수 없습니다.  
  
또는 
 <paramref name="targetMode" />가 <see cref="F:System.IO.Packaging.TargetMode.Internal" />로 지정되었지만 <paramref name="targetUri" />가 절대적인 외부 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 새 관계를 추가할 수 없습니다.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우  
  
또는 
지정된 <paramref name="id" />의 파트가 이미 있는 경우</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="packagePart.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">삭제할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 파트 수준 <see cref="T:System.IO.Packaging.PackageRelationship" />을 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 올바른 XML 식별자 여야 합니다.  합니다 `id` 형식은 xsd: id 이며에 지정 된 명명 규칙을 따라야 합니다 *XML Schema Part 2: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 하는 경우 지정 된 `id` 와 일치 하지 않습니다는 <xref:System.IO.Packaging.PackageRelationship.Id%2A> 이 파트에서 소유한는 관계의 모든 관계가 삭제 되 고 예외가 throw 되지 않습니다.  
  
 지정된 된 관계를 삭제 이외의 <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> 메서드이 파트 또는 대상 파트에 실제로 변경 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.IOException">패키지가 읽기 전용인 경우. 이 경우 관계를 삭제할 수 없습니다.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberSignature Language="F#" Value="abstract member GetContentTypeCore : unit -&gt; string&#xA;override this.GetContentTypeCore : unit -&gt; string" Usage="packagePart.GetContentTypeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 파트 콘텐츠의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식을 반환합니다.</summary>
        <returns>파트 콘텐츠의 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> 메서드는 가상 메서드이며는 <xref:System.IO.Packaging.PackagePart> 추상 기본 클래스입니다. 생성 시 콘텐츠 형식에 대 한 값을 제공할 수 없습니다는 파생된 형식에만이 메서드를 구현 하거나 콘텐츠 형식 값은 중요 한 또는 비용이 많이 드는 작업입니다. 반환 값은 올바른 이어야 합니다 [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] 콘텐츠 형식입니다.  
  
 파생된 클래스에서 호출할 수 있습니다 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> 초기화를 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 기본값으로 파생된 클래스의 속성입니다.  이후에 <xref:System.IO.Packaging.PackagePart.ContentType%2A> 속성이 설정 되어이 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">파생 클래스는 <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> 메서드에 필요한 재정의 구현을 제공하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">반환할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />의 관계를 반환합니다.</summary>
        <returns>지정된 <paramref name="id" />와 일치하는 관계입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 올바른 XML 식별자 여야 합니다.  합니다 `id` 형식은 xsd: id 이며에 지정 된 명명 규칙을 따라야 합니다 *XML Schema Part 2: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 사용할 수는 <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> 지정 된 관계를 확인 하는 방법 <xref:System.IO.Packaging.PackageRelationship.Id%2A> 이 부분이 소유 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)  
  
또는 
지정된 <paramref name="id" />의 관계가 패키지에 없는 경우</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 파트에서 소유한 모든 관계의 컬렉션을 반환합니다.</summary>
        <returns>이 파트에서 소유한 모든 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 컬렉션은 `null`있지만 파트 관계를 정의 하지 않으면 컬렉션 요소가 포함 될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">컬렉션에서 찾아서 반환할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />과 일치하는 관계의 컬렉션을 반환합니다.</summary>
        <returns>지정된 <paramref name="relationshipType" />과 일치하는 관계의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 컬렉션은 `null`하지만, 관계가 없으면 지정 된 일치 하는 경우 컬렉션 요소가 포함 될 수 있습니다 `relationshipType` 파트에 대해 정의 되는 합니다.  
  
 선행 또는 후행 공백은 `relationshipType` 문자열을 자동으로 잘립니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging 규칙 사양</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파트 콘텐츠 데이터 스트림을 반환합니다.</summary>
        <block subset="none" type="usage"><para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
기본적으로 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 서브 클래스 구현의 추상 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 클래스를 열고 ZIP 파일에서 파트 데이터 스트림의 반환 합니다.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.IO.Stream" Usage="packagePart.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파트 콘텐츠 데이터 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 데이터 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 콘텐츠 스트림을 엽니다 <xref:System.IO.FileMode> 의 <xref:System.IO.FileMode.OpenOrCreate> 하 고 <xref:System.IO.FileAccess> 부모와 동일한 권한을 <xref:System.IO.Packaging.Package>합니다.  
  
 오버 로드 <xref:System.IO.Packaging.PackagePart.GetStream%2A> 메서드를 사용 하면 특정을 설정할 수 있습니다 <xref:System.IO.FileMode>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">파생된 서브클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드에서 반환한 스트림 개체가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
기본적으로 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 서브 클래스 구현의 추상 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 클래스를 열고 ZIP 파일에서 파트 데이터 스트림의 반환 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode -&gt; System.IO.Stream" Usage="packagePart.GetStream mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">콘텐츠 스트림을 열 I/O 모드입니다.</param>
        <summary>지정된 I/O <see cref="T:System.IO.FileMode" />에서 열린 콘텐츠 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.FileAccess> 반환 된 콘텐츠 스트림의 권한은 부모 사용 권한을 동일 <xref:System.IO.Packaging.Package>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 매개 변수가 유효한 <see cref="T:System.IO.FileMode" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> 매개 변수가 패키지 및 파트 스트림과 호환되지 않는 경우  
  
또는 
파생된 서브클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드에서 반환한 스트림 개체가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
기본적으로 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 서브 클래스 구현의 추상 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 클래스를 열고 ZIP 파일에서 파트 데이터 스트림의 반환 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStream (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">콘텐츠 스트림을 열 I/O 모드입니다.</param>
        <param name="access">콘텐츠 스트림을 열 때 사용하는 액세스 권한입니다.</param>
        <summary>지정된 <see cref="T:System.IO.FileMode" /> 및 <see cref="T:System.IO.FileAccess" />로 열린 파트 콘텐츠 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 스트림입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> 매개 변수가 유효한 <see cref="T:System.IO.FileMode" /> 열거형 값이 아닌 경우  
  
또는 
<paramref name="access" /> 매개 변수가 유효한 <see cref="T:System.IO.FileAccess" /> 열거형 값이 아닌 경우</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> 또는 <paramref name="access" />가 패키지 및 파트 스트림과 호환되지 않는 경우  
  
또는 
<paramref name="access" /> 매개 변수가 <see cref="F:System.IO.FileAccess.Read" />로 지정되었지만 <paramref name="mode" /> 매개 변수에서 쓰기 권한을 필요로 하는 경우.  <see cref="T:System.IO.FileMode" />, <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, 그리고 <see cref="F:System.IO.FileMode.Truncate" />의 <see cref="F:System.IO.FileMode.Append" /> 값에는 <see cref="F:System.IO.FileAccess.Write" /> 또는 <see cref="F:System.IO.FileAccess.ReadWrite" /> 액세스가 필요합니다. 
또는 
파생된 서브클래스의 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드에서 반환한 스트림 개체가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> 내부적으로 호출 하는 파생 된 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 파생된 클래스에서 구현 된 실제 형식에 따라 메서드를 실제로 열고 파트 데이터 스트림의 반환 합니다.  
  
기본적으로 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 서브 클래스 구현의 추상 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 클래스를 열고 ZIP 파일에서 파트 데이터 스트림의 반환 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamCore : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStreamCore (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">콘텐츠 스트림을 열 I/O 모드입니다.</param>
        <param name="access">콘텐츠 스트림을 열 때 사용하는 액세스 권한입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 <see cref="T:System.IO.FileMode" /> 및 <see cref="T:System.IO.FileAccess" />로 열린 파트 콘텐츠 스트림을 반환합니다.</summary>
        <returns>파트의 콘텐츠 데이터 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 애플리케이션을 호출 하지 않아야 <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> 직접 대신 호출 해야 하지만 <xref:System.IO.Packaging.PackagePart.GetStream%2A>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 구현을 수행 하는 작업이 나 순서에 대해 어떠한가 정도 하지 해야 합니다.는 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 메서드를 호출 합니다.</para></block>
        <block subset="none" type="usage"><para>파생 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 메서드를 호출 합니다 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 열고 파트 데이터 스트림의 반환 하는 메서드는 파생된 클래스에서 구현 된 실제 형식에 따라 합니다.  
  
기본적으로 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 서브 클래스 구현의 추상 <see cref="T:System.IO.Packaging.PackagePart" /> 클래스에 제공 되 고 사용 됩니다.  기본 작업에 <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> 내부적으로 호출 <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> 의 <see cref="T:System.IO.Packaging.ZipPackagePart" /> 클래스를 열고 ZIP 파일에서 파트 데이터 스트림의 반환 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Package : System.IO.Packaging.Package" Usage="System.IO.Packaging.PackagePart.Package" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파트의 부모 <see cref="T:System.IO.Packaging.Package" />를 가져옵니다.</summary>
        <value>파트의 부모 패키지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.Package%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  부모 생성자에 의해 설정 된 후 <xref:System.IO.Packaging.PackagePart.Package%2A> 의 일부를 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="packagePart.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">확인할 관계의 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />입니다.</param>
        <summary>지정된 <see cref="P:System.IO.Packaging.PackageRelationship.Id" />의 관계를 이 파트가 소유하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>지정된 <paramref name="id" />의 관계를 이 파트가 소유하는 경우에는 <see langword="true" />이고 그렇지 않은 경우에는 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` 올바른 XML 식별자 여야 합니다.  합니다 `id` 형식은 xsd: id 이며에 지정 된 명명 규칙을 따라야 합니다 *XML Schema Part 2: Datatypes* 사양 (참조 [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" />가 올바른 XML 식별자가 아닌 경우</exception>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <exception cref="T:System.IO.IOException">패키지가 쓰기 전용인 경우. 이 경우 관계 정보를 읽을 수 없습니다.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Uri : Uri" Usage="System.IO.Packaging.PackagePart.Uri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파트의 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]를 가져옵니다.</summary>
        <value>[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 패키지 루트에 상대적인 파트의 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> 액세스할 수 있는 읽기 전용 속성은 경우에만 부모 <xref:System.IO.Packaging.Package> 열려 있습니다.  
  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> 속성은 자동 설정 된 <xref:System.IO.Packaging.PackagePart.%23ctor%2A> 생성자입니다.  생성자에 의해 설정 된 후의 <xref:System.IO.Packaging.PackagePart.Uri%2A> 파트의 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파트가 삭제된 경우  
  
또는 
<see cref="P:System.IO.Packaging.PackagePart.Package" />가 열려 있지 않은 경우(<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> 또는 <see cref="M:System.IO.Packaging.Package.Close" />가 호출된 경우)</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>