<Type Name="NamedPipeServerStream" FullName="System.IO.Pipes.NamedPipeServerStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4a5afa19f5bea5e2dcb790da27f58ad758fb07f2" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39911000" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NamedPipeServerStream : System.IO.Pipes.PipeStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NamedPipeServerStream extends System.IO.Pipes.PipeStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.Pipes.NamedPipeServerStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NamedPipeServerStream&#xA;Inherits PipeStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NamedPipeServerStream sealed : System::IO::Pipes::PipeStream" />
  <TypeSignature Language="F#" Value="type NamedPipeServerStream = class&#xA;    inherit PipeStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Pipes</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Pipes.PipeStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>동기 및 비동기 읽기/쓰기 작업을 모두 지원하는 명명된 파이프 주위의 <see cref="T:System.IO.Stream" />을 노출합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 파이프는 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신에 대 한 단방향 또는 이중 파이프를 제공합니다. 로컬 또는 네트워크를 통해 명명 된 파이프를 프로세스 간 통신에 사용할 수 있습니다. 여러 단일 파이프 이름을 공유할 수 있습니다 <xref:System.IO.Pipes.NamedPipeClientStream> 개체입니다.  
  
 모든 프로세스는 명명된 된 파이프 서버 또는 클라이언트 또는 둘 다로 작동할 수 있습니다.  
  
> [!NOTE]
>  에 대 한 [!INCLUDE[winxppro](~/includes/winxppro-md.md)] 고 [!INCLUDE[win2kserver](~/includes/win2kserver-md.md)], 최대 10 개의 파이프는 네트워크를 통해 동시에 연결할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 자식 프로세스는 동일한 컴퓨터를 사용 하 여 명명 된 파이프에는 부모 프로세스에서 문자열을 보내는 방법을 보여 줍니다. 만드는이 예제는 <xref:System.IO.Pipes.NamedPipeServerStream> 사용 하 여 부모 프로세스에서 개체를 <xref:System.IO.Pipes.PipeDirection> 값 <xref:System.IO.Pipes.PipeDirection.Out>합니다. 대기 후 서버를 <xref:System.IO.Pipes.NamedPipeClientStream> 연결할 자식 프로세스에서 개체입니다. 이 예제에서는 두 프로세스가 동일한 컴퓨터에는 및 <xref:System.IO.Pipes.NamedPipeClientStream> 개체에는 <xref:System.IO.Pipes.PipeDirection> 의 값 <xref:System.IO.Pipes.PipeDirection.In>합니다. 그런 다음, 부모 프로세스는 사용자가 제공한 문자열을 자식 프로세스로 보냅니다. 문자열을 콘솔에 표시 됩니다.  
  
 이 예제는 사용 하는 서버 프로세스는 <xref:System.IO.Pipes.NamedPipeServerStream> 클래스입니다. 파이프 클라이언트와 서버 모두에 대 한 코드를 포함 한 전체 코드 예제를 보려면 [방법: 네트워크 프로세스 간 통신에 사용 하 여 명명 된 파이프](~/docs/standard/io/how-to-use-named-pipes-for-network-interprocess-communication.md)합니다.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream pipeName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <summary>지정된 파이프 이름을 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   기본 파이프 방향을 <xref:System.IO.Pipes.PipeDirection.InOut>합니다.  
  
-   동일한 이름을 공유 하는 서버 인스턴스의 최대 수는 1로 설정 합니다.  
  
-   <xref:System.IO.Pipes.PipeTransmissionMode>의 <xref:System.IO.Pipes.PipeTransmissionMode.Byte> 값입니다.  
  
-   <xref:System.IO.Pipes.PipeOptions>의 <xref:System.IO.Pipes.PipeOptions.None> 값입니다.  
  
-   기본 입력 및 출력 버퍼 크기입니다.  
  
-   파이프 보안 설정이 없습니다.  
  
-   <xref:System.IO.HandleInheritability>의 <xref:System.IO.HandleInheritability.None> 값입니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 파이프 이름 및 파이프 방향을 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   <xref:System.IO.Pipes.PipeTransmissionMode>의 <xref:System.IO.Pipes.PipeTransmissionMode.Byte> 값입니다.  
  
-   <xref:System.IO.Pipes.PipeOptions>의 <xref:System.IO.Pipes.PipeOptions.None> 값입니다.  
  
-   기본 입력 및 출력 버퍼 크기입니다.  
  
-   파이프 보안 설정이 없습니다.  
  
-   <xref:System.IO.HandleInheritability>의 <xref:System.IO.HandleInheritability.None> 값입니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 파이프 하 여 자식 프로세스에는 부모 프로세스에서 문자열을 보내는 방법을 보여 줍니다. 이 예제에서는 <xref:System.IO.Pipes.NamedPipeServerStream> 부모 프로세스에는 개체입니다. <xref:System.IO.Pipes.NamedPipeServerStream> 개체에는 <xref:System.IO.Pipes.PipeDirection> 의 값 <xref:System.IO.Pipes.PipeDirection.Out>, 그러면 될 때까지 차단를 <xref:System.IO.Pipes.NamedPipeClientStream> 현재 연결을 설정 하는 개체 <xref:System.IO.Pipes.NamedPipeServerStream> 개체입니다.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향 및 최대 서버 인스턴스 수를 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   동일한 이름을 공유 하는 서버 인스턴스의 최대 수에 1의 기본값입니다.  
  
-   기본값 <xref:System.IO.Pipes.PipeTransmissionMode> 의 값 <xref:System.IO.Pipes.PipeTransmissionMode.Byte>합니다.  
  
-   <xref:System.IO.Pipes.PipeOptions>의 <xref:System.IO.Pipes.PipeOptions.None> 값입니다.  
  
-   기본 입력 및 출력 버퍼 크기입니다.  
  
-   파이프 보안 설정이 없습니다.  
  
-   <xref:System.IO.HandleInheritability>의 <xref:System.IO.HandleInheritability.None> 값입니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
음수가 아닌 숫자가 필요합니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄) 
또는 
 <see cref="F:System.IO.HandleInheritability.None" /> 또는 <see cref="F:System.IO.HandleInheritability.Inheritable" />이 필요한 경우  
  
또는 
액세스 권한이 <see cref="F:System.IO.Pipes.PipeAccessRights.ChangePermissions" /> , <see cref="F:System.IO.Pipes.PipeAccessRights.TakeOwnership" /> 및 <see cref="F:System.IO.Pipes.PipeAccessRights.AccessSystemSecurity" /> 플래그로 제한되는 경우</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.Pipes.PipeDirection direction, bool isAsync, bool isConnected, class Microsoft.Win32.SafeHandles.SafePipeHandle safePipeHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.Boolean,System.Boolean,Microsoft.Win32.SafeHandles.SafePipeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::IO::Pipes::PipeDirection direction, bool isAsync, bool isConnected, Microsoft::Win32::SafeHandles::SafePipeHandle ^ safePipeHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : System.IO.Pipes.PipeDirection * bool * bool * Microsoft.Win32.SafeHandles.SafePipeHandle -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (direction, isAsync, isConnected, safePipeHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="isAsync" Type="System.Boolean" />
        <Parameter Name="isConnected" Type="System.Boolean" />
        <Parameter Name="safePipeHandle" Type="Microsoft.Win32.SafeHandles.SafePipeHandle" />
      </Parameters>
      <Docs>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="isAsync">핸들이 비동기 방식으로 열린 것을 표시하려면 <see langword="true" />, 표시하지 않으려면 <see langword="false" />입니다.</param>
        <param name="isConnected">파이프가 연결된 경우 <see langword="true" />, 그렇지 않은 경우 <see langword="false" />입니다.</param>
        <param name="safePipeHandle">이 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 개체가 캡슐화할 파이프의 SafeHandle입니다.</param>
        <summary>지정된 파이프 핸들을 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="safePipeHandle" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="safePipeHandle" />은(는) 잘못된 핸들입니다.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="safePipeHandle" />이 유효한 파이프 핸들이 아닌 경우  
  
또는 
서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <param name="transmissionMode">파이프의 전송 모드를 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향, 최대 서버 인스턴스 수 및 전송 모드를 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   기본값 <xref:System.IO.Pipes.PipeOptions> 의 값 <xref:System.IO.Pipes.PipeOptions.None>합니다.  
  
-   기본 입력 및 출력 버퍼 크기입니다.  
  
-   파이프 보안 설정이 없습니다.  
  
-   <xref:System.IO.HandleInheritability>의 <xref:System.IO.HandleInheritability.None> 값입니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄)</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode, options As PipeOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <param name="transmissionMode">파이프의 전송 모드를 결정하는 열거형 값 중 하나입니다.</param>
        <param name="options">파이프를 열거나 만드는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향, 최대 서버 인스턴스 수, 전송 모드 및 파이프 옵션을 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   기본 입력 및 출력 버퍼 크기입니다.  
  
-   파이프 보안 설정이 없습니다.  
  
-   <xref:System.IO.HandleInheritability>의 <xref:System.IO.HandleInheritability.None> 값입니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄) 
또는 
 <paramref name="options" />은 유효한 <see cref="T:System.IO.Pipes.PipeOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pipeName As String, direction As PipeDirection, maxNumberOfServerInstances As Integer, transmissionMode As PipeTransmissionMode, options As PipeOptions, inBufferSize As Integer, outBufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <param name="transmissionMode">파이프의 전송 모드를 결정하는 열거형 값 중 하나입니다.</param>
        <param name="options">파이프를 열거나 만드는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="inBufferSize">입력 버퍼 크기를 나타내는 0보다 큰 양의 값입니다.</param>
        <param name="outBufferSize">출력 버퍼 크기를 나타내는 0보다 큰 양의 값입니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향, 최대 서버 인스턴스 수, 전송 모드, 파이프 옵션 및 권장 입출력 버퍼 크기를 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   추가 파이프 보안 설정이 없습니다.  
  
-   기본값 <xref:System.IO.HandleInheritability> 의 값 <xref:System.IO.HandleInheritability.None>합니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄) 
또는 
 <paramref name="options" />은 유효한 <see cref="T:System.IO.Pipes.PipeOptions" /> 값이 아닙니다.  
  
또는 
 <paramref name="inBufferSize" />가 음수입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <param name="transmissionMode">파이프의 전송 모드를 결정하는 열거형 값 중 하나입니다.</param>
        <param name="options">파이프를 열거나 만드는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="inBufferSize">입력 버퍼 크기를 나타내는 0보다 큰 양의 값입니다.</param>
        <param name="outBufferSize">출력 버퍼 크기를 나타내는 0보다 큰 양의 값입니다.</param>
        <param name="pipeSecurity">파이프의 액세스 제어 및 감사 보안을 결정하는 개체입니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향, 최대 서버 인스턴스 수, 전송 모드, 파이프 옵션, 권장 입출력 버퍼 크기 및 파이프 보안을 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 다음과 같은 특징이 있는 개체:  
  
-   기본값 <xref:System.IO.HandleInheritability> 의 값 <xref:System.IO.HandleInheritability.None>합니다.  
  
-   지정 되지 않은 추가 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄) 
또는 
 <paramref name="options" />은 유효한 <see cref="T:System.IO.Pipes.PipeOptions" /> 값이 아닙니다.  
  
또는 
 <paramref name="inBufferSize" />가 음수입니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity * System.IO.HandleInheritability -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <param name="transmissionMode">파이프의 전송 모드를 결정하는 열거형 값 중 하나입니다.</param>
        <param name="options">파이프를 열거나 만드는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="inBufferSize">입력 버퍼 크기를 나타내는 0보다 큰 양의 값입니다.</param>
        <param name="outBufferSize">출력 버퍼 크기를 나타내는 0보다 큰 양의 값입니다.</param>
        <param name="pipeSecurity">파이프의 액세스 제어 및 감사 보안을 결정하는 개체입니다.</param>
        <param name="inheritability">자식 프로세스가 기본 핸들을 상속할 수 있는지 여부를 결정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향, 최대 서버 인스턴스 수, 전송 모드, 파이프 옵션, 권장 입출력 버퍼 크기, 파이프 보안 및 상속 모드를 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.IO.Pipes.NamedPipeServerStream> 가 없는 개체가 추가 지정 <xref:System.IO.Pipes.PipeAccessRights>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄) 
또는 
 <paramref name="options" />은 유효한 <see cref="T:System.IO.Pipes.PipeOptions" /> 값이 아닙니다.  
  
또는 
 <paramref name="inBufferSize" />가 음수입니다.  
  
또는 
 <paramref name="inheritability" />은 유효한 <see cref="T:System.IO.HandleInheritability" /> 값이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NamedPipeServerStream (string pipeName, System.IO.Pipes.PipeDirection direction, int maxNumberOfServerInstances, System.IO.Pipes.PipeTransmissionMode transmissionMode, System.IO.Pipes.PipeOptions options, int inBufferSize, int outBufferSize, System.IO.Pipes.PipeSecurity pipeSecurity, System.IO.HandleInheritability inheritability, System.IO.Pipes.PipeAccessRights additionalAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pipeName, valuetype System.IO.Pipes.PipeDirection direction, int32 maxNumberOfServerInstances, valuetype System.IO.Pipes.PipeTransmissionMode transmissionMode, valuetype System.IO.Pipes.PipeOptions options, int32 inBufferSize, int32 outBufferSize, class System.IO.Pipes.PipeSecurity pipeSecurity, valuetype System.IO.HandleInheritability inheritability, valuetype System.IO.Pipes.PipeAccessRights additionalAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability,System.IO.Pipes.PipeAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NamedPipeServerStream(System::String ^ pipeName, System::IO::Pipes::PipeDirection direction, int maxNumberOfServerInstances, System::IO::Pipes::PipeTransmissionMode transmissionMode, System::IO::Pipes::PipeOptions options, int inBufferSize, int outBufferSize, System::IO::Pipes::PipeSecurity ^ pipeSecurity, System::IO::HandleInheritability inheritability, System::IO::Pipes::PipeAccessRights additionalAccessRights);" />
      <MemberSignature Language="F#" Value="new System.IO.Pipes.NamedPipeServerStream : string * System.IO.Pipes.PipeDirection * int * System.IO.Pipes.PipeTransmissionMode * System.IO.Pipes.PipeOptions * int * int * System.IO.Pipes.PipeSecurity * System.IO.HandleInheritability * System.IO.Pipes.PipeAccessRights -&gt; System.IO.Pipes.NamedPipeServerStream" Usage="new System.IO.Pipes.NamedPipeServerStream (pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability, additionalAccessRights)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pipeName" Type="System.String" />
        <Parameter Name="direction" Type="System.IO.Pipes.PipeDirection" />
        <Parameter Name="maxNumberOfServerInstances" Type="System.Int32" />
        <Parameter Name="transmissionMode" Type="System.IO.Pipes.PipeTransmissionMode" />
        <Parameter Name="options" Type="System.IO.Pipes.PipeOptions" />
        <Parameter Name="inBufferSize" Type="System.Int32" />
        <Parameter Name="outBufferSize" Type="System.Int32" />
        <Parameter Name="pipeSecurity" Type="System.IO.Pipes.PipeSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="additionalAccessRights" Type="System.IO.Pipes.PipeAccessRights" />
      </Parameters>
      <Docs>
        <param name="pipeName">파이프의 이름입니다.</param>
        <param name="direction">파이프의 방향을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="maxNumberOfServerInstances">같은 이름을 공유하는 서버 인스턴스의 최대 수입니다. 이 값에 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 전달할 수 있습니다.</param>
        <param name="transmissionMode">파이프의 전송 모드를 결정하는 열거형 값 중 하나입니다.</param>
        <param name="options">파이프를 열거나 만드는 방법을 결정하는 열거형 값 중 하나입니다.</param>
        <param name="inBufferSize">입력 버퍼 크기입니다.</param>
        <param name="outBufferSize">출력 버퍼 크기입니다.</param>
        <param name="pipeSecurity">파이프의 액세스 제어 및 감사 보안을 결정하는 개체입니다.</param>
        <param name="inheritability">자식 프로세스가 기본 핸들을 상속할 수 있는지 여부를 결정하는 열거형 값 중 하나입니다.</param>
        <param name="additionalAccessRights">파이프의 액세스 권한을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>지정된 파이프 이름, 파이프 방향, 최대 서버 인스턴스 수, 전송 모드, 파이프 옵션, 권장 입출력 버퍼 크기, 파이프 보안, 상속 모드 및 파이프 액세스 권한을 사용하여 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pipeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pipeName" />이 빈 문자열인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="pipeName" />이 "익명"으로 설정된 경우  
  
또는 
 <paramref name="direction" />은 유효한 <see cref="T:System.IO.Pipes.PipeDirection" /> 값이 아닙니다.  
  
또는 
 <paramref name="maxNumberofServerInstances" />가 -1보다 작거나 254보다 큰 경우(-1은 <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />를 나타냄) 
또는 
 <paramref name="options" />은 유효한 <see cref="T:System.IO.Pipes.PipeOptions" /> 값이 아닙니다.  
  
또는 
 <paramref name="inBufferSize" />가 음수입니다.  
  
또는 
 <paramref name="inheritability" />은 유효한 <see cref="T:System.IO.HandleInheritability" /> 값이 아닙니다.  
  
또는 
 <paramref name="additionalAccessRights" />은 유효한 <see cref="T:System.IO.Pipes.PipeAccessRights" /> 값이 아닙니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pipeName" />에 콜론(":")이 포함된 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">운영 체제가 지원되지 않는 Windows Millennium Edition, Windows 98 또는 Windows 95인 경우</exception>
        <exception cref="T:System.IO.IOException">서버 인스턴스의 최대 수를 초과한 경우</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">직접 실행 호출자에 대 한 완전 신뢰 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForConnection">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForConnection (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginWaitForConnection(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForConnection (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForConnection(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginWaitForConnection : AsyncCallback * obj -&gt; IAsyncResult" Usage="namedPipeServerStream.BeginWaitForConnection (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">클라이언트가 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 개체에 연결할 때 호출할 메서드입니다.</param>
        <param name="state">다른 요청에서 특정 비동기 요청을 구별하는 사용자 제공 개체입니다.</param>
        <summary>클라이언트 연결을 대기할 비동기 작업을 시작합니다.</summary>
        <returns>비동기 요청을 참조하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 비동기 <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnection%2A>합니다.  
  
 <xref:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection%2A> 호출할 때마다 한 번씩 호출 해야 <xref:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파이프가 비동기적으로 열리지 않은 경우  
  
또는 
파이프 연결이 이미 설정된 경우  
  
또는 
파이프 핸들이 설정되지 않았습니다.</exception>
        <exception cref="T:System.IO.IOException">파이프 연결이 끊어진 경우</exception>
        <exception cref="T:System.ObjectDisposedException">파이프가 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.Disconnect" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect();" />
      <MemberSignature Language="F#" Value="member this.Disconnect : unit -&gt; unit" Usage="namedPipeServerStream.Disconnect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 연결을 끊습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.IO.Pipes.NamedPipeServerStream.Disconnect%2A> 메서드는 파이프의 전송 모드 설정 되지 않았으면 보낸된 모든 문자를 읽을 때까지 차단 됩니다 <xref:System.IO.Pipes.PipeTransmissionMode.Message> 버퍼 크기를 생성 하는 생성자에서 설정 됩니다는 <xref:System.IO.Pipes.NamedPipeServerStream> 개체입니다. 이 경우 모든 메시지가 수신 됩니다. 호출 <xref:System.IO.Pipes.PipeStream.WaitForPipeDrain%2A> 파이프에서 모든 데이터를 읽은 때까지 차단 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파이프 연결이 아직 설정되지 않은 경우  
  
또는 
연결된 파이프가 이미 연결이 끊긴 경우  
  
또는 
파이프 핸들이 설정되지 않았습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">파이프가 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForConnection">
      <MemberSignature Language="C#" Value="public void EndWaitForConnection (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndWaitForConnection(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndWaitForConnection (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndWaitForConnection(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndWaitForConnection : IAsyncResult -&gt; unit" Usage="namedPipeServerStream.EndWaitForConnection asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">보류 중인 비동기 요청입니다.</param>
        <summary>클라이언트 연결을 대기할 비동기 작업을 끝냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection%2A> 호출할 때마다 한 번씩 호출 해야 <xref:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">파이프가 비동기적으로 열리지 않은 경우  
  
또는 
파이프 핸들이 설정되지 않았습니다.</exception>
        <exception cref="T:System.IO.IOException">파이프 연결이 끊어진 경우</exception>
        <exception cref="T:System.ObjectDisposedException">파이프가 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~NamedPipeServerStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!NamedPipeServerStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="namedPipeServerStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가비지 컬렉션에 의해 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 인스턴스가 회수되기 전에 관리되지 않는 리소스를 해제하고 기타 정리 작업을 수행합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImpersonationUserName">
      <MemberSignature Language="C#" Value="public string GetImpersonationUserName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetImpersonationUserName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetImpersonationUserName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetImpersonationUserName();" />
      <MemberSignature Language="F#" Value="member this.GetImpersonationUserName : unit -&gt; string" Usage="namedPipeServerStream.GetImpersonationUserName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파이프 반대쪽 끝에서 클라이언트의 사용자 이름을 가져옵니다.</summary>
        <returns>파이프 반대쪽 끝에 있는 클라이언트의 사용자 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName%2A> 메서드가 반환 `null` 클라이언트 파이프에 아직 기록 되지 않은 경우 또는 연결 된 클라이언트가 사용 하 여 연결 되지 않은 경우는 <xref:System.Security.Principal.TokenImpersonationLevel> 의 <xref:System.Security.Principal.TokenImpersonationLevel.Impersonation>합니다.  
  
   
  
## Examples  
 다음 예제에서는 여러 동시 클라이언트 요청에 응답할 수 있는 파이프 서버를 만드는 방법과 클라이언트 가장 하는 방법을 보여 줍니다. 이 예제에서는 만듭니다는 <xref:System.IO.Pipes.NamedPipeServerStream> 대기 하는 여러 스레드를 만드는 다음 부모 프로세스에서 개체 <xref:System.IO.Pipes.NamedPipeClientStream> 연결할 개체입니다. 클라이언트가 연결 되 면 서버에 파일 이름을 제공 하 고 해당 파일의 내용을 읽고 클라이언트로 다시 전송 됩니다. 때문에 <xref:System.IO.Pipes.NamedPipeServerStream> 파일을 열 때, 클라이언트 요청 수만 파일을 열 수 있는 권한이 클라이언트를 가장 합니다.  
  
 [!code-cpp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파이프 연결이 아직 설정되지 않은 경우  
  
또는 
연결된 파이프가 이미 연결이 끊긴 경우  
  
또는 
파이프 핸들이 설정되지 않았습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">파이프가 닫혔습니다.</exception>
        <exception cref="T:System.IO.IOException">파이프 연결이 끊어진 경우  
  
또는 
클라이언트의 사용자 이름이 19자보다 깁니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">보안 주체 개체를 조작할 수 있습니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MaxAllowedServerInstances">
      <MemberSignature Language="C#" Value="public const int MaxAllowedServerInstances = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxAllowedServerInstances = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxAllowedServerInstances As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxAllowedServerInstances = -1;" />
      <MemberSignature Language="F#" Value="val mutable MaxAllowedServerInstances : int" Usage="System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>시스템 리소스가 허용하는 최대 서버 인스턴스 수를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances> 만들면를 <xref:System.IO.Pipes.NamedPipeServerStream> 시스템 리소스가 허용 하는 서버 인스턴스의 최대 수를 설정할 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RunAsClient">
      <MemberSignature Language="C#" Value="public void RunAsClient (System.IO.Pipes.PipeStreamImpersonationWorker impersonationWorker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunAsClient(class System.IO.Pipes.PipeStreamImpersonationWorker impersonationWorker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.RunAsClient(System.IO.Pipes.PipeStreamImpersonationWorker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunAsClient (impersonationWorker As PipeStreamImpersonationWorker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunAsClient(System::IO::Pipes::PipeStreamImpersonationWorker ^ impersonationWorker);" />
      <MemberSignature Language="F#" Value="member this.RunAsClient : System.IO.Pipes.PipeStreamImpersonationWorker -&gt; unit" Usage="namedPipeServerStream.RunAsClient impersonationWorker" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="impersonationWorker" Type="System.IO.Pipes.PipeStreamImpersonationWorker" />
      </Parameters>
      <Docs>
        <param name="impersonationWorker">호출할 메서드를 지정하는 대리자입니다.</param>
        <summary>클라이언트를 가장하는 동안 대리자를 호출합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 원격 서버에 연결 하는 클라이언트의 사용 권한이 적용 됩니다. 예를 들어 연결 중인 클라이언트에 서버에서 파일의 내용을 요청 하려고 하는 경우 클라이언트를 열려면 충분 한 권한이 있는 파일만 요청할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 여러 동시 클라이언트 요청에 응답할 수 있는 파이프 서버를 만드는 방법과 클라이언트 가장 하는 방법을 보여 줍니다. 이 예제에서는 만듭니다는 <xref:System.IO.Pipes.NamedPipeServerStream> 대기 하는 여러 스레드를 만드는 다음 부모 프로세스에서 개체 <xref:System.IO.Pipes.NamedPipeClientStream> 연결할 개체입니다. 클라이언트가 연결 되 면 서버에 파일 이름을 제공 하 고 해당 파일의 내용을 읽고 클라이언트로 다시 전송 됩니다. 때문에 <xref:System.IO.Pipes.NamedPipeServerStream> 파일을 열 때, 클라이언트 요청 수만 파일을 열 수 있는 권한이 클라이언트를 가장 합니다.  
  
 [!code-cpp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cpp/program.cpp#01)]
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_ImpersonationSample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_ImpersonationSample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파이프 연결이 아직 설정되지 않은 경우  
  
또는 
연결된 파이프가 이미 연결이 끊긴 경우  
  
또는 
파이프 핸들이 설정되지 않았습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">파이프가 닫혔습니다.</exception>
        <exception cref="T:System.IO.IOException">파이프 연결이 끊어진 경우  
  
또는 
I/O 오류가 발생했습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">보안 주체 개체를 조작할 수 있습니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForConnection">
      <MemberSignature Language="C#" Value="public void WaitForConnection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForConnection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnection" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForConnection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForConnection();" />
      <MemberSignature Language="F#" Value="member this.WaitForConnection : unit -&gt; unit" Usage="namedPipeServerStream.WaitForConnection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>클라이언트가 이 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 개체에 연결할 때까지 기다립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하면는 <xref:System.IO.Pipes.NamedPipeServerStream> 클라이언트가 연결 될 때까지 차단 하는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 파이프 하 여 자식 프로세스에는 부모 프로세스에서 문자열을 보내는 방법을 보여 줍니다. 이 예제에서는 <xref:System.IO.Pipes.NamedPipeServerStream> 부모 프로세스에는 개체입니다. 이 개체에는 <xref:System.IO.Pipes.PipeDirection> 값 <xref:System.IO.Pipes.PipeDirection.Out>, 그러면 될 때까지 차단를 <xref:System.IO.Pipes.NamedPipeClientStream> 개체에 대 한 연결을 설정 합니다 <xref:System.IO.Pipes.NamedPipeServerStream> 개체. 이 예제는에 대해 제공 된 큰 예제의 일부 합니다 <xref:System.IO.Pipes.NamedPipeServerStream> 고 <xref:System.IO.Pipes.NamedPipeClientStream> 클래스입니다.  
  
 [!code-csharp[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/cs/Program.cs#01)]
 [!code-vb[System.IO.Pipes.NamedPipeServerStream_Sample1#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Pipes.NamedPipeServerStream_Sample1/vb/program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">파이프 연결이 이미 설정된 경우  
  
또는 
파이프 핸들이 설정되지 않았습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">파이프가 닫혔습니다.</exception>
        <exception cref="T:System.IO.IOException">파이프 연결이 끊어진 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForConnectionAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트가 이 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 개체에 비동기 방식으로 연결할 때까지 기다립니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForConnectionAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForConnectionAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForConnectionAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitForConnectionAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitForConnectionAsync : unit -&gt; System.Threading.Tasks.Task" Usage="namedPipeServerStream.WaitForConnectionAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>클라이언트가 이 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 개체에 비동기 방식으로 연결할 때까지 기다립니다.</summary>
        <returns>비동기 대기 작업(operation)을 나타내는 작업(task)입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 이면이 메서드를 즉시 반환 하지만 클라이언트가 호출할 때 연결 프로세스가 완료 되 <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> 또는 <xref:System.IO.Pipes.NamedPipeClientStream.ConnectAsync%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitForConnectionAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitForConnectionAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitForConnectionAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitForConnectionAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitForConnectionAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="namedPipeServerStream.WaitForConnectionAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Pipes</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">취소 요청을 모니터링할 토큰입니다.</param>
        <summary>클라이언트가 이 <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> 개체에 비동기 방식으로 연결할 때까지 기다리고 취소 요청을 모니터링합니다.</summary>
        <returns>비동기 대기 작업(operation)을 나타내는 작업(task)입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 이면이 메서드를 즉시 반환 하지만 클라이언트가 호출할 때 연결 프로세스가 완료 되 <xref:System.IO.Pipes.NamedPipeClientStream.Connect%2A> 또는 <xref:System.IO.Pipes.NamedPipeClientStream.ConnectAsync%2A>합니다.  
  
 취소 요청 취소 토큰을 사용 하 여 에서만 작동 하는 경우는 <xref:System.IO.Pipes.NamedPipeServerStream> 파이프 옵션 값을 사용 하 여 개체를 만든 <xref:System.IO.Pipes.PipeOptions.Asynchronous?displayProperty=nameWithType> 취소 되기 전에 발생 하는 경우 또는 <xref:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>