<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4efb38db636d140b16f13448a6c93cee7d7e92b0" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52255356" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>디렉터리 및 하위 디렉터리를 만들고, 이동하고, 열거하는 인스턴스 메서드를 노출합니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.DirectoryInfo> 복사, 이동, 이름 바꾸기 및 디렉터리 삭제 등의 일반적인 작업에 대 한 클래스입니다.  
  
 인스턴스 메서드를 사용 하 여 개체를 여러 번 재사용 하려는 경우 고려해 <xref:System.IO.DirectoryInfo> 의 해당 정적 메서드 대신는 <xref:System.IO.Directory> 클래스를 보안 검사는 항상 되지 않으므로 필요 합니다.  
  
> [!NOTE]
>  입력 문자열로 경로 허용 하는 멤버를 해당 경로 올바른 형식 이어야 합니다. 또는 예외가 발생 합니다. 예를 들어, 경로 정규화 공백으로 시작 하지만 경로 클래스의 메서드에서 잘리지 않습니다. 따라서 경로 잘못 되었으며 예외가 발생 합니다. 마찬가지로, 경로 또는 경로의 조합을 두 번 정규화 될 수 없습니다. 예를 들어, "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다. 경로 잘 구성 된 경우에 경로 문자열을 허용 하는 메서드를 사용 하 여 확인 합니다.  
  
 경로 허용 하는 멤버의 경로 파일 또는 디렉터리를 참조할 수 있습니다. 지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로 참조할 수 있습니다. 예를 들어, 다음은 허용 가능한 경로.  
  
-   "c:\\\MyDir\\\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.  
  
-   "c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.  
  
-   "MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.  
  
-   "\\\\\\\MyServer\\\MyShare" C#에서 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.  
  
 기본적으로 새 디렉터리에 대 한 전체 읽기/쓰기 액세스는 모든 사용자에 게 부여 됩니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 멤버 중 일부는 `DirectoryInfo` 클래스입니다.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 다음 예제에서는 디렉터리와 해당 콘텐츠를 복사 하는 방법에 설명 합니다.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
    <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see langword="DirectoryInfo" />를 만들 경로를 지정하는 문자열입니다.</param>
        <summary>지정된 경로를 사용하여 <see cref="T:System.IO.DirectoryInfo" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 디렉터리가 존재 하는지 확인 하지 않습니다. 이 생성자에는 후속 작업에서 디스크에 액세스 하는 데 사용 되는 문자열에 대 한 자리 표시자입니다.  
  
 `path` 매개 변수는 범용 명명 규칙 (UNC) 공유에 파일을 포함 하는 파일 이름 수 있습니다.  
  
> [!CAUTION]
>  문자 집합을 특정 문화권 설정을 사용 하 여 컴파일하고 하면 서로 다른 문화권 설정 사용 하 여 동일한 문자 검색 문자를 해석할 수 없어 및 throw 예외가 발생할 수 있습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자를 사용 하 여 지정 된 디렉터리와 하위 디렉터리를 만듭니다 및 하위 디렉터리를 포함 하는 디렉터리를 삭제할 수 없습니다 하는 방법을 보여 줍니다.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />에 잘못된 문자(", &lt;, &gt; 또는 |)가 들어 있는 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 및 디렉터리에서 계속 하십시오. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>디렉터리를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>디렉터리를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해당 디렉터리가 이미 존재 하는 경우 두이 일은 없습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 지정된 된 디렉터리가 있는지 여부를 다음 예제에서는 검사는 존재 하지 않는 경우 디렉터리를 삭제에서 디렉터리를 만듭니다.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">디렉터리를 만들 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일을 작성 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">디렉터리에 적용할 액세스 제어입니다.</param>
        <summary>
          <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체를 사용하여 디렉터리를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드를 사용 하 여 보안 적용 되기 전에 디렉터리에 액세스할 수 없는 가능성이 있으므로 액세스 제어를 사용 하 여 디렉터리를 만듭니다.  
  
 해당 디렉터리가 이미 존재 하는 경우 두이 일은 없습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" />로 지정한 디렉터리가 읽기 전용이거나 빈 디렉터리가 아닙니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 빈 문자열이거나 공백만 포함하거나 <see cref="F:System.IO.Path.InvalidPathChars" />로 정의된 하나 이상의 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.NotSupportedException">콜론(:) 문자만으로 디렉터리를 만들려고 했습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리를 만들 수 있는 권한입니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 경로에 하위 디렉터리를 하나 이상 만듭니다. 지정된 경로는 <see cref="T:System.IO.DirectoryInfo" /> 클래스의 이 인스턴스에 대한 상대적 경로일 수 있습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">지정된 경로입니다. 이 경로는 다른 디스크 볼륨이나 UNC(Universal Naming Convention) 이름이 될 수 없습니다.</param>
        <summary>지정된 경로에 하위 디렉터리를 하나 이상 만듭니다. 지정된 경로는 <see cref="T:System.IO.DirectoryInfo" /> 클래스의 이 인스턴스에 대한 상대적 경로일 수 있습니다.</summary>
        <returns>
          <paramref name="path" />에 지정된 마지막 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 모든 디렉터리가 `path` 하지 않으면 만들어집니다 일부 `path` 올바르지 않습니다. `path` 매개 변수는 파일 경로가 아닌 디렉터리 경로 지정 합니다. 하위 디렉터리에 이미 있으면이 메서드는 없습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 하위 디렉터리를 만드는 하는 방법을 보여 줍니다. 이 예제에서는 만든된 디렉터리를 만든 후 제거 됩니다. 따라서이 샘플을 테스트 하려면 줄을 주석 처리를 삭제 코드에서입니다.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 올바른 파일 경로를 지정하지 않거나 잘못된 <see langword="DirectoryInfo" /> 문자를 포함합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">하위 디렉터리를 만들 수 없습니다.  
  
또는 
<paramref name="path" />에 지정된 이름을 갖는 파일 또는 디렉터리가 이미 있습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자가 디렉터리를 만들기 위한 코드 액세스 권한이 없습니다.  
  
또는 
호출자가 <see cref="T:System.IO.DirectoryInfo" /> 개체가 설명하는 디렉터리를 읽기 위한 코드 액세스 권한이 없습니다.  이 문제는 <paramref name="path" /> 매개 변수가 기존 디렉터리를 설명할 때 발생할 수 있습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 드라이브 레이블("C:\\")에 속하지 않는 콜론 문자(:)가 포함되어 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">지정된 경로입니다. 이 경로는 다른 디스크 볼륨이나 UNC(Universal Naming Convention) 이름이 될 수 없습니다.</param>
        <param name="directorySecurity">적용할 보안입니다.</param>
        <summary>지정된 경로에 지정된 보안을 사용하여 하위 디렉터리를 하나 이상 만듭니다. 지정된 경로는 <see cref="T:System.IO.DirectoryInfo" /> 클래스의 이 인스턴스에 대한 상대적 경로일 수 있습니다.</summary>
        <returns>
          <paramref name="path" />에 지정된 마지막 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 모든 디렉터리가 `path` 하지 않으면 만들어집니다 일부 `path` 올바르지 않습니다. `path` 매개 변수는 파일 경로가 아닌 디렉터리 경로 지정 합니다. 하위 디렉터리에 이미 있으면이 메서드는 없습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />가 올바른 파일 경로를 지정하지 않거나 잘못된 <see langword="DirectoryInfo" /> 문자를 포함합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">하위 디렉터리를 만들 수 없습니다.  
  
또는 
<paramref name="path" />에 지정된 이름을 갖는 파일 또는 디렉터리가 이미 있습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자가 디렉터리를 만들기 위한 코드 액세스 권한이 없습니다.  
  
또는 
호출자가 <see cref="T:System.IO.DirectoryInfo" /> 개체가 설명하는 디렉터리를 읽기 위한 코드 액세스 권한이 없습니다.  이 문제는 <paramref name="path" /> 매개 변수가 기존 디렉터리를 설명할 때 발생할 수 있습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />에 드라이브 레이블("C:\\")에 속하지 않는 콜론 문자(:)가 포함되어 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>경로에서 <see cref="T:System.IO.DirectoryInfo" /> 및 해당 내용을 삭제합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.IO.DirectoryInfo" />가 비어 있으면 이를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예에서는 비어 있지 않은 디렉터리를 삭제 하려고 하면 예외가 throw 됩니다.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리에 읽기 전용 파일이 포함되어 있습니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">이 <see cref="T:System.IO.DirectoryInfo" /> 개체가 설명하는 디렉터리가 없거나 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">디렉터리가 비어 있지 않습니다.  
  
또는 
이 디렉터리는 응용 프로그램의 현재 작업 디렉터리입니다.  
  
또는 
디렉터리에 대해 열린 핸들이 있고 운영 체제가 Windows XP 또는 이전 버전입니다. 이 열린 핸들은 디렉터리를 열거하면 발생할 수 있습니다. 자세한 내용은 [방법: 디렉터리 및 파일 열거](~/docs/standard/io/how-to-enumerate-directories-and-files.md)를 참조하세요.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리를 작성 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive">이 디렉터리, 하위 디렉터리 및 모든 파일을 삭제하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>하위 디렉터리와 파일을 삭제할지를 지정하여 <see cref="T:System.IO.DirectoryInfo" />의 이 인스턴스를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `DirectoryInfo` 파일 또는 하위 디렉터리에이 메서드를 삭제 합니다 `DirectoryInfo` 경우에 `recursive` 는 `false`합니다. 삭제 하려고를 `DirectoryInfo` 비어 있는 경우 `recursive` 됩니다 `false` throw는 <xref:System.IO.IOException>합니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리를 삭제 하는 방법을 보여 줍니다. 디렉터리가 제거 되기 때문에 먼저 주석 처리를 `Delete` 디렉터리가 존재 하는지 테스트할 줄. 그런 다음 동일한 디렉터리가 성공적으로 제거 되었는지 테스트 하는 코드 줄 주석 처리를 제거 합니다.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리에 읽기 전용 파일이 포함되어 있습니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">이 <see cref="T:System.IO.DirectoryInfo" /> 개체가 설명하는 디렉터리가 없거나 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">디렉터리가 읽기 전용인 경우  
  
또는 
디렉터리에 하나 이상의 파일 또는 하위 디렉터리가 포함되어 있고 <paramref name="recursive" />가 <see langword="false" />입니다.  
  
또는 
이 디렉터리는 응용 프로그램의 현재 작업 디렉터리입니다.  
  
또는 
디렉터리 또는 해당 파일 중 하나에 대해 열린 핸들이 있고 운영 체제가 Windows XP 또는 이전 버전입니다. 이 열린 핸들은 디렉터리 및 파일을 열거하면 발생할 수 있습니다. 자세한 내용은 [방법: 디렉터리 및 파일 열거](~/docs/standard/io/how-to-enumerate-directories-and-files.md)를 참조하세요.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">쓰기에 대해 쓰기 권한이 필요한 플래그는 <see langword="DirectoryInfo" /> 및 하위 디렉터리를 삭제할 수 있습니다.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리에 있는 디렉터리 정보의 열거 가능 컬렉션을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 디렉터리에 있는 디렉터리 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>현재 디렉터리에 있는 디렉터리의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> 고 <xref:System.IO.DirectoryInfo.GetDirectories%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.DirectoryInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetDirectories%2A>, 전체 배열의 기다려야 <xref:System.IO.DirectoryInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.DirectoryInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 C:\Program Files 디렉터리 아래 하위 디렉터리를 열거 하 고 LINQ 쿼리를 사용 하 여 값을 확인 하 여 2009 전에 생성 된 모든 디렉터리의 이름을 반환 하는 <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> 속성입니다.  
  
 하위 디렉터리의 이름에만 필요한 경우 사용 하 여 정적 <xref:System.IO.Directory> 성능 향상을 위해 클래스입니다. 예를 들어 참조 된 <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> 메서드.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 검색 패턴과 일치하는 디렉터리 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="searchPattern" />과 일치하는 디렉터리의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> 고 <xref:System.IO.DirectoryInfo.GetDirectories%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.DirectoryInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetDirectories%2A>, 전체 배열의 기다려야 <xref:System.IO.DirectoryInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.DirectoryInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다. 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 검색 패턴 및 하위 디렉터리 검색 옵션과 일치하는 디렉터리 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="searchPattern" /> 및 <paramref name="searchOption" />과 일치하는 디렉터리의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> 고 <xref:System.IO.DirectoryInfo.GetDirectories%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.DirectoryInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetDirectories%2A>, 전체 배열의 기다려야 <xref:System.IO.DirectoryInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.DirectoryInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
   
  
## Examples  
 이 메서드를 사용 하는 다음 예제에서는 지정된 된 디렉터리에서 시작 하며 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 시작 디렉터리 내 디렉터리와 파일을 열거 하 고 모든 세부 정보 표시 방법 개 10MB의에서 파일 크기입니다.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리에 있는 파일 정보의 열거 가능 컬렉션을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 디렉터리에 있는 파일 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>현재 디렉터리에 있는 파일의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 고 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFiles%2A>, 전체 배열의 기다려야 <xref:System.IO.FileInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 디렉터리에서 파일을 열거 하 고 LINQ 쿼리를 사용 하 여 값을 확인 하 여 2009 전에 생성 된 모든 파일의 이름을 반환 하는 <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> 속성입니다.  
  
 파일의 이름에만 필요한 경우 사용 하 여 정적 <xref:System.IO.Directory> 성능 향상을 위해 클래스입니다. 예를 들어 참조 된 <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 다음 예제에서는 다른 검색 옵션을 사용 하 여 디렉터리의 파일을 열거 하는 방법을 보여 줍니다. Log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, 및 SubFile.txt 라는 파일에 있는 하위 디렉터리를 명명 된 파일이 있는 디렉터리를 가정 합니다.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>검색 패턴과 일치하는 파일 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="searchPattern" />과 일치하는 파일의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 고 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFiles%2A>, 전체 배열의 기다려야 <xref:System.IO.FileInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 검색 옵션을 사용 하 여 디렉터리의 파일을 열거 하는 방법을 보여 줍니다. Log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, 및 SubFile.txt 라는 파일에 있는 하위 디렉터리를 명명 된 파일이 있는 디렉터리를 가정 합니다.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다. 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 검색 패턴 및 하위 디렉터리 검색 옵션과 일치하는 파일 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="searchPattern" /> 및 <paramref name="searchOption" />과 일치하는 파일의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 고 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFiles%2A>, 전체 배열의 기다려야 <xref:System.IO.FileInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 검색 옵션을 사용 하 여 디렉터리의 파일을 열거 하는 방법을 보여 줍니다. Log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, 및 SubFile.txt 라는 파일에 있는 하위 디렉터리를 명명 된 파일이 있는 디렉터리를 가정 합니다.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리에 있는 파일 시스템 정보의 열거 가능 컬렉션을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 디렉터리에 있는 파일 시스템 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>현재 디렉터리에 있는 파일 시스템 정보의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> 고 <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileSystemInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, 전체 배열의 기다려야 <xref:System.IO.FileSystemInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileSystemInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 검색 패턴과 일치하는 파일 시스템 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="searchPattern" />과 일치하는 파일 시스템 정보의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> 고 <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileSystemInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, 전체 배열의 기다려야 <xref:System.IO.FileSystemInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileSystemInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다. 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 검색 패턴 및 하위 디렉터리 검색 옵션과 일치하는 파일 시스템 정보의 열거 가능 컬렉션을 반환합니다.</summary>
        <returns>
          <paramref name="searchPattern" /> 및 <paramref name="searchOption" />과 일치하는 파일 시스템 정보의 열거 가능 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> 고 <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileSystemInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, 전체 배열의 기다려야 <xref:System.IO.FileSystemInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> 더 효율적일 수 있습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileSystemInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 반환된 된 컬렉션은 캐시 되지 않습니다. 각 호출에는 <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> 메서드 컬렉션에 새 열거형을를 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디렉터리가 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>디렉터리가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.DirectoryInfo.Exists%2A> 속성이 반환 `false` 지정한 파일이 있는지 확인 하는 동안 오류가 발생 하는 경우. 잘못 된 문자 또는 실패 했거나 누락 된 디스크에 너무 많은 문자를 사용 하 여 파일 이름을 전달할 때 예외를 발생 시키는 상황에서 발생할 수 있습니다 또는 호출자에 게 파일을 읽을 수 있는 사용 권한이 없습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다는 `Exists` 원본 디렉터리가 대상 디렉터리에 복사 하는 컨텍스트의 속성입니다.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디렉터리의 전체 경로를 가져옵니다.</summary>
        <value>전체 경로를 포함하는 문자열입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리의 ACL(액세스 제어 목록) 항목을 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 액세스를 검색 하는 메서드 현재 파일에 대 한 목록 (ACL) 항목을 제어 합니다.  
  
 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체에서 설명하는 디렉터리의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.IO.DirectoryInfo" /> 개체를 가져옵니다.</summary>
        <returns>디렉터리의 액세스 제어 규칙을 캡슐화하는 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.IO.Directory.GetAccessControl%2A> 메서드 오버 로드 액세스를 지정 하 고 제어 섹션 <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> Visual basic에서).  
  
 사용 된 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 방법입니다.  
  
 ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 특정된 파일이 나 디렉터리에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 고 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> 디렉터리에서 항목 목록 (ACL)을 제어 하는 메서드를 추가 하 고 다음 액세스를 제거 합니다.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">디렉터리를 찾거나 수정할 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리가 읽기 전용인 경우  
  
또는 
현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.IOException">디렉터리를 여는 동안 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리에 대 한 액세스 제어 목록 (ACL)을 열거할 수 있는 권한입니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">가져올 ACL(액세스 제어 목록) 정보의 형식을 지정하는 <see cref="T:System.Security.AccessControl.AccessControlSections" /> 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체에서 설명하는 디렉터리의 지정된 ACL(액세스 제어 목록) 항목 형식을 캡슐화하는 <see cref="T:System.IO.DirectoryInfo" /> 개체를 가져옵니다.</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 매개 변수에 설명된 파일의 액세스 제어 규칙을 캡슐화하는 <paramref name="path" /> 개체입니다.  
  
예외 
 <list type="table"><listheader><term> 예외 형식 
 </term><description> 조건 
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> 디렉터리를 찾거나 수정할 수 없는 경우  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> 현재 프로세스에 디렉터리를 열 수 있는 권한이 없는 경우  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> 디렉터리를 여는 동안 I/O 오류가 발생한 경우  
  
 </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> 현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> 디렉터리가 읽기 전용인 경우  
  
또는 
현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 방법입니다.  
  
 ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 특정된 파일이 나 디렉터리에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리에 대 한 액세스 제어 목록 (ACL)을 열거할 수 있는 권한입니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리의 하위 디렉터리를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 디렉터리의 하위 디렉터리를 반환합니다.</summary>
        <returns>
          <see cref="T:System.IO.DirectoryInfo" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하위 디렉터리가 없으면이 메서드는 빈 배열을 반환 합니다. 이 메서드는 재귀 되지 않습니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.DirectoryInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 다음 예제는 루트 디렉터리에 있는 모든 디렉터리를 검색 하 고 디렉터리 이름을 표시 합니다.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see cref="T:System.IO.DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리 읽기. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>주어진 검색 조건에 일치하는 현재 <see cref="T:System.IO.DirectoryInfo" />에 있는 디렉터리의 배열을 반환합니다.</summary>
        <returns>
          <see langword="DirectoryInfo" />에 일치하는 <paramref name="searchPattern" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.DirectoryInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 다음 예제에서는 지정 된 문자를 포함 하는 경로에 디렉터리를 계산 합니다.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" />에는 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 정의된 잘못된 문자가 하나 이상 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see langword="DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽을 파일 및 디렉터리 및 경로에 액세스할 수 있습니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.</param>
        <summary>하위 디렉터리를 검색할지를 나타내는 값을 사용하여 현재 <see cref="T:System.IO.DirectoryInfo" />에서 지정된 검색 조건과 일치하는 디렉터리의 배열을 반환합니다.</summary>
        <returns>
          <see langword="DirectoryInfo" />에 일치하는 <paramref name="searchPattern" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 하위 디렉터리가 없는지 또는 하위 디렉터리가 없는지와 일치 하는 경우는 `searchPattern` 매개 변수를이 메서드는 빈 배열을 반환 합니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.DirectoryInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 다음 예제에는 문자 "c"로 시작 하는 파일과 디렉터리 모두 나열 합니다 "c:\\"입니다.  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" />에는 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 정의된 잘못된 문자가 하나 이상 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <see langword="DirectoryInfo" /> 개체에 캡슐화된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.UnauthorizedAccessException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽을 파일 및 디렉터리 및 경로에 액세스할 수 있습니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리에서 파일 목록을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 디렉터리에서 파일 목록을 반환합니다.</summary>
        <returns>
          <see cref="T:System.IO.FileInfo" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 고 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFiles%2A>, 전체 배열의 기다려야 <xref:System.IO.FileInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 더 효율적일 수 있습니다.  
  
 파일이 없을 경우는 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다.  
  
 반환 된 파일 이름의 순서를 보장할 수 없습니다. 사용 된 <xref:System.Array.Sort%2A> 메서드는 특정 정렬 해야 하는 경우.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 다음 예제에서는 다른 검색 옵션을 사용 하 여 디렉터리에서 파일의 목록을 가져오는 방법을 보여 줍니다. Log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, 및 SubFile.txt 라는 파일에 있는 하위 디렉터리를 명명 된 파일이 있는 디렉터리를 가정 합니다.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리 읽기. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>현재 디렉터리에서 지정된 검색 패턴과 일치하는 파일 목록을 반환합니다.</summary>
        <returns>
          <see cref="T:System.IO.FileInfo" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 고 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFiles%2A>, 전체 배열의 기다려야 <xref:System.IO.FileInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 더 효율적일 수 있습니다.  
  
 파일이 없을 경우는 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다.  
  
 다음 와일드 카드 지정 자가 허용 되는 `searchPattern` 매개 변수입니다.  
  
|와일드 카드 문자|설명|  
|------------------------|-----------------|  
|*|0 개 이상의 문자입니다.|  
|?|정확히 0 개 이상의 문자입니다.|  
  
 반환 된 파일 이름의 순서를 보장할 수 없습니다. 사용 된 <xref:System.Array.Sort%2A> 메서드는 특정 정렬 해야 하는 경우.  
  
 와일드 카드가 허용 됩니다. 예를 들어를 `searchPattern` 모든 파일은 확장명이 "txt" 이름 "*.txt" 검색 문자열입니다. 합니다 `searchPattern` 문자열 "s\*" "s" 문자로 시작 하는 이름은 모든 파일을 검색 합니다. 없거나 파일이 없는 경우 일치 하는 파일을 `searchPattern` 문자열는 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다.  
  
> [!NOTE]
>  별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` (예를 들어, * ".txt"), 일치 하는 동작을 지정된 된 파일 확장명의 길이 따라 달라 집니다. A `searchPattern` 파일을 정확히 3 자 확장이 반환 확장인 3 개 이상의 문자를 사용 하 여 파일을 처음 세 문자에 지정 된 파일 확장명이 일치 하는 위치는 `searchPattern`합니다. A `searchPattern` 파일을 하나, 둘 또는 세 개 이상의 문자 확장 자에 지정 된 파일 확장명과 일치 하는 확장명을 가진 파일만 반환 하는 `searchPattern`합니다. 물음표 와일드 카드 문자를 사용할 경우이 메서드는 지정된 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어, 디렉터리, "file1.txt" 및 "file1.txtother", 검색 패턴은 두 개의 파일이 지정 된 "파일?. txt"반환만 첫 번째 파일인 검색 패턴은 하는 동안" 파일\*.txt "파일을 모두 반환 합니다.  
  
> [!NOTE]
>  검색 패턴 비슷합니다 8.3 파일 이름 형식 및 긴 파일 이름 형식을 모두 사용 하 여 파일 이름에 대해이 메서드는 확인, 때문에 "* 1\*.txt" 예기치 않은 파일 이름을 반환할 수 있습니다. 예를 들어, 검색 패턴을 사용 하 여 "\*1\*.txt" 동등한 8.3 파일 이름 형식 "longf~1.txt" 될 수 있으므로 "longfilename.txt"를 반환 합니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 다음 예제에서는 다른 검색 옵션을 사용 하 여 디렉터리에서 파일의 목록을 가져오는 방법을 보여 줍니다. Log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, 및 SubFile.txt 라는 파일에 있는 하위 디렉터리를 명명 된 파일이 있는 디렉터리를 가정 합니다.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" />에는 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 정의된 잘못된 문자가 하나 이상 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 파일 및 디렉터리에서 읽기에 대 한 액세스 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다.</param>
        <summary>하위 디렉터리를 검색할지를 나타내는 값을 사용하여 현재 디렉터리에서 지정된 검색 패턴과 일치하는 파일 목록을 반환합니다.</summary>
        <returns>
          <see cref="T:System.IO.FileInfo" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 고 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드 차이점은 다음과 같습니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, 컬렉션을 열거 하는 것이 먼저 <xref:System.IO.FileInfo> 전체 컬렉션에 반환 되기 전에 개체입니다.  
  
-   사용 하는 경우 <xref:System.IO.DirectoryInfo.GetFiles%2A>, 전체 배열의 기다려야 <xref:System.IO.FileInfo> 개체를 배열에 액세스 하려면 먼저 반환 합니다.  
  
 따라서 여러 파일 및 디렉터리를 사용 하 여 작업할 때 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> 더 효율적일 수 있습니다.  
  
 파일이 없을 경우는 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다.  
  
 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 문자|설명|  
|------------------------|-----------------|  
|*(별표)|0 개 이상의 문자입니다.|  
|? (물음표)|정확히 0 개 이상의 문자입니다.|  
  
 반환 된 파일 이름의 순서를 보장할 수 없습니다. 사용 된 <xref:System.Array.Sort%2A> 메서드는 특정 정렬 해야 하는 경우.  
  
 와일드 카드가 허용 됩니다. 예를 들어를 `searchPattern` 모든 파일은 확장명이 "txt" 이름 "*.txt" 검색 문자열입니다. 합니다 `searchPattern` 문자열 "s\*" "s" 문자로 시작 하는 이름은 모든 파일을 검색 합니다. 없거나 파일이 없는 경우 일치 하는 파일을 `searchPattern` 문자열는 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다.  
  
> [!NOTE]
>  별표 와일드 카드 문자를 사용 하는 경우는 `searchPattern` (예를 들어, * ".txt"), 일치 하는 동작을 지정된 된 파일 확장명의 길이 따라 달라 집니다. A `searchPattern` 파일을 정확히 3 자 확장이 반환 확장인 3 개 이상의 문자를 사용 하 여 파일을 처음 세 문자에 지정 된 파일 확장명이 일치 하는 위치는 `searchPattern`합니다. A `searchPattern` 파일을 하나, 둘 또는 세 개 이상의 문자 확장 자에 지정 된 파일 확장명과 일치 하는 확장명을 가진 파일만 반환 하는 `searchPattern`합니다. 물음표 와일드 카드 문자를 사용할 경우이 메서드는 지정된 된 파일 확장명과 일치 하는 파일에만 반환 합니다. 예를 들어, 디렉터리, "file1.txt" 및 "file1.txtother", 검색 패턴은 두 개의 파일이 지정 된 "파일?. txt"반환만 첫 번째 파일인 검색 패턴은 하는 동안" 파일\*.txt "파일을 모두 반환 합니다.  
  
 다음 목록에 대 한 서로 다른 길이의 동작을 보여 줍니다.는 `searchPattern` 매개 변수:  
  
-   "*.abc"는 확장 of.abc,.abcd,.abcde,.abcdef 파일을 반환 등입니다.  
  
-   "*.abcd"는 확장 of.abcd을 가진 파일만 반환 합니다.  
  
-   "*.abcde"는 확장 of.abcde을 가진 파일만 반환 합니다.  
  
-   "*.abcdef"는 확장 of.abcdef을 가진 파일만 반환 합니다.  
  
> [!NOTE]
>  검색 패턴 비슷합니다 8.3 파일 이름 형식 및 긴 파일 이름 형식을 모두 사용 하 여 파일 이름에 대해이 메서드는 확인, 때문에 "* 1\*.txt" 예기치 않은 파일 이름을 반환할 수 있습니다. 예를 들어, 검색 패턴을 사용 하 여 "\*1\*.txt" 동등한 8.3 파일 이름 형식 "longf~1.txt" 될 수 있으므로 "longfilename.txt"를 반환 합니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileInfo> 속성:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 다음 예제에서는 다른 검색 옵션을 사용 하 여 디렉터리에서 파일의 목록을 가져오는 방법을 보여 줍니다. Log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, 및 SubFile.txt 라는 파일에 있는 하위 디렉터리를 명명 된 파일이 있는 디렉터리를 가정 합니다.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" />에는 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 정의된 잘못된 문자가 하나 이상 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />는 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 파일 및 디렉터리에서 읽기에 대 한 액세스 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 디렉터리의 파일과 하위 디렉터리를 나타내는 강력한 형식의 <see cref="T:System.IO.FileSystemInfo" /> 개체 배열을 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>디렉터리의 모든 파일과 하위 디렉터리를 나타내는 강력한 형식의 <see cref="T:System.IO.FileSystemInfo" /> 항목 배열을 반환합니다.</summary>
        <returns>강력한 형식의 <see cref="T:System.IO.FileSystemInfo" /> 항목 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일 또는 디렉터리에 없는 경우는 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다. 이 메서드는 재귀 되지 않습니다.  
  
 하위 디렉터리에 대 한 합니다 <xref:System.IO.FileSystemInfo> 파생된 클래스에이 메서드에서 반환 된 개체를 캐스팅 될 수 <xref:System.IO.DirectoryInfo>입니다. 사용 하 여는 <xref:System.IO.FileAttributes> 에서 반환 된 값을 <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> 속성을 여부를 <xref:System.IO.FileSystemInfo> 파일 또는 디렉터리를 나타냅니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileSystemInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 다음 예제에서는 파일 및 지정된 된 디렉터리에서 디렉터리를 계산합니다.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">파일에 있는 디렉터리 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <summary>지정된 검색 조건과 일치하는 파일 및 하위 디렉터리를 나타내는 강력한 형식의 <see cref="T:System.IO.FileSystemInfo" /> 개체 배열을 검색합니다.</summary>
        <returns>검색 기준과 일치하는 강력한 형식의 <see langword="FileSystemInfo" /> 개체 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 이 메서드는 재귀 되지 않습니다.  
  
 하위 디렉터리에 대 한 합니다 <xref:System.IO.FileSystemInfo> 파생된 클래스에이 메서드에서 반환 된 개체를 캐스팅 될 수 <xref:System.IO.DirectoryInfo>입니다. 사용 하 여는 <xref:System.IO.FileAttributes> 에서 반환 된 값을 <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> 속성을 여부를 <xref:System.IO.FileSystemInfo> 파일 또는 디렉터리를 나타냅니다.  
  
 와일드 카드를 사용할 수 있습니다. 예를 들어 합니다 `searchPattern` 문자열 "* t" 모든 디렉터리 이름에 대 한 검색 `path` 문자 "t"로 끝나는 합니다. 합니다 `searchPattern` 문자열 "s\*"의 모든 디렉터리 이름에 대 한 검색 `path` "s"로 시작 합니다.  
  
 문자열 "..."에 사용할 수 있습니다 `searchPattern` 디렉터리 이름에 같은 잘못 된 디렉터리 이름의 일부로 지정 된 경우 "는. 합니다. b "로 설정 합니다. 디렉터리 계층 구조 위로 이동 하려면 사용할 수 없습니다. 파일이 나 디렉터리 또는 파일 또는 디렉터리가 일치 하는 경우는 `searchPattern` 문자열을 <xref:System.IO.DirectoryInfo>,이 메서드는 빈 배열을 반환 합니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileSystemInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 다음 예제에서는 파일 및 지정된 된 검색 패턴과 일치 하는 디렉터리를 계산 합니다.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" />에는 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 정의된 잘못된 문자가 하나 이상 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽을 파일 및 디렉터리 및 경로에 액세스할 수 있습니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">디렉터리 및 파일 이름과 일치하는지 비교할 검색 문자열입니다.  이 매개 변수는 유효한 리터럴 경로와 와일드카드(* 및 ?) 문자로 된 조합을 포함하지만 정규식을 지원하지 않습니다.</param>
        <param name="searchOption">검색 작업에 현재 디렉터리만 포함할지 아니면 모든 하위 디렉터리를 포함할지를 지정하는 열거형 값 중 하나입니다. 기본값은 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />입니다.</param>
        <summary>지정된 검색 조건과 일치하는 파일 및 하위 디렉터리를 나타내는 <see cref="T:System.IO.FileSystemInfo" /> 개체 배열을 검색합니다.</summary>
        <returns>검색 조건과 일치하는 파일 시스템 항목의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 리터럴 및 와일드 카드 문자의 조합일 수 있습니다 하지만 정규식을 지원 하지 않습니다. 다음 와일드 카드 지정 자가 허용 됩니다 `searchPattern`합니다.  
  
|와일드 카드 지정자|일치 항목|  
|------------------------|-------------|  
|*(별표)|해당 위치에 0 개 이상의 문자입니다.|  
|? (물음표)|해당 위치에 0 개 이상의 문자입니다.|  
  
 와일드 카드 문자 이외의 문자는 리터럴 문자. 예를 들어, 문자열 "* t"에서 문자 "t"로 끝나는 모든 이름 검색 합니다. ". 합니다 `searchPattern` 문자열 "s\*"의 모든 이름 검색 `path` "s"로 시작 합니다.  
  
 하위 디렉터리에 대 한 합니다 <xref:System.IO.FileSystemInfo> 파생된 클래스에이 메서드에서 반환 된 개체를 캐스팅 될 수 <xref:System.IO.DirectoryInfo>입니다. 사용 하 여는 <xref:System.IO.FileAttributes> 에서 반환 된 값을 <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> 속성을 여부를 <xref:System.IO.FileSystemInfo> 파일 또는 디렉터리를 나타냅니다.  
  
 이 메서드는 다음 값을 미리 채웁니다 <xref:System.IO.FileSystemInfo> 속성:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" />에는 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 메서드로 정의된 잘못된 문자가 하나 이상 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" />은 유효한 <see cref="T:System.IO.SearchOption" /> 값이 아닙니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">이 디렉터리를 이동할 곳의 이름과 경로입니다. 대상 디렉터리는 다른 디스크 볼륨이나 동일한 이름의 디렉터리가 될 수는 없지만, 이 디렉터리를 하위 디렉터리로 추가할 기존 디렉터리가 될 수는 있습니다.</param>
        <summary>
          <see cref="T:System.IO.DirectoryInfo" /> 인스턴스 및 해당 내용을 새 경로로 이동합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 throw는 <xref:System.IO.IOException> 예를 들어 c:\mydir c:\public를 이동 하려고 하 고 c:\public 이미 있습니다. 지정 해야 합니다 "c:\\\public\\\mydir"로 합니다 `destDirName` 매개 변수를 같은 새 디렉터리 이름을 지정 하거나 "c:\\\newdir"입니다.  
  
 이 메서드는 읽기 전용 디렉터리에서 디렉터리 이동을 허용 합니다. 읽기/쓰기 특성을 모두 디렉터리의 영향을 줍니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 디렉터리를 이동 하는 방법을 보여 줍니다.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destDirName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destDirName" />이 빈 문자열(''")입니다.</exception>
        <exception cref="T:System.IO.IOException">디렉터리를 다른 볼륨으로 이동하려고 했습니다.  
  
또는 
 <paramref name="destDirName" />이 이미 있습니다.  
  
또는 
이 경로에 액세스할 수 있는 권한이 없습니다.  
  
또는 
이동되는 디렉터리와 대상 디렉터리의 이름이 같습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">대상 디렉터리를 찾을 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">대상 디렉터리에 대 한 읽기 및 쓰기 파일 및 디렉터리에 대 한 합니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.IO.DirectoryInfo" /> 인스턴스의 이름을 가져옵니다.</summary>
        <value>디렉터리 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 <xref:System.IO.DirectoryInfo.Name%2A> 속성 "Bin" 등 디렉터리의 이름만 반환 합니다. "C:\public\Bin"와 같은 전체 경로 사용 합니다 <xref:System.IO.FileSystemInfo.FullName%2A> 속성입니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.Name%2A> 의 속성을 <xref:System.IO.DirectoryInfo> 권한이 필요 하지 (생성 하는 데 필요한 디렉터리에 읽기 권한 이상의 <xref:System.IO.DirectoryInfo.Exists%2A>) 디렉터리 이름을 제공할 수 있지만. 전달 하는 데 필요한 경우 out을 <xref:System.IO.DirectoryInfo> 암호화 된 보안 이름 사용 하 여 보호 된 디렉터리에 신뢰할 수 없는 코드의 사용에 대 한 더미 디렉터리를 만듭니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예에서는 현재의 이름을 표시 `DirectoryInfo` 인스턴스만 해당 합니다.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 하위 디렉터리의 부모 디렉터리를 가져옵니다.</summary>
        <value>부모 디렉터리 또는 <see langword="null" /> 경로가 null 또는 파일 경로 루트 (같은 "\\", "c:" 또는 * "\\\server\share").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 디렉터리의 부모 디렉터리를 참조 하는 방법을 보여 줍니다.  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽을 파일 및 디렉터리 및 경로에 액세스할 수 있습니다. 연관 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디렉터리의 루트 부분을 가져옵니다.</summary>
        <value>디렉터리의 루트를 나타내는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 지정 된 디렉터리에 대 한 루트 위치를 표시합니다.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">읽을 파일 및 디렉터리 및 경로에 액세스할 수 있습니다. 연관 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">
          <paramref name="path" /> 매개 변수에 설명된 디렉터리에 적용할 ACL 항목을 설명하는 개체입니다.</param>
        <summary>
          <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 개체에서 설명하는 ACL(액세스 제어 목록) 항목을 현재 <see cref="T:System.IO.DirectoryInfo" /> 개체에서 설명하는 디렉터리에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 액세스 제어 목록 (ACL)을 개인 및/또는 있거나 없는, 특정된 파일이 나 디렉터리에 대 한 특정 작업에 대 한 권한이 있는 사용자 그룹에 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> 메서드는 상속 되지 않은 ACL 목록을 표시 하는 파일에 ACL 항목을 적용 합니다.  
  
> [!CAUTION]
>  에 지정 된 ACL `directorySecurity` 디렉터리에 대 한 기존 ACL을 대체 합니다. 새 사용자에 대 한 권한을 추가 하려면 사용 된 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 기존 ACL을 가져오고 수정 방법입니다.  
  
 합니다 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> 메서드만 지속 되 면 <xref:System.Security.AccessControl.DirectorySecurity> 개체를 만든 후 수정 된 개체입니다.  경우는 <xref:System.Security.AccessControl.DirectorySecurity> 개체 수정 되지 않은, 파일에 유지 되지 것입니다.  검색할 수 없는 따라서는 <xref:System.Security.AccessControl.DirectorySecurity> 한 파일에서 개체 및 다른 파일에 동일한 개체를 다시 적용 합니다.  
  
 ACL 정보 파일에서 다른 위치로 복사할:  
  
1.  사용 하 여는 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 검색 하는 메서드는 <xref:System.Security.AccessControl.DirectorySecurity> 소스 파일에서 개체입니다.  
  
2.  새 <xref:System.Security.AccessControl.DirectorySecurity> 대상 파일에 대 한 개체입니다.  
  
3.  사용 된 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> 원본의 메서드 <xref:System.Security.AccessControl.DirectorySecurity> ACL 정보를 검색할 개체입니다.  
  
4.  사용 된 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 대상에 3 단계에서 검색 정보를 복사 하는 메서드 <xref:System.Security.AccessControl.DirectorySecurity> 개체입니다.  
  
5.  대상 설정 <xref:System.Security.AccessControl.DirectorySecurity> 개체를 사용 하 여 대상 파일을 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> 고 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> 디렉터리에서 항목 목록 (ACL)을 제어 하는 메서드를 추가 하 고 다음 액세스를 제거 합니다.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directorySecurity" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없거나 수정할 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 프로세스에 파일을 열 수 있는 액세스 권한이 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">디렉터리에 대 한 액세스 제어 목록 (ACL)를 열거할 수 있는 권한입니다. 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>사용자가 통과한 원래의 경로를 반환합니다.</summary>
        <returns>사용자가 통과한 원래의 경로를 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
  </Members>
</Type>