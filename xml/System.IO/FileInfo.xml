<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="425ccbdc751ac51d8b73bac64c158126c9feed8b" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57925125" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type FileInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>파일을 만들고, 복사하고, 삭제하고, 이동하고, 열기 위한 속성 및 인스턴스 메서드를 제공하고, <see cref="T:System.IO.FileStream" /> 개체를 만드는 것을 도와 줍니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo> 복사, 이동, 이름 바꾸기, 만들기, 열기, 삭제 하 고 파일에 추가 하는 등의 일반적인 작업에 대 한 클래스입니다.  
  
 동일한 파일에 여러 작업을 수행 하는 경우 보다 효율적으로 사용할 수 있습니다 <xref:System.IO.FileInfo> 메서드 중 해당 정적 메서드 대신 인스턴스는 <xref:System.IO.File> 클래스를 보안 검사는 항상 되지 않으므로 필요 합니다.  
  
 많은 <xref:System.IO.FileInfo> 메서드를 작성 하거나 파일을 열 때 다른 I/O 형식을 반환 합니다. 형식을 사용할 수 있습니다 이러한 다른 추가 파일을 조작할 수 있습니다. 자세한 내용은 특정 참조 <xref:System.IO.FileInfo> 와 같은 멤버 <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>를 <xref:System.IO.FileInfo.CreateText%2A>, 또는 <xref:System.IO.FileInfo.Create%2A>합니다.  
  
 기본적으로 새 파일에 대 한 전체 읽기/쓰기 액세스는 모든 사용자에 게 부여 됩니다.  
  
 다음 표에서 다양 한 동작을 사용자 지정 하는 데 사용 되는 열거형을 설명 <xref:System.IO.FileInfo> 메서드.  
  
|열거형|설명|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|읽기 및 쓰기 파일에 대 한 액세스를 지정합니다.|  
|<xref:System.IO.FileShare>|이미 사용 중인 파일에 대 한 허용 되는 액세스 수준을 지정 합니다.|  
|<xref:System.IO.FileMode>|기존 파일의 내용을 유지 또는 덮어쓸지 여부를 하 고 기존 파일을 만드는 요청에 예외가 발생 하는지 여부를 지정 합니다.|  
  
> [!NOTE]
>  입력 문자열로 경로 허용 하는 멤버를 해당 경로 올바른 형식 이어야 합니다. 또는 예외가 발생 합니다. 예를 들어, 경로 정규화 공백으로 시작 하지만 경로 클래스의 메서드에서 잘리지 않습니다. 따라서 경로 잘못 되었으며 예외가 발생 합니다. 마찬가지로, 경로 또는 경로의 조합을 두 번 정규화 될 수 없습니다. 예를 들어, "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다. 경로 잘 구성 된 경우에 경로 문자열을 허용 하는 메서드를 사용 하 여 확인 합니다.  
  
 경로 허용 하는 멤버의 경로 파일 또는 디렉터리를 참조할 수 있습니다. 지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로 참조할 수 있습니다. 예를 들어, 다음은 허용 가능한 경로.  
  
-   "c:\\\MyDir\\\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.  
  
-   "c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.  
  
-   "MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.  
  
-   "\\\\\\\MyServer\\\MyShare" C#에서 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.  
  
 <xref:System.IO.FileInfo> 클래스 파일에 대 한 정보를 검색할 수 있도록 하는 속성을 제공 합니다. 각 속성을 사용 하는 방법의 예에 대 한 속성 페이지를 참조 하세요.  
  
-   <xref:System.IO.FileInfo.Directory%2A> 속성 파일의 부모 디렉터리를 나타내는 개체를 검색 합니다.  
  
-   <xref:System.IO.FileInfo.DirectoryName%2A> 속성 파일의 부모 디렉터리의 전체 경로 검색 합니다.  
  
-   <xref:System.IO.FileInfo.Exists%2A> 속성을 운영 하기 전에 파일의 존재를 확인 합니다.  
  
-   <xref:System.IO.FileInfo.IsReadOnly%2A> 속성을 검색 하거나 파일을 수정할 수 있는지 여부를 지정 하는 값을 설정 합니다.  
  
-   <xref:System.IO.FileInfo.Length%2A> 파일의 크기를 검색 합니다.  
  
-   <xref:System.IO.FileInfo.Name%2A> 파일의 이름을 검색 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 멤버 중 일부는 `FileInfo` 클래스입니다.  
  
 속성을 먼저 검색 하는 경우 <xref:System.IO.FileInfo> 호출을 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 메서드 및 캐시 정보입니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져올 수 있습니다.  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 이 예제에서는 다음과 유사한 출력을 생성 합니다.  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
    <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.IO.FileInfo : string -&gt; System.IO.FileInfo" Usage="new System.IO.FileInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">새 파일의 정규화된 이름이거나 상대적인 파일 이름입니다. 경로가 디렉터리 구분 기호 문자로 끝나서는 안 됩니다.</param>
        <summary>파일 경로의 래퍼 역할을 하는 <see cref="T:System.IO.FileInfo" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규화 된 이름 또는 상대 파일 이름을 지정할 수 있지만 보안 검사는 정규화 된 이름을 가져옵니다.  
  
   
  
## Examples  
 다음 예제는 다음 쓰기에서 읽기, 복사 및 삭제 하는 두 개의 파일을 만들려면이 생성자를 사용 합니다.  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 다음 예제에서는 기존 파일을 엽니다 또는 파일을 만듭니다, 그리고 파일에 텍스트를 추가 및 결과 표시 합니다.  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileName" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">파일 이름이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="fileName" />에 대한 액세스가 거부되었습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="fileName" />의 문자열 중간에 콜론(:)이 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberSignature Language="F#" Value="member this.AppendText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.AppendText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.StreamWriter" />의 이 인스턴스가 나타내는 파일에 텍스트를 추가하는 <see cref="T:System.IO.FileInfo" />를 만듭니다.</summary>
        <returns>새 <see langword="StreamWriter" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일에 텍스트를 추가 하 고 해당 파일에서 읽습니다.  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 다음 예제에서는 파일의 끝에 추가 텍스트를 보여 줍니다. 및 콘솔에 추가 작업의 결과 표시 합니다. 처음이이 루틴이 호출 되는 파일이 존재 하지 않는 경우 만들어집니다. 그런 다음 지정된 된 텍스트 파일에 추가 됩니다.  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일에 추가 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 파일에 기존 파일을 복사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">복사할 새 파일의 이름입니다.</param>
        <summary>새 파일에 기존 파일을 복사하고 기존 파일을 덮어쓸 수 없도록 합니다.</summary>
        <returns>정규화된 경로가 있는 새 파일입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.CopyTo(System.String,System.Boolean)> 기존 파일을 덮어쓸 수 있도록 하는 방법입니다.  
  
> [!CAUTION]
>  가능 하면이 메서드를 사용 하 여 짧은 파일 이름 (예: XXXXXX~1.XXX)를 사용 하지 마세요. 두 파일이 동일한 짧은 경우 파일 이름은 다음이 메서드 수 실패 및 예외를 발생 시키는 및/또는 원치 않는 동작이 발생  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 `CopyTo` 메서드.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 다음 예제에서는 대상 파일이 이미 있는 경우 예외를 throw 하는 다른 파일에 한 파일을 복사 하는 방법을 보여 줍니다.  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" />이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.IO.IOException">오류가 발생했거나 대상 파일이 이미 있습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destFileName" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리 경로를 거치거나 파일이 다른 드라이브로 이동됩니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="destFileName" />에 지정된 디렉터리가 없습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" />은 문자열 내에 콜론(:)을 포함하지만 볼륨을 지정하지는 않습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">복사할 새 파일의 이름입니다.</param>
        <param name="overwrite">기존 파일을 덮어쓸 수 있도록 하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>새 파일에 기존 파일을 복사하고 기존 파일을 덮어쓸 수 있도록 합니다.</summary>
        <returns>새 파일이 반환되거나, <paramref name="overwrite" />가 <see langword="true" />인 경우 기존 파일을 덮어씁니다. 파일이 있고 <paramref name="overwrite" />가 <see langword="false" />이면 <see cref="T:System.IO.IOException" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 허용 하거나 기존 파일 덮어쓰지 않도록 하려면이 메서드를 사용 합니다. 사용 된 <xref:System.IO.FileInfo.CopyTo(System.String)> 기본적으로 기존 파일 덮어쓰지 않도록 하는 방법입니다.  
  
> [!CAUTION]
>  가능 하면이 메서드를 사용 하 여 짧은 파일 이름 (예: XXXXXX~1.XXX)를 사용 하지 마세요. 두 파일이 동일한 짧은 경우 파일 이름은 다음이 메서드 수 실패 및 예외를 발생 시키는 및/또는 원치 않는 동작이 발생  
  
   
  
## Examples  
 다음 예제에서는 두 오버 로드는 `CopyTo` 메서드.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 다음 예제에서는 한 파일을 이미 존재 하는 파일을 덮어쓸지 여부를 지정 하는 다른 파일을 복사 하는 방법을 보여 줍니다.  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" />이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.IO.IOException">오류가 발생했거나 대상 파일이 이미 있으며 <paramref name="overwrite" />가 <see langword="false" />입니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destFileName" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="destFileName" />에 지정된 디렉터리가 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">디렉터리 경로를 거치거나 파일이 다른 드라이브로 이동됩니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" />의 문자열 중간에 콜론(:)이 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; System.IO.FileStream" Usage="fileInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일을 만듭니다.</summary>
        <returns>새 파일입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 새 파일에 대 한 전체 읽기/쓰기 액세스는 모든 사용자에 게 부여 됩니다.  
  
 이 메서드는에서 제공 하는 기능에 대 한 래퍼 <xref:System.IO.File.Create%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 파일에 대 한 참조를 만들고 다음 사용 하 여 디스크에서 파일을 만듭니다 `FileInfo.Create()`합니다.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 다음 예제에서는 파일을 만듭니다, 그리고 일부 텍스트를 추가 및 해당 파일에서 읽습니다.  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberSignature Language="F#" Value="member this.CreateText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.CreateText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>새 텍스트 파일을 쓰는 <see cref="T:System.IO.StreamWriter" />를 만듭니다.</summary>
        <returns>새 <see langword="StreamWriter" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 새 파일에 대 한 전체 읽기/쓰기 액세스는 모든 사용자에 게 부여 됩니다.  
  
   
  
## Examples  
 다음 예제는 `CreateText` 메서드.  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">파일 이름이 디렉터리입니다.</exception>
        <exception cref="T:System.IO.IOException">디스크가 읽기 전용입니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberSignature Language="F#" Value="member this.Decrypt : unit -&gt; unit" Usage="fileInfo.Decrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 계정으로 <see cref="M:System.IO.FileInfo.Encrypt" /> 메서드를 통해 암호화된 파일을 해독합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.FileInfo.Decrypt%2A> 메서드를 사용 하 여 암호화 된 파일을 암호 해독할 수 있습니다는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드.  <xref:System.IO.FileInfo.Decrypt%2A> 메서드는 현재 사용자 계정을 사용 하 여 암호화 된 파일에만 해독할 수 있습니다.  
  
 모두를 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 메서드는 메서드를 호출 하는 프로세스의 파일 암호화 키 및 컴퓨터에 설치 된 암호화 서비스 공급자 (CSP)를 사용 합니다.  
  
 현재 파일 시스템을 NTFS 및 현재 운영 체제가 Microsoft Windows NT 해야 서식이 지정 된 이상 이어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 메서드를 암호화 한 다음 파일을 해독 합니다.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">잘못된 드라이브를 지정했습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">NTFS 파일 시스템이 아닙니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닌 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일이 읽기 전용인 경우  
  
또는 
현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
보안 작업: 요청 합니다.  
  
현재 설명 하는 파일에 읽기 및 쓰기 사용 권한을 <see cref="T:System.IO.FileInfo" /> 개체입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="fileInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일을 영구적으로 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일이 없으면이 메서드는 없습니다.  
  
   
  
## Examples  
 다음 예제는 `Delete` 메서드.  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 다음 예제에서는 만듭니다, 그리고 닫히고 파일을 삭제 합니다.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Microsoft Windows NT를 실행하는 컴퓨터에 대상 파일이 열려 있거나 메모리 매핑된 경우  
  
또는 
파일에 대해 열린 핸들이 있고 운영 체제가 Windows XP 또는 이전 버전입니다. 이 열린 핸들은 디렉터리 및 파일을 열거하면 발생할 수 있습니다. 자세한 내용은 [방법: 디렉터리 및 파일 열거](~/docs/standard/io/how-to-enumerate-directories-and-files.md)를 참조하세요.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">경로가 디렉터리인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Directory : System.IO.DirectoryInfo" Usage="System.IO.FileInfo.Directory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 디렉터리의 인스턴스를 가져옵니다.</summary>
        <value>이 파일의 부모 디렉터리를 나타내는 <see cref="T:System.IO.DirectoryInfo" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부모 디렉터리 문자열을 사용 합니다 <xref:System.IO.FileInfo.DirectoryName%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 또는 파일을 만듭니다, 그리고의 전체 경로 결정 하 고 결정 열리고 디렉터리의 전체 내용이 표시 됩니다.  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryName : string" Usage="System.IO.FileInfo.DirectoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디렉터리의 전체 경로를 나타내는 문자열을 가져옵니다.</summary>
        <value>디렉터리의 전체 경로를 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부모 디렉터리에 <xref:System.IO.DirectoryInfo> 개체를 사용 하 여는 <xref:System.IO.FileInfo.Directory%2A> 속성.  
  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져올 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 파일의 전체 경로 검색 합니다.  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">디렉터리 이름에 대해 <see langword="null" />이 전달된 경우</exception>
        <exception cref="T:System.IO.PathTooLongException">정규화된 경로 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberSignature Language="F#" Value="member this.Encrypt : unit -&gt; unit" Usage="fileInfo.Encrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일을 암호화하는 데 사용된 계정으로만 해독할 수 있도록 암호화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.Encrypt%2A> 메서드를 사용 하면이 메서드를 호출 하는 데 계정 으로만 해독할 수 있도록 파일을 암호화할 수 있습니다.  사용 합니다 <xref:System.IO.FileInfo.Decrypt%2A> 하 여 암호화 된 파일의 암호를 해독 하는 메서드는 <xref:System.IO.FileInfo.Encrypt%2A> 메서드.  
  
 모두를 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 메서드는 메서드를 호출 하는 프로세스의 파일 암호화 키 및 컴퓨터에 설치 된 암호화 서비스 공급자 (CSP)를 사용 합니다.  
  
 현재 파일 시스템을 NTFS 및 현재 운영 체제가 Microsoft Windows NT 해야 서식이 지정 된 이상 이어야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.IO.FileInfo.Encrypt%2A> 메서드 및 <xref:System.IO.FileInfo.Decrypt%2A> 파일 암호화 및 암호를 해독할 수 방법입니다.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">잘못된 드라이브를 지정했습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">NTFS 파일 시스템이 아닙니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닌 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일이 읽기 전용인 경우  
  
또는 
현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
보안 작업: 요청 합니다.  
  
현재 설명 하는 파일에 읽기 및 쓰기 사용 권한을 <see cref="T:System.IO.FileInfo" /> 개체입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.FileInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>파일이 있으면 <see langword="true" />이고, 파일이 없거나 파일이 디렉터리이면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져올 수 있습니다.  
  
 합니다 <xref:System.IO.FileInfo.Exists%2A> 속성이 반환 `false` 지정한 파일이 있는지 확인 하는 동안 오류가 발생 하는 경우. 잘못 된 문자 또는 실패 했거나 누락 된 디스크에 너무 많은 문자를 사용 하 여 파일 이름을 전달할 때 예외를 발생 시키는 상황에서 발생할 수 있습니다 또는 호출자에 게 파일을 읽을 수 있는 사용 권한이 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.IO.FileInfo.Exists%2A> 속성 파일을 열기 전에 있는지 확인 합니다.  파일이 없는 경우 사용자 지정 예외를 throw 하려면이 기법을 사용할 수 있습니다.  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체를 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.GetAccessControl%2A> 현재 파일에 대 한 목록 (ACL) 항목을 제어 하는 액세스를 검색 하는 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 ACL(액세스 제어 목록) 항목을 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체를 가져옵니다.</summary>
        <returns>현재 파일의 액세스 제어 규칙을 캡슐화하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.GetAccessControl%2A> 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 방법입니다.  
  
 ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 지정된 된 파일에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.IO.FileInfo.GetAccessControl%2A> 메서드 및 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드를 추가 하 고 다음 파일에서 액세스 제어 목록 (ACL) 항목을 제거 합니다.  이 예제를 실행하려면 유효한 사용자 또는 그룹 계정을 제공해야 합니다.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">현재 시스템 계정에 관리 권한이 없는 경우</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
보안 작업: 요청 합니다.  
  
액세스 제어 목록을 읽을 수 있는 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">검색할 액세스 제어 항목 그룹을 지정하는 <see cref="T:System.Security.AccessControl.AccessControlSections" /> 값 중 하나입니다.</param>
        <summary>현재 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 파일의 지정된 ACL(액세스 제어 목록) 항목 형식을 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체를 가져옵니다.</summary>
        <returns>현재 파일의 액세스 제어 규칙을 캡슐화하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.GetAccessControl%2A> 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 검색 하는 방법입니다.  
  
 ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 지정된 된 파일에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">현재 시스템 계정에 관리 권한이 없는 경우</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
보안 작업: 요청 합니다.  
  
액세스 제어 목록을 읽을 수 있는 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.IO.FileInfo.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 파일이 읽기 전용인지 여부를 결정하는 값을 가져오거나 설정합니다.</summary>
        <value>현재 파일이 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.IsReadOnly%2A> 속성을 신속 하 게 확인 또는 현재 파일이 읽기 전용인 지 여부를 변경 합니다.  
  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져올 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.FileInfo.IsReadOnly%2A> 속성을 읽기 전용으로 표시 하 고 읽기 / 쓰기 가능으로 표시 합니다.  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ArgumentException">사용자에게 쓰기 권한이 없지만 이 속성을 <see langword="false" />로 설정하려고 한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
보안 작업: 요청 합니다.  
  
현재 설명 하는 파일에 읽기 및 쓰기 사용 권한을 <see cref="T:System.IO.FileInfo" /> 개체입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileInfo.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 파일의 크기(바이트)를 가져옵니다.</summary>
        <value>현재 파일의 크기(바이트)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.IO.FileInfo.Length%2A> 경우 속성은 사전 캐시의 현재 인스턴스를 <xref:System.IO.FileInfo> 개체는 다음 중 하나에서 반환 된 <xref:System.IO.DirectoryInfo> 메서드:  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 에 최신 값을 가져오려면 호출을 <xref:System.IO.FileSystemInfo.Refresh%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 파일의 크기를 표시 합니다.  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><see cref="M:System.IO.FileSystemInfo.Refresh" />가 파일이나 디렉터리의 상태를 업데이트할 수 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일이 없습니다.  
  
또는 
<see langword="Length" /> 속성이 디렉터리에 대해 호출되는 경우</exception>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="fileInfo.MoveTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">파일을 이동할 경로입니다. 이 경로에서 다른 파일 이름을 지정할 수 있습니다.</param>
        <summary>지정된 파일을 새 위치로 이동하고 새 파일의 이름을 지정할 수 있는 옵션을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 디스크 볼륨에서 작동합니다. 예를 들어 파일 c:\MyFile.txt d:\public 이동할 수 있습니다 및 NewFile.txt 변경 합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 위치로 파일을 이동 하 고 파일 이름을 바꾸면 보여 줍니다.  
  
 [!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
 [!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">대상 파일이 이미 있거나 대상 장치가 준비되어 있지 않는 상태 등의 I/O 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destFileName" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" />이 비어 있거나, 공백만 포함하거나 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="destFileName" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destFileName" />의 문자열 중간에 콜론(:)이 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string * bool -&gt; unit" Usage="fileInfo.MoveTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destFileName">To be added.</param>
        <param name="overwrite">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파일 이름을 가져옵니다.</summary>
        <value>파일의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처음 호출 될 때 <xref:System.IO.FileInfo> 호출 <xref:System.IO.FileSystemInfo.Refresh%2A> 파일에 대 한 정보를 캐시 합니다. 후속 호출에서 호출 해야 <xref:System.IO.FileSystemInfo.Refresh%2A> 정보의 최신 복사본을 가져올 수 있습니다.  
  
 파일 확장명을 포함 하는 파일의 이름입니다.  
  
   
  
## Examples  
 다음 예제에서는 `Name` 속성을 현재 디렉터리에 파일의 이름을 표시 합니다.  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>다양한 읽기/쓰기 및 공유 권한으로 파일을 엽니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode -&gt; System.IO.FileStream" Usage="fileInfo.Open mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">파일을 여는 모드(예: <see langword="Open" /> 또는 <see langword="Append" />)를 지정하는 <see cref="T:System.IO.FileMode" /> 상수입니다.</param>
        <summary>지정된 모드로 파일을 엽니다.</summary>
        <returns>공유 권한 없이 읽기/쓰기 권한을 사용하여 지정된 모드로 연 파일입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일에 일부 정보를 추가 고 파일을 읽고 파일을 엽니다.  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">파일이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">쓰고 파일에서 읽는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">파일을 여는 모드(예: <see langword="Open" /> 또는 <see langword="Append" />)를 지정하는 <see cref="T:System.IO.FileMode" /> 상수입니다.</param>
        <param name="access"><see langword="Read" />, <see langword="Write" /> 또는 <see langword="ReadWrite" /> 파일 액세스 권한 중 어떤 권한으로 파일을 열지를 지정하는 <see cref="T:System.IO.FileAccess" /> 상수입니다.</param>
        <summary>읽기, 쓰기 또는 읽기/쓰기 권한을 사용하여 지정된 모드로 파일을 엽니다.</summary>
        <returns>공유 권한 없이 지정된 액세스 권한 및 모드로 연 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예에서는 읽기 전용으로 파일을 열고 파일에서 읽습니다.  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">쓰고 파일에서 읽는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 아무 것도 없거나 공백만 있는 경우</exception>
        <exception cref="T:System.ArgumentNullException">하나 이상의 인수가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">파일을 여는 모드(예: <see langword="Open" /> 또는 <see langword="Append" />)를 지정하는 <see cref="T:System.IO.FileMode" /> 상수입니다.</param>
        <param name="access"><see langword="Read" />, <see langword="Write" /> 또는 <see langword="ReadWrite" /> 파일 액세스 권한 중 어떤 권한으로 파일을 열지를 지정하는 <see cref="T:System.IO.FileAccess" /> 상수입니다.</param>
        <param name="share">이 파일에 대해 다른 <see langword="FileStream" /> 개체의 액세스 형식을 지정하는 <see cref="T:System.IO.FileShare" /> 상수입니다.</param>
        <summary>읽기, 쓰기 또는 읽기/쓰기 권한과 지정된 공유 옵션을 사용하여 특정 모드로 파일을 엽니다.</summary>
        <returns>지정된 액세스 권한 및 공유 옵션을 사용하여 특정 모드로 연 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예에서는 읽기 및 쓰기 있지만 다른 사용자 또는 프로세스에 대 한 액세스를 허용 하지 않는 파일을 여는 방법을 보여 줍니다.  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 아무 것도 없거나 공백만 있는 경우</exception>
        <exception cref="T:System.ArgumentNullException">하나 이상의 인수가 null인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">쓰고 파일에서 읽는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberSignature Language="F#" Value="member this.OpenRead : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>읽기 전용 <see cref="T:System.IO.FileStream" />을 만듭니다.</summary>
        <returns>새 읽기 전용 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 읽기 전용 <xref:System.IO.FileStream> 개체를 <xref:System.IO.FileShare> 모드가 설정 <xref:System.IO.FileShare.Read>합니다.  
  
   
  
## Examples  
 다음 예에서는 읽기 전용으로 파일을 열고 여기에서 읽습니다.  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일이 이미 열려 있습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 읽기. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberSignature Language="F#" Value="member this.OpenText : unit -&gt; System.IO.StreamReader" Usage="fileInfo.OpenText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>UTF8 인코딩 방식으로 기존 텍스트 파일에서 읽는 <see cref="T:System.IO.StreamReader" />를 만듭니다.</summary>
        <returns>UTF8 인코딩 방식을 사용하는 새 <see langword="StreamReader" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일에서 텍스트를 읽습니다.  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />이 읽기 전용이거나 디렉터리인 경우</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberSignature Language="F#" Value="member this.OpenWrite : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenWrite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>쓰기 전용 <see cref="T:System.IO.FileStream" />을 만듭니다.</summary>
        <returns>새 파일 또는 기존 파일의 공유되지 않는 쓰기 전용 <see cref="T:System.IO.FileStream" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.OpenWrite%2A> 메서드 경우 이미 파일 경로 대 한 존재 하지 않는 경우 새 파일을 만들고 파일을 엽니다. 기존 파일을 추가 하지 않습니다 새 텍스트 기존 텍스트입니다. 대신 새 문자를 사용 하 여 기존 문자를 덮어씁니다. 파일을 덮어쓴 경우 긴 문자열 (예: "This is OpenWrite 메서드 테스트")는 더 짧은 문자열 (예: "두 번째 실행")를 사용 하 여 문자열의 동시에 포함 됩니다 ("OpenWrite 메서드의 두 번째 runtest").  
  
   
  
## Examples  
 다음 예제에서는 파일을 쓰기용으로 열리고 파일에서 읽습니다.  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:System.IO.FileInfo" /> 개체의 인스턴스를 만들 때 지정된 경로는 읽기 전용이거나 디렉터리입니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><see cref="T:System.IO.FileInfo" /> 개체의 인스턴스를 만들 때 지정한 경로가 유효하지 않은 경우(예: 매핑되지 않은 드라이브의 경로에 해당하는 경우)</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 읽고 파일을 작성 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 파일의 내용을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일로 대체합니다. 이때 원본 파일을 삭제하고 대체된 파일의 백업을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.IO.FileInfo.Replace%2A> 신속 하 게 파일을 현재 설명 하는 파일의 내용으로 교체 해야 할 때 메서드 <xref:System.IO.FileInfo> 개체.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationBackupFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">현재 파일로 대체할 파일의 이름입니다.</param>
        <param name="destinationBackupFileName"><paramref name="destFileName" /> 매개 변수에 설명된 파일의 백업을 만드는 데 사용할 파일 이름입니다.</param>
        <summary>지정된 파일의 내용을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일로 대체합니다. 이때 원본 파일을 삭제하고 대체된 파일의 백업을 만듭니다.</summary>
        <returns><paramref name="destFileName" /> 매개 변수에 설명된 파일에 대한 정보를 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.FileInfo.Replace%2A> 메서드는 현재 설명 하는 파일의 내용이 지정된 된 파일의 내용을 바꿉니다 <xref:System.IO.FileInfo> 개체입니다.  또한 대체 된 파일의 백업을 만듭니다.  마지막으로 새 반환 <xref:System.IO.FileInfo> 덮어쓴된 파일을 설명 하는 개체입니다.  
  
> [!CAUTION]
>  이 메서드는 경우 Windows 2000 환경에서 성공의 `destFileName` 읽기 전용 이며 예외가 발생 하지 것입니다. 사용 된 <xref:System.IO.FileInfo.IsReadOnly%2A> 경우 대상 파일은 읽기 전용 교체를 시도 하기 전에 확인할 속성입니다.  
  
 전달 `null` 에 `destBackupFileName` 대체할 파일의 백업을 만들려면 원하지 않는 경우 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.File.Replace%2A> 메서드를 다른 파일을 사용 하 여 파일을 바꾸고 대체 된 파일의 백업을 만듭니다.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" /> 매개 변수에 설명된 경로가 올바른 형식이 아닙니다.  
  
또는 
<paramref name="destBackupFileName" /> 매개 변수에 설명된 경로가 올바른 형식이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destFileName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.  
  
또는 
<paramref name="destinationFileName" /> 매개 변수에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
보안 작업: 요청 합니다.  
  
쓰는 데 필요한 권한에서 설명 하는 파일에는 <paramref name="destBackupFileName" /> 매개 변수에 지정 된 경우.</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationBackupFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">현재 파일로 대체할 파일의 이름입니다.</param>
        <param name="destinationBackupFileName"><paramref name="destFileName" /> 매개 변수에 설명된 파일의 백업을 만드는 데 사용할 파일 이름입니다.</param>
        <param name="ignoreMetadataErrors">대체된 파일과 대체 파일 사이에 발생하는 병합 오류(예: 특성 및 ACL)를 무시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 파일의 내용을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일로 대체합니다. 이때 원본 파일을 삭제하고 대체된 파일의 백업을 만듭니다.  병합 오류를 무시할지 여부도 지정합니다.</summary>
        <returns><paramref name="destFileName" /> 매개 변수에 설명된 파일에 대한 정보를 캡슐화하는 <see cref="T:System.IO.FileInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.FileInfo.Replace%2A> 메서드는 현재 설명 하는 파일의 내용이 지정된 된 파일의 내용을 바꿉니다 <xref:System.IO.FileInfo> 개체입니다.  또한 대체 된 파일의 백업을 만듭니다.  마지막으로 새 반환 <xref:System.IO.FileInfo> 덮어쓴된 파일을 설명 하는 개체입니다.  
  
> [!CAUTION]
>  이 메서드는 경우 Windows 2000 환경에서 성공의 `destFileName` 읽기 전용 이며 예외가 발생 하지 것입니다. 사용 된 <xref:System.IO.FileInfo.IsReadOnly%2A> 경우 대상 파일은 읽기 전용 교체를 시도 하기 전에 확인할 속성입니다.  
  
 전달 `null` 에 `destBackupFileName` 대체할 파일의 백업을 만들려면 원하지 않는 경우 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.IO.File.Replace%2A> 메서드를 다른 파일을 사용 하 여 파일을 바꾸고 대체 된 파일의 백업을 만듭니다.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destFileName" /> 매개 변수에 설명된 경로가 올바른 형식이 아닙니다.  
  
또는 
<paramref name="destBackupFileName" /> 매개 변수에 설명된 경로가 올바른 형식이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destFileName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">현재 <see cref="T:System.IO.FileInfo" /> 개체에 설명된 파일을 찾을 수 없습니다.  
  
또는 
<paramref name="destinationFileName" /> 매개 변수에 설명된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows NT 이상이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
보안 작업: 요청 합니다.  
  
쓰는 데 필요한 권한에서 설명 하는 파일에는 <paramref name="destBackupFileName" /> 매개 변수에 지정 된 경우.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileInfo.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">현재 파일에 적용할 ACL(액세스 제어 목록) 항목을 설명하는 <see cref="T:System.Security.AccessControl.FileSecurity" /> 개체입니다.</param>
        <summary><see cref="T:System.Security.AccessControl.FileSecurity" /> 개체에서 설명하는 ACL(액세스 제어 목록) 항목을 현재 <see cref="T:System.IO.FileInfo" /> 개체에서 설명하는 파일에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드 상속 되지 않은 ACL 목록을 나타내는 현재 파일에 대 한 액세스 제어 목록 (ACL) 항목을 적용 합니다.  
  
 사용 된 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드를 추가 하거나 파일에서 ACL 항목을 제거 해야 할 경우.  
  
> [!CAUTION]
>  에 대해 지정 된 ACL을 `fileSecurity` 매개 변수 파일에 대 한 기존 ACL을 대체 합니다. 에 새 사용자에 대 한 권한을 추가 하려면 사용 합니다 <xref:System.IO.Directory.GetAccessControl%2A> 메서드를 추가 하려면, 수정 및 사용 하 여 <xref:System.IO.FileInfo.SetAccessControl%2A> 파일에 다시 적용 합니다.  
  
 ACL에는 개인 및/또는 그룹 했거나 권한이 없는, 지정된 된 파일에서 특정 작업을 설명 합니다. 자세한 내용은 [방법: Access Control 목록 항목 추가 또는 제거](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)를 참조하세요.  
  
 합니다 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드만 지속 되 면 <xref:System.Security.AccessControl.FileSecurity> 개체를 만든 후 수정 된 개체입니다.  경우는 <xref:System.Security.AccessControl.FileSecurity> 개체 수정 되지 않은, 파일에 유지 되지 것입니다.  검색할 수 없는 따라서는 <xref:System.Security.AccessControl.FileSecurity> 한 파일에서 개체 및 다른 파일에 동일한 개체를 다시 적용 합니다.  
  
 ACL 정보 파일에서 다른 위치로 복사할:  
  
1.  사용 하 여는 <xref:System.IO.FileInfo.GetAccessControl%2A> 검색 하는 메서드는 <xref:System.Security.AccessControl.FileSecurity> 소스 파일에서 개체입니다.  
  
2.  새 <xref:System.Security.AccessControl.FileSecurity> 대상 파일에 대 한 개체입니다.  
  
3.  사용 된 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> 원본의 메서드 <xref:System.Security.AccessControl.FileSecurity> ACL 정보를 검색할 개체입니다.  
  
4.  사용 된 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> 또는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 대상에 3 단계에서 검색 정보를 복사 하는 메서드 <xref:System.Security.AccessControl.FileSecurity> 개체입니다.  
  
5.  대상 설정 <xref:System.Security.AccessControl.FileSecurity> 개체를 사용 하 여 대상 파일을 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.IO.FileInfo.GetAccessControl%2A> 메서드 및 <xref:System.IO.FileInfo.SetAccessControl%2A> 메서드를 추가 하 고 다음 파일에서 ACL 항목을 제거 합니다.  이 예제를 실행하려면 유효한 사용자 또는 그룹 계정을 제공해야 합니다.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileSecurity" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.SystemException">파일을 찾을 수 없거나 수정할 수 없는 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">현재 프로세스에 파일을 열 수 있는 액세스 권한이 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">현재 운영 체제가 Microsoft Windows 2000 이상이 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" />  
  
보안 작업: 요청 
파일에 액세스할 수 있는 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="fileInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>경로를 문자열로 반환합니다.</summary>
        <returns>경로를 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환한 문자열을 <xref:System.IO.FileInfo.ToString%2A> 메서드는 생성자에 전달 된 경로 나타냅니다.  만들 때를 <xref:System.IO.FileInfo> 생성자를 사용 하 여 개체를 <xref:System.IO.FileInfo.ToString%2A> 메서드 정규화 된 경로 반환 합니다.  그러나 의해 반환 된 문자열을 가지는 <xref:System.IO.FileInfo.ToString%2A> 메서드는 정규화 된 경로 나타내지 않습니다.  만든 경우에 예를 들어,를 <xref:System.IO.FileInfo> 를 사용 하 여 개체를 <xref:System.IO.DirectoryInfo.GetFiles%2A> 메서드를 <xref:System.IO.FileInfo.ToString%2A> 메서드는 정규화 된 경로 나타내지 않습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
  </Members>
</Type>