<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d6e92442757fd51d003d6e8352e0318077814f8" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58736123" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>파일이나 디렉터리 경로 정보를 포함하는 <see cref="T:System.String" /> 인스턴스에 대한 작업을 수행합니다. 이러한 작업은 플랫폼 간에 호환되는 방식으로 수행됩니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 경로가 파일 또는 디렉터리의 위치를 제공 하는 문자열입니다. 디스크의 위치로 경로 반드시 가리키지 않습니다 예를 들어, 경로 메모리에 또는 장치에서 위치를 매핑할 수 있습니다. 패스의 정확한 형식은 현재 플랫폼에 의해 결정 됩니다. 예를 들어 일부 시스템 경로 시작할 수 드라이브 또는 볼륨 문자를 사용 하 여이 요소를 다른 시스템에 없을 때. 일부 시스템에서는 파일 경로 파일에 저장 된 정보 유형을 지정 하는 확장을 포함할 수 있습니다. 파일 이름 확장명의 형식은 플랫폼에 따라 다릅니다. 예를 들어 일부 시스템 3 자에 대 한 확장을 제한 하 고 없기도 합니다. 현재 플랫폼에는 또한 경로의 요소를 구분 하는 데 사용 되는 문자 집합 및 경로 지정 하는 경우에 사용할 수 없는 문자 집합을 결정 합니다. 필드 이러한 차이로 인해 합니다 `Path` 클래스의 일부 멤버의 정확한 동작 뿐만 아니라는 `Path` 클래스는 플랫폼에 따라 다릅니다.  
  
 경로 절대 또는 상대 위치 정보를 포함할 수 있습니다. 위치를 완벽 하 게 지정 하는 절대 경로: 파일 또는 디렉터리 고유 하 게 식별할 수 현재 위치에 관계 없이 합니다. 상대 경로 부분 위치를 지정 합니다: 상대 경로 사용 하 여 지정 된 파일을 찾을 때 현재 위치가 시작 지점으로 사용 됩니다. 현재 디렉터리를 확인 하려면 호출 <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>합니다.  

 .NET core 1.1 및 이후 버전 및.NET Framework 4.6.2 이상와 같은 장치 이름에는 파일 시스템 개체에 대 한 액세스도 지원 "\\? \C:\"합니다.

Windows에서 파일 경로 형식에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다.

 멤버는 대부분의 `Path` 클래스와 파일 시스템으로 작용 하지 경로 문자열에서 지정 된 파일의 존재 여부를 확인 하지 않습니다. `Path` 클래스와 같은 경로 문자열을 수정 하는 멤버 <xref:System.IO.Path.ChangeExtension%2A>, 파일 시스템의 파일 이름에 효과가 없습니다. `Path` 하지만 멤버 않습니다, 지정 된 경로 문자열의 내용을 검사 및 throw를 <xref:System.ArgumentException> 문자열에서 반환 된 문자에 정의 된 경로 문자열에서 유효 하지 않은 문자를 포함 하는 경우 예외를 <xref:System.IO.Path.GetInvalidPathChars%2A> 메서드. 예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 포함 될 수 있습니다 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), (\0), null 및 18 번 및 20부터 25 통해 유니코드 문자 16입니다.  
  
 멤버는 `Path` 클래스를 사용 하면 쉽고 빠르게 파일 이름 확장명을 경로의 일부를 인지 여부를 확인 하 고 두 문자열을 하나의 경로 이름으로 결합 등 일반적인 작업을 수행할 수 있습니다.  
  
 모든 멤버는 `Path` 클래스는 정적이 고 경로의 인스턴스 없이 호출할 수 있습니다.  
  
> [!NOTE]
>  입력 문자열로 경로 허용 하는 멤버를 해당 경로 올바른 형식 이어야 합니다. 또는 예외가 발생 합니다. 예를 들어, 경로 정규화 공백으로 시작 하지만 경로 클래스의 메서드에서 잘리지 않습니다. 따라서 경로 잘못 되었으며 예외가 발생 합니다. 마찬가지로, 경로 또는 경로의 조합을 두 번 정규화 될 수 없습니다. 예를 들어, "c:\temp c:\windows"는 또한 대부분의 경우에서 예외가 발생합니다. 경로 잘 구성 된 경우에 경로 문자열을 허용 하는 메서드를 사용 하 여 확인 합니다.  
  
 경로 허용 하는 멤버의 경로 파일 또는 디렉터리를 참조할 수 있습니다. 지정된 된 경로 상대 경로 또는 서버 및 공유 이름에 대 한 범용 명명 규칙 (UNC) 경로 참조할 수 있습니다. 예를 들어, 다음은 허용 가능한 경로.  
  
-   "c:\\\MyDir\\\MyFile.txt" C# 또는 Visual Basic의 "c:\MyDir\MyFile.txt"입니다.  
  
-   "c:\\\MyDir" C# 또는 Visual Basic의 "c:\MyDir"입니다.  
  
-   "MyDir\\\MySubdir" C# 또는 Visual Basic의 "MyDir\MySubDir"입니다.  
  
-   "\\\\\\\MyServer\\\MyShare" C#에서 또는 "\\\MyServer\MyShare" Visual Basic의 합니다.  
  
 문자열에서 이러한 모든 작업이 수행 되 되므로 모든 시나리오에서 결과가 올바른지 확인할 수 없습니다. 예를 들어를 <xref:System.IO.Path.GetExtension%2A> 메서드를 전달 하는 문자열을 구문 분석 하 고 해당 문자열에서 확장명을 반환 합니다. 그러나 해당 확장을 사용 하 여 파일을 디스크에 있는지이 아닙니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.   
  
## Examples  
 다음 예제에서는 기본 멤버 중 일부는 `Path` 클래스입니다.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">방법: 새로 만든 데이터 파일 읽기 및 쓰기</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 대체 문자를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
이 필드와 동일한 값을 가질 수 있습니다 <xref:System.IO.Path.DirectorySeparatorChar>합니다. `AltDirectorySeparatorChar` 및 <xref:System.IO.Path.DirectorySeparatorChar> 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.  
  
이 필드의 값은 Windows와 Unix 기반 운영 체제에서 슬래시 ('/').  
  
## Examples  

다음 예제에서는 <xref:System.IO.Path> Unix 기반 시스템에서 Windows에 값 필드입니다. Windows 지원 하거나 슬래시는 (에서 반환 된 합니다 <xref:System.IO.Path.AltDirectorySeparatorChar> 필드) 또는 백슬래시 (에서 반환 된는 <xref:System.IO.Path.DirectorySeparatorChar> 필드)를 경로 구분 기호 문자로, Unix 기반 시스템 슬래시만을 지원 하지만.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">수정할 경로 정보입니다. 경로에는 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 문자가 포함될 수 없습니다.</param>
        <param name="extension">앞에 마침표가 있거나 없는 새 확장명입니다. <paramref name="path" />에서 기존 확장명을 제거하려면 <see langword="null" />을(를) 지정하세요.</param>
        <summary>경로 문자열의 확장명을 변경합니다.</summary>
        <returns>수정된 경로 정보입니다.  
  
Windows 기반 데스크톱 플랫폼에서 <paramref name="path" />이(가) <see langword="null" />이거나 빈 문자열("")이면 경로 정보가 수정되지 않고 반환됩니다. <paramref name="extension" />이(가) <see langword="null" />이면 반환된 문자열에 확장명이 제거된 지정된 경로가 포함되어 있습니다. <paramref name="path" />에 확장명이 없고 <paramref name="extension" />이(가) <see langword="null" />이 아니면 반환된 경로 문자열에는 <paramref name="path" /> 끝에 추가된 <paramref name="extension" />이(가) 포함되어 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모두 `path` 나 `extension` 마침표 (.) `ChangeExtension` 기간을 추가 합니다.  
  
 `extension` 매개 변수는 여러 개의 마침표 및 올바른 경로 문자를 포함할 수 있습니다 및 길이 제한이 있습니다. 경우 `extension` 됩니다 `null`, 반환된 된 문자열의 내용이 들어 `path` 마지막 기간 및 그 다음에 모든 문자 제거 합니다.  
  
 하는 경우 `extension` 빈 문자열이 면 반환된 된 경로 문자열의 내용이 들어 `path` 마지막 마침표 다음 문자를 사용 하 여 제거 합니다.  
  
 하는 경우 `path` 확장 되지 않은 및 `extension` 아닙니다 `null`, 반환 된 문자열에 포함 되어 `path` 뒤에 `extension`입니다.  
  
 하는 경우 `extension` 아닙니다 `null` 앞에 마침표를 포함 하지 않습니다 마침표가 추가 됩니다.  
  
 경우 `path` 여러 마침표로 구분 된 여러 확장을 포함 합니다. 반환된 된 문자열의 내용을 포함 `path` 마지막을 사용 하 여 기간 및 다음 문자만으로 대체 `extension`합니다. 예를 들어 경우 `path` "\Dir1\examples\pathtests.csx.txt"은 및 `extension` "cs" 이면 수정 된 경로 "\Dir1\examples\pathtests.csx.cs"입니다.  
  
 반환된 된 결과 모든 시나리오에서 유효한 지 확인 하는 것이 불가능 합니다. 예를 들어 있으면 `path` 비어 `extension` 추가 됩니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다는 `ChangeExtension` 메서드.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>여러 문자열을 한 경로로 결합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

이 메서드는 개별 문자열 파일 경로 나타내는 단일 문자열로 연결 합니다. 그러나 아닌 첫 번째 인수는 루트 경로 있으면 모든 이전 경로 구성 요소 무시 되 고 해당 루트 경로 구성 요소를 사용 하 여 반환된 된 문자열을 시작 합니다. 대 안으로 합니다 `Combine` 메서드를 사용 하는 것이 좋습니다 합니다 <xref:System.IO.Path.Join%2A> 또는 <xref:System.IO.Path.TryJoin%2A> 메서드.

> [!IMPORTANT]
> 이 메서드는 첫 번째 인수는 절대 경로 및 다음 인수 또는 인수는 상대 경로 가정 합니다. 이 경우 없는 경우 모든 후속 인수는 사용자가 문자열 입력 하는 경우에 특히를 호출 합니다 <xref:System.IO.Path.Join%2A> 또는 <xref:System.IO.Path.TryJoin%2A> 메서드 대신 합니다.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">경로 각 부분의 배열입니다.</param>
        <summary>문자열 배열을 한 경로로 결합합니다.</summary>
        <returns>결합된 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` 배열을 결합 하는 경로 부분을 지정 해야 합니다. 후속 경로 중 하나를 절대 경로 결합 작업을 다시 결합 된 모든 이전 경로 삭제 하는 절대 경로 시작 합니다.  

경우에 있는 모든 요소 `paths` 마지막 드라이브가 아닌로 끝나지 않습니다 하지만 합니다 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 문자를 `Combine` 메서드를 추가 <xref:System.IO.Path.DirectorySeparatorChar> 해당 요소와 다음 사이의 문자. 요소는 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료 하는 경우는 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다. 다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.  
  
 공백이 있는 경우 매개 변수를 구문 분석 됩니다.  
  
 디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다. 예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다. 성공적으로 해석 되므로 `Combine` 메서드.  
  
## Examples  
 다음 예제에서는 경로에 문자열 배열을 결합합니다.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">배열의 문자열 중 하나에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함된 경우</exception>
        <exception cref="T:System.ArgumentNullException">배열의 문자열 중 하나가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">결합할 첫 번째 경로입니다.</param>
        <param name="path2">결합할 두 번째 경로입니다.</param>
        <summary>두 문자열을 한 경로로 결합합니다.</summary>
        <returns>결합된 경로입니다. 지정된 경로 중 하나가 0 길이의 문자열이면 이 메서드는 다른 경로를 반환합니다. <paramref name="path2" />에 절대 경로가 포함되어 있으면 이 메서드는 <paramref name="path2" />을(를) 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `path1` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>를 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>를 <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 연결 하기 전에 합니다. 해당 경우 `path1` 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다. 다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다. 하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.  
  
 공백이 있는 경우 매개 변수를 구문 분석 됩니다. 따라서 경우 `path2` 공백 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드를 추가 `path2` 에 `path1` 만 반환 하는 대신 `path2`합니다.  
  
 디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다. 예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다. 성공적으로 해석 되므로 `Combine` 메서드.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제는 `Combine` Windows 기반 데스크톱 플랫폼에서 메서드.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> 또는 <paramref name="path2" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> 또는 <paramref name="path2" />가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">결합할 첫 번째 경로입니다.</param>
        <param name="path2">결합할 두 번째 경로입니다.</param>
        <param name="path3">결합할 세 번째 경로입니다.</param>
        <summary>세 문자열을 한 경로로 결합합니다.</summary>
        <returns>결합된 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` 절대 경로 여야 합니다 (예를 들어, "d:\archives" 또는 "\\\archives\public"). 하는 경우 `path2` 또는 `path3` 결합 작업 이전에 모두 무시 항목 경로 및 절대 경로를 다시 설정 합니다. 절대 경로 이기도 합니다.  
  
 길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.  
  
 하는 경우 `path1` 또는 `path2` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> 에 추가 됩니다 `path1` 또는`path2` 연결 하기 전에 합니다. 경우 `path1` 나 `path2` 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다. 다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다. 하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.  
  
 공백이 있는 경우 매개 변수를 구문 분석 됩니다. 따라서 경우 `path2` 공백 문자 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드 추가 `path2` 에 `path1`입니다.  
  
 디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다. 예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다. 성공적으로 해석 되므로 `Combine` 메서드.  
  
   
  
## Examples  
 다음 예제에서는 세 개의 경로 결합합니다.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" /> 또는 <paramref name="path3" />이 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" /> 또는 <paramref name="path3" />가 <see langword="null" />입니다.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">결합할 첫 번째 경로입니다.</param>
        <param name="path2">결합할 두 번째 경로입니다.</param>
        <param name="path3">결합할 세 번째 경로입니다.</param>
        <param name="path4">결합할 네 번째 경로입니다.</param>
        <summary>네 문자열을 한 경로로 결합합니다.</summary>
        <returns>결합된 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` 절대 경로 여야 합니다 (예를 들어, "d:\archives" 또는 "\\\archives\public"). 후속 경로 중 하나 이면 절대 경로 결합 작업은 이전에 결합 된 모든 경로 삭제 하 고 절대 경로를 다시 설정 합니다.  
  
 길이가 0 인 문자열 조합된 된 경로에서 생략 됩니다.  
  
 하는 경우 `path1`, `path2`, 또는 `path3` (즉, "c:" 또는 "d:") 드라이브 참조가 아닌 경우 및에 정의 된 대로 유효한 구분 기호 문자로 끝나지 않습니다 <xref:System.IO.Path.DirectorySeparatorChar>에 <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> 추가 됩니다 이전 연결 합니다. 경우 `path1`, `path2`, 또는 `path3` 는 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Combine` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 항목을 추가 합니다. 다음 예에서는 백슬래시를 경로 구분 기호 문자로 사용 되는 경우 Windows 및 Unix 기반 시스템에서 결과 비교 합니다. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 경우 `path2` 루트를 포함 하지 않습니다 (예를 들어 `path2` 시작 하지 않고 구분 기호 문자 또는 드라이브 지정), 결과 중간에 다른 구분 기호 문자로 두 경로 연결 합니다. 하는 경우 `path2` 루트가 포함 `path2` 반환 됩니다.  
  
 공백이 있는 경우 매개 변수를 구문 분석 됩니다. 따라서 경우 `path2` 공백 문자 (예: "\file.txt")를 포함 합니다 <xref:System.IO.Path.Combine%2A> 메서드 추가 `path2` 에 `path1`입니다.  
  
 디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Combine` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다. 예를 들어 while `Path.Combine("c:\\", "*.txt")` 잘못 되었을 수 검색 문자열로 유효에서 파일을 만드는 경우입니다. 성공적으로 해석 되므로 `Combine` 메서드.  
  
   
  
## Examples  
 다음 예제에서는 네 개의 경로 결합합니다.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> 또는 <paramref name="path4" />가 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자 중 하나 이상을 포함합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> 또는 <paramref name="path4" />가 <see langword="null" />입니다.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>계층적 파일 시스템 구조를 반영하는 경로 문자열에서 디렉터리 수준을 구분하는 데 사용되는 플랫폼 특정 문자를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> 및 `DirectorySeparatorChar` 은 모두 경로 문자열에서 디렉터리 수준을 구분 하는 것에 대 한 유효 합니다.  
  
경우.NET Core를 사용 하 여 여러 플랫폼에서 실행 되는 응용 프로그램을 개발 하는:

- 슬래시를 사용 해야를 하드 코드 디렉터리 구분 문자로 선호 하는 경우 (`/`) 문자입니다. Unix 시스템에서 인식할 수 있는 유일한 디렉터리 구분 문자는 예제에서 출력으로 며는 <xref:System.IO.Path.AltDirectorySeparatorChar> Windows에서.

- 문자열 연결을 사용 하 여 동적으로 런타임 시 경로 구분 기호 문자를 검색 하 고 파일 시스템 경로에 통합. 예를 들면 다음과 같습니다. 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   값을 검색할 수도 있습니다는 <xref:System.IO.Path.AltDirectorySeparatorChar> 속성, Windows 및 Unx 기반 시스템 모두에서 동일 이기 때문입니다.

- 검색 된 <xref:System.IO.Path.AltDirectorySeparatorChar> 속성

응용 프로그램 플랫폼 간 없는 경우에 시스템에 대 한 적절 한 구분 기호를 사용할 수 있습니다.

## Examples  

다음 예제에서는 <xref:System.IO.Path> Unix 기반 시스템에서 Windows에 값 필드입니다. Windows 지원 하거나 슬래시는 (에서 반환 된 합니다 <xref:System.IO.Path.AltDirectorySeparatorChar> 필드) 또는 백슬래시 (에서 반환 된는 <xref:System.IO.Path.DirectorySeparatorChar> 필드)를 경로 구분 기호 문자로, Unix 기반 시스템 슬래시만을 지원 하지만.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>문자 범위로 표시되는 지정된 경로의 디렉터리 정보를 반환합니다.</summary>
        <returns><paramref name="path" />의 디렉터리 정보 또는 <paramref name="path" />가 <see langword="null" />인 경우 빈 범위, 빈 범위 또는 루트(예: \,C: 또는 \\server\share)입니다.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">파일 또는 디렉터리의 경로입니다.</param>
        <summary>지정된 경로 문자열에 대한 디렉터리 정보를 반환합니다.</summary>
        <returns><paramref name="path" />에 대한 디렉터리 정보이며, <paramref name="path" />이(가) 루트 디렉터리를 나타내거나 null인 경우 <see langword="null" />입니다. <see cref="F:System.String.Empty" />에 디렉터리 정보가 포함되어 있지 않으면 <paramref name="path" />이(가) 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 경우에서이 메서드에서 반환 된 문자열 모든 문자로 구성 경로의 마지막 포함 되지 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>합니다. 경로 구성 된 경우의 루트 디렉터리와 같은 "c:\\", null이 반환 됩니다. 이 메서드를 사용 하 여 경로 지원 하지 않습니다 "파일:". 반환 된 경로 포함 되어 있지 않으므로 합니다 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar>, 다시 반환 된 경로 전달 합니다 <xref:System.IO.Path.GetDirectoryName%2A> 메서드는 결과 문자열에 대 한 후속 호출 당 하나의 폴더 수준의 잘림이 발생 합니다. 예를 들어, "C:\Directory\SubDirectory\test.txt" 경로에 전달 된 <xref:System.IO.Path.GetDirectoryName%2A> 메서드는 "C:\Directory\SubDirectory"를 반환 합니다. 해당 문자열이 "C:\Directory\SubDirectory" 전달 <xref:System.IO.Path.GetDirectoryName%2A> "C:\Directory" 됩니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제는 `GetDirectoryName` Windows 기반 데스크톱 플랫폼에서 메서드.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 매개 변수가 잘못된 문자를 포함하거나, 비어 있거나, 공백만 포함하는 경우</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 <paramref name="path" /> 매개변수가 시스템에 정의된 최대 길이보다 깁니다.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">확장명을 가져올 파일 경로입니다.</param>
        <summary>읽기 전용 문자 범위로 표시되는 파일 경로의 확장명을 반환합니다.</summary>
        <returns>지정된 경로(마침표 “.” 포함)의 확장명 또는 <paramref name="path" />에 확장명 정보가 없는 경우 <see cref="P:System.ReadOnlySpan`1.Empty" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

이 메서드는 확장명을 가져옵니다 `path` 를 검색 하 여 `path` 동안 ("."), 읽기 전용 범위에서 마지막 문자에서 시작 하 고 해당 첫 번째 문자까지 합니다. 잠시 전에 발견 되는 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 문자, 후, 기간 및 문자를 포함 하는 반환 된 읽기 전용 범위가 고, 그렇지 <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> 반환 됩니다.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">확장명을 가져올 경로 문자열입니다.</param>
        <summary>지정된 경로 문자열에서 확장명을 반환합니다.</summary>
        <returns>"."(마침표)를 포함한 지정된 경로의 확장명, <see langword="null" /> 또는 <see cref="F:System.String.Empty" />입니다. <paramref name="path" />이(가) <see langword="null" />이면, <see cref="M:System.IO.Path.GetExtension(System.String)" />은(는) <see langword="null" />을(를) 반환합니다. <paramref name="path" />에 확장명 정보가 없는 경우 <see cref="M:System.IO.Path.GetExtension(System.String)" />은(는) <see cref="F:System.String.Empty" />을(를) 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

이 메서드는 확장명을 가져옵니다 `path` 를 검색 하 여 `path` 마침표 (.)의 마지막 문자를 사용 하 여 시작에 대 한 `path` 첫 번째 문자까지 합니다. 잠시 전에 발견 되는 <xref:System.IO.Path.DirectorySeparatorChar> 또는 <xref:System.IO.Path.AltDirectorySeparatorChar> 뒤; 기간 및 문자를 포함 하는 반환 되는 문자열 문자이 고, 그렇지 <xref:System.String.Empty?displayProperty=nameWithType> 반환 됩니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.
 
## Examples  
 다음 예제는 `GetExtension` Windows 기반 데스크톱 플랫폼에서 메서드.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">파일 이름과 확장명을 가져올 경로를 포함하는 읽기 전용 범위입니다.</param>
        <summary>읽기 전용 문자 범위로 표시되는 파일 경로의 파일 이름 및 확장명을 반환합니다.</summary>
        <returns><paramref name="path" />에서 마지막 디렉터리 구분 문자 뒤의 문자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

반환 된 읽기 전용 범위에서 마지막 구분 기호를 수행 하는 경로 문자가 `path`합니다. 하는 경우의 마지막 문자 `path` 메서드는 반환 디렉터리나 볼륨 구분 기호 문자는 <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>합니다. 하는 경우 `path` 메서드는 반환 없음 구분 기호 문자를 포함 `path`합니다.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">파일 이름과 확장명을 가져올 경로 문자열입니다.</param>
        <summary>지정된 경로 문자열에서 파일 이름과 확장명을 반환합니다.</summary>
        <returns><paramref name="path" />에서 마지막 디렉터리 구분 문자 뒤의 문자입니다. <paramref name="path" />의 마지막 문자가 디렉터리나 볼륨 구분 문자이면 이 메서드는 <see cref="F:System.String.Empty" />을(를) 반환합니다. <paramref name="path" />이(가) <see langword="null" />이면 이 메서드는 <see langword="null" />을(를) 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

반환된 된 값이 `null` 파일 경로 이면 `null`합니다.  
  
시작 파일 이름 부분을 확인 하는 데 구분 기호 문자 <xref:System.IO.Path.DirectorySeparatorChar> 고 <xref:System.IO.Path.AltDirectorySeparatorChar>입니다.  

때문에 *\\* Unix에서 올바른 파일 이름이 `GetFileName` Unix 기반 플랫폼에서 실행 되는 Windows에서 파일 이름을 올바르게 반환 없습니다 =와 같은 기반된 경로 *c:\\mydir\\myfile.ext*, 하지만 `GetFileName` 와 같은 Unix 기반 경로에서 Windows 기반 플랫폼에서 실행 파일 이름을 올바르게 반환할 수 있습니다 */tmp/myfile.ext*이므로의 동작을 `GetFileName` 메서드는 하지 엄격 하 게 Unix 및 Windows 기반 플랫폼에서 동일 합니다.

공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 동작을 보여 줍니다.는 `GetFileName` Windows 기반 데스크톱 플랫폼에서 메서드.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">확장명 없이 파일 이름을 가져올 경로를 포함하는 읽기 전용 범위입니다.</param>
        <summary>읽기 전용 문자 범위로 표시되는 파일 경로의 확장명 없는 파일 이름을 반환합니다.</summary>
        <returns>마지막 마침표(.)와 그다음에 나오는 모든 문자를 제외한 <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />에서 반환된 읽기 전용 범위의 문자입니다.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">파일의 경로입니다.</param>
        <summary>확장명 없이 지정된 경로 문자열의 파일 이름을 반환합니다.</summary>
        <returns>마지막 마침표(.)와 그 다음에 나오는 모든 문자인 <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />에서 반환한 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다는 `GetFileNameWithoutExtension` 메서드.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">절대 경로 정보를 가져올 파일 또는 디렉터리입니다.</param>
        <summary>지정된 경로 문자열에 대한 절대 경로를 반환합니다.</summary>
        <returns>"C:\MyFile.txt"처럼 <paramref name="path" />의 정규화된 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 시스템에서 파일 또는 디렉터리를 찾는 데 필요한 모든 정보를 포함 하는 절대 경로입니다.  
  
 파일 또는 지정 된 디렉터리가 `path` 있이 필요는 없습니다. 예를 들어 경우 *c:\temp\newdir* 은 현재 디렉터리 호출 `GetFullPath` 와 같은 파일 이름을 *test.txt* 반환 *c:\temp\newdir\test.txt*합니다. 파일이 필요 합니다.  

> [!IMPORTANT]
> 경우 `path` 상대 경로이 오버 로드에 현재 드라이브 및 현재 디렉터리에 기반 할 수 있습니다 하는 정규화 된 경로 반환 합니다. 응용 프로그램을 실행할 때 현재 디렉터리와 현재 드라이브 언제 든 지 변경할 수 있습니다. 결과적으로,이 오버 로드에서 반환 하는 경로가 사전에 확인할 수 없습니다. 명확한 경로 반환 하려면 호출을 <xref:System.IO.Path.GetFullPath(System.String,System.String)> 오버 로드 합니다. 호출할 수도 있습니다는 <xref:System.IO.Path.IsPathFullyQualified%2A> 이거나 상대 경로 경로 정규화 된 여부를 결정 하는 방법 및 여부에 대 한 호출 `GetFullPath` 필요 합니다.

 그러나 경우 `path` 없으면 호출자에 대 한 경로 정보를 얻을 수 있는 권한이 있어야 합니다. `path`합니다. 멤버는 대부분 달리는 <xref:System.IO.Path> 클래스,이 메서드는 파일 시스템에 액세스 합니다.  
  
 이 메서드는 현재 디렉터리와 현재 볼륨 정보를 사용 하 여 정규화 `path`합니다. 파일을 지정 하는 경우에 이름을 `path`, `GetFullPath` 현재 디렉터리의 정규화 된 경로 반환 합니다.  
  
 짧은 파일 이름에 전달 하는 경우 긴 파일 이름으로 확장 됩니다.  
  
 경로 중요 한 문자가 없는 경우 사용할 수 없는 하나 이상 포함 되어 있지 않으면 "." 문자 뒤에 공백 개수에 관계 없이 로 구문 분석 됩니다 "."또는"..".  

.NET core 1.1 및 이후 버전 및.NET Framework 4.6.2 및 이상 버전도 같은 장치 이름을 포함 하는 경로 지원 "\\? \C:\"합니다.

Windows에서 파일 경로 형식에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다. 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.
  
## Examples  
 다음 예제는 `GetFullPath` Windows 기반 데스크톱 플랫폼에서 메서드.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />가 길이가 0인 문자열이거나 공백만 포함하거나 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 하나 이상의 잘못된 문자를 포함하는 경우  
  
또는 
절대 경로를 검색할 수 없는 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 사용 권한이 없습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />에 볼륨 식별자(예: "c:\\")의 일부가 아닌 콜론(":")이 포함됩니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><paramref name="basePath" />에 연결할 상대 경로입니다.</param>
        <param name="basePath">정규화된 경로의 시작입니다.</param>
        <summary>정규화된 기본 경로의 절대 경로와 상대 경로를 반환합니다.</summary>
        <returns>절대 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

하는 경우 `path` 메서드는 빈 경로 `basePath`합니다. 하는 경우 `path` 메서드에 전달 하는 정규화 된 경로가 `path` 에 <xref:System.IO.Path.GetFullPath(System.String)> 메서드 결과 반환 합니다.

이 메서드를 사용 하 여 결정적 경로 지정된 된 볼륨을 기반으로 하며 상대 경로 사용 하는 경우 디렉터리를 루트 돌아갑니다. 미리 정의 된를 사용 하 여 `basePath` 현재 드라이브 및 디렉터리에서 예기치 않은 변경 사항으로 인해 불필요 한 파일 경로 대 한 현재 드라이브 디렉터리 가드에 기반 하는 대신 합니다. 

## <a name="example"></a>예제

다음 예에서는 변수를 정의 `basePath`를 응용 프로그램의 현재 디렉터리를 나타냅니다. 그런 다음 전달 하는 `GetFullPath` 응용 프로그램의 데이터 디렉터리로 정규화 된 경로 가져올 방법입니다.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 또는 <paramref name="basePath" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" />는 정규화된 경로가 아닙니다.

또는

<paramref name="path" /> 또는 <paramref name="basePath" />에 U+0000과 같은 잘못된 경로 문자가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파일 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</summary>
        <returns>파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다. 전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다. 예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 메서드 및 <xref:System.IO.Path.GetInvalidPathChars%2A> 잘못 된 문자를 검색 하는 방법입니다.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>경로 이름에 사용할 수 없는 문자가 포함된 배열을 가져옵니다.</summary>
        <returns>파일 이름에 사용할 수 없는 문자가 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다. 전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다. 예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 메서드 및 <xref:System.IO.Path.GetInvalidPathChars%2A> 잘못 된 문자를 검색 하는 방법입니다.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">루트 디렉터리 정보를 가져올 경로입니다.</param>
        <summary>지정된 문자 범위에 포함된 경로에서 루트 디렉터리 정보를 가져옵니다.</summary>
        <returns>`path`의 루트 디렉터리를 포함하는 문자 범위입니다.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">루트 디렉터리 정보를 가져올 경로입니다.</param>
        <summary>지정된 경로의 루트 디렉터리 정보를 가져옵니다.</summary>
        <returns><paramref name="path" />의 루트 디렉터리이며, <paramref name="path" />가 <see langword="null" />인 경우 <see langword="null" />이며 <paramref name="path" />에 루트 디렉터리 정보가 포함되어 있지 않은 경우 빈 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.  
  
 이 메서드에서 반환 된 문자열에 대 한 가능한 패턴은 다음과 같습니다.  
  
- 빈 문자열 (`path` 현재 드라이브 또는 볼륨에 대 한 상대 경로 지정).  
  
- "\" (`path` 현재 드라이브의 절대 경로 지정).  
  
- "X:" (`path` 여기서 X 나타냅니다 드라이브 또는 볼륨 문자를 드라이브에 대 한 상대 경로 지정).  
  
- "X:\" (`path` 절대 경로가 지정된 된 드라이브에서 지정).  
  
- "\\\ComputerName\SharedFolder" (UNC 경로).  
  
- "\\? \C:" (DOS 장치 경로.NET Core 1.1 이상 및.NET Framework 4.6.2 이상 버전에서 지원)
   
 Windows에서 파일 경로에 대 한 자세한 내용은 참조 하세요. [Windows 시스템에서 파일 경로 형식](~/docs/standard/io/file-path-formats.md)합니다. 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
## Examples  
 다음 예제를 사용 하는 방법을 보여 줍니다는 `GetPathRoot` 메서드.  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우  
  
또는 
 <paramref name="path" />에 <see cref="F:System.String.Empty" />가 전달된 경우</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>임의의 폴더 이름 또는 파일 이름을 반환합니다.</summary>
        <returns>임의의 폴더 이름 또는 파일 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.GetRandomFileName%2A> 메서드는 폴더 이름 또는 파일 이름으로 사용할 수 있는 강력 하 게 암호화, 임의 문자열을 반환 합니다. 와 달리 <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> 파일을 만들지 않습니다. 파일 시스템의 보안을 매우 중요 하지만,이 메서드 대신 사용 해야 <xref:System.IO.Path.GetTempFileName%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서 출력 보기는 <xref:System.IO.Path.GetRandomFileName%2A> 메서드.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">결과 경로의 기준이 되는 소스 경로입니다. 이 경로는 항상 디렉터리로 간주합니다.</param>
        <param name="path">대상 경로입니다.</param>
        <summary>한 경로에서 다른 경로까지 상대 경로를 반환합니다.</summary>
        <returns>상대 경로 또는 경로가 동일한 루트를 공유하지 않는 경우 <paramref name="path" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

호출 하 여 경로로 확인 되는 <xref:System.IO.Path.GetFullPath%2A> 차이 계산 하기 전에 메서드. 현재 플랫폼에 대 한 기본 파일 경로 비교를 사용 하는 메서드 (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> Windows 및 MacOs 용 <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> Linux에 대 한 합니다. 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> 또는 <paramref name="path" />가 <see langword="null" />인 경우</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>디스크에 크기가 0바이트인 고유한 이름의 임시 파일을 만들고 해당 파일의 전체 경로를 반환합니다.</summary>
        <returns>임시 파일의 전체 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법을 사용 하 여 임시 파일을 만듭니다는 합니다. TMP 파일 확장명입니다. 사용자의 임시 폴더 경로 내에서 임시 파일을 만들 반환한는 <xref:System.IO.Path.GetTempPath%2A> 메서드.  
  
 합니다 <xref:System.IO.Path.GetTempFileName%2A> 메서드를 발생 시킵니다는 <xref:System.IO.IOException> 이전 임시 파일을 삭제 하지 않고 65535 개 파일을 만들려면 사용 하는 경우.  
  
 합니다 <xref:System.IO.Path.GetTempFileName%2A> 메서드를 발생 시킵니다는 <xref:System.IO.IOException> 고유한 임시 파일 이름은 사용할 수 없는 경우. 이 오류를 해결 하려면 모든 필요 없는 임시 파일을 삭제 합니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">사용할 수 있는 고유한 임시 파일 이름이 없는 경우와 같은 I/O 오류가 발생한 경우  
  
또는 
이 메서드로 임시 파일을 만들지 못한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">임시 디렉터리에 작성 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 사용자의 임시 폴더 경로를 반환합니다.</summary>
        <returns>백슬래시로 끝나는 임시 폴더 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 다음 순서 대로 환경 변수의 존재 유무를 확인 하 고 찾은 첫 번째 경로 사용 하 여:  
  
1.  TMP 환경 변수로 지정 된 경로입니다.  
  
2.  TEMP 환경 변수로 지정 된 경로입니다.  
  
3.  USERPROFILE 환경 변수로 지정 된 경로입니다.  
  
4.  Windows 디렉터리입니다.  
  
   
  
## Examples  
 다음 코드에서는 <xref:System.IO.Path.GetTempPath%2A> 메서드를 호출하는 방법을 보여 줍니다.  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 이 예제에서는 다음과 유사한 출력을 생성 합니다.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 사용 권한이 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">환경 변수를 무제한으로 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">확장명을 검색할 경로입니다.</param>
        <summary>지정된 문자 범위로 표시되는 경로에 파일 이름 확장명이 포함되는지 확인합니다.</summary>
        <returns>경로의 마지막 디렉터리 구분 문자 또는 볼륨 구분 기호 다음에 나오는 문자에 마침표(“.”)와 하나 이상의 문자가 차례로 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

마침표 `path` 확장으로 간주 되지 않습니다.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">확장명을 검색할 경로입니다.</param>
        <summary>경로에 파일 확장명이 포함된지를 확인합니다.</summary>
        <returns>경로의 마지막 디렉터리 구분 문자(\\\ 또는 /) 또는 볼륨 구분 기호 문자(:) 다음에 나오는 문자에 마침표(.)와 하나 이상의 문자가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 끝에서 시작 `path`, 하나 이상의 문자 뒤에 마침표 (.)이이 메서드를 검색 합니다. 이 패턴은 되기 전에 발견 되는 경우는 <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, 또는 <xref:System.IO.Path.VolumeSeparatorChar> 문자가 발견 되는이 메서드가 반환 `true`합니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 `HasExtension` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.IO.Path" /> 클래스의 멤버에 전달되는 경로 문자열 인수에 사용할 수 없는 플랫폼 특정 문자 배열을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 된 배열 전체 파일 및 디렉터리 이름에 잘못 된 문자 집합을 포함 하는 보장 되지 않습니다. 전체 집합이 잘못 된 문자는 파일 시스템에 따라 달라질 수 있습니다. 예를 들어 Windows 기반 데스크톱 플랫폼에서 잘못 된 경로 문자가 있습니다/유니코드 문자 1-31, 뿐만 아니라 따옴표 ("), 보다 작은 (\<), 보다 큼 (>), 파이프 (&#124;), 백스페이스 (\b), null (\0) 및 탭 (\t)입니다.  
  
> [!CAUTION]
>  사용 하지 않는 <xref:System.IO.Path.InvalidPathChars> 경우 코드는 신뢰할 수 없는 코드와 동일한 응용 프로그램 도메인에서 실행 될 수 있습니다. <xref:System.IO.Path.InvalidPathChars> 배열 이므로 해당 요소를 덮어쓸 수 있습니다. 신뢰할 수 없는 코드의 요소를 덮어쓰면 <xref:System.IO.Path.InvalidPathChars>, 악용 될 수 있는 방식으로 작동 하지 코드 발생할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 된 `InvalidPathChars` 속성입니다.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>파일 경로가 정규화되었는지 여부를 나타내는 값을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

오버 로드는 `IsPathFullyQualified` 둘 다 사용 하는 메서드 핸들 경로 <xref:System.IO.Path.DirectorySeparatorChar> 및 <xref:System.IO.Path.AltDirectorySeparatorChar> 문자입니다. 인수로 전달 되는 경로에 모든 유효성 검사를 수행 하지 않습니다. Uri 상대 경로로 해석 되 고 반환 결과적으로, `false`합니다. 

정규화 된 경로 차이가 (나타난 것 처럼 합니다 `IsPathFullyQualified` 메서드) 및 루트 경로 (나타난 것 처럼는 <xref:System.IO.Path.IsPathRooted%2A> 메서드). A *정규화 된 경로* 하거나 *절대 경로* 항상 대상 파일 또는 디렉터리에는 특정 드라이브 또는 장치에서 정확한 경로 정의 하 고 현재 디렉터리를 현재 드라이브에 종속 되지 않습니다. Windows 시스템에서 예를 들어 *C:/users/user1/documents/reports/2019/january/highlights.pdf* c: 드라이브의 루트에서 대상 파일에 절대 경로 정의 *highlights.pdf*합니다. A *루트 경로* 시작 드라이브 또는 루트 디렉터리를 지정 하지만 (루트 디렉터리에서 루 팅) 하는 경우 현재 디렉터리 (드라이브를 지정된 하 여 루트) 하는 경우 또는 현재 드라이브에 따라 달라 집니다. 다음 예제에서는 정규화 된 경로 및 루트 경로 간의 차이점을 보여 줍니다.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">파일 경로입니다.</param>
        <summary>지정된 문자 범위로 표시되는 파일 경로가 특정 드라이브 또는 UNC 경로에 고정되었는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>경로가 특정 드라이브 또는 UNC 경로에 고정된 경우 <see langword="true" />이고, 경로가 현재 드라이브 또는 작업 디렉터리에 상대적인 경우 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">파일 경로입니다.</param>
        <summary>지정된 파일 경로가 특정 드라이브 또는 UNC 경로에 고정되었는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>경로가 특정 드라이브 또는 UNC 경로에 고정된 경우 <see langword="true" />이고, 경로가 현재 드라이브 또는 작업 디렉터리에 상대적인 경우 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />입니다.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>파일 경로에 루트가 포함되는지 여부를 나타내는 값을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

A **루트 경로** 파일 경로가 UNIC 경로 또는 특정 드라이브에 고정 되어 있는; 현재 드라이브 또는 작업 디렉터리를 기준으로 하는 경로 사용 하 여 대조 됩니다. 예를 들어, Windows 시스템에서 루트 경로 (예: "\Documents") 백슬래시 또는 드라이브 문자 및 콜론 (예: "C:Documents")를 사용 하 여 시작합니다. 

루트 경로 (즉, 정규화 된) 절대 또는 상대 경로일 수 있습니다는 note 합니다. 절대 루트 경로 특정 디렉터리를 드라이브의 루트에서 정규화 된 경로입니다. 상대 루트 경로 드라이브를 지정 하지만 해당 정규화 된 경로가 현재 디렉터리에 대 한 해결. 다음 예제에서 차이점을 보여 줍니다.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">테스트할 경로입니다.</param>
        <summary>파일 경로를 나타내는 지정된 문자 범위가 루트를 포함하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="path" />에 루트가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">테스트할 경로입니다.</param>
        <summary>지정된 경로 문자열에 루트가 포함되는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="path" />에 루트가 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.IO.Path.IsPathRooted%2A> 메서드가 반환 `true` 첫 번째 문자 디렉터리 구분 기호 문자가 문자 인지와 같은 "\\", 경로 드라이브 문자와 콜론 (:)으로 시작 하는 경우 또는 합니다. 예를 들어 반환 `true` 에 대 한 `path` 와 같은 문자열 "\\\MyDir\\\MyFile.txt", "c:\\\MyDir", 또는 "C:MyDir"입니다. 반환 `false` 에 대 한 `path` "MyDir"와 같은 문자열입니다.  
  
 이 메서드는 경로 또는 파일 이름이 존재 하는지 확인 하지 않습니다.  
  
 공통적인 I/O 작업의 목록을 참조 하세요 [공통적인 I/O 작업](~/docs/standard/io/common-i-o-tasks.md)합니다.  

## Examples  
 다음 예제에서는 방법을 `IsPathRooted` 세 개의 문자열을 테스트 하려면 메서드를 사용할 수 있습니다.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />에 <see cref="M:System.IO.Path.GetInvalidPathChars" />에 정의된 잘못된 문자가 하나 이상 포함되어 있는 경우</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="path2">조인할 두 번째 경로를 포함하는 문자 범위입니다.</param>
        <summary>두 경로 구성 요소를 단일 경로로 연결합니다.</summary>
        <returns>결합된 경로입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
이 메서드를 단순히 연결 `path` 하 고 `path2` 끝에 있는 이미 있지 않은 경우 두 개의 경로 구성 요소 간에 디렉터리 구분 문자를 추가 하 고 `path1` 의 시작 이나 `path2`합니다. 경우는 <xref:System.ReadOnlySpan%601.Length> 중 `path1` 또는 `path2` 가 0 이면 메서드는 다른 경로 반환 합니다. 경우는 <xref:System.ReadOnlySpan%601.Length> 둘 다의 `path1` 하 고 `path2` 가 0 이면 메서드는 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 

하는 경우 `path1` 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Join` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 것을 추가 합니다. Windows 백슬래시를 사용 하는 하드 코드 된 경로에서이 문제가 발생 합니다 ("\") 문자를 경로 구분 기호로 Unix 기반 시스템에서 인식 되지 않습니다. 이 문제를 해결 하려면 다음을 수행할 수 있습니다.

- 값을 검색 합니다 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 디렉터리 구분 문자를 하드 코딩 하는 것이 아니라 속성입니다.

- 디렉터리 구분 기호로 슬래시 ("/")를 사용 합니다. 이 문자에서 반환 되는 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Unix 기반 시스템 및 속성을 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Windows 시스템에서 속성입니다. 

달리 합니다 <xref:System.IO.Path.Combine%2A> 메서드는 <xref:System.IO.Path.Join%2A> 메서드는 반환 된 경로 루트를 시도 하지 않습니다. (즉, `path2` 절대 경로 합니다 `Join` 메서드는 삭제 하지 않습니다 `path1` 반환 `path2` 으로 <xref:System.IO.Path.Combine%2A> 메서드는.) 다음 예제에서는 두 가지 방법으로 반환 된 경로에서 차이점을 보여 줍니다. 경우 원인을 `path2` 사용자 입력이를 <xref:System.IO.Path.Combine%2A> 메서드를 사용 하면 파일 시스템 리소스에 액세스 하는 사용자 (같은 *c: /사용자/User1/문서/재무/* 예제의 경우) 응용 프로그램에서 수행한 액세스할 수 있도록 하려는 합니다.  

디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Join` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다. 예를 들어 while `Path.Join("c:\\", "*.txt")` 있습니다 수 잘못 된 경우 파일을 만드는 것이 올바른 검색 문자열입니다. `Join` 메서드 따라서 성공적으로 해석 합니다. 

## <a name="example"></a>예제

다음 예제에서 반환 된 경로에서 차이점을 보여 줍니다.는 <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> 고 <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> 메서드. 첫 번째 문자열은 드라이브 및 루트 디렉터리를 포함 하는 정규화 된 경로 두 번째는 첫 번째 경로에서 상대 경로 두 메서드는 동일한 결과 생성 합니다. 두 번째와 세 번째 호출에서는 `ShowPathInformation` 메서드를 두 가지 방법으로 반환 된 문자열을 분기 합니다. 두 번째 메서드 호출에서 첫 번째 문자열 인수는 드라이브, 두 번째는 루트 디렉터리입니다. `Join` 두 문자열을 연결 하는 메서드 및 유지 중복 경로 구분 기호입니다. `Combine` 메서드 드라이브를 중단 하 고 현재 드라이브에서 루트 디렉터리를 반환 합니다. C:\ 드라이브에는 응용 프로그램의 현재 문자열은 파일이 나 디렉터리의 파일을 사용 하 고 c: d: 대신에 액세스 하 합니다. 마지막으로, 때문에 세 번째 호출에서 두 인수 `ShowPathInformation` 루 팅 된를 `Join` 메서드에서 단순히 추가 동안 무의미 파일 경로 만들 수는 `Combine` 메서드 첫 번째 문자열을 삭제 하 고 두 번째를 반환 합니다. 파일 액세스 수 있도록 응용 프로그램에 대 한이 문자열을 사용 하 여 중요 한 파일에 대 한 의도 하지 않은 액세스 합니다.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="path2">조인할 두 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="path3">조인할 세 번째 경로를 포함하는 문자 범위입니다.</param>
        <summary>세 개의 경로 구성 요소를 단일 경로로 연결합니다.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
이 메서드를 단순히 연결 `path`, `path2`, 및 `path3` 표시 되어 있지 않으면 하는 경우 경로 구성 요소 간에 디렉터리 구분 문자를 추가 합니다. 경우는 <xref:System.ReadOnlySpan%601.Length> 하나라 `path1`, `path2`, 또는 `path3` 인수가 0 이면 나머지 인수를 연결 하는 메서드. 경우는 <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> 가 0 이면 모든 구성 요소의 메서드 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.    

하는 경우 `path1` 또는 `path2` 는 대상 플랫폼에 적합 하지 않은 경로 구분 기호 문자에서 종료를 `Join` 메서드는 원래 경로 구분 기호 문자를 유지 하 고 지원 되는 것을 추가 합니다. Windows 백슬래시를 사용 하는 하드 코드 된 경로에서이 문제가 발생 합니다 ("\") 문자를 경로 구분 기호로 Unix 기반 시스템에서 인식 되지 않습니다. 이 문제를 해결 하려면 다음을 수행할 수 있습니다.

- 값을 검색 합니다 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 디렉터리 구분 문자를 하드 코딩 하는 것이 아니라 속성입니다.

- 디렉터리 구분 기호로 슬래시 ("/")를 사용 합니다. 이 문자에서 반환 되는 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Unix 기반 시스템 및 속성을 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Windows 시스템에서 속성입니다. 

달리 합니다 <xref:System.IO.Path.Combine%2A> 메서드는 <xref:System.IO.Path.Join%2A> 메서드는 반환 된 경로 루트를 시도 하지 않습니다. (즉, `path2` 또는 `path2` 절대 경로를 `Join` 메서드는 이전 경로를 삭제 하지 않습니다는 <xref:System.IO.Path.Combine%2A> 메서드는 하지 않습니다.  
  
디렉터리 및 파일 이름에 일부 잘못 된 문자에서 허용 되지 않는으로 해석 되는 `Join` 메서드 검색 와일드 카드 문자를 이러한 문자를 사용할 수 있으므로 합니다. 예를 들어 while `Path.Join("c:\\", "temp", "*.txt")` 있습니다 수 잘못 된 경우 파일을 만드는 것이 올바른 검색 문자열입니다. `Join` 메서드 따라서 성공적으로 해석 합니다. 

## <a name="example"></a>예제

다음 예제에서 반환 된 경로에서 차이점을 보여 줍니다.는 <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> 고 <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> 메서드. 첫 번째 문자열은 드라이브 및 루트 디렉터리를 포함 하는 정규화 된 경로 두 번째는 첫 번째 경로에서 상대 경로 두 메서드는 동일한 결과 생성 합니다. 두 번째와 세 번째 호출에서는 `ShowPathInformation` 메서드를 두 가지 방법으로 반환 된 문자열을 분기 합니다. 두 번째 메서드 호출에서 첫 번째 문자열 인수는 드라이브, 두 번째는 루트 디렉터리입니다. `Join` 두 문자열을 연결 하는 메서드 및 유지 중복 경로 구분 기호입니다. 에 대 한 호출을 <xref:System.IO.Path.GetFullPath%2A> 메서드는 중복을 제거 합니다. `Combine` 메서드 드라이브를 중단 하 고 현재 드라이브에서 루트 디렉터리를 반환 합니다. C:\ 드라이브에는 응용 프로그램의 현재 문자열은 파일이 나 디렉터리의 파일을 사용 하 고 c: d: 대신에 액세스 하 합니다. 마지막으로, 때문에 세 번째 호출에서 마지막 인수 `ShowPathInformation` 루 팅 된를 `Join` 메서드 단순히 추가 무의미 파일 경로 만들려면 먼저 두 개의 인수를 하는 동안는 `Combine` 처음 두 문자열을 삭제 하 고 반환 하는 메서드 세 번째입니다. 파일 액세스 수 있도록 응용 프로그램에 대 한이 문자열을 사용 하 여 중요 한 파일에 대 한 의도 하지 않은 액세스 합니다.  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>환경 변수에서 경로 문자열을 구분하는 데 사용되는 플랫폼 특정 구분 문자입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 기반 데스크톱 플랫폼에서이 필드의 값에 세미콜론 (;) 기본적으로 하지만 다른 플랫폼에서 다를 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 된 `PathSeparator` 필드입니다.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>개별 경로 구성 요소를 미리 할당된 문자 범위로 연결하려고 시도하고 작업이 성공했는지 여부를 나타내는 값을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

대상 문자 범위는 연결 된 경로 포함할 수 있는 크기 여야 합니다. 연결 된 경로 호출 하 여 검색할 수 있습니다는 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 메서드를 다음 예제와 같이 보여 줍니다.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="path2">조인할 두 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="destination">연결된 경로를 포함할 문자 범위입니다.</param>
        <param name="charsWritten">메서드가 반환하는 경우 <paramref name="destination" />에 기록된 문자 수를 나타내는 값입니다.</param>
        <summary>두 개의 경로 구성 요소를 미리 할당된 단일 문자 범위로 연결하려고 시도하고 작업이 성공했는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>연결 작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` 연결 된 경로 포함할 수 있는 크기 여야 합니다. 연결 된 경로 호출 하 여 검색할 수 있습니다는 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 메서드를 예로 보여 줍니다.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">조인할 첫 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="path2">조인할 두 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="path3">조인할 세 번째 경로를 포함하는 문자 범위입니다.</param>
        <param name="destination">연결된 경로를 포함할 문자 범위입니다.</param>
        <param name="charsWritten">메서드가 반환하는 경우 <paramref name="destination" />에 기록된 문자 수를 나타내는 값입니다.</param>
        <summary>두 개의 경로 구성 요소를 미리 할당된 단일 문자 범위로 연결하려고 시도하고 작업이 성공했는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>연결 작업에 성공하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` 연결 된 경로 포함할 수 있는 크기 여야 합니다. 연결 된 경로 호출 하 여 검색할 수 있습니다는 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 메서드를 예로 보여 줍니다.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows 시스템의 파일 경로 형식</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>플랫폼 특정 볼륨 구분 기호 문자를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드의 값은 Windows 및 Macintosh 및 UNIX 운영 체제에서 슬래시 (/)에 콜론 (:). 예: "c:\windows" 또는 "MacVolume:System 폴더" 경로 구문 분석에 가장 유용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 된 `VolumeSeparatorChar` 필드입니다.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">파일 및 스트림 I/O</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">방법: 파일의 텍스트 읽기</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">방법: 파일에 텍스트 쓰기</related>
      </Docs>
    </Member>
  </Members>
</Type>
