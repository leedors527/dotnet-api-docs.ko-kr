<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24ee9e0178965939d224c31ccbd71a445222d09c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36480598" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>보안 토큰 처리기에 대한 추상 기본 클래스입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> 클래스는 모든 보안 토큰 처리기 파생 되는 기본 클래스입니다. 보안 토큰 처리기는 담당 합니다.  
  
-   보안 토큰의 유효성 검사 (<xref:System.IdentityModel.Tokens.SecurityToken>) 프로세스를 패키징 클레임에는 토큰에 포함 하도록 설계 된 형식의 한 <xref:System.Security.Claims.ClaimsIdentity> 개체입니다.  
  
-   직렬화 및 역직렬화 형식의 보안 토큰 처리 하도록 설계 되었습니다.  
  
-   직렬화 및 역직렬화 키 식별자 절 (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>)에서 처리 하도록 설계 되었습니다 형식의 토큰을 참조 하는 `<wsse:SecurityTokenReference>` 요소입니다.  
  
-   보안 토큰을 만들기는 <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> 의 구현으로 전달 된 개체는 <xref:System.IdentityModel.SecurityTokenService> 클래스입니다.  
  
-   구현에 대 한 보안 토큰에서 키 식별자 절을 만드는 <xref:System.IdentityModel.SecurityTokenService> 클래스입니다.  
  
 즉시 다음과 같은 보안 토큰 처리기를 제공 하는 Windows Identity Foundation (WIF):  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 이 클래스는 클래스는 토큰의 처리에 관련 된 기능을 구현 하는 추가 멤버를 노출 합니다. 대부분의 경우에서에서 직접 읽지 못하고 이러한 클래스 중 하나에서 파생 되는 것이 더 수 있습니다는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> 클래스입니다.  
  
 보안 토큰 처리기를 추가 하거나 지정 하 여 토큰 처리기 컬렉션에서 제거할 수는 [ &lt;추가&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;제거&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md), 또는 [ &lt;지우기&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) 아래의 요소는 [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) 구성 파일의 요소입니다. <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> 처리기 컬렉션에 대 한 구성 설정이 포함 된 개체를 통해 액세스할 수는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> 속성과 토큰 처리기의 구성원 인 처리기 컬렉션에서 액세스할 수는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> 속성입니다. 재정의할 수 있습니다는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> 처리기를 사용 하는 모든 사용자 지정 구성 요소를 처리 하기 위해 메서드.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> 클래스는 다른 여러 속성 및 메서드를 노출 합니다. 구현 하도록 선택한 기능에 따라 이러한 멤버의 일부나 전부를 재정의할 수 있습니다.  
  
 재정의 해야 합니다는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> 속성 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> 메서드 클래스는 보안 토큰의 형식에 대 한 정보는 WIF 인프라를 처리 하도록 설계 되었습니다.  
  
 유효성 검사, serialization 및 deserialization 속성이 나 처리기 메서드 또는 기능을 구현 하는 메서드를 함께 특정 기능을 수행할 수 있는지 여부를 나타내는 방법을 통해 기능이 노출 됩니다. 다음 목록에는 속성 또는 해당 기능을 구현 하는 방법을 사용 하 여 기능을 나타내는 방법을 쌍:  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> 속성 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 메서드:에 대 한 토큰에 포함 된 클레임을 패키지 하 고 토큰의 유효성을 검사 한 <xref:System.Security.Claims.ClaimsIdentity>합니다.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> 속성 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> 메서드: serialization 토큰입니다.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> 메서드 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> 메서드: deserialization 토큰입니다.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> 메서드 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> 메서드: 키 식별자 절을 역직렬화 합니다.  
  
-   <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> 메서드 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> 메서드: 키 식별자 절을 직렬화 합니다.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> 및 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> 메서드 구현에서 파이프라인에서 호출 됩니다는 <xref:System.IdentityModel.SecurityTokenService> 클래스입니다.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> 지정한 토큰이 이미 수신 여부를 결정 하는 WIF 인프라 메서드를 호출 합니다. 기본적으로이 메서드는 다음과 같이 반환 됩니다. `false`을 나타내는 토큰이 아직 수신 되지 않았습니다. 메서드를 재정의할 수 있으며 재생 된 토큰을 검색 하는 논리를 제공할 수 있습니다.  
  
   
  
## Examples  
 모든 코드 예제는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler> 항목에서 가져온는 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다. 다음 XML SWT 토큰 처리기 토큰 처리기 컬렉션에 추가 하는 방법을 보여 줍니다.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> 클래스를 초기화하기 위해 파생 클래스의 생성자에서 호출됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">시작 요소에 배치된 XML 판독기입니다. 판독기를 이 메서드에 의해 이동해서는 안 됩니다.</param>
        <summary>지정된 XML 리더기가 키 식별자 절로 언급된 XML 요소가 이 인스턴스에 의해 역직렬화될 수 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> 메서드가 요소를 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현은 반환 `false` 를 나타내는 키 식별자 절을 읽을 수 없습니다.  
  
 파생된 클래스는 인스턴스 키 식별자 절을 deserialize 할 수 있는지 여부를 결정 하기 위해 판독기가 참조 하는 요소를 확인 합니다. 호출을 통해 일반적으로 이렇게는 <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> 메서드를 지정 하는 적절 한 요소와 네임 스페이스 문자열. 재정의 하는 경우 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>를 재정의 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> 키 식별자 절을 deserialize 하는 데 논리를 제공 하는 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 토큰이 이 인스턴스에 의해 처리한 형식의 토큰으로 역직렬화될 수 있는지 여부를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">읽을 토큰 문자열입니다.</param>
        <summary>지정된 문자열이 이 인스턴스에 의해 처리한 형식의 토큰으로 역직렬화될 수 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> 메서드가 요소를 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현에서는 항상 `false`을 반환합니다.  
  
 이 메서드를 재정의 하는 경우 재정의 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> 메서드 토큰을 deserialize 하는 데 논리를 제공 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">시작 요소에 배치된 XML 판독기입니다. 판독기를 이 메서드에 의해 이동해서는 안 됩니다.</param>
        <summary>지정된 XML 리더기에 의해 참조된 XML 요소가 이 인스턴스에 의해 처리한 형식의 토큰으로 읽힐 수 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>
          <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> 메서드가 요소를 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현에서는 항상 `false`을 반환합니다.  
  
 파생된 클래스 인스턴스가 보안 토큰을 deserialize 할 수 있는지 여부를 결정 하기 위해 판독기가 참조 하는 요소를 확인 합니다. 호출을 통해 일반적으로 이렇게는 <xref:System.Xml.XmlReader.IsStartElement%2A> 메서드를 지정 하는 적절 한 요소와 네임 스페이스 문자열. 재정의 하는 경우 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>를 재정의 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> 메서드 또는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> 키 식별자 절을 deserialize 하는 데 논리를 제공 하는 메서드.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> 메서드를 처리기에서 토큰을 읽을 수 있는지 확인 합니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>처리기가 보안 토큰의 유효성 검사를 지원하는지 나타내는 값을 가져옵니다.</summary>
        <value>클래스가 보안 토큰에 대한 유효성을 검사할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스에서 유효성 검사를 구현 하려면 반환 하도록이 속성을 재정의 `true` 재정의 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 메서드를 유효성 검사 논리를 구현 합니다.  
  
   
  
## Examples  
 다음 코드를 재정의 하는 방법을 보여 줍니다는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> 사용자 지정 처리기 토큰 유효성을 검사할 수를 나타내는 속성입니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">확인할 키 식별자 절입니다.</param>
        <summary>이 인스턴스가 지정된 키 식별자 절을 serialize할 수 있는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>키 식별자 절을 serialize할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현에서는 항상 `false`을 반환합니다.  
  
 재정의 하는 경우 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>를 재정의 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> 키 식별자 절을 serialize 하는 논리를 제공 하는 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>처리기가 보안 토큰을 serialize할 수 있는지 나타내는 값을 가져옵니다.</summary>
        <value>클래스가 토큰을 serialize할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스에서 serialization을 구현 하려면이 속성이 반환 하도록 재정의 `true` 재정의 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> 직렬화 논리를 구현 하는 메서드.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> 사용자 지정 처리기가 토큰을 serialize 할 수 있는지를 나타내는 속성입니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 인스턴스에 대한 구성을 제공하는 <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" /> 개체를 가져오거나 설정합니다.</summary>
        <value>현재 현스턴스에 대한 구성 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> 속성은 일반적으로에서 구성 인프라에서 설정 된 [ &lt;securityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) 하는 동안 응용 프로그램 구성 파일의 요소를 시작 합니다.  
  
 파생된 클래스에서 사용 하는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> 구성 설정에 액세스 하려면 속성; 예를 들어, 발급자 이름 레지스트리에서 사용 하는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 메서드에서 액세스할 수는 <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> 구성 개체의 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 인스턴스를 포함하는 토큰 처리기 컬렉션을 가져옵니다.</summary>
        <value>현재 인스턴스를 포함하는 토큰 처리기 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 토큰 처리기에 추가 된 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> 인스턴스,이 속성이 자동 설정 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">참조가 만들어지는 토큰입니다.</param>
        <param name="attached">연결된 참조를 만들어야 하는 경우 <see langword="true" />이고, 연결되지 않은 참조를 만들어야 하는 경우 <see langword="false" />입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 해당 클래스에 의해 처리되는 토큰에 대한 보안 토큰 참조를 만듭니다. 이 메서드는 STS(보안 토큰 서비스)에 의해 호출됩니다.</summary>
        <returns>지정된 토큰을 참조하는 키 식별자 절입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 파생된 클래스는 키 식별자 절을 반환 하려면이 메서드를 재정의 (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>) 만드는 데 사용할 수 있는 한 `<wsse:SecurityTokenReference>` 지정된 된 토큰에 대 한 요소입니다.  
  
 구현에서 호출 된 <xref:System.IdentityModel.SecurityTokenService> 클래스입니다.  
  
 일반적으로 <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> 사용할 아닌 다른 사용자 지정 보안 토큰 서비스를 만들 때 필요 하지 않습니다. 보안 토큰 서비스에서 보안 토큰을 반환할 때 발급된 보안 토큰에는 연결된 보안 토큰과 연결되지 않은 보안 토큰에 대한 참조가 포함되어 있습니다. 연결된 참조는 SOAP 메시지의 보안 헤더에 포함된 보안 토큰을 나타내며 연결되지 않은 참조는 SOAP 메시지의 보안 헤더에 포함되지 않은 보안 토큰을 나타냅니다. 일반적으로 이러한 참조는 발급된 보안 토큰의 신뢰성을 확인합니다.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> 메서드를 지정된 된 토큰에서 키 식별자 절을 만듭니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">토큰이 만들어지는 보안 토큰 설명자입니다. 토큰 설명자의 속성이 이 메서드를 호출 하기 전에 설정됩니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 설명자를 사용하여 보안 토큰을 만듭니다. 이 메서드는 STS(보안 토큰 서비스)에 의해 호출됩니다.</summary>
        <returns>토큰 설명자의 속성과 일치하는 보안 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 구현에서 호출 된 <xref:System.IdentityModel.SecurityTokenService> 클래스입니다.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> 메서드를 만들고 토큰 설명자에서 토큰을 반환 합니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">재생을 확인할 토큰입니다.</param>
        <summary>파생된 클래스에서 재정의된 경우 지정된 토큰이 재생 중인 것으로 검색되면 예외를 throw합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현은 아무 작업도 수행하지 않습니다.  
  
 파생된 클래스에서 throw 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> 토큰이 이미 사용 되었습니다.  
  
 Windows Identity Foundation (WIF) 제공 된 <xref:System.IdentityModel.Tokens.TokenReplayCache> 클래스는 재생에서 캐시를 파생 될 수 있습니다 및 [ &lt;tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) 구성 하는 데 사용할 수 있는 구성 요소는 응용 프로그램에서 토큰 처리기에서 사용 하는 재생 캐시가 그러나 정확한 구현의 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> 메서드는 파생된 클래스의 디자이너까지 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 요청에 사용된 URI를 반환하여 해당 클래스에 의해 처리된 형식의 토큰을 식별합니다.</summary>
        <returns>이 처리기에서 지원하는 토큰 형식을 식별하는 URI 집합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> 현재 인스턴스에 의해 처리 된 토큰을 통해 액세스 됩니다는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> 속성입니다. <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> 메서드 토큰 형식을 참조 하는 메시지에 사용할 수 있는 허용 가능한 식별자의 집합을 반환 합니다. URI 값에 사용 되는 예를 들어는 `<wst:TokenType>` 에서 요소는 `<wst:RequestSecurityToken>` 특정 종류의 토큰을 요청 하는 요소 (나타내는 <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> 개체 모델의 속성).  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> 메서드를 사용자 지정 토큰에 대 한 토큰 유형 식별자를 반환 합니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">구성 XML 요소입니다. 형식 <see cref="T:System.Xml.XmlElement" />의 목록에 있는 각 노드입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 XML에서 사용자 지정 구성을 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> 구성 인프라 메서드를 호출 합니다. 이 메서드를 호출할 때는 `nodelist` 토큰 처리기의 최상위 자식 요소가 포함 됩니다 [ &lt;추가&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) 구성 파일에서 요소입니다. 특성이 나 자식 요소가 파생 된 클래스에 대해 정의한 구성 스키마에 따라 이러한 각 들어 차례로 있습니다.  
  
 기본 구현은 throw 한 <xref:System.NotImplementedException>합니다. 구성 파일에서 보안 토큰 처리기의 초기화를 사용 하도록 설정 하려면 파생된 클래스에서이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">키 식별자 절로 deserialize될 XML의 시작 요소에 배치된 XML 판독기입니다.</param>
        <summary>파생 클래스에서 재정의된 경우 지정된 XML 판독기에 의해 참조된 XML을 파생 클래스에 의해 처리된 키 식별자 절로 deserialize합니다.</summary>
        <returns>XML에서 deserialize된 키 식별자 절입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 XML에서 키 식별자 절을 deserialize 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야이 메서드를 재정의 하는 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 지정된 XML을 파생 클래스에 의해 처리된 유형의 토큰으로 deserialize합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">deserialize할 문자열입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 문자열을 파생된 클래스에 의해 처리된 유형의 토큰으로 deserialize합니다.</summary>
        <returns>지정된 문자열에서 deserialize된 보안 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  신뢰할 수 없는 데이터로이 메서드를 호출 하는 것은 보안상 위험 합니다. 신뢰할 수 있는 데이터에만이 메서드를 호출 합니다. 자세한 내용은 참조 [데이터 유효성 검사](https://www.owasp.org/index.php/Data_Validation)합니다.  
  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 문자열에서 보안 토큰을 deserialize 할 수 있는 기능을 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야를 재정의할 경우이 메서드는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">토큰의 시작 요소에 배치된 XML 판독기입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 문자열을 파생 클래스에 의해 처리된 유형의 토큰으로 deserialize합니다.</summary>
        <returns>XML에서 deserialize된 보안 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  신뢰할 수 없는 데이터로이 메서드를 호출 하는 것은 보안상 위험 합니다. 신뢰할 수 있는 데이터에만이 메서드를 호출 합니다. 자세한 내용은 참조 [데이터 유효성 검사](https://www.owasp.org/index.php/Data_Validation)합니다.  
  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 XML에서 보안 토큰을 deserialize 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야이 메서드를 재정의 하는 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> 메서드. 일반적으로 파생된 클래스에서 메서드는 참조 된 XML에서 토큰을 deserialize 할 수 없습니다 경우 throw는 <xref:System.Xml.XmlException>합니다.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> 메서드를 지정된 된 XML 판독기에서 사용자 지정 토큰을 읽도록 합니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">토큰의 시작 요소에 배치된 XML 판독기입니다.</param>
        <param name="tokenResolver">out-of-band 및 캐시된 토큰을 포함하는 토큰 확인자입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정된 XML 판독기에 의해 참조된 XML을 지정된 토큰 확인자를 사용하여 파생 클래스에 의해 처리된 형식의 토큰으로 deserialize합니다.</summary>
        <returns>XML에서 deserialize된 보안 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  신뢰할 수 없는 데이터로이 메서드를 호출 하는 것은 보안상 위험 합니다. 신뢰할 수 있는 데이터에만이 메서드를 호출 합니다. 자세한 내용은 참조 [데이터 유효성 검사](https://www.owasp.org/index.php/Data_Validation)합니다.  
  
 기본 구현에서 무시 된 `tokenResolver` 매개 변수 호출을 위임 하 고는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> 메서드.  
  
 XML에서 보안 토큰을 deserialize 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야이 메서드를 재정의 하는 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> 메서드. 일반적으로 파생된 클래스에서 메서드는 참조 된 XML에서 토큰을 deserialize 할 수 없습니다 경우 throw는 <xref:System.Xml.XmlException>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 이 인스턴스에서 처리하는 보안 토큰의 형식을 가져옵니다.</summary>
        <value>이 인스턴스에서 처리하는 보안 토큰의 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스에서이 속성을 재정의 하 고 반환 해야는 <xref:System.Type> 보안 토큰의 (<xref:System.IdentityModel.Tokens.SecurityToken>) 하는 파생된 클래스에 의해 처리 됩니다.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> 반환 하는 <xref:System.Type> 의 사용자 지정 처리기에 의해 처리 되는 보안 토큰입니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">유효성 검사 중인 보안 토큰입니다.</param>
        <param name="errorMessage">추적에 쓸 메시지입니다.</param>
        <summary>추적 기능이 설정된 경우 보안 토큰의 유효성 검사 중 오류 이벤트를 추적합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 토큰의 유효성 검사가 실패할 때 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">유효성을 검사한 토큰입니다.</param>
        <summary>추적 기능이 설정된 경우 보안 토큰 이벤트의 성공적인 유효성 검사를 추적합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 해야는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 토큰 유효성 검사가 끝난 후 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">유효성을 검사할 토큰입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정한 보안 토큰의 유효성을 검사합니다. 토큰은 파생된 클래스에서 처리되는 형식이어야 합니다.</summary>
        <returns>토큰에 포함되어 있는 ID입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 메서드 유효성을 검사 하 고 역직렬화 된 보안 토큰에서 클레임을 추출 하도록 인프라에 의해 호출 됩니다. 이러한 클레임의 컬렉션에 반환될지 <xref:System.Security.Claims.ClaimsIdentity> 메서드에 의해 반환 되는 개체입니다. 일반적인 경우이 컬렉션에는 단일 id를 포함 됩니다.  
  
 파생된 클래스에서 유효성 검사 일반적으로 포함 Uri에 지정 된 대상 그룹에 대해 토큰에 지정 된 대상은 유효성을 검사 하는 <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> 에 지정 된 토큰 처리기 구성 개체의 속성은 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> 속성입니다. 이러한 Uri는 일반적으로 아래에 있는 구성 파일에서 설정 된 [ &lt;audienceUris&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) 요소입니다. 대상 그룹을 확인할 수 없는 경우는 <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> 예외를 throw 해야 합니다.  
  
 발급자 중 하나에 발급자 토큰을 전달 하 여 유효성 검사 일반적으로 토큰을 처리 하는 경우는 <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> 에 대 한 메서드는 <xref:System.IdentityModel.Tokens.IssuerNameRegistry> 를 통해 처리기에 대 한 구성 개체에는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> 속성입니다. 일반적으로 발급자 이름 레지스트리를 통해 구성 된 [ &lt;issuerNameRegistry&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) 구성 파일의 요소입니다. <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> 발급자의 이름을 반환 합니다. 이 이름은 설정 하는 데 사용 해야는 <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> 토큰에 포함 된 클레임의 속성입니다. 발급자 이름 레지스트리 발급자 토큰에 대 한 항목이 포함 되어 있지 않으면 <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> 반환 `null`합니다. 이 경우에 <xref:System.IdentityModel.Tokens.SecurityTokenException> 는 일반적으로 파생된 클래스에서 throw 있지만이 동작은 디자이너 클래스의 최대는 합니다.  
  
   
  
## Examples  
 다음 코드와의 재정의 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 단순 웹 토큰 (SWT) 처리 하는 보안 토큰 처리기에 대 한 메서드. 코드에서 가져온 것은 `CustomToken` 샘플. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 다음 코드 `CreateClaims` 의 재정의에서 호출 되는 메서드는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 이전 예제의 메서드. 이 메서드는 반환 된 <xref:System.Security.Claims.ClaimsIdentity> 토큰에 있는 클레임에서 만들어지는 개체입니다. 코드에서 가져온 것은 `CustomToken` 샘플. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 다음 코드 `ValidateSignature` 의 재정의에서 호출 되는 메서드는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 단순 웹 토큰 처리기에서 메서드. 이 메서드는 토큰에 서명 구성 된를 사용 하 여 유효성을 검사 <xref:System.IdentityModel.Tokens.IssuerTokenResolver>합니다. 코드에서 가져온 것은 `CustomToken` 샘플. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 다음 코드 `ValidateAudience` 의 재정의에서 호출 되는 메서드는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> 단순 웹 토큰 처리기에서 메서드. 이 메서드는 대상 구성에 지정 된 Uri에 대 한 토큰에 포함 된 대상 그룹의 유효성을 검사 합니다. 코드에서 가져온 것은 `CustomToken` 샘플. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">XML 작성기입니다.</param>
        <param name="securityKeyIdentifierClause">serialize할 키 식별자 절입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정한 키 식별자 절을 XML에 serialize합니다. 키 식별자 절은 파생된 클래스에서 지원되는 형식이어야 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 XML에는 키 식별자 절을 serialize 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야이 메서드를 재정의 하는 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 지정한 보안 토큰을 serialize합니다. 토큰은 파생된 클래스에서 처리되는 형식이어야 합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">serialize할 토큰입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정한 보안 토큰을 문자열에 serialize합니다. 토큰은 파생된 클래스에서 처리되는 형식이어야 합니다.</summary>
        <returns>serialize된 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 보안 토큰 XML serialize 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야이 메서드를 재정의 하는 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">XML 작성기입니다.</param>
        <param name="token">serialize할 토큰입니다.</param>
        <summary>파생 클래스에서 재정의되는 경우 지정한 보안 토큰을 XML에 serialize합니다. 토큰은 파생된 클래스에서 처리되는 형식이어야 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로이 메서드에서 throw 된 <xref:System.NotImplementedException> 예외입니다.  
  
 보안 토큰 XML serialize 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 또한 재정의 해야이 메서드를 재정의 하는 경우는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드에서는 재정의 하는 방법을 보여 줍니다.는 <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> 메서드를 사용자 지정 토큰을 serialize 합니다. 코드에서 가져온 것은 `Custom Token` 샘플. 이 예제는 단순 웹 토큰 (SWT)의 처리를 사용 하는 사용자 지정 클래스를 제공 합니다. 이 샘플 및 WIF 및 다운로드 위치를 사용할 수 있는 다른 샘플에 대 한 정보를 참조 하십시오. [WIF 코드 샘플 인덱스](~/docs/framework/security/wif-code-sample-index.md)합니다.  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>