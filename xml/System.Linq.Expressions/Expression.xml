<Type Name="Expression" FullName="System.Linq.Expressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d2bcc9edb22ce616e169fae6c835a452b366252" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53301066" /></Metadata><TypeSignature Language="C#" Value="public abstract class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Expression" />
  <TypeSignature Language="C++ CLI" Value="public ref class Expression abstract" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>식 트리 노드를 나타내는 클래스가 파생되는 기본 클래스를 제공합니다. 또한 다양한 노드 형식을 만드는 <see langword="static" />(Visual Basic에서는 <see langword="Shared" />) 팩터리 메서드가 들어 있습니다. 이 클래스는 <see langword="abstract" /> 클래스입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 블록 식을 만드는 방법을 보여 줍니다. Block 식 두 이루어져 <xref:System.Linq.Expressions.MethodCallExpression> 개체와 하나의 <xref:System.Linq.Expressions.ConstantExpression> 개체.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.Expression" />의 새 인스턴스를 생성합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.Expression" />의 새 인스턴스를 생성합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Expression (System.Linq.Expressions.ExpressionType nodeType, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.Linq.Expressions.ExpressionType nodeType, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Expression(System::Linq::Expressions::ExpressionType nodeType, Type ^ type);" />
      <MemberSignature Language="F#" Value="new System.Linq.Expressions.Expression : System.Linq.Expressions.ExpressionType * Type -&gt; System.Linq.Expressions.Expression" Usage="new System.Linq.Expressions.Expression (nodeType, type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nodeType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="nodeType">노드 형식으로 설정할 <see cref="T:System.Linq.Expressions.ExpressionType" />입니다.</param>
        <param name="type">이 <see cref="P:System.Linq.Expressions.Expression.Type" />의 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.Expression" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 파생된 클래스의 생성자에서 호출 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">이 노드를 열어 볼 방문자입니다.</param>
        <summary>이 노드 형식에 대한 특정 Visit 메서드로 디스패치합니다. 예를 들어 <see cref="T:System.Linq.Expressions.MethodCallExpression" />은 <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />을 호출합니다.</summary>
        <returns>이 노드를 열어 본 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 기본 구현 <xref:System.Linq.Expressions.ExpressionType.Extension> 노드의 호출 <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>합니다. 파생된 방문자 클래스에 대해 좀 더 구체적인 메서드를 호출 하려면이 메서드를 재정의 합니다 <xref:System.Linq.Expressions.ExpressionVisitor> 클래스입니다. 하지만 호출 하 여 알 수 없는 방문자가 계속 지원 해야 <xref:System.Linq.Expressions.ExpressionVisitor.VisitExtension%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 산술 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 산술 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 더하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 개의 정수를 추가 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 더하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Add (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Add(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Add(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Add : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Add (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 산술 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Add" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 더하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 더하기 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 정수 변수에 값을 추가 하 고 다음 작업의 결과 변수에 할당 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#18)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하지 않는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AddAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하는 더하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 산술 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하는 산술 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 더하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 더하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AddChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AddChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AddChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AddChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AddChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AddChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 산술 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 작업에 대 한 구현 메서드는 다음 규칙에 따라 선택 됩니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 더하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 더하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 더하기 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="And">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="AND" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="AND" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.And" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `AND` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 정수 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은의 결과 형식은 미리 정의 된 비트 `AND` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드 형식은의 결과 형식은 미리 정의 된 비트에 해당 하는 nullable 형식을 `AND` 연산자입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 부울 값의 논리적 AND 연산을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 비트 <see langword="AND" /> 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression And (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression And(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function And (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ And(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member And : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.And (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="AND" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.And" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 작업에 대 한 구현 메서드는 다음 규칙에 따라 선택 됩니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `AND` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 정수 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은의 결과 형식은 미리 정의 된 비트 `AND` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드 형식은의 결과 형식은 미리 정의 된 비트에 해당 하는 nullable 형식을 `AND` 연산자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 비트 <see langword="AND" /> 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAlso">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>첫 번째 피연산자가 <see cref="T:System.Linq.Expressions.BinaryExpression" />로 계산되는 경우에만 두 번째 피연산자를 계산하는 조건부 <see langword="AND" /> 연산을 나타내는 <see langword="true" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>첫 번째 피연산자가 <see cref="T:System.Linq.Expressions.BinaryExpression" />로 계산되는 경우에만 두 번째 피연산자를 계산하는 조건부 <see langword="AND" /> 연산을 나타내는 <see langword="true" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `AND` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
    > [!NOTE]
    >  조건부 `AND` C# 또는 Visual Basic의 연산자를 오버 로드할 수 없습니다. 그러나 조건부 `AND` 연산자는 비트를 사용 하 여 계산 됩니다 `AND` 연산자입니다. 따라서 사용자 정의의 오버 로드를 비트 `AND` 연산자에는이 노드 유형에 대 한 구현 메서드 일 수 있습니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식을 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상의 값이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   `left`. 형식 및 `right`합니다. 형식이 동일한 부울 형식이는 있습니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은 미리 정의 된 조건부의 결과 형식은 `AND` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable, 노드가 리프트 된입니다. 노드 형식은 미리 정의 된 조건부의 결과 형식에 해당 하는 nullable 형식을 `AND` 연산자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 식을 만들려면 수행 하는 논리적 방법과 작업 경우에만 해당 두 피연산자의 첫 번째 피연산자를 보여 줍니다. `true`합니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#19)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 비트 <see langword="AND" /> 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="left" />.Type과 <paramref name="right" />.Type이 동일한 부울 형식이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AndAlso">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAlso (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAlso(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAlso (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAlso(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAlso : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAlso (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>첫 번째 피연산자가 true로 확인되는 경우에만 두 번째 피연산자를 계산하는 조건부 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="AND" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 작업에 대 한 구현 메서드는 다음 규칙에 따라 선택 됩니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `AND` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
    > [!NOTE]
    >  조건부 `AND` C# 또는 Visual Basic의 연산자를 오버 로드할 수 없습니다. 그러나 조건부 `AND` 연산자는 비트를 사용 하 여 계산 됩니다 `AND` 연산자입니다. 따라서 사용자 정의의 오버 로드를 비트 `AND` 연산자에는이 노드 유형에 대 한 구현 메서드 일 수 있습니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식을 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상의 값이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   `left`. 형식 및 `right`합니다. 형식이 동일한 부울 형식이는 있습니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은 미리 정의 된 조건부의 결과 형식은 `AND` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable, 노드가 리프트 된입니다. 노드 형식은 미리 정의 된 조건부의 결과 형식에 해당 하는 nullable 형식을 `AND` 연산자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 비트 <see langword="AND" /> 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type과 <paramref name="right" />.Type이 동일한 부울 형식이 아닌 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AndAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 AND 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 AND 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 AND 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression AndAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression AndAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ AndAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member AndAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.AndAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>비트 AND 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayAccess">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>배열에 액세스할 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, indexes As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array">다차원 배열을 나타내는 식입니다.</param>
        <param name="indexes">배열을 인덱싱하는 데 사용되는 식이 포함된 <see cref="T:System.Collections.Generic.IEnumerable`1" />입니다.</param>
        <summary>다차원 배열에 액세스할 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.IndexExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열을 나타내는 식을 사용 하 여 얻을 수는 <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> 메서드를 통해 또는 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 또는 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 다차원 배열의 요소 값을 변경 하는 방법을 보여 줍니다는 `ArrayAccess` 메서드.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#21)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression ArrayAccess (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression ArrayAccess(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayAccess (array As Expression, ParamArray indexes As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ ArrayAccess(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayAccess : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.ArrayAccess (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">인덱싱할 배열을 나타내는 식입니다.</param>
        <param name="indexes">배열을 인덱싱하는 데 사용되는 식이 포함된 배열입니다.</param>
        <summary>배열에 액세스할 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.IndexExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배열을 나타내는 식을 사용 하 여 얻을 수는 <xref:System.Linq.Expressions.Expression.MakeMemberAccess%2A> 메서드를 통해 또는 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 또는 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A>합니다.  
  
 다차원 배열에 대 한 사용을 <xref:System.Linq.Expressions.Expression.ArrayAccess%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 배열 요소 값을 변경 하는 방법을 보여 줍니다는 `ArrayAccess` 메서드.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#20)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ArrayIndex">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>배열 인덱스 연산자 적용을 나타내는 <see cref="T:System.Linq.Expressions.Expression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, indexes As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />입니다.</param>
        <param name="indexes"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</param>
        <summary>차수가 1보다 큰 배열에 대한 배열 인덱스 연산자 적용을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소의 `indexes` 있어야 <xref:System.Linq.Expressions.Expression.Type%2A> 같음 <xref:System.Int32>합니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `array` 차수가의 요소 수와 일치 하는 배열 형식을 나타내야 `indexes`합니다.  
  
 경우 순위 `array`합니다. 이 메서드는 반환 형식이 1 이면는 <xref:System.Linq.Expressions.BinaryExpression>합니다. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> 속성이로 설정 되어 `array` 하며 <xref:System.Linq.Expressions.BinaryExpression.Right%2A> 의 단일 요소 속성 `indexes`합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 의 속성을 <xref:System.Linq.Expressions.BinaryExpression> 의 요소 형식을 나타내는 `array`합니다. 형식입니다.  
  
 경우 순위 `array`합니다. 이 메서드는 반환 형식이 둘 이상의 면을 <xref:System.Linq.Expressions.MethodCallExpression>입니다. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> 속성을 <xref:System.Reflection.MethodInfo> 공용 인스턴스 메서드를 설명 하는 `Get` 나타내는 형식에는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성 `array`.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.MethodCallExpression> 2 차원 배열에 대 한 인덱싱을 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 또는 <paramref name="indexes" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type이 배열 형식을 나타내지 않는 경우  
  
또는 
<paramref name="array" />.Type의 차수가 <paramref name="indexes" />의 요소 수와 일치하지 않는 경우  
  
또는 
<paramref name="indexes" />의 요소 중 하나 이상의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 <see cref="T:System.Int32" /> 형식을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ArrayIndex (System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, index As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, System::Linq::Expressions::Expression ^ index);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="index" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="index"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>차수가 1인 배열에 대한 배열 인덱스 연산자 적용을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` 형식의 인덱스를 나타내야 <xref:System.Int32>합니다.  
  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.BinaryExpression> 됩니다 `null`, 모두 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 및 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 로 설정 됩니다 `false`합니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성은 요소 형식의 같음 `array`합니다. 형식입니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 또는 <paramref name="index" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type이 배열 형식을 나타내지 않는 경우  
  
또는 
 <paramref name="array" />.Type이 나타내는 배열 형식의 차수가 1이 아닌 경우  
  
또는 
 <paramref name="index" />.Type이 <see cref="T:System.Int32" /> 형식을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression ArrayIndex (System.Linq.Expressions.Expression array, params System.Linq.Expressions.Expression[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression ArrayIndex(class System.Linq.Expressions.Expression array, class System.Linq.Expressions.Expression[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayIndex (array As Expression, ParamArray indexes As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ ArrayIndex(System::Linq::Expressions::Expression ^ array, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="static member ArrayIndex : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.ArrayIndex (array, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexes" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">배열 인덱스 작업에 대한 <see cref="T:System.Linq.Expressions.Expression" /> 인스턴스 - 인덱스의 배열입니다.</param>
        <param name="indexes"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 개체의 배열입니다.</param>
        <summary>다차원 배열에 대한 배열 인덱스 연산자를 적용하는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 요소의 `indexes` 있어야 <xref:System.Linq.Expressions.Expression.Type%2A> 같음 <xref:System.Int32>합니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `array` 차수가의 요소 수와 일치 하는 배열 형식을 나타내야 `indexes`합니다.  
  
 경우 순위 `array`합니다. 이 메서드는 반환 형식이 1 이면는 <xref:System.Linq.Expressions.BinaryExpression>합니다. <xref:System.Linq.Expressions.BinaryExpression.Left%2A> 속성이로 설정 되어 `array` 하며 <xref:System.Linq.Expressions.BinaryExpression.Right%2A> 의 단일 요소 속성 `indexes`합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 의 속성을 <xref:System.Linq.Expressions.BinaryExpression> 의 요소 형식을 나타내는 `array`합니다. 형식입니다.  
  
 경우 순위 `array`합니다. 이 메서드는 반환 형식이 둘 이상의 면을 <xref:System.Linq.Expressions.MethodCallExpression>입니다. <xref:System.Linq.Expressions.MethodCallExpression.Method%2A> 속성을 <xref:System.Reflection.MethodInfo> 공용 인스턴스 메서드를 설명 하는 `Get` 나타내는 형식에는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성 `array`.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.ArrayIndex%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.MethodCallExpression> 2 차원 배열에 대 한 인덱싱을 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#3)]
 [!code-vb[System.Linq.Expressions.Expression#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 또는 <paramref name="indexes" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type이 배열 형식을 나타내지 않는 경우  
  
또는 
<paramref name="array" />.Type의 차수가 <paramref name="indexes" />의 요소 수와 일치하지 않는 경우  
  
또는 
<paramref name="indexes" />의 요소 중 하나 이상의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 <see cref="T:System.Int32" /> 형식을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ArrayLength (System.Linq.Expressions.Expression array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ArrayLength(class System.Linq.Expressions.Expression array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ArrayLength (array As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ArrayLength(System::Linq::Expressions::Expression ^ array);" />
      <MemberSignature Language="F#" Value="static member ArrayLength : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ArrayLength array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <summary>1차원 배열 길이를 가져오는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> 속성이 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />인 <paramref name="array" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 `array` 배열 형식을 나타내야 합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 값과 같음 <xref:System.Int32>합니다. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 속성은 `null`, 모두 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 로 설정 됩니다 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />.Type이 배열 형식을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Assign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Assign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Assign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Assign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Assign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Assign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Assign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Assign` 값 형식에 대 한 값을 복사 하는 식 및 참조 형식에 대 한 참조를 복사 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 할당 작업을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#12)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Bind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberAssignment" />를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MemberInfo member, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MemberInfo ^ member, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MemberInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (member, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />입니다.</param>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />입니다.</param>
        <summary>필드 또는 속성 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberAssignment" />를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberAssignment" />이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> 및 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `expression` 나타내는 형식에 할당할 수 있어야 합니다 <xref:System.Reflection.FieldInfo.FieldType%2A> 또는 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 속성 `member`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 또는 <paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />가 필드나 속성을 나타내지 않는 경우  
  
또는 
<paramref name="member" />가 나타내는 속성에 <see langword="set" /> 접근자가 없는 경우  
  
또는 
 <paramref name="expression" />.Type을 <paramref name="member" />가 나타내는 필드 또는 속성의 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberAssignment Bind (System.Reflection.MethodInfo propertyAccessor, System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberAssignment Bind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberAssignment ^ Bind(System::Reflection::MethodInfo ^ propertyAccessor, System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Bind : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MemberAssignment" Usage="System.Linq.Expressions.Expression.Bind (propertyAccessor, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberAssignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">속성 접근자 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />입니다.</param>
        <summary>속성 접근자 메서드를 사용한 멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberAssignment" />를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberAssignment" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />로 액세스되는 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />로 설정되고 <paramref name="propertyAccessor" /> 속성이 <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />으로 설정된 <paramref name="expression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `expression` 가 나타내는 형식에 할당할 수 있어야 합니다 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 액세스 되는 속성의 속성 `propertyAccessor`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 또는 <paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />가 속성 접근자 메서드를 나타내지 않는 경우  
  
또는 
<paramref name="propertyAccessor" />에서 액세스되는 속성에 <see langword="set" /> 접근자가 없는 경우  
  
또는 
 <paramref name="expression" />.Type을 <paramref name="member" />가 나타내는 필드 또는 속성의 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Block">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 식을 포함하고 변수가 없는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block expressions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 식을 포함하고 변수가 없는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 블록 식을 만드는 방법을 보여 줍니다. Block 식 두 이루어져 <xref:System.Linq.Expressions.MethodCallExpression> 개체와 하나의 <xref:System.Linq.Expressions.ConstantExpression> 개체.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#13)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), expressions As IEnumerable(Of Expression)) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables">블록의 변수입니다.</param>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 변수와 식이 포함된 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 블록 식에 매개 변수를 전달 하 여 블록 내에서이 매개 변수를 처리 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#14)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (variables As IEnumerable(Of ParameterExpression), ParamArray expressions As Expression()) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables">블록의 변수입니다.</param>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 변수와 식이 포함된 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">블록의 첫 번째 식입니다.</param>
        <param name="arg1">블록의 두 번째 식입니다.</param>
        <summary>2개 식을 포함하고 변수가 없는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">블록의 결과 형식입니다.</param>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 식을 포함하고 변수가 없으며 특정 결과 형식이 있는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">블록의 결과 형식입니다.</param>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 식을 포함하고 변수가 없으며 특정 결과 형식이 있는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">블록의 첫 번째 식입니다.</param>
        <param name="arg1">블록의 두 번째 식입니다.</param>
        <param name="arg2">블록의 세 번째 식입니다.</param>
        <summary>3개 식을 포함하고 변수가 없는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">블록의 결과 형식입니다.</param>
        <param name="variables">블록의 변수입니다.</param>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 변수와 식이 포함된 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables, params System.Linq.Expressions.Expression[] expressions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables, class System.Linq.Expressions.Expression[] expressions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ expressions);" />
      <MemberSignature Language="F#" Value="static member Block : Type * seq&lt;System.Linq.Expressions.ParameterExpression&gt; * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (type, variables, expressions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
        <Parameter Name="expressions" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">블록의 결과 형식입니다.</param>
        <param name="variables">블록의 변수입니다.</param>
        <param name="expressions">블록의 식입니다.</param>
        <summary>지정된 변수와 식이 포함된 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">블록의 첫 번째 식입니다.</param>
        <param name="arg1">블록의 두 번째 식입니다.</param>
        <param name="arg2">블록의 세 번째 식입니다.</param>
        <param name="arg3">블록의 네 번째 식입니다.</param>
        <summary>4개 식을 포함하고 변수가 없는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Block">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BlockExpression Block (System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BlockExpression Block(class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Block (arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As BlockExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BlockExpression ^ Block(System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Block : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BlockExpression" Usage="System.Linq.Expressions.Expression.Block (arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BlockExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="arg0">블록의 첫 번째 식입니다.</param>
        <param name="arg1">블록의 두 번째 식입니다.</param>
        <param name="arg2">블록의 세 번째 식입니다.</param>
        <param name="arg3">블록의 네 번째 식입니다.</param>
        <param name="arg4">블록의 다섯 번째 식입니다.</param>
        <summary>5개 식을 포함하고 변수가 없는 <see cref="T:System.Linq.Expressions.BlockExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.BlockExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Block 식 실행 되 면 블록의 마지막 식의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Break">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>break 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <summary>break 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Break이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, 이동 시 대상 레이블에 null 값이 전달되는 <paramref name="target" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 포함 하는 식을 만드는 방법을 보여 줍니다.는 <xref:System.Linq.Expressions.LoopExpression> 사용 하는 개체는 <xref:System.Linq.Expressions.Expression.Break%2A> 메서드.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Break (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <summary>break 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다. 이동 시 레이블에 전달되는 값을 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Break이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, 이동 시 대상 레이블에 <paramref name="target" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 break 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Break이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정된 <paramref name="type" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Break (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Break(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Break(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Break : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Break (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 break 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다. 이동 시 레이블에 전달되는 값을 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Break이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 <paramref name="type" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Call">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="instance">인스턴스 메서드 호출에 대한 인스턴스를 지정하는 <see cref="T:System.Linq.Expressions.Expression" />이며 <see langword="null" /> (Visual Basic의 경우 <see langword="static" />) 메서드에 대해 <see langword="Shared" />를 전달합니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <summary>인수를 받지 않는 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 호출을 나타내는 `static` (`Shared` Visual basic에서) 메서드를 `null` 에 대 한는 `instance` 이 메서드를 호출할 때 매개 변수입니다.  
  
 경우 `method` 인스턴스 메서드를 나타냅니다는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `instance` 가 나타내는 메서드의 선언 형식에 할당할 수 있어야 `method`.  
  
 합니다 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 결과 속성 <xref:System.Linq.Expressions.MethodCallExpression> 비어 있습니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성이 나타내는 메서드의 반환 형식에 같음 `method`합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 인수 없이 메서드를 호출 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#15)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="instance" />가 <see langword="null" />이고 <paramref name="method" />가 인스턴스 메서드를 나타내는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />.Type을 <paramref name="method" />로 나타내는 메서드의 선언 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="method">대상 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="arguments">호출 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />의 컬렉션입니다.</param>
        <summary>static(Visual Basic에서는 Shared) 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>1개 인수를 받는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />(Visual Basic에서는 <see langword="static" />) 메서드에 대한 호출을 나타내는 <see langword="Shared" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 호출 하는 식을 만드는 방법을 보여 줍니다.는 `static` (`Shared` Visual Basic의) 인수 하나를 사용 하는 메서드입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#16)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see langword="static" />(Visual Basic에서는 <see langword="Shared" />) 메서드를 나타내는 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 개체의 배열입니다.</param>
        <summary>인수가 있는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />(Visual Basic에서는 <see langword="static" />) 메서드에 대한 호출을 나타내는 <see langword="Shared" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `arguments` 아닙니다 `null`를 나타내는 메서드의 매개 변수 수와 동일한 요소 수 있어야 `method`합니다. 각 요소에 `arguments` 아니어야 `null` 의 해당 매개 변수에 할당할 수 있어야 하 고 `method`, 가능한 한 후 *인용*합니다.  
  
> [!NOTE]
>  경우에 해당 메서드 매개 변수 형식의 요소 인용 됩니다 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.MethodCallExpression> 비어 있으면 `arguments` 는 `null`. 동일한 요소를 포함 하는 고, 그렇지 `arguments`, 일부는 따옴표로 묶을 수 있습니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.MethodCallExpression> 같은지를 나타내는 메서드의 반환 형식을 `method`합니다. <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 속성은 `null`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" />의 요소 수가 <paramref name="method" />로 나타내는 메서드의 매개 변수 수와 같지 않은 경우  
  
또는 
<paramref name="arguments" />의 요소 중 하나 이상을 <paramref name="method" />로 나타내는 메서드의 해당 매개 변수에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arguments As IEnumerable(Of Expression)) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />입니다. <see langword="null" />(Visual Basic에서는 <see langword="static" />) 메서드의 경우 <see langword="Shared" />을 전달합니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</param>
        <summary>인수를 받는 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 호출을 나타내는 `static` (`Shared` Visual Basic에서) 메서드를 `null` 에 대 한 합니다 `instance` 이 메서드를 호출할 때 매개 변수 호출 또는 <xref:System.Linq.Expressions.Expression.Call%2A> 대신 합니다.  
  
 경우 `method` 인스턴스 메서드를 나타냅니다는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `instance` 가 나타내는 메서드의 선언 형식에 할당할 수 있어야 `method`.  
  
 하는 경우 `arguments` 아닙니다 `null`를 나타내는 메서드의 매개 변수 수와 동일한 요소 수 있어야 `method`합니다. 각 요소에 `arguments` 아니어야 `null` 의 해당 매개 변수에 할당할 수 있어야 하 고 `method`, 가능한 한 후 *인용*합니다.  
  
> [!NOTE]
>  경우에 해당 메서드 매개 변수 형식의 요소 인용 됩니다 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.MethodCallExpression> 비어 있으면 `arguments` 는 `null`. 동일한 요소를 포함 하는 고, 그렇지 `arguments`, 일부는 따옴표로 묶을 수 있습니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.MethodCallExpression> 같은지를 나타내는 메서드의 반환 형식을 `method`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="instance" />가 <see langword="null" />이고 <paramref name="method" />가 인스턴스 메서드를 나타내는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />.Type을 <paramref name="method" />로 나타내는 메서드의 선언 형식에 할당할 수 없는 경우  
  
또는 
<paramref name="arguments" />의 요소 수가 <paramref name="method" />로 나타내는 메서드의 매개 변수 수와 같지 않은 경우  
  
또는 
<paramref name="arguments" />의 요소 중 하나 이상을 <paramref name="method" />로 나타내는 메서드의 해당 매개 변수에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">인스턴스 메서드 호출에 대한 인스턴스를 지정하는 <see cref="T:System.Linq.Expressions.Expression" />이며 <see langword="null" /> (Visual Basic의 경우 <see langword="static" />) 메서드에 대해 <see langword="Shared" />를 전달합니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> 개체의 배열입니다.</param>
        <summary>인수를 받는 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 호출을 나타내는 `static` (`Shared` Visual Basic에서) 메서드를 `null` 에 대 한 합니다 `instance` 이 메서드를 호출할 때 매개 변수 호출 또는 <xref:System.Linq.Expressions.Expression.Call%2A> 대신 합니다.  
  
 경우 `method` 인스턴스 메서드를 나타냅니다는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `instance` 가 나타내는 메서드의 선언 형식에 할당할 수 있어야 `method`.  
  
 하는 경우 `arguments` 아닙니다 `null`를 나타내는 메서드의 매개 변수 수와 동일한 요소 수 있어야 `method`합니다. 각 요소에 `arguments` 아니어야 `null` 의 해당 매개 변수에 할당할 수 있어야 하 고 `method`, 가능한 한 후 *인용*합니다.  
  
> [!NOTE]
>  경우에 해당 메서드 매개 변수 형식의 요소 인용 됩니다 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
 <xref:System.Linq.Expressions.MethodCallExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.MethodCallExpression> 비어 있으면 `arguments` 는 `null`. 동일한 요소를 포함 하는 고, 그렇지 `arguments`, 일부는 따옴표로 묶을 수 있습니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.MethodCallExpression> 같은지를 나타내는 메서드의 반환 형식을 `method`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="instance" />가 <see langword="null" />이고 <paramref name="method" />가 인스턴스 메서드를 나타내는 경우  
  
또는 
 <paramref name="arguments" />가 <see langword="null" />이 아니고 하나 이상의 해당 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="instance" />.Type을 <paramref name="method" />로 나타내는 메서드의 선언 형식에 할당할 수 없는 경우  
  
또는 
<paramref name="arguments" />의 요소 수가 <paramref name="method" />로 나타내는 메서드의 매개 변수 수와 같지 않은 경우  
  
또는 
<paramref name="arguments" />의 요소 중 하나 이상을 <paramref name="method" />로 나타내는 메서드의 해당 매개 변수에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg1">두 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>2개 인수를 받는 static 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">인스턴스 호출에 대한 인스턴스를 지정하는 <see cref="T:System.Linq.Expressions.Expression" />입니다. static(Visual Basic에서는 Shared) 메서드의 경우 null을 전달합니다.</param>
        <param name="method">대상 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg1">두 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>2개 인수를 받는 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 두 개의 인수를 포함 하는 인스턴스 메서드를 호출 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#17)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, methodName As String, typeArguments As Type(), ParamArray arguments As Expression()) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">특정 메서드에 대해 <see cref="T:System.Linq.Expressions.Expression" /> 속성 값을 검색할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="methodName">메서드의 이름입니다.</param>
        <param name="typeArguments">제네릭 메서드의 형식 매개 변수를 지정하는 <see cref="T:System.Type" /> 개체 배열입니다. methodName에서 제네릭이 아닌 메서드를 지정하는 경우 이 인수는 null입니다.</param>
        <param name="arguments">메서드에 대한 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" /> 개체 배열입니다.</param>
        <summary>적합한 팩터리 메서드를 호출하여 메서드를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고, <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 속성이 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />이고, <paramref name="instance" />가 지정된 인스턴스 메서드를 나타내는 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />로 설정되고 <see cref="T:System.Reflection.MethodInfo" />가 지정된 인수로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.MethodCallExpression> 가리키는 메서드의 반환 형식 같은지 `methodName`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 또는 <paramref name="methodName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="methodName" />.Type 또는 해당 기본 형식에 이름이 <paramref name="typeArguments" />이고 형식 매개 변수가 <paramref name="arguments" />와 일치하고 매개 변수 형식이 <paramref name="instance" />와 일치하는 메서드가 없는 경우  
  
또는 
<paramref name="methodName" />.Type 또는 해당 기본 형식에 이름이 <paramref name="typeArguments" />이고 형식 매개 변수가 <paramref name="arguments" />와 일치하고 매개 변수 형식이 <paramref name="instance" />와 일치하는 메서드가 둘 이상 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg1">두 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg2">세 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>3개 인수를 받는 static 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (Type type, string methodName, Type[] typeArguments, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Type type, string methodName, class System.Type[] typeArguments, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(Type ^ type, System::String ^ methodName, cli::array &lt;Type ^&gt; ^ typeArguments, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Call : Type * string * Type[] * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (type, methodName, typeArguments, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Type[]" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">지정된 <see cref="T:System.Type" />(Visual Basic에서는 <see langword="static" />) 메서드가 포함된 형식을 지정하는 <see langword="Shared" />입니다.</param>
        <param name="methodName">메서드의 이름입니다.</param>
        <param name="typeArguments">제네릭 메서드의 형식 매개 변수를 지정하는 <see cref="T:System.Type" /> 개체 배열입니다. methodName에서 제네릭이 아닌 메서드를 지정하는 경우 이 인수는 null입니다.</param>
        <param name="arguments">메서드에 대한 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" /> 개체 배열입니다.</param>
        <summary>적합한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.MethodCallExpression" />(Visual Basic에서는 <see langword="static" />) 메서드를 호출하는 동작을 나타내는 <see langword="Shared" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 속성이 지정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />(Visual Basic에서는 <see cref="T:System.Reflection.MethodInfo" />) 메서드를 나타내는 <see langword="static" />로 설정되고 <see langword="Shared" /> 속성이 지정된 인수로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.MethodCallExpression> 가리키는 메서드의 반환 형식 같은지 `methodName`합니다. <xref:System.Linq.Expressions.MethodCallExpression.Object%2A> 속성은 `null`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 또는 <paramref name="methodName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="methodName" /> 또는 해당 기본 형식에 이름이 <paramref name="typeArguments" />이고 형식 매개 변수가 <paramref name="arguments" />와 일치하고 매개 변수 형식이 <paramref name="type" />와 일치하는 메서드가 없는 경우  
  
또는 
<paramref name="methodName" /> 또는 해당 기본 형식에 이름이 <paramref name="typeArguments" />이고 형식 매개 변수가 <paramref name="arguments" />와 일치하고 매개 변수 형식이 <paramref name="type" />와 일치하는 메서드가 둘 이상 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Linq.Expressions.Expression instance, System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Linq.Expressions.Expression instance, class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (instance As Expression, method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Linq::Expressions::Expression ^ instance, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Call : System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (instance, method, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="instance">인스턴스 호출에 대한 인스턴스를 지정하는 <see cref="T:System.Linq.Expressions.Expression" />입니다. static(Visual Basic에서는 Shared) 메서드의 경우 null을 전달합니다.</param>
        <param name="method">대상 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg1">두 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg2">세 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>3개 인수를 받는 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg1">두 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg2">세 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg3">네 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>4개 인수를 받는 static 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MethodCallExpression Call (System.Reflection.MethodInfo method, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3, System.Linq.Expressions.Expression arg4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MethodCallExpression Call(class System.Reflection.MethodInfo method, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3, class System.Linq.Expressions.Expression arg4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Call (method As MethodInfo, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression, arg4 As Expression) As MethodCallExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MethodCallExpression ^ Call(System::Reflection::MethodInfo ^ method, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3, System::Linq::Expressions::Expression ^ arg4);" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.MethodCallExpression" Usage="System.Linq.Expressions.Expression.Call (method, arg0, arg1, arg2, arg3, arg4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MethodCallExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg4" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</param>
        <param name="arg0">첫 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg1">두 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg2">세 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg3">네 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arg4">다섯 번째 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>5개 인수를 받는 static 메서드에 대한 호출을 나타내는 <see cref="T:System.Linq.Expressions.MethodCallExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MethodCallExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> 및 <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" />가 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReduce">
      <MemberSignature Language="C#" Value="public virtual bool CanReduce { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReduce" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.CanReduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReduce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReduce { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReduce : bool" Usage="System.Linq.Expressions.Expression.CanReduce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>노드를 더 단순한 노드로 줄일 수 있는지 나타냅니다. true를 반환하면 Reduce()를 호출하여 축소된 형식을 만들 수 있습니다.</summary>
        <value>노드를 줄일 수 있으면 true이고, 그렇지 않으면 false입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Catch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>catch 문을 나타내는 <see cref="T:System.Linq.Expressions.CatchBlock" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">이 처리기가 catch한 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체에 대한 참조를 나타내는 <see cref="T:System.Exception" />입니다.</param>
        <param name="body">catch 문의 본문입니다.</param>
        <summary>처리기 본문에 사용하기 위해 catch된 <see cref="T:System.Linq.Expressions.CatchBlock" /> 개체에 대한 참조가 포함된 catch 문을 나타내는 <see cref="T:System.Exception" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">이 <see cref="P:System.Linq.Expressions.Expression.Type" />이 처리할 <see cref="T:System.Exception" />의 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</param>
        <param name="body">catch 문의 본문입니다.</param>
        <summary>catch 문을 나타내는 <see cref="T:System.Linq.Expressions.CatchBlock" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 의 <xref:System.Exception> 를 찾아낼 수에 대 한 참조 하지만 지정할 수 있습니다 합니다 <xref:System.Exception> 개체에서 사용 하기 위해 제공 됩니다는 <xref:System.Linq.Expressions.CatchBlock>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch (variable As ParameterExpression, body As Expression, filter As Expression) As CatchBlock" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="variable">이 처리기가 catch한 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체에 대한 참조를 나타내는 <see cref="T:System.Exception" />입니다.</param>
        <param name="body">catch 문의 본문입니다.</param>
        <param name="filter"><see cref="T:System.Exception" /> 필터의 본문입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.CatchBlock" /> 필터와 catch된 <see cref="T:System.Exception" /> 개체에 대한 참조가 포함된 catch 문을 나타내는 <see cref="T:System.Exception" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock Catch (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock Catch(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ Catch(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member Catch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.Catch (type, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">이 <see cref="P:System.Linq.Expressions.Expression.Type" />이 처리할 <see cref="T:System.Exception" />의 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</param>
        <param name="body">catch 문의 본문입니다.</param>
        <param name="filter"><see cref="T:System.Exception" /> 필터의 본문입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.CatchBlock" /> 필터는 있지만 catch된 <see cref="T:System.Exception" /> 개체에 대한 참조는 없는 catch 문을 나타내는 <see cref="T:System.Exception" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearDebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression ClearDebugInfo (System.Linq.Expressions.SymbolDocumentInfo document);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression ClearDebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ClearDebugInfo (document As SymbolDocumentInfo) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ ClearDebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document);" />
      <MemberSignature Language="F#" Value="static member ClearDebugInfo : System.Linq.Expressions.SymbolDocumentInfo -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.ClearDebugInfo document" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
      </Parameters>
      <Docs>
        <param name="document">소스 파일을 나타내는 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />입니다.</param>
        <summary>시퀀스 위치를 지우기 위한 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />을 만듭니다.</summary>
        <returns>시퀀스 위치를 지우기 위한 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Coalesce">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>결합 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>결합 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 결과의 속성 <xref:System.Linq.Expressions.BinaryExpression> 됩니다 `null` 모두 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 및 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 으로 설정 됩니다 `false`합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 속성이 병합 작업의 결과 형식과 같습니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
#### <a name="result-type"></a>결과 유형  
 다음 규칙에는 결과 형식을 결정합니다.  
  
-   경우 `left`합니다. 형식이 nullable 형식을 나타내는지 및 `right`합니다. 형식이 nullable이 아닌 해당 형식으로 암시적으로 변환할 수는 결과 형식은 nullable이 아닌 해당 `left`합니다. 형식입니다.  
  
-   그렇지 않은 경우, `right`합니다. 형식으로 암시적으로 변환할 `left`합니다. 결과 형식은 형식이 `left`합니다. 형식입니다.  
  
-   그렇지 않은 경우, 해당 하는 nullable이 아닌 `left`합니다. 형식으로 암시적으로 변환할 `right`합니다. 결과 형식은 형식이 `right`합니다. 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 참조 형식 또는 nullable 값 형식을 나타내지 않는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" />.Type과 <paramref name="right" />.Type을 상호 변환할 수 없는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/088b1f0d-c1af-4fe1-b4b8-196fd5ea9132">?? 연산자(C# 참조)</related>
      </Docs>
    </Member>
    <Member MemberName="Coalesce">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Coalesce (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Coalesce(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coalesce (left As Expression, right As Expression, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Coalesce(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member Coalesce : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Coalesce (left, right, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>지정된 변환 함수를 사용한 병합 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 결과의 속성 <xref:System.Linq.Expressions.BinaryExpression> 됩니다 `null` 모두 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 및 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 으로 설정 됩니다 `false`합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.BinaryExpression> 병합 작업의 결과 형식과 같습니다.  
  
 다음 규칙에는 결과 형식을 결정합니다.  
  
-   경우 `left`합니다. 형식이 nullable 형식을 나타내는지 및 `right`합니다. 형식이 nullable이 아닌 해당 형식으로 암시적으로 변환할 수는 결과 형식은 nullable이 아닌 해당 `left`합니다. 형식입니다.  
  
-   그렇지 않은 경우, `right`합니다. 형식으로 암시적으로 변환할 `left`합니다. 결과 형식은 형식이 `left`합니다. 형식입니다.  
  
-   그렇지 않은 경우, 해당 하는 nullable이 아닌 `left`합니다. 형식으로 암시적으로 변환할 `right`합니다. 결과 형식은 형식이 `right`합니다. 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="left" />.Type과 <paramref name="right" />.Type을 상호 변환할 수 없는 경우  
  
또는 
 <paramref name="conversion" />이 <see langword="null" />이 아니고 <paramref name="conversion" />.Type이 정확히 하나의 인수를 받지 않는 대리자 형식인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 참조 형식 또는 nullable 값 형식을 나타내지 않는 경우  
  
또는 
<paramref name="left" />의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 대리자 형식 <paramref name="conversion" />.Type의 매개 변수 형식에 할당할 수 없는 경우  
  
또는 
<paramref name="right" />의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 대리자 형식 <paramref name="conversion" />.Type의 반환 형식과 다른 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Condition">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>조건문을 나타내는 <see cref="T:System.Linq.Expressions.ConditionalExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Condition (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />입니다.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />입니다.</param>
        <param name="ifFalse"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />입니다.</param>
        <summary>조건문을 나타내는 <see cref="T:System.Linq.Expressions.ConditionalExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> 및 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.ConditionalExpression> 값과 같음 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 의 속성 `ifTrue`합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 조건문을 나타내는 식을 만드는 방법을 보여 줍니다. 첫 번째 인수를 평가 하는 경우 `true`, 두 번째 인수가 고 그렇지 않으면 실행 되 고, 세 번째 인수 실행 됩니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#3)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="test" />, <paramref name="ifTrue" /> 또는 <paramref name="ifFalse" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="test" />.Type이 <see cref="T:System.Boolean" />이 아닌 경우  
  
또는 
 <paramref name="ifTrue" />.Type이 <paramref name="ifFalse" />.Type과 다른 경우</exception>
        <altmember cref="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
        <altmember cref="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      </Docs>
    </Member>
    <Member MemberName="Condition">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression Condition (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression Condition(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ Condition(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Condition : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.Condition (test, ifTrue, ifFalse, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />입니다.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />입니다.</param>
        <param name="ifFalse"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />입니다.</param>
        <param name="type"><see cref="P:System.Linq.Expressions.Expression.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>조건문을 나타내는 <see cref="T:System.Linq.Expressions.ConditionalExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> 및 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 조건 식의 경우에서의 결과 형식은 명시적으로 통합는 유형의 `ifTrue` 및 `ifFalse` 식이 같지. 두 유형의 `ifTrue` 및 `ifFalse` 암시적으로 참조 여야 결과 형식에 할당할 수 있습니다. 합니다 `type` 일 수 <xref:System.Void>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Constant">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ConstantExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Constant (value As Object) As ConstantExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Constant : obj -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.ConstantExpression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ConstantExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ConstantExpression> 유형과 같은지 `value`합니다. 하는 경우 `value` 됩니다 `null`를 <xref:System.Linq.Expressions.Expression.Type%2A> 값과 같음 <xref:System.Object>합니다.  
  
 나타내는 `null`를 사용할 수도 있습니다는 <xref:System.Linq.Expressions.Expression.Constant%28System.Object%2CSystem.Type%29> 메서드는 명시적으로 형식을 지정할 수 있습니다는.  
  
   
  
## Examples  
 다음 코드 예제에는 상수 값을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#4)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConstantExpression Constant (object value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConstantExpression Constant(object value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConstantExpression ^ Constant(System::Object ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Constant : obj * Type -&gt; System.Linq.Expressions.ConstantExpression" Usage="System.Linq.Expressions.Expression.Constant (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConstantExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.ConstantExpression" /> 및 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ConstantExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> 및 <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 nullable 형식의 값을 나타내는 데 유용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 nullable 형식의 상수를 나타내는 식을 만들고 해당 값을 설정 하는 방법을 보여 줍니다. `null`합니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#22)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" />가 <see langword="null" />이 아니고 <paramref name="type" />의 동적 형식에서 <paramref name="value" />을 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Continue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>continue 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Continue (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <summary>continue 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Continue이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, 이동 시 대상 레이블에 null 값이 전달되는 <paramref name="target" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 사용 하는 루프 식을 만드는 방법을 보여 줍니다는 <xref:System.Linq.Expressions.Expression.Continue%2A> 메서드.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#46)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#46)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Continue (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Continue(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Continue(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Continue : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Continue (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 continue 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Continue이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 null 값이 전달되는 <paramref name="type" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>형식 변환 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>형식 변환 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 속성은 `false`입니다. 노드가 리프트 된 경우 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 는 `true`합니다. 그렇지 않으면 `false`입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `expression`합니다. 형식 또는 `type` 은 암시적 또는 명시적 변환 연산자를 정의 하는 사용자 정의 형식은 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우는 다음과 같습니다.  
  
    -   모두 `expression`입니다. 형식 및 `type` 구현 방법이 숫자 또는 부울 형식 또는 null을 허용 하거나 허용 하지 않는 열거형 형식을 나타내는 `null`합니다.  
  
    -   경우 `expression`합니다. 형식 또는 `type` unboxing 참조 형식 및는 명시적 boxing은 또는에서 참조 변환이 있는 `expression`합니다. 입력 `type`의 메서드 구현은 `null`합니다.  
  
#### <a name="lifted-versus-non-lifted"></a>비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수 있고 구현 메서드의 반환 형식은 할당할 `type`, 노드가 리프트 하지 않습니다.  
  
-   하나 또는 두 경우의 `expression`합니다. 형식 또는 `type` nullable 값 형식이 며 해당 nullable이 아닌 값 형식은 인수 형식과 구현 메서드의 반환 형식에 같음 각각 노드가 리프트 된 합니다.  
  
 구현 메서드가 `null`:  
  
-   모두 `expression`입니다. 형식 및 `type` 는 nullable이 아닌, 노드가 리프트 하지 않습니다.  
  
-   그렇지 않은 경우 노드가 리프트 된 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 형식 변환 작업을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#23)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type과 <paramref name="type" /> 사이에 변환 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Convert (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Convert(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Convert(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Convert (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</param>
        <summary>구현 메서드가 지정된 변환 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />, <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 및 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 속성은 `false`입니다. 노드가 리프트 된 경우 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 는 `true`합니다. 그렇지 않으면 `false`입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   메서드가 아닌 경우 `null`, 구현 메서드를 것입니다. Void가 아닌를 나타내야 `static` (`Shared` Visual basic에서) 인수 하나를 사용 하는 메서드입니다.  
  
-   경우에 그렇지 `expression`합니다. 형식 또는 `type` 은 암시적 또는 명시적 변환 연산자를 정의 하는 사용자 정의 형식은 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우는 다음과 같습니다.  
  
    -   모두 `expression`입니다. 형식 및 `type` 구현 방법이 숫자 또는 부울 형식 또는 null을 허용 하거나 허용 하지 않는 열거형 형식을 나타내는 `null`합니다.  
  
    -   경우 `expression`합니다. 형식 또는 `type` unboxing 참조 형식 및는 명시적 boxing은 또는에서 참조 변환이 있는 `expression`합니다. 입력 `type`의 메서드 구현은 `null`합니다.  
  
#### <a name="lifted-versus-non-lifted"></a>비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수 있고 구현 메서드의 반환 형식은 할당할 `type`, 노드가 리프트 하지 않습니다.  
  
-   중 하나 또는 두 경우의 `expression`합니다. 형식 또는 `type` nullable 값 형식이 고 해당 nullable이 아닌 값 형식은 인수 형식과 구현 메서드의 반환 형식에 같음 각각 노드가 리프트 된 합니다.  
  
 구현 메서드가 `null`:  
  
-   모두 `expression`입니다. 형식 및 `type` 는 nullable이 아닌, 노드가 리프트 하지 않습니다.  
  
-   그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니거나, 정확하게 하나의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type과 <paramref name="type" /> 사이에 변환 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="expression" />.Type을 <paramref name="method" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우  
  
또는 
<paramref name="method" />가 나타내는 메서드의 반환 형식을 <paramref name="type" />에 할당할 수 없는 경우  
  
또는 
 <paramref name="expression" />.Type 또는 <paramref name="type" />이 nullable 값 형식이고 nullable이 아닌 해당 값 형식이 <paramref name="method" />가 나타내는 메서드의 인수 형식 또는 반환 형식과 각각 일치하지 않는 경우</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><paramref name="method" /> 설명과 일치하는 메서드가 둘 이상 있는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>대상 형식에서 오버플로가 발생할 때 예외가 throw되는 변환 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>대상 형식에서 오버플로가 발생할 때 예외가 throw되는 변환 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 속성은 `false`입니다. 노드가 리프트 된 경우 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 는 `true`합니다. 그렇지 않으면 `false`입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `expression`합니다. 형식 또는 `type` 은 암시적 또는 명시적 변환 연산자를 정의 하는 사용자 정의 형식은 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우는 다음과 같습니다.  
  
    -   모두 `expression`입니다. 형식 및 `type` 구현 방법이 숫자 또는 부울 형식 또는 null을 허용 하거나 허용 하지 않는 열거형 형식을 나타내는 `null`합니다.  
  
    -   경우 `expression`합니다. 형식 또는 `type` unboxing 참조 형식 및는 명시적 boxing은 또는에서 참조 변환이 있는 `expression`합니다. 입력 `type`의 메서드 구현은 `null`합니다.  
  
#### <a name="lifted-versus-non-lifted"></a>비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수 있고 구현 메서드의 반환 형식은 할당할 `type`, 노드가 리프트 하지 않습니다.  
  
-   중 하나 또는 두 경우의 `expression`합니다. 형식 또는 `type` nullable 값 형식이 고 해당 nullable이 아닌 값 형식은 인수 형식과 구현 메서드의 반환 형식에 같음 각각 노드가 리프트 된 합니다.  
  
 구현 메서드가 `null`:  
  
-   모두 `expression`입니다. 형식 및 `type` 는 nullable이 아닌, 노드가 리프트 하지 않습니다.  
  
-   그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type과 <paramref name="type" /> 사이에 변환 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression ConvertChecked (System.Linq.Expressions.Expression expression, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression ConvertChecked(class System.Linq.Expressions.Expression expression, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ ConvertChecked(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.ConvertChecked (expression, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</param>
        <summary>구현 메서드가 지정된 대상 형식에서 오버플로가 발생할 때 예외가 throw되는 변환 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />, <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 및 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 속성은 `false`입니다. 노드가 리프트 된 경우 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 는 `true`합니다. 그렇지 않으면 `false`입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   메서드가 아닌 경우 `null`, 구현 메서드를 것입니다. Void가 아닌를 나타내야 `static` (`Shared` Visual basic에서) 인수 하나를 사용 하는 메서드입니다.  
  
-   경우에 그렇지 `expression`합니다. 형식 또는 `type` 은 암시적 또는 명시적 변환 연산자를 정의 하는 사용자 정의 형식은 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우는 다음과 같습니다.  
  
    -   모두 `expression`입니다. 형식 및 `type` 구현 방법이 숫자 또는 부울 형식 또는 null을 허용 하거나 허용 하지 않는 열거형 형식을 나타내는 `null`합니다.  
  
    -   경우 `expression`합니다. 형식 또는 `type` unboxing 참조 형식 및는 명시적 boxing은 또는에서 참조 변환이 있는 `expression`합니다. 입력 `type`의 메서드 구현은 `null`합니다.  
  
#### <a name="lifted-versus-non-lifted"></a>비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수 있고 구현 메서드의 반환 형식은 할당할 `type`, 노드가 리프트 하지 않습니다.  
  
-   중 하나 또는 두 경우의 `expression`합니다. 형식 또는 `type` nullable 값 형식이 고 해당 nullable이 아닌 값 형식은 인수 형식과 구현 메서드의 반환 형식에 같음 각각 노드가 리프트 된 합니다.  
  
 구현 메서드가 `null`:  
  
-   모두 `expression`입니다. 형식 및 `type` 는 nullable이 아닌, 노드가 리프트 하지 않습니다.  
  
-   그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니거나, 정확하게 하나의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type과 <paramref name="type" /> 사이에 변환 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="expression" />.Type을 <paramref name="method" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우  
  
또는 
<paramref name="method" />가 나타내는 메서드의 반환 형식을 <paramref name="type" />에 할당할 수 없는 경우  
  
또는 
 <paramref name="expression" />.Type 또는 <paramref name="type" />이 nullable 값 형식이고 nullable이 아닌 해당 값 형식이 <paramref name="method" />가 나타내는 메서드의 인수 형식 또는 반환 형식과 각각 일치하지 않는 경우</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><paramref name="method" /> 설명과 일치하는 메서드가 둘 이상 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DebugInfo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DebugInfoExpression DebugInfo (System.Linq.Expressions.SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DebugInfoExpression DebugInfo(class System.Linq.Expressions.SymbolDocumentInfo document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DebugInfo (document As SymbolDocumentInfo, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer) As DebugInfoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DebugInfoExpression ^ DebugInfo(System::Linq::Expressions::SymbolDocumentInfo ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="static member DebugInfo : System.Linq.Expressions.SymbolDocumentInfo * int * int * int * int -&gt; System.Linq.Expressions.DebugInfoExpression" Usage="System.Linq.Expressions.Expression.DebugInfo (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DebugInfoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Linq.Expressions.SymbolDocumentInfo" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">소스 파일을 나타내는 <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />입니다.</param>
        <param name="startLine">이 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />의 시작 줄입니다. 0보다 커야 합니다.</param>
        <param name="startColumn">이 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />의 시작 열입니다. 0보다 커야 합니다.</param>
        <param name="endLine">이 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />의 끝 줄입니다. 시작 줄보다 크거나 같아야 합니다.</param>
        <param name="endColumn">이 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />의 끝 열입니다. 끝 줄이 시작 줄과 같을 경우 끝 열은 시작 열보다 크거나 같아야 합니다. 어떤 경우에도 0보다 커야 합니다.</param>
        <summary>지정된 범위를 사용하여 <see cref="T:System.Linq.Expressions.DebugInfoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DebugInfoExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1씩 감소하는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">감소시킬 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>1씩 감소하는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>감소되는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 식은 작동 하며 전달 된 개체의 값을 변경 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 값에서 1을 빼는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#5)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Decrement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Decrement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Decrement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Decrement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Decrement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">감소시킬 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>1씩 감소하는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>감소되는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 식은 작동 하며 전달 된 개체의 값을 변경 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Default (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Default(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Default(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Default(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Default : Type -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Default type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.DefaultExpression" /> 속성이 지정된 형식으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DefaultExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> 속성이 지정된 형식으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 지정된 된 형식에 대 한 기본 값을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#6)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>산술 나누기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>산술 나누기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 나누기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 나누기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 나누기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
   
  
## Examples  
 다음 코드 예제는의 첫 번째 인수가 두 번째 인수로 나누는 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#7)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 나누기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Divide (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Divide(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Divide(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Divide (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>산술 나누기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 나누기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 나누기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 나누기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 나누기 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivideAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 나누기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 나누기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 나누기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression DivideAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression DivideAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivideAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ DivideAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member DivideAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.DivideAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하지 않는 나누기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 연산을 나타내는 <see cref="T:System.Linq.Expressions.DynamicExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="returnType">동적 식의 결과 형식입니다.</param>
        <param name="arguments">동적 작업의 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 결과의 속성 인수의 형식에서 유추 됩니다 하 고 지정 된 형식을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="returnType">동적 식의 결과 형식입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 결과의 속성 인수의 형식에서 유추 됩니다 하 고 지정 된 형식을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="returnType">동적 식의 결과 형식입니다.</param>
        <param name="arguments">동적 작업의 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 결과의 속성 인수의 형식에서 유추 됩니다 하 고 지정 된 형식을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="returnType">동적 식의 결과 형식입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <param name="arg1">동적 작업의 두 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 결과의 속성 인수의 형식에서 유추 됩니다 하 고 지정 된 형식을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="returnType">동적 식의 결과 형식입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <param name="arg1">동적 작업의 두 번째 인수입니다.</param>
        <param name="arg2">동적 작업의 세 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 결과의 속성 인수의 형식에서 유추 됩니다 하 고 지정 된 형식을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression Dynamic (System.Runtime.CompilerServices.CallSiteBinder binder, Type returnType, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression Dynamic(class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Type returnType, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dynamic (binder As CallSiteBinder, returnType As Type, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ Dynamic(System::Runtime::CompilerServices::CallSiteBinder ^ binder, Type ^ returnType, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Dynamic : System.Runtime.CompilerServices.CallSiteBinder * Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.Dynamic (binder, returnType, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="returnType">동적 식의 결과 형식입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <param name="arg1">동적 작업의 두 번째 인수입니다.</param>
        <param name="arg2">동적 작업의 세 번째 인수입니다.</param>
        <param name="arg3">동적 작업의 네 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.DynamicExpression.DelegateType%2A> 결과의 속성 인수의 형식에서 유추 됩니다 하 고 지정 된 형식을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ElementInit" />를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, arguments As IEnumerable(Of Expression)) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="addMethod"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />입니다.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 속성에 설정할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />입니다.</param>
        <summary>지정된 <see cref="T:System.Linq.Expressions.ElementInit" />을 두 번째 인수로 사용하여 <see cref="T:System.Collections.Generic.IEnumerable`1" />를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ElementInit" /> 및 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` 매개 변수는 "Add" (대/소문자 구분) 라는 인스턴스 메서드를 나타내야 합니다. Add 메서드의 요소 수로 매개 변수 수가 같은 있어야 `arguments`합니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소에 `arguments` add 메서드의 해당 매개 변수의 형식에 할당할 수 있어야 후 가능한 *인용*합니다.  
  
> [!NOTE]
>  경우에 해당 메서드 매개 변수 형식의 요소 인용 됩니다 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> 메서드를를 <xref:System.Linq.Expressions.ElementInit> 호출을 나타내는 <xref:System.Collections.Generic.Dictionary%602.Add%2A> 사전 컬렉션의 요소를 초기화 하는 방법입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addMethod" /> 또는 <paramref name="arguments" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="addMethod" />를 나타내는 메서드 이름이 "Add"(대/소문자 구분 안 함)가 아닌 경우  
  
또는 
<paramref name="addMethod" />를 나타내는 메서드가 인스턴스 메서드가 아닌 경우  
  
또는 
 <paramref name="arguments" />의 요소 수가 <paramref name="addMethod" />로 나타내는 메서드의 매개 변수 수와 같지 않은 경우  
  
또는 
<paramref name="arguments" />의 하나 이상의 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="addMethod" />가 나타내는 메서드의 해당 매개 변수 형식에 적용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ElementInit ElementInit (System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ElementInit ElementInit(class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ElementInit (addMethod As MethodInfo, ParamArray arguments As Expression()) As ElementInit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ElementInit ^ ElementInit(System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member ElementInit : System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ElementInit" Usage="System.Linq.Expressions.Expression.ElementInit (addMethod, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ElementInit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="addMethod"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />입니다.</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> 개체의 배열입니다.</param>
        <summary>지정된 값 배열을 두 번째 인수로 사용하여 <see cref="T:System.Linq.Expressions.ElementInit" />를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ElementInit" /> 및 <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addMethod` 매개 변수는 "Add" (대/소문자 구분) 라는 인스턴스 메서드를 나타내야 합니다. Add 메서드의 요소 수로 매개 변수 수가 같은 있어야 `arguments`합니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소에 `arguments` add 메서드의 해당 매개 변수의 형식에 할당할 수 있어야 후 가능한 *인용*합니다.  
  
> [!NOTE]
>  경우에 해당 메서드 매개 변수 형식의 요소 인용 됩니다 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.ElementInit%28System.Reflection.MethodInfo%2CSystem.Linq.Expressions.Expression%5B%5D%29> 메서드를를 <xref:System.Linq.Expressions.ElementInit> 호출을 나타내는 <xref:System.Collections.Generic.Dictionary%602.Add%2A> 사전 컬렉션의 요소를 초기화 하는 방법입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#4)]
 [!code-vb[System.Linq.Expressions.Expression#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addMethod" /> 또는 <paramref name="arguments" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">addMethod가 나타내는 메서드의 이름이 "Add"(대/소문자 구분 안 함)가 아닌 경우  
  
또는 
addMethod가 나타내는 메서드가 인스턴스 메서드가 아닌 경우  
  
또는 
인수에 들어 있는 요소 수가 addMethod가 나타내는 메서드의 매개 변수 개수와 다른 경우  
  
또는 
<paramref name="arguments" />의 하나 이상의 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="addMethod" />가 나타내는 메서드의 해당 매개 변수 형식에 적용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DefaultExpression Empty ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DefaultExpression Empty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty () As DefaultExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DefaultExpression ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.Expressions.DefaultExpression" Usage="System.Linq.Expressions.Expression.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DefaultExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Void" /> 형식을 가진 빈 식을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DefaultExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />로 설정된 <see cref="T:System.Void" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여기서는 식이 필요 하지만 조치가 필요한 빈 식을 사용할 수 있습니다. 예를 들어, 빈 식 블록 식의 마지막 식으로 사용할 수 있습니다. 이 경우 블록 식의 반환 값은 void입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 빈 식을 만들고 블록 식에 추가 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#31)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equal">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>같음 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>같음 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true`합니다. 그렇지 않으면 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 항상 `false`입니다. 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 같음 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   구현 메서드는이 고, 그렇지 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건을 충족 하는 경우 노드가 리프트 된 및 노드의 유형입니다 <xref:System.Boolean>:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 인수의 값이 같은지 여부를 확인 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#8)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 같음 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Equal">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Equal (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Equal(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equal (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Equal(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Equal : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Equal (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>같음 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true` 하며 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성이 `liftToNull`합니다. 그렇지 않은 경우 둘 다 `false`합니다. 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 같음 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   구현 메서드는이 고, 그렇지 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된; 또한 노드 형식은 nullable <xref:System.Boolean> 하는 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 nullable <xref:System.Boolean> 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 같음 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOr">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="XOR" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>사용자 정의 형식에 대해 <c>op_ExclusiveOr</c>을 사용하여 비트 <see langword="XOR" /> 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 오버 로드 하는 사용자 정의 유형을 나타냅니다는 `XOR` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 정수 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은 미리 정의 된 결과 형식 `XOR` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드 형식은 미리 정의 된 결과 형식에 해당 하는 nullable 형식을 `XOR` 연산자입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 논리적 XOR 연산을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#9)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 <see langword="XOR" /> 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOr (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOr(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOr (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOr(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOr : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOr (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>사용자 정의 형식에 대해 <c>op_ExclusiveOr</c>을 사용하여 비트 <see langword="XOR" /> 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 메서드를 구현 하는 선택한을 결정 합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 오버 로드 하는 사용자 정의 유형을 나타냅니다는 `XOR` 연산자를 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는 합니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 정수 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은 미리 정의 된 결과 형식 `XOR` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드 형식은 미리 정의 된 결과 형식에 해당 하는 nullable 형식을 `XOR` 연산자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <see langword="XOR" /> 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExclusiveOrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 XOR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>사용자 정의 형식에 대해 <c>op_ExclusiveOr</c>을 사용하여 비트 XOR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>사용자 정의 형식에 대해 <c>op_ExclusiveOr</c>을 사용하여 비트 XOR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveOrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ExclusiveOrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ExclusiveOrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExclusiveOrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ExclusiveOrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ExclusiveOrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ExclusiveOrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>사용자 정의 형식에 대해 <c>op_ExclusiveOr</c>을 사용하여 비트 XOR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Field">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>필드 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * System.Reflection.FieldInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />입니다. <see langword="static" />(Visual Basic에서는 <see langword="Shared" />)의 경우 <paramref name="expression" />이 <see langword="null" />입니다.</param>
        <param name="field"><see cref="T:System.Reflection.FieldInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />입니다.</param>
        <summary>필드 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> 및 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberExpression> 값과 같음 합니다 <xref:System.Reflection.FieldInfo.FieldType%2A> 의 속성 `field`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="field" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="field" />가 나타내는 필드가 <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니고 <paramref name="expression" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type을 <paramref name="field" />가 나타내는 필드의 선언 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />에 이름이 <see cref="P:System.Linq.Expressions.Expression.Type" />인 필드가 포함된 <paramref name="fieldName" />입니다. 이 값은 정적 필드의 경우 null일 수 있습니다.</param>
        <param name="fieldName">액세스할 필드의 이름입니다.</param>
        <summary>필드 이름을 통한 필드 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />으로 설정되고 <paramref name="expression" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />이 가리키는 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" />로 설정된 <paramref name="fieldName" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberExpression> 값과 같음는 <xref:System.Reflection.FieldInfo.FieldType%2A> 의 속성을 <xref:System.Reflection.FieldInfo> 가리키는 필드를 나타내는 `fieldName`.  
  
 이 메서드는 검색 `expression`합니다. 형식 및 이름이 있는 필드에 대 한 기본 형식 `fieldName`합니다. Public 필드는 public이 아닌 필드를 통해 우선을 적용 됩니다. 이 메서드를 전달 하는 경우 일치 하는 필드를 찾으면 `expression` 하며 <xref:System.Reflection.FieldInfo> 에 해당 필드를 나타내는 <xref:System.Linq.Expressions.Expression.Field%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 필드 액세스를 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#37)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="fieldName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="fieldName" />.Type 또는 해당 기본 형식에 이름이 <paramref name="expression" />인 필드가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Field">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Field (System.Linq.Expressions.Expression expression, Type type, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Field(class System.Linq.Expressions.Expression expression, class System.Type type, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Field(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ fieldName);" />
      <MemberSignature Language="F#" Value="static member Field : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Field (expression, type, fieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">필드의 포함 개체입니다. 이 값은 정적 필드의 경우 null일 수 있습니다.</param>
        <param name="type">필드를 포함하는 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="fieldName">액세스할 필드입니다.</param>
        <summary>필드 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.MemberExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetActionType">
      <MemberSignature Language="C#" Value="public static Type GetActionType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetActionType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActionType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetActionType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetActionType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetActionType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><see cref="T:System.Type" /> 대리자 형식의 형식 인수를 지정하는 1개에서 16개의 <see langword="System.Action" /> 개체가 들어있는 배열입니다.</param>
        <summary>특정 형식 인수가 있는 제네릭 <c>System.Action</c> 대리자 형식을 나타내는 <see cref="T:System.Type" /> 개체를 만듭니다.</summary>
        <returns>지정된 형식 인수가 있는 <c>System.Action</c> 대리자의 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어 경우 요소의 `typeArgs` 형식을 나타내는 `T1…Tn`, 결과 <xref:System.Type> 개체가 생성 된 대리자 형식을 나타내는 `System.Action<T1,…,Tn>` C# 또는 `System.Action(Of T1,…,Tn)` Visual Basic의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeArgs" />에 17개 이상의 요소가 포함된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateType">
      <MemberSignature Language="C#" Value="public static Type GetDelegateType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetDelegateType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetDelegateType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetDelegateType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetDelegateType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs">대리자의 형식 인수입니다.</param>
        <summary>특정 형식 인수가 있는 제네릭 <c>System.Func</c> 또는 <c>System.Action</c> 대리자 형식을 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" /> 개체를 가져옵니다.</summary>
        <returns>대리자 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마지막 형식 인수는 대리자의 반환 형식을 결정합니다. 작업이 없거나 Func 충분히 큰 경우 사용자 지정 대리자 형식이 생성 됩니다.  
  
 Func와 마찬가지로 마지막 인수가 반환 형식입니다. 작업을 생성 하려면 System.Void를 설정할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFuncType">
      <MemberSignature Language="C#" Value="public static Type GetFuncType (params Type[] typeArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetFuncType(class System.Type[] typeArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFuncType (ParamArray typeArgs As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetFuncType(... cli::array &lt;Type ^&gt; ^ typeArgs);" />
      <MemberSignature Language="F#" Value="static member GetFuncType : Type[] -&gt; Type" Usage="System.Linq.Expressions.Expression.GetFuncType typeArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArgs"><see cref="T:System.Type" /> 대리자 형식의 형식 인수를 지정하는 1개에서 17개의 <see langword="System.Func" /> 개체가 포함된 배열입니다.</param>
        <summary>특정 형식 인수가 있는 제네릭 <c>System.Func</c> 대리자 형식을 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" /> 개체를 만듭니다. 마지막 형식 인수는 생성된 대리자의 반환 형식을 지정합니다.</summary>
        <returns>지정된 형식 인수가 있는 <c>System.Func</c> 대리자의 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `typeArgs` 하나 이상 및 최대 17 요소를 포함 해야 합니다.  
  
 예를 들어 경우 요소의 `typeArgs` 형식을 나타내는 `T1…Tn`, 결과 <xref:System.Type> 개체가 생성 된 대리자 형식을 나타내는 `System.Func<T1,…,Tn>` C# 또는 `System.Func(Of T1,…,Tn)` Visual Basic의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeArgs" />에 1개 미만 또는 17개보다 많은 요소가 들어 있는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Goto">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>"go to" 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <summary>"go to" 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Goto이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 지정된 값으로 설정되며, 이동 시 대상 레이블에 null 값이 전달되는 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 포함 된 식을 만드는 방법을 보여 줍니다는 <xref:System.Linq.Expressions.GotoExpression> 개체입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#45)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#45)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Goto (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <summary>"go to" 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다. 이동 시 레이블에 전달되는 값을 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Goto이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, 이동 시 대상 레이블에 <paramref name="target" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 "go to" 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Goto이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 지정된 값으로 설정되며, <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 null 값이 전달되는 <paramref name="type" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Goto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Goto (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Goto(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Goto(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Goto : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Goto (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 "go to" 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다. 이동 시 레이블에 전달되는 값을 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Goto이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 <paramref name="type" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>"보다 큼" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>"보다 큼" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true`합니다. 그렇지 않으면 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 항상 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "보다 큼" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건을 충족 하는 경우 노드가 리프트 된 및 노드의 유형입니다 <xref:System.Boolean>:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 개의 정수를 비교 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#10)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 "보다 큼" 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>"보다 큼" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true` 하며 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성이 `liftToNull`합니다. 그렇지 않은 경우 둘 다 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "보다 큼" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된; 또한 노드 형식은 nullable <xref:System.Boolean> 하는 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 nullable <xref:System.Boolean> 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 "보다 큼" 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>"보다 크거나 같음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>"보다 크거나 같음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true`합니다. 그렇지 않으면 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 항상 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "크거나 같음" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건을 충족 하는 경우 노드가 리프트 된 및 노드의 유형입니다 <xref:System.Boolean>:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 개의 정수를 비교 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#11)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 "보다 크거나 같음" 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression GreaterThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression GreaterThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreaterThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ GreaterThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.GreaterThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>"보다 크거나 같음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true` 하며 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성이 `liftToNull`합니다. 그렇지 않은 경우 둘 다 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "크거나 같음" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된; 또한 노드 형식은 nullable <xref:System.Boolean> 하는 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 nullable <xref:System.Boolean> 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 “크거나 같음" 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IfThen">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThen (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThen(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThen (test As Expression, ifTrue As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThen(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue);" />
      <MemberSignature Language="F#" Value="static member IfThen : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThen (test, ifTrue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />입니다.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.ConditionalExpression" /> 문을 사용하여 조건부 블록을 나타내는 <see langword="if" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> 및 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />입니다. <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> 속성은 기본 식으로 설정되고 이 메서드에서 반환되는 결과 <see cref="T:System.Linq.Expressions.ConditionalExpression" />의 형식은 <see cref="T:System.Void" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 조건부 블록을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#32)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ConditionalExpression IfThenElse (System.Linq.Expressions.Expression test, System.Linq.Expressions.Expression ifTrue, System.Linq.Expressions.Expression ifFalse);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ConditionalExpression IfThenElse(class System.Linq.Expressions.Expression test, class System.Linq.Expressions.Expression ifTrue, class System.Linq.Expressions.Expression ifFalse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (test As Expression, ifTrue As Expression, ifFalse As Expression) As ConditionalExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ConditionalExpression ^ IfThenElse(System::Linq::Expressions::Expression ^ test, System::Linq::Expressions::Expression ^ ifTrue, System::Linq::Expressions::Expression ^ ifFalse);" />
      <MemberSignature Language="F#" Value="static member IfThenElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.ConditionalExpression" Usage="System.Linq.Expressions.Expression.IfThenElse (test, ifTrue, ifFalse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ConditionalExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifTrue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="ifFalse" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="test"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />입니다.</param>
        <param name="ifTrue"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />입니다.</param>
        <param name="ifFalse"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.ConditionalExpression" /> 및 <see langword="if" /> 문을 사용하여 조건부 블록을 나타내는 <see langword="else" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ConditionalExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> 및 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />입니다. 이 메서드에서 반환되는 결과 <see cref="T:System.Linq.Expressions.ConditionalExpression" />의 형식은 <see cref="T:System.Void" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 조건부 블록을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#33)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>값이 1씩 증가하는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">증가시킬 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>값이 1씩 증가하는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>증가되는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 식은 작동 하며으로 전달 되는 개체의 값을 변경 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 증가 작업을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#24)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Increment (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Increment(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Increment(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Increment : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Increment (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">증가시킬 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>1씩 증가하는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>증가되는 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 식은 작동 하며으로 전달 되는 개체의 값을 변경 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.InvocationExpression" />를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">적용되는 대리자 또는 람다 식을 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arguments">대리자 또는 람다 식이 적용되는 인수를 나타내는 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 개체가 포함된 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>인수 식 목록에 대리자 또는 람다 식을 적용하는 <see cref="T:System.Linq.Expressions.InvocationExpression" />을 만듭니다.</summary>
        <returns>지정된 대리자 또는 람다 식을 제공된 인수에 적용하는 <see cref="T:System.Linq.Expressions.InvocationExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.InvocationExpression> 나타내는 대리자의 반환 형식을 나타내는 `expression`합니다. 형식입니다.  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.InvocationExpression> 비어 있으면 `arguments` 는 `null`. 동일한 요소를 포함 하는 고, 그렇지 `arguments` 그 중 일부를 제외 하 고 <xref:System.Linq.Expressions.Expression> 개체가 될 수 있습니다 *따옴표 붙은*합니다.  
  
> [!NOTE]
>  대리자의 해당 매개 변수를 나타내는 경우에 요소 인용 됩니다 `expression` 유형의 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.InvocationExpression> 지정 된 인수를 사용 하 여 람다 식의 호출을 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type이 대리자 형식이나 <see cref="T:System.Linq.Expressions.Expression`1" />을 나타내지 않는 경우  
  
또는 
<paramref name="arguments" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="expression" />이 나타내는 대리자의 해당 매개 변수 형식에 할당할 수 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="arguments" />에 들어 있는 요소 수가 <paramref name="expression" />이 나타내는 대리자의 매개 변수 목록과 다른 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.InvocationExpression Invoke (System.Linq.Expressions.Expression expression, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.InvocationExpression Invoke(class System.Linq.Expressions.Expression expression, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::InvocationExpression ^ Invoke(System::Linq::Expressions::Expression ^ expression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.InvocationExpression" Usage="System.Linq.Expressions.Expression.Invoke (expression, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.InvocationExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="expression">적용되는 대리자 또는 람다 식을 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arguments">대리자 또는 람다 식이 적용되는 인수를 나타내는 <see cref="T:System.Linq.Expressions.Expression" /> 개체의 배열입니다.</param>
        <summary>인수 식 목록에 대리자 또는 람다 식을 적용하는 <see cref="T:System.Linq.Expressions.InvocationExpression" />을 만듭니다.</summary>
        <returns>지정된 대리자 또는 람다 식을 제공된 인수에 적용하는 <see cref="T:System.Linq.Expressions.InvocationExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.InvocationExpression> 나타내는 대리자의 반환 형식을 나타내는 `expression`합니다. 형식입니다.  
  
 <xref:System.Linq.Expressions.InvocationExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.InvocationExpression> 비어 있으면 `arguments` 는 `null`. 동일한 요소를 포함 하는 고, 그렇지 `arguments` 그 중 일부를 제외 하 고 <xref:System.Linq.Expressions.Expression> 개체가 될 수 있습니다 *따옴표 붙은*합니다.  
  
> [!NOTE]
>  대리자의 해당 매개 변수를 나타내는 경우에 요소 인용 됩니다 `expression` 유형의 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `arguments`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.Invoke%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.InvocationExpression> 지정 된 인수를 사용 하 여 람다 식의 호출을 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#6)]
 [!code-vb[System.Linq.Expressions.Expression#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type이 대리자 형식이나 <see cref="T:System.Linq.Expressions.Expression`1" />을 나타내지 않는 경우  
  
또는 
<paramref name="arguments" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="expression" />이 나타내는 대리자의 해당 매개 변수 형식에 할당할 수 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="arguments" />에 들어 있는 요소 수가 <paramref name="expression" />이 나타내는 대리자의 매개 변수 목록과 다른 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsFalse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식이 false로 계산되는지 여부를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">계산할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>식이 false로 계산되는지 여부를 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFalse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsFalse (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsFalse(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsFalse(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsFalse : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsFalse (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">계산할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>식이 false로 계산되는지 여부를 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsTrue">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식이 true로 계산되는지 여부를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">계산할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>식이 true로 계산되는지 여부를 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrue">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression IsTrue (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression IsTrue(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ IsTrue(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member IsTrue : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.IsTrue (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">계산할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>식이 true로 계산되는지 여부를 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Label">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelTarget" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label () As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label();" />
      <MemberSignature Language="F#" Value="static member Label : unit -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이름이 없는 void 형식의 레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelTarget" />을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Linq.Expressions.LabelTarget" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 포함 된 식을 만드는 방법을 보여 줍니다는 <xref:System.Linq.Expressions.LabelTarget> 개체입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target">이 <see cref="T:System.Linq.Expressions.LabelTarget" />과 연결될 <see cref="T:System.Linq.Expressions.LabelExpression" />입니다.</param>
        <summary>기본값이 없는 레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelExpression" />을 만듭니다.</summary>
        <returns>기본값이 없는 <see cref="T:System.Linq.Expressions.LabelExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (name As String) As LabelTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">레이블의 이름입니다.</param>
        <summary>void 형식과 지정된 이름을 사용하여 레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelTarget" />을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Linq.Expressions.LabelTarget" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Label : Type -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">레이블로 이동할 때 전달되는 값의 형식입니다.</param>
        <summary>지정된 유형을 사용하여 레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelTarget" />을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Linq.Expressions.LabelTarget" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Linq.Expressions.LabelTarget> 루프 식에는 개체입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelExpression Label (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelExpression Label(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Label (target As LabelTarget, defaultValue As Expression) As LabelExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelExpression ^ Label(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member Label : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LabelExpression" Usage="System.Linq.Expressions.Expression.Label (target, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="defaultValue" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target">이 <see cref="T:System.Linq.Expressions.LabelTarget" />과 연결될 <see cref="T:System.Linq.Expressions.LabelExpression" />입니다.</param>
        <param name="defaultValue">일반 제어 흐름을 통해 레이블에 접근하는 경우 이 <see cref="T:System.Linq.Expressions.LabelExpression" />의 값입니다.</param>
        <summary>지정된 기본값을 사용하여 레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelExpression" />을 만듭니다.</summary>
        <returns>지정된 기본값이 있는 <see cref="T:System.Linq.Expressions.LabelExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LabelTarget Label (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LabelTarget Label(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LabelTarget ^ Label(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Label : Type * string -&gt; System.Linq.Expressions.LabelTarget" Usage="System.Linq.Expressions.Expression.Label (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LabelTarget</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">레이블로 이동할 때 전달되는 값의 형식입니다.</param>
        <param name="name">레이블의 이름입니다.</param>
        <summary>지정된 형식과 이름을 사용하여 레이블을 나타내는 <see cref="T:System.Linq.Expressions.LabelTarget" />을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Linq.Expressions.LabelTarget" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Lambda">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>람다 식을 나타내는 식 트리를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="parameters"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 개체의 배열입니다.</param>
        <summary>우선 대리자 형식을 생성하여 <see cref="T:System.Linq.Expressions.LambdaExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters` 매개 변수 16 개 이상의 요소가 없어야 합니다.  
  
 요소의 `parameters` 같아야 참조 매개 변수 식에 `body`입니다.  
  
 이 메서드 중 하나를 사용 하 여 적절 한 대리자 형식을 생성 합니다 `System.Func` 제네릭 대리자입니다. 그런 다음 중 하나에 대리자 형식에 전달 합니다 <xref:System.Linq.Expressions.ExpressionType.Lambda> 를 만드는 팩터리 메서드가 <xref:System.Linq.Expressions.LambdaExpression>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameters" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" />에 17개 이상의 요소가 포함된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 개체가 포함된 배열입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="name">람다의 이름입니다. 디버그 정보를 내보내는 데 사용됩니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">람다에 대한 대리자 시그니처를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>우선 대리자 형식을 생성하여 <see cref="T:System.Linq.Expressions.LambdaExpression" />을 만듭니다. 컴파일 시간에 대리자 형식을 알 수 없을 때 사용할 수 있습니다.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> 속성이 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />이고 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 속성이 지정된 값으로 설정된 람다 식을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 함수에서 반환 되는 개체가 형식의 <xref:System.Linq.Expressions.Expression%601>합니다. <xref:System.Linq.Expressions.LambdaExpression> 형식 람다 식의 구체적인 종류는 컴파일 시간에 알 수 없으므로 반환 되는 개체를 나타내는 데 사용 됩니다.  
  
 가 나타내는 대리자 형식에 대 한 매개 변수 개수`delegateType` 의 길이가 같아야 `parameters`합니다.  
  
 요소의 `parameters` 같아야 참조 매개 변수 식에 `body`입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 개체의 속성이 `delegateType`합니다. 하는 경우 `parameters` 됩니다 `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 결과 개체의 속성은 빈 컬렉션입니다.  
  
   
  
## Examples  
 다음 예제에서는 전달된 된 인수에 1을 추가 하는 람다 식을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#42)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegateType" /> 또는 <paramref name="body" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameters" />에서 하나 이상의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" />이 대리자 형식을 나타내지 않는 경우  
  
또는 
 <paramref name="body" />.Type이 나타내는 형식을 <paramref name="delegateType" />이 나타내는 대리자 형식의 반환 형식에 할당할 수 없는 경우  
  
또는 
 <paramref name="parameters" />에 들어 있는 요소 수가 <paramref name="delegateType" />이 나타내는 대리자 형식의 매개 변수 목록과 다른 경우  
  
또는 
<paramref name="parameters" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="delegateType" />이 나타내는 대리자 형식의 해당 매개 변수 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">람다에 대한 대리자 시그니처를 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="parameters"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 개체의 배열입니다.</param>
        <summary>우선 대리자 형식을 생성하여 <see cref="T:System.Linq.Expressions.LambdaExpression" />을 만듭니다. 컴파일 시간에 대리자 형식을 알 수 없을 때 사용할 수 있습니다.</summary>
        <returns><see cref="P:System.Linq.Expressions.Expression.NodeType" /> 속성이 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />이고 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 속성이 지정된 값으로 설정된 람다 식을 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 함수에서 반환 되는 개체가 형식의 <xref:System.Linq.Expressions.Expression%601>합니다. <xref:System.Linq.Expressions.LambdaExpression> 형식 람다 식의 구체적인 종류는 컴파일 시간에 알 수 없으므로 반환 되는 개체를 나타내는 데 사용 됩니다.  
  
 가 나타내는 대리자 형식에 대 한 매개 변수 개수 `delegateType` 의 길이가 같아야 `parameters`합니다.  
  
 요소의 `parameters` 같아야 참조 매개 변수 식에 `body`입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 개체의 속성이 `delegateType`합니다. 하는 경우 `parameters` 됩니다 `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 결과 개체의 속성은 빈 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="delegateType" /> 또는 <paramref name="body" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameters" />에서 하나 이상의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" />이 대리자 형식을 나타내지 않는 경우  
  
또는 
 <paramref name="body" />.Type이 나타내는 형식을 <paramref name="delegateType" />이 나타내는 대리자 형식의 반환 형식에 할당할 수 없는 경우  
  
또는 
 <paramref name="parameters" />에 들어 있는 요소 수가 <paramref name="delegateType" />이 나타내는 대리자 형식의 매개 변수 목록과 다른 경우  
  
또는 
<paramref name="parameters" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="delegateType" />이 나타내는 대리자 형식의 해당 매개 변수 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="name">람다의 이름입니다. 디버그 정보를 내보내는 데 사용됩니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">람다에 대한 대리자 시그니처를 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType">람다에 대한 대리자 시그니처를 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 개체가 포함된 배열입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">람다에 대한 대리자 시그니처를 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="name">람다의 이름입니다. 디버그 정보를 내보내는 데 사용됩니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LambdaExpression Lambda (Type delegateType, System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LambdaExpression Lambda(class System.Type delegateType, class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (delegateType As Type, body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As LambdaExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LambdaExpression ^ Lambda(Type ^ delegateType, System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : Type * System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.LambdaExpression" Usage="System.Linq.Expressions.Expression.Lambda (delegateType, body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LambdaExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType">람다에 대한 대리자 시그니처를 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="name">람다의 이름입니다. 디버그 정보를 내보내는 데 사용됩니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>먼저 대리자 형식을 생성하여 LambdaExpression을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성이 Lambda이고 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">대리자 형식입니다.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>컴파일 타임에 대리자 형식이 알려진 <see cref="T:System.Linq.Expressions.Expression`1" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대리자 형식에 대 한 매개 변수 개수 `TDelegate` 의 요소 수와 같아야 `parameters`합니다.  
  
 요소의 `parameters` 같아야 참조 매개 변수 식에 `body`입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 개체의 속성 형식을 나타내는 `TDelegate`합니다. 하는 경우 `parameters` 됩니다 `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 결과 개체의 속성은 빈 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameters" />에서 하나 이상의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" />가 대리자 형식이 아닌 경우  
  
또는 
 <paramref name="body" />.Type이 나타내는 형식을 <paramref name="TDelegate" />의 반환 형식에 할당할 수 없는 경우  
  
또는 
 <paramref name="parameters" />에 들어 있는 요소 수가 <paramref name="TDelegate" />의 매개 변수 목록과 다른 경우  
  
또는 
<paramref name="parameters" />의 해당 매개 변수 형식에서 <paramref name="TDelegate" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">대리자 형식입니다.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="parameters"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 개체의 배열입니다.</param>
        <summary>컴파일 타임에 대리자 형식이 알려진 <see cref="T:System.Linq.Expressions.Expression`1" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대리자 형식에 대 한 매개 변수 개수 `TDelegate` 의 요소 수와 같아야 `parameters`합니다.  
  
 요소의 `parameters` 같아야 참조 매개 변수 식에`body`입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 개체의 속성 형식을 나타내는 `TDelegate`합니다. 하는 경우 `parameters` 됩니다 `null`, <xref:System.Linq.Expressions.LambdaExpression.Parameters%2A> 결과 개체의 속성은 빈 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameters" />에서 하나 이상의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="TDelegate" />가 대리자 형식이 아닌 경우  
  
또는 
 <paramref name="body" />.Type이 나타내는 형식을 <paramref name="TDelegate" />의 반환 형식에 할당할 수 없는 경우  
  
또는 
 <paramref name="parameters" />에 들어 있는 요소 수가 <paramref name="TDelegate" />의 매개 변수 목록과 다른 경우  
  
또는 
<paramref name="parameters" />의 해당 매개 변수 형식에서 <paramref name="TDelegate" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">대리자 형식입니다.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>컴파일 타임에 대리자 형식이 알려진 <see cref="T:System.Linq.Expressions.Expression`1" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" /> 속성이 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, bool tailCall, params System.Linq.Expressions.ParameterExpression[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, bool tailCall, class System.Linq.Expressions.ParameterExpression[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, tailCall As Boolean, ParamArray parameters As ParameterExpression()) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, bool tailCall, ... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * bool * System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">대리자 형식입니다.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> 개체가 포함된 배열입니다.</param>
        <summary>컴파일 타임에 대리자 형식이 알려진 <see cref="T:System.Linq.Expressions.Expression`1" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">대리자 형식입니다.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="name">람다의 이름입니다. 디버깅 정보를 생성하는 데 사용됩니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>컴파일 타임에 대리자 형식이 알려진 <see cref="T:System.Linq.Expressions.Expression`1" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.Expression&lt;TDelegate&gt; Lambda&lt;TDelegate&gt; (System.Linq.Expressions.Expression body, string name, bool tailCall, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.Expression`1&lt;!!TDelegate&gt; Lambda&lt;TDelegate&gt;(class System.Linq.Expressions.Expression body, string name, bool tailCall, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda(Of TDelegate) (body As Expression, name As String, tailCall As Boolean, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Lambda(System::Linq::Expressions::Expression ^ body, System::String ^ name, bool tailCall, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="static member Lambda : System.Linq.Expressions.Expression * string * bool * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="System.Linq.Expressions.Expression.Lambda (body, name, tailCall, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="tailCall" Type="System.Boolean" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">대리자 형식입니다.</typeparam>
        <param name="body"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />입니다.</param>
        <param name="name">람다의 이름입니다. 디버깅 정보를 생성하는 데 사용됩니다.</param>
        <param name="tailCall">만들어진 식을 컴파일할 때 마무리 호출 최적화가 적용될지를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <param name="parameters"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</param>
        <summary>컴파일 타임에 대리자 형식이 알려진 <see cref="T:System.Linq.Expressions.Expression`1" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression`1" /> 속성이 <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> 및 <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 왼쪽 시프트 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 왼쪽 시프트 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 왼쪽 시프트 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식은 정수 계열 형식 (중 하나 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>를 <xref:System.UInt32>, <xref:System.Int64>를 <xref:System.UInt64>, 또는 해당 nullable 형식) 및 `right`합니다. 형식은 <xref:System.Int32>의 메서드 구현은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 왼쪽 시프트 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 왼쪽 시프트 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 왼쪽 시프트 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="LeftShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 왼쪽 시프트 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 왼쪽 시프트 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식은 정수 계열 형식 (중 하나 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>를 <xref:System.UInt32>, <xref:System.Int64>를 <xref:System.UInt64>, 또는 해당 nullable 형식) 및 `right`합니다. 형식은 <xref:System.Int32>의 메서드 구현은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 왼쪽 시프트 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 왼쪽 시프트 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 왼쪽 시프트 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LeftShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 왼쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 왼쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 왼쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LeftShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LeftShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeftShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LeftShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member LeftShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LeftShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>비트 왼쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>"보다 작음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>"보다 작음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true`합니다. 그렇지 않으면 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 항상 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 작업에 대 한 구현 메서드는 다음 규칙에 따라 선택 됩니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "보다 작음" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건을 충족 하는 경우 노드가 리프트 된 및 노드의 유형입니다 <xref:System.Boolean>:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 개의 정수를 비교 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#25)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 "보다 작음" 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThan">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThan (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThan(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThan (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThan(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThan (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>"보다 작음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true` 하며 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성이 `liftToNull`합니다. 그렇지 않은 경우 둘 다 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "보다 작음" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된; 또한 노드 형식은 nullable <xref:System.Boolean> 하는 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 nullable <xref:System.Boolean> 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 "보다 작음" 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>"보다 작거나 같음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>"보다 작거나 같음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true`합니다. 그렇지 않으면 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 항상 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "보다 작거나 같음" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건을 충족 하는 경우 노드가 리프트 된 및 노드의 유형입니다 <xref:System.Boolean>:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 개의 정수를 비교 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#26)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 "보다 작거나 같음" 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression LessThanOrEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression LessThanOrEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LessThanOrEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ LessThanOrEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.LessThanOrEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>"보다 작거나 같음" 숫자 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true` 하며 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성이 `liftToNull`합니다. 그렇지 않은 경우 둘 다 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` "보다 작거나 같음" 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된; 또한 노드 형식은 nullable <xref:System.Boolean> 하는 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 nullable <xref:System.Boolean> 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 "보다 작거나 같음" 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.MemberListBinding" /> 개체를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> 속성에 설정할 필드 또는 속성을 나타내는 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />입니다.</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ElementInit" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />입니다.</param>
        <summary>멤버가 필드 또는 속성인 <see cref="T:System.Linq.Expressions.MemberListBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> 및 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />가 필드나 속성을 나타내지 않는 경우  
  
또는 
<paramref name="member" />가 나타내는 필드 또는 속성의 <see cref="P:System.Reflection.FieldInfo.FieldType" /> 또는 <see cref="P:System.Reflection.PropertyInfo.PropertyType" />이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (member As MemberInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MemberInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (member, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> 속성에 설정할 필드 또는 속성을 나타내는 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />입니다.</param>
        <param name="initializers"><see cref="T:System.Linq.Expressions.ElementInit" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 개체의 배열입니다.</param>
        <summary>멤버가 필드 또는 속성인 <see cref="T:System.Linq.Expressions.MemberListBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> 및 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />가 필드나 속성을 나타내지 않는 경우  
  
또는 
<paramref name="member" />가 나타내는 필드 또는 속성의 <see cref="P:System.Reflection.FieldInfo.FieldType" /> 또는 <see cref="P:System.Reflection.PropertyInfo.PropertyType" />이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, initializers As IEnumerable(Of ElementInit)) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">속성 접근자 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ElementInit" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />입니다.</param>
        <summary>지정된 속성 접근자 메서드에 따라 <see cref="T:System.Linq.Expressions.MemberListBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />로 액세스되는 속성을 나타내는 <see cref="T:System.Reflection.MemberInfo" />로 설정되고 <paramref name="propertyAccessor" />가 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />의 요소로 채워진 <paramref name="initializers" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />가 속성 접근자 메서드를 나타내지 않는 경우  
  
또는 
<paramref name="propertyAccessor" />가 나타내는 메서드가 액세스하는 속성의 <see cref="P:System.Reflection.PropertyInfo.PropertyType" />에서 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberListBinding ListBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberListBinding ListBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ListBind (propertyAccessor As MethodInfo, ParamArray initializers As ElementInit()) As MemberListBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberListBinding ^ ListBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListBind : System.Reflection.MethodInfo * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.MemberListBinding" Usage="System.Linq.Expressions.Expression.ListBind (propertyAccessor, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberListBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">속성 접근자 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="initializers"><see cref="T:System.Linq.Expressions.ElementInit" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> 개체의 배열입니다.</param>
        <summary>지정된 속성 접근자 메서드에 따라 <see cref="T:System.Linq.Expressions.MemberListBinding" /> 개체를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberListBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />로 액세스되는 속성을 나타내는 <see cref="T:System.Reflection.MemberInfo" />로 설정되고 <paramref name="propertyAccessor" />가 <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />의 요소로 채워진 <paramref name="initializers" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />가 속성 접근자 메서드를 나타내지 않는 경우  
  
또는 
<paramref name="propertyAccessor" />가 나타내는 메서드가 액세스하는 속성의 <see cref="P:System.Reflection.PropertyInfo.PropertyType" />에서 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ListInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.ListInitExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ElementInit&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.ElementInit&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ElementInit&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.ElementInit" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />입니다.</param>
        <summary>지정된 <see cref="T:System.Linq.Expressions.ListInitExpression" /> 개체를 사용하여 컬렉션을 초기화하는 <see cref="T:System.Linq.Expressions.ElementInit" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> 및 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `newExpression` 구현 하는 형식을 나타내야 <xref:System.Collections.IEnumerable>합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ListInitExpression> 값과 같음 `newExpression`합니다. 형식입니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.ListInitExpression> 두 키-값 쌍이 포함 된 새 사전 인스턴스 초기화를 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />입니다.</param>
        <summary>이름이 "Add"인 메서드를 사용하여 컬렉션에 요소를 추가하는 <see cref="T:System.Linq.Expressions.ListInitExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `newExpression` 구현 하는 형식을 나타내야 <xref:System.Collections.IEnumerable>합니다.  
  
 이 오버 로드를 사용 하려면 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.Expression%7D%29>, `newExpression`합니다. 형식 또는 해당 기본 형식에 정확히 하나의 인수를 받는 "Add" (대/소문자 구분) 라는 단일 메서드를 선언 해야 합니다. 인수의 형식을 나타내는 형식에서 할당할 수 있어야 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 첫 번째 요소의 `initializers`합니다.  
  
 합니다 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 반환 된 속성 <xref:System.Linq.Expressions.ListInitExpression> 형식의 요소가 포함 되어 <xref:System.Linq.Expressions.ElementInit> 의 각 요소에 대해 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 의 해당 요소를 포함 하는 singleton 컬렉션은 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 에서 검색 된 추가 메서드를 나타내는 `newExpression`합니다. 형식 또는 해당 기본 형식입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ListInitExpression> 값과 같음 `newExpression`합니다. 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="newExpression" />.Type 또는 해당 기본 형식에 선언된 "Add"(대/소문자 구분 안 함)라는 인스턴스 메서드가 없는 경우  
  
또는 
<paramref name="newExpression" />.Type 또는 해당 기본 형식의 add 메서드가 정확히 하나의 인수만 사용하지 않는 경우  
  
또는 
<paramref name="initializers" />의 첫 번째 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성으로 표시되는 형식을 <paramref name="newExpression" />.Type 또는 해당 기본 형식의 add 메서드에 대한 인수 형식에 할당할 수 없는 경우  
  
또는 
"Add"(대/소문자 구분 안 함)라는 둘 이상의 인수 호환 메서드가 <paramref name="newExpression" />.Type 및/또는 해당 기본 형식에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.ElementInit[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.ElementInit[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::ElementInit ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.ElementInit[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.ElementInit[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</param>
        <param name="initializers"><see cref="T:System.Linq.Expressions.ElementInit" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 개체의 배열입니다.</param>
        <summary>지정된 <see cref="T:System.Linq.Expressions.ListInitExpression" /> 개체를 사용하여 컬렉션을 초기화하는 <see cref="T:System.Linq.Expressions.ElementInit" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> 및 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `newExpression` 구현 하는 형식을 나타내야 <xref:System.Collections.IEnumerable>합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ListInitExpression> 값과 같음 `newExpression`합니다. 형식입니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.ElementInit%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.ListInitExpression> 두 키-값 쌍이 포함 된 새 사전 인스턴스 초기화를 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#7)]
 [!code-vb[System.Linq.Expressions.Expression#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</param>
        <param name="initializers"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 개체의 배열입니다.</param>
        <summary>이름이 "Add"인 메서드를 사용하여 컬렉션에 요소를 추가하는 <see cref="T:System.Linq.Expressions.ListInitExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `newExpression` 구현 하는 형식을 나타내야 <xref:System.Collections.IEnumerable>합니다.  
  
 이 오버 로드를 사용 하려면 <xref:System.Linq.Expressions.Expression.ListInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.Expression%5B%5D%29>, `newExpression`합니다. 형식 또는 해당 기본 형식에 정확히 하나의 인수를 받는 "Add" (대/소문자 구분) 라는 단일 메서드를 선언 해야 합니다. 인수의 형식을 나타내는 형식에서 할당할 수 있어야 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 첫 번째 요소의 `initializers`합니다.  
  
 합니다 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 반환 된 속성 <xref:System.Linq.Expressions.ListInitExpression> 형식의 요소가 포함 되어 <xref:System.Linq.Expressions.ElementInit> 의 각 요소에 대해 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 의 해당 요소를 포함 하는 singleton 컬렉션은 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 에서 검색 된 추가 메서드를 나타내는 `newExpression`합니다. 형식 또는 해당 기본 형식입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ListInitExpression> 값과 같음 `newExpression`합니다. 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="newExpression" />.Type 또는 해당 기본 형식에 선언된 "Add"(대/소문자 구분 안 함)라는 인스턴스 메서드가 없는 경우  
  
또는 
<paramref name="newExpression" />.Type 또는 해당 기본 형식의 add 메서드가 정확히 하나의 인수만 사용하지 않는 경우  
  
또는 
<paramref name="initializers" />의 첫 번째 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성으로 표시되는 형식을 <paramref name="newExpression" />.Type 또는 해당 기본 형식의 add 메서드에 대한 인수 형식에 할당할 수 없는 경우  
  
또는 
"Add"(대/소문자 구분 안 함)라는 둘 이상의 인수 호환 메서드가 <paramref name="newExpression" />.Type 및/또는 해당 기본 형식에 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</param>
        <param name="addMethod">컬렉션에 요소를 추가하는 "Add"(대/소문자 구분 안 함)라는 인스턴스 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />입니다.</param>
        <summary>지정된 메서드를 사용하여 컬렉션에 요소를 추가하는 <see cref="T:System.Linq.Expressions.ListInitExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `newExpression` 구현 하는 형식을 나타내야 <xref:System.Collections.IEnumerable>합니다.  
  
 하는 경우 `addMethod` 됩니다 `null`, `newExpression`합니다. 형식 또는 해당 기본 형식에 정확히 하나의 인수를 받는 "Add" (대/소문자 구분) 라는 단일 메서드를 선언 해야 합니다. 하는 경우 `addMethod` 아닙니다 `null`, 정확히 하나의 매개 변수가 있는 "Add" (대/소문자 구분) 라는 인스턴스 메서드를 나타내야 합니다. 가 나타내는 형식 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소 `initializers` add 메서드의 인수 형식에 할당할 수 있어야 합니다.  
  
 합니다 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 반환 된 속성 <xref:System.Linq.Expressions.ListInitExpression> 형식의 요소가 포함 되어 <xref:System.Linq.Expressions.ElementInit> 의 각 요소에 대해 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 의 해당 요소를 포함 하는 singleton 컬렉션은 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 값과 같음 `addMethod`합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ListInitExpression> 값과 같음 `newExpression`합니다. 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우  
  
또는 
 <paramref name="addMethod" />가 <see langword="null" />이 아니고 정확히 하나의 인수를 받는 "Add"(대/소문자 구분 안 함)라는 인스턴스 메서드를 나타내지 않는 경우  
  
또는 
 <paramref name="addMethod" />가 <see langword="null" />이 아니고 <paramref name="initializers" />에 있는 요소 중 하나 이상의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 <paramref name="addMethod" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="addMethod" />가 <see langword="null" />이고 <paramref name="newExpression" />.Type 또는 해당 기본 형식에 하나의 형식 호환 인수를 받는 "Add"라는 인스턴스 메서드가 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ListInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ListInitExpression ListInit (System.Linq.Expressions.NewExpression newExpression, System.Reflection.MethodInfo addMethod, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ListInitExpression ListInit(class System.Linq.Expressions.NewExpression newExpression, class System.Reflection.MethodInfo addMethod, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ListInitExpression ^ ListInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Reflection::MethodInfo ^ addMethod, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member ListInit : System.Linq.Expressions.NewExpression * System.Reflection.MethodInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.ListInitExpression" Usage="System.Linq.Expressions.Expression.ListInit (newExpression, addMethod, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ListInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="addMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</param>
        <param name="addMethod">하나의 인수를 받으며 컬렉션에 요소를 추가하는 인스턴스 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="initializers"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> 개체의 배열입니다.</param>
        <summary>지정된 메서드를 사용하여 컬렉션에 요소를 추가하는 <see cref="T:System.Linq.Expressions.ListInitExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ListInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 `newExpression` 구현 하는 형식을 나타내야 <xref:System.Collections.IEnumerable>합니다.  
  
 하는 경우 `addMethod` 됩니다 `null`, `newExpression`합니다. 형식 또는 해당 기본 형식에 정확히 하나의 인수를 받는 "Add" (대/소문자 구분) 라는 단일 메서드를 선언 해야 합니다. 하는 경우 `addMethod` 아닙니다 `null`, 정확히 하나의 매개 변수가 있는 "Add" (대/소문자 구분) 라는 인스턴스 메서드를 나타내야 합니다. 가 나타내는 형식 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소 `initializers` add 메서드의 인수 형식에 할당할 수 있어야 합니다.  
  
 합니다 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 반환 된 속성 <xref:System.Linq.Expressions.ListInitExpression> 형식의 요소가 포함 되어 <xref:System.Linq.Expressions.ElementInit> 의 각 요소에 대해 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.Arguments%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 의 해당 요소를 포함 하는 singleton 컬렉션은 `initializers`합니다. 합니다 <xref:System.Linq.Expressions.ElementInit.AddMethod%2A> 속성의 각 요소 <xref:System.Linq.Expressions.ListInitExpression.Initializers%2A> 값과 같음 `addMethod`합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.ListInitExpression> 값과 같음 `newExpression`합니다. 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 하나 이상의 요소가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newExpression" />.Type이 <see cref="T:System.Collections.IEnumerable" />을 구현하지 않는 경우  
  
또는 
 <paramref name="addMethod" />가 <see langword="null" />이 아니고 정확히 하나의 인수를 받는 "Add"(대/소문자 구분 안 함)라는 인스턴스 메서드를 나타내지 않는 경우  
  
또는 
 <paramref name="addMethod" />가 <see langword="null" />이 아니고 <paramref name="initializers" />에 있는 요소 중 하나 이상의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 <paramref name="addMethod" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="addMethod" />가 <see langword="null" />이고 <paramref name="newExpression" />.Type 또는 해당 기본 형식에 하나의 형식 호환 인수를 받는 "Add"라는 인스턴스 메서드가 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Loop">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.LoopExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop body" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">루프의 본문입니다.</param>
        <summary>지정된 본문을 사용하여 <see cref="T:System.Linq.Expressions.LoopExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.LoopExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">루프의 본문입니다.</param>
        <param name="break">루프 본문에서 사용하는 break 대상입니다.</param>
        <summary>지정된 본문과 break 대상을 사용하여 <see cref="T:System.Linq.Expressions.LoopExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.LoopExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 포함 된 블록 식을 만드는 방법을 보여 줍니다는 <xref:System.Linq.Expressions.LoopExpression> 개체입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#44)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#44)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.LoopExpression Loop (System.Linq.Expressions.Expression body, System.Linq.Expressions.LabelTarget break, System.Linq.Expressions.LabelTarget continue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.LoopExpression Loop(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.LabelTarget break, class System.Linq.Expressions.LabelTarget continue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Loop (body As Expression, break As LabelTarget, continue As LabelTarget) As LoopExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::LoopExpression ^ Loop(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::LabelTarget ^ break, System::Linq::Expressions::LabelTarget ^ continue);" />
      <MemberSignature Language="F#" Value="static member Loop : System.Linq.Expressions.Expression * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.LoopExpression" Usage="System.Linq.Expressions.Expression.Loop (body, break, continue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.LoopExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="break" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="continue" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="body">루프의 본문입니다.</param>
        <param name="break">루프 본문에서 사용하는 break 대상입니다.</param>
        <param name="continue">루프 본문에서 사용하는 continue 대상입니다.</param>
        <summary>지정된 본문을 사용하여 <see cref="T:System.Linq.Expressions.LoopExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.LoopExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeBinary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>적절한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="binaryType">이진 연산의 형식을 지정하는 <see cref="T:System.Linq.Expressions.ExpressionType" />입니다.</param>
        <param name="left">왼쪽 피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="right">오른쪽 피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>지정된 왼쪽 및 오른쪽 피연산자를 사용하고 적합한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns>적절한 팩터리 메서드를 호출한 결과인 <see cref="T:System.Linq.Expressions.BinaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `binaryType` 매개 변수를 결정 하는 <xref:System.Linq.Expressions.BinaryExpression> 팩터리 메서드를 호출 합니다. 예를 들어 경우 `binaryType` 됩니다 <xref:System.Linq.Expressions.ExpressionType.Subtract>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Subtract%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.MakeBinary%28System.Linq.Expressions.ExpressionType%2CSystem.Linq.Expressions.Expression%2CSystem.Linq.Expressions.Expression%29> 메서드를를 <xref:System.Linq.Expressions.BinaryExpression> 다른 빼기 1 개의 숫자를 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#8)]
 [!code-vb[System.Linq.Expressions.Expression#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" />이 이항 식 노드에 해당하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="binaryType">이진 연산의 형식을 지정하는 <see cref="T:System.Linq.Expressions.ExpressionType" />입니다.</param>
        <param name="left">왼쪽 피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="right">오른쪽 피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method">구현 메서드를 지정하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>지정된 왼쪽 피연산자, 오른쪽 피연산자 및 구현 메서드를 사용하고 적합한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns>적절한 팩터리 메서드를 호출한 결과인 <see cref="T:System.Linq.Expressions.BinaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `binaryType` 매개 변수를 결정 하는 <xref:System.Linq.Expressions.BinaryExpression> 팩터리 메서드입니다.이 메서드를 호출 합니다. 예를 들어 경우 `binaryType` 됩니다 <xref:System.Linq.Expressions.ExpressionType.Subtract>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Subtract%2A>합니다. 합니다 `liftToNull` 고 `method` 적합 한 팩터리 메서드는 해당 매개 변수가 없는 경우 매개 변수가 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" />이 이항 식 노드에 해당하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeBinary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MakeBinary (System.Linq.Expressions.ExpressionType binaryType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MakeBinary(valuetype System.Linq.Expressions.ExpressionType binaryType, class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeBinary (binaryType As ExpressionType, left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MakeBinary(System::Linq::Expressions::ExpressionType binaryType, System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MakeBinary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MakeBinary (binaryType, left, right, liftToNull, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="binaryType">이진 연산의 형식을 지정하는 <see cref="T:System.Linq.Expressions.ExpressionType" />입니다.</param>
        <param name="left">왼쪽 피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="right">오른쪽 피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method">구현 메서드를 지정하는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="conversion">형식 변환 함수를 나타내는 <see cref="T:System.Linq.Expressions.LambdaExpression" />입니다. 이 매개 변수는 <paramref name="binaryType" />이 <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> 또는 복합 할당으로 설정되어 있는 경우에만 사용됩니다.</param>
        <summary>지정된 왼쪽 피연산자, 오른쪽 피연산자, 구현 메서드 및 형식 변환 함수를 사용하고 적합한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns>적절한 팩터리 메서드를 호출한 결과인 <see cref="T:System.Linq.Expressions.BinaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `binaryType` 매개 변수를 결정 하는 <xref:System.Linq.Expressions.BinaryExpression> 팩터리 메서드입니다.이 메서드를 호출 합니다. 예를 들어 경우 `binaryType` 됩니다 <xref:System.Linq.Expressions.ExpressionType.Subtract>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Subtract%2A>합니다. `liftToNull`하십시오 `method` 및 `conversion` 적합 한 팩터리 메서드는 해당 매개 변수가 없는 경우 매개 변수가 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="binaryType" />이 이항 식 노드에 해당하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeCatchBlock">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.CatchBlock MakeCatchBlock (Type type, System.Linq.Expressions.ParameterExpression variable, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.CatchBlock MakeCatchBlock(class System.Type type, class System.Linq.Expressions.ParameterExpression variable, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::CatchBlock ^ MakeCatchBlock(Type ^ type, System::Linq::Expressions::ParameterExpression ^ variable, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ filter);" />
      <MemberSignature Language="F#" Value="static member MakeCatchBlock : Type * System.Linq.Expressions.ParameterExpression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.CatchBlock" Usage="System.Linq.Expressions.Expression.MakeCatchBlock (type, variable, body, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.CatchBlock</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="variable" Type="System.Linq.Expressions.ParameterExpression" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="filter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="type">이 <see cref="P:System.Linq.Expressions.Expression.Type" />이 처리할 <see cref="T:System.Exception" />의 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</param>
        <param name="variable">이 처리기가 catch한 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 개체에 대한 참조를 나타내는 <see cref="T:System.Exception" />입니다.</param>
        <param name="body">catch 문의 본문입니다.</param>
        <param name="filter"><see cref="T:System.Exception" /> 필터의 본문입니다.</param>
        <summary>지정된 요소를 사용하여 catch 문을 나타내는 <see cref="T:System.Linq.Expressions.CatchBlock" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.CatchBlock" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` null이 아니어야 하며 유형에 `variable` (제공 된 경우).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeDynamic">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 연산을 나타내는 <see cref="T:System.Linq.Expressions.DynamicExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arguments As IEnumerable(Of Expression)) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" />에서 사용되는 대리자의 형식입니다.</param>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="arguments">동적 작업의 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" />에서 사용되는 대리자의 형식입니다.</param>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="arg0">동적 작업의 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" /> 및 1개 인수에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, ParamArray arguments As Expression()) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" />에서 사용되는 대리자의 형식입니다.</param>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="arguments">동적 작업의 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" />에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" />에서 사용되는 대리자의 형식입니다.</param>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <param name="arg1">동적 작업의 두 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" /> 및 2개 인수에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" />에서 사용되는 대리자의 형식입니다.</param>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <param name="arg1">동적 작업의 두 번째 인수입니다.</param>
        <param name="arg2">동적 작업의 세 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" /> 및 3개 인수에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeDynamic">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.DynamicExpression MakeDynamic (Type delegateType, System.Runtime.CompilerServices.CallSiteBinder binder, System.Linq.Expressions.Expression arg0, System.Linq.Expressions.Expression arg1, System.Linq.Expressions.Expression arg2, System.Linq.Expressions.Expression arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.DynamicExpression MakeDynamic(class System.Type delegateType, class System.Runtime.CompilerServices.CallSiteBinder binder, class System.Linq.Expressions.Expression arg0, class System.Linq.Expressions.Expression arg1, class System.Linq.Expressions.Expression arg2, class System.Linq.Expressions.Expression arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeDynamic (delegateType As Type, binder As CallSiteBinder, arg0 As Expression, arg1 As Expression, arg2 As Expression, arg3 As Expression) As DynamicExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::DynamicExpression ^ MakeDynamic(Type ^ delegateType, System::Runtime::CompilerServices::CallSiteBinder ^ binder, System::Linq::Expressions::Expression ^ arg0, System::Linq::Expressions::Expression ^ arg1, System::Linq::Expressions::Expression ^ arg2, System::Linq::Expressions::Expression ^ arg3);" />
      <MemberSignature Language="F#" Value="static member MakeDynamic : Type * System.Runtime.CompilerServices.CallSiteBinder * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.DynamicExpression" Usage="System.Linq.Expressions.Expression.MakeDynamic (delegateType, binder, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.DynamicExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="binder" Type="System.Runtime.CompilerServices.CallSiteBinder" />
        <Parameter Name="arg0" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg1" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg2" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="arg3" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="delegateType"><see cref="T:System.Runtime.CompilerServices.CallSite" />에서 사용되는 대리자의 형식입니다.</param>
        <param name="binder">동적 작업의 런타임 바인더입니다.</param>
        <param name="arg0">동적 작업의 첫 번째 인수입니다.</param>
        <param name="arg1">동적 작업의 두 번째 인수입니다.</param>
        <param name="arg2">동적 작업의 세 번째 인수입니다.</param>
        <param name="arg3">동적 작업의 네 번째 인수입니다.</param>
        <summary>제공된 <see cref="T:System.Linq.Expressions.DynamicExpression" /> 및 4개 인수에 의해 바인딩된 동적 작업을 나타내는 <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.DynamicExpression" />이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" /> 및 <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />가 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGoto">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression MakeGoto (System.Linq.Expressions.GotoExpressionKind kind, System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression MakeGoto(valuetype System.Linq.Expressions.GotoExpressionKind kind, class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ MakeGoto(System::Linq::Expressions::GotoExpressionKind kind, System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeGoto : System.Linq.Expressions.GotoExpressionKind * System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.MakeGoto (kind, target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kind" Type="System.Linq.Expressions.GotoExpressionKind" />
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="kind"><see cref="T:System.Linq.Expressions.GotoExpressionKind" />의 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 <see cref="T:System.Linq.Expressions.GotoExpression" />의 이동을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpressionKind" />을 만듭니다. 이동 시 레이블에 전달되는 값도 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />이고, <paramref name="kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 <paramref name="type" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeIndex">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression MakeIndex (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression MakeIndex(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeIndex (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ MakeIndex(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member MakeIndex : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.MakeIndex (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">속성이 속해 있는 개체입니다. 속성이 <see langword="static" />(Visual Basic에서는 <see langword="shared" />)인 경우 null입니다.</param>
        <param name="indexer">인덱싱할 속성을 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="arguments">속성을 인덱싱하는 데 사용할 인수가 포함된 <c>IEnumerable&lt;Expression&gt;</c>(Visual Basic에서는 <c>IEnumerable (Of Expression)</c>)입니다.</param>
        <summary>개체의 인덱싱된 속성에 액세스하는 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.IndexExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeMemberAccess">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression MakeMemberAccess (System.Linq.Expressions.Expression expression, System.Reflection.MemberInfo member);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression MakeMemberAccess(class System.Linq.Expressions.Expression expression, class System.Reflection.MemberInfo member) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ MakeMemberAccess(System::Linq::Expressions::Expression ^ expression, System::Reflection::MemberInfo ^ member);" />
      <MemberSignature Language="F#" Value="static member MakeMemberAccess : System.Linq.Expressions.Expression * System.Reflection.MemberInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.MakeMemberAccess (expression, member)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="expression">멤버가 속하는 개체를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다. 이 값은 정적 멤버의 경우 null일 수 있습니다.</param>
        <param name="member">액세스할 필드 또는 속성을 설명하는 <see cref="T:System.Reflection.MemberInfo" />입니다.</param>
        <summary>필드 또는 속성 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns>적절한 팩터리 메서드를 호출한 결과인 <see cref="T:System.Linq.Expressions.MemberExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 만드는 데 사용할 수는 <xref:System.Linq.Expressions.MemberExpression> 필드 또는 속성의 형식에 따라 액세스를 나타내는 `member`합니다. 경우 `member` 유형의 <xref:System.Reflection.FieldInfo>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Field%2A> 만들려는 <xref:System.Linq.Expressions.MemberExpression>합니다. 경우 `member` 유형의 <xref:System.Reflection.PropertyInfo>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Property%2A> 만들려는 <xref:System.Linq.Expressions.MemberExpression>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />가 필드나 속성을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTry">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression MakeTry (Type type, System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, System.Linq.Expressions.Expression fault, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt; handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression MakeTry(class System.Type type, class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.Expression fault, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.CatchBlock&gt; handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ MakeTry(Type ^ type, System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, System::Linq::Expressions::Expression ^ fault, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member MakeTry : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.CatchBlock&gt; -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.MakeTry (type, body, finally, fault, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.CatchBlock&gt;" />
      </Parameters>
      <Docs>
        <param name="type">try 식의 결과 형식입니다. null일 경우 본문 및 모든 처리기에 같은 형식이 있어야 합니다.</param>
        <param name="body">try 블록의 본문입니다.</param>
        <param name="finally">finally 블록의 본문입니다. try 블록에 연결된 finally 블록이 없을 경우 null을 전달합니다.</param>
        <param name="fault">fault 블록의 본문입니다. try 블록에 연결된 fault 블록이 없을 경우 null을 전달합니다.</param>
        <param name="handlers">try 블록과 연결되는 catch 문을 나타내는 <see cref="T:System.Linq.Expressions.CatchBlock" />의 컬렉션입니다.</param>
        <summary>지정된 요소를 사용하여 try 블록을 나타내는 <see cref="T:System.Linq.Expressions.TryExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.TryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeUnary">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>적절한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="unaryType">단항 연산의 형식을 지정하는 <see cref="T:System.Linq.Expressions.ExpressionType" />입니다.</param>
        <param name="operand">피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="type">변환할 형식을 지정하는 <see cref="T:System.Type" />입니다. 해당 사항이 없는 경우 <see langword="null" />을 전달합니다.</param>
        <summary>지정된 피연산자를 사용하고 적합한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>적절한 팩터리 메서드를 호출한 결과인 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `unaryType` 매개 변수를 결정 하는 <xref:System.Linq.Expressions.UnaryExpression> 팩터리 메서드를 호출 합니다. 예를 들어 경우 `unaryType` 값과 같음 <xref:System.Linq.Expressions.ExpressionType.Convert>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Convert%2A>합니다. `type`이라고 하는 팩터리 메서드에 적용 되지 않는 경우 매개 변수가 무시 됩니다.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="operand" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unaryType" />이 단항 식 노드에 해당하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnary">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression MakeUnary (System.Linq.Expressions.ExpressionType unaryType, System.Linq.Expressions.Expression operand, Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression MakeUnary(valuetype System.Linq.Expressions.ExpressionType unaryType, class System.Linq.Expressions.Expression operand, class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ MakeUnary(System::Linq::Expressions::ExpressionType unaryType, System::Linq::Expressions::Expression ^ operand, Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MakeUnary : System.Linq.Expressions.ExpressionType * System.Linq.Expressions.Expression * Type * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.MakeUnary (unaryType, operand, type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unaryType" Type="System.Linq.Expressions.ExpressionType" />
        <Parameter Name="operand" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="unaryType">단항 연산의 형식을 지정하는 <see cref="T:System.Linq.Expressions.ExpressionType" />입니다.</param>
        <param name="operand">피연산자를 나타내는 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="type">변환할 형식을 지정하는 <see cref="T:System.Type" />입니다. 해당 사항이 없는 경우 <see langword="null" />을 전달합니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>지정된 피연산자 및 구현 메서드를 사용하고 적합한 팩터리 메서드를 호출하여 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>적절한 팩터리 메서드를 호출한 결과인 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `unaryType` 매개 변수를 결정 하는 <xref:System.Linq.Expressions.UnaryExpression> 팩터리 메서드를 호출 합니다. 예를 들어 경우 `unaryType` 값과 같음 <xref:System.Linq.Expressions.ExpressionType.Convert>,이 메서드를 호출 <xref:System.Linq.Expressions.Expression.Convert%2A>합니다. 합니다 `type` 고 `method` 이라고 하는 팩터리 메서드에 적용 되지 않은 경우 매개 변수가 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="operand" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="unaryType" />이 단항 식 노드에 해당하지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberBind">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>멤버의 재귀적 멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />입니다.</param>
        <param name="bindings"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.MemberBinding" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />입니다.</param>
        <summary>필드 또는 속성의 재귀적 멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> 및 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` 매개 변수를 필드 또는 속성을 나타내야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 또는 <paramref name="bindings" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />가 필드나 속성을 나타내지 않는 경우  
  
또는 
<paramref name="bindings" />에 있는 요소의 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 <paramref name="member" />가 나타내는 필드 또는 속성의 형식에 속하는 멤버를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MemberInfo member, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MemberInfo member, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (member As MemberInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MemberInfo ^ member, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MemberInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (member, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="member"><see cref="T:System.Reflection.MemberInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />입니다.</param>
        <param name="bindings"><see cref="T:System.Linq.Expressions.MemberBinding" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 개체의 배열입니다.</param>
        <summary>필드 또는 속성의 재귀적 멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> 및 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `member` 매개 변수를 필드 또는 속성을 나타내야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="member" /> 또는 <paramref name="bindings" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="member" />가 필드나 속성을 나타내지 않는 경우  
  
또는 
<paramref name="bindings" />에 있는 요소의 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 <paramref name="member" />가 나타내는 필드 또는 속성의 형식에 속하는 멤버를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, bindings As IEnumerable(Of MemberBinding)) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyAccessor">속성 접근자 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="bindings"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.MemberBinding" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />입니다.</param>
        <summary>속성 접근자 메서드를 사용한 멤버의 재귀적 멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />로 액세스되는 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />로 설정되고 <paramref name="propertyAccessor" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 또는 <paramref name="bindings" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />가 속성 접근자 메서드를 나타내지 않는 경우  
  
또는 
<paramref name="bindings" />에 있는 요소의 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 <paramref name="propertyAccessor" />가 나타내는 메서드로 액세스되는 속성의 형식에 속하는 멤버를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberBind">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberMemberBinding MemberBind (System.Reflection.MethodInfo propertyAccessor, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberMemberBinding MemberBind(class System.Reflection.MethodInfo propertyAccessor, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MemberBind (propertyAccessor As MethodInfo, ParamArray bindings As MemberBinding()) As MemberMemberBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberMemberBinding ^ MemberBind(System::Reflection::MethodInfo ^ propertyAccessor, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberBind : System.Reflection.MethodInfo * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberMemberBinding" Usage="System.Linq.Expressions.Expression.MemberBind (propertyAccessor, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberMemberBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="propertyAccessor">속성 접근자 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <param name="bindings"><see cref="T:System.Linq.Expressions.MemberBinding" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> 개체의 배열입니다.</param>
        <summary>속성 접근자 메서드를 사용한 멤버의 재귀적 멤버 초기화를 나타내는 <see cref="T:System.Linq.Expressions.MemberMemberBinding" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberMemberBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />이고 <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> 속성이 <see cref="P:System.Linq.Expressions.MemberBinding.Member" />로 액세스되는 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />로 설정되고 <paramref name="propertyAccessor" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" /> 또는 <paramref name="bindings" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />가 속성 접근자 메서드를 나타내지 않는 경우  
  
또는 
<paramref name="bindings" />에 있는 요소의 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 <paramref name="propertyAccessor" />가 나타내는 메서드로 액세스되는 속성의 형식에 속하는 멤버를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>새 개체를 만들고 개체의 속성을 초기화하는 식을 나타냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt; bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.MemberBinding&gt; bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * seq&lt;System.Linq.Expressions.MemberBinding&gt; -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.MemberBinding&gt;" />
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />입니다.</param>
        <param name="bindings"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.MemberBinding" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />입니다.</param>
        <summary>새 개체를 만들고 개체의 속성을 초기화하는 식을 나타냅니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> 및 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberInitExpression> 값과 같음 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 의 속성 `newExpression`합니다.  
  
   
  
## Examples  
 다음 예제에서는 새 개체를 만들고 개체의 속성을 초기화 하는 식을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#40)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="bindings" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bindings" />에 있는 요소의 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 <paramref name="newExpression" />.Type이 나타내는 형식의 멤버를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberInitExpression MemberInit (System.Linq.Expressions.NewExpression newExpression, params System.Linq.Expressions.MemberBinding[] bindings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberInitExpression MemberInit(class System.Linq.Expressions.NewExpression newExpression, class System.Linq.Expressions.MemberBinding[] bindings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberInitExpression ^ MemberInit(System::Linq::Expressions::NewExpression ^ newExpression, ... cli::array &lt;System::Linq::Expressions::MemberBinding ^&gt; ^ bindings);" />
      <MemberSignature Language="F#" Value="static member MemberInit : System.Linq.Expressions.NewExpression * System.Linq.Expressions.MemberBinding[] -&gt; System.Linq.Expressions.MemberInitExpression" Usage="System.Linq.Expressions.Expression.MemberInit (newExpression, bindings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberInitExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newExpression" Type="System.Linq.Expressions.NewExpression" />
        <Parameter Name="bindings" Type="System.Linq.Expressions.MemberBinding[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="newExpression"><see cref="T:System.Linq.Expressions.NewExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />입니다.</param>
        <param name="bindings"><see cref="T:System.Linq.Expressions.MemberBinding" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> 개체의 배열입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.MemberInitExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberInitExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> 및 <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberInitExpression> 값과 같음 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 의 속성 `newExpression`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.MemberInit%28System.Linq.Expressions.NewExpression%2CSystem.Linq.Expressions.MemberBinding%5B%5D%29> 메서드를는 <xref:System.Linq.Expressions.MemberInitExpression> 새 개체의 두 가지 멤버의 초기화를 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#9)]
 [!code-vb[System.Linq.Expressions.Expression#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newExpression" /> 또는 <paramref name="bindings" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bindings" />에 있는 요소의 <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> 속성이 <paramref name="newExpression" />.Type이 나타내는 형식의 멤버를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Modulo">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>산술 나머지 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>산술 나머지 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 모듈러스 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 나머지 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 나머지 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 나머지 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Modulo">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Modulo (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Modulo(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Modulo (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Modulo(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Modulo : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Modulo (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>산술 나머지 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 작업에 대 한 구현 메서드는 다음 규칙에 따라 선택 됩니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 모듈러스 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 나머지 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 나머지 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 나머지 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ModuloAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>나머지 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>나머지 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>나머지 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuloAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ModuloAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ModuloAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModuloAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ModuloAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member ModuloAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ModuloAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>나머지 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 산술 곱하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 산술 곱하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 곱하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 두 값을 곱합니다 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#27)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 곱하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Multiply (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Multiply(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Multiply(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Multiply (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 산술 곱하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 곱하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 곱하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하지 않는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member MultiplyAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하는 곱하기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 산술 곱하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하는 산술 곱하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 곱하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 곱하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression MultiplyChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression MultiplyChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MultiplyChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ MultiplyChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member MultiplyChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.MultiplyChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 산술 곱하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 곱하기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 곱하기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 곱하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Negate">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>산술 부정 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <summary>산술 부정 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 이 고, 그렇지 않으면입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `expression`합니다. 형식이 단항 빼기 연산자를 정의 하는 사용자 정의 형식이 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
   
  
## Examples  
 다음 예제에는 산술 부정 연산을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#50)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#50](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type에 단항 빼기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Negate (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Negate(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Negate(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Negate (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</param>
        <summary>산술 부정 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 이 고, 그렇지 않으면입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드 인수 하나를 사용 하는 것이 노드에 대 한 구현 메서드.  
  
-   경우 `expression`합니다. 형식이 단항 빼기 연산자를 정의 하는 사용자 정의 형식이 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니거나, 정확하게 하나의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="expression" />.Type에 단항 빼기 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="expression" />.Type 또는 이 형식이 nullable 값 형식인 경우 nullable이 아닌 해당 형식을 <paramref name="method" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NegateChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 산술 부정 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <summary>오버플로를 검사하는 산술 부정 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 이 고, 그렇지 않으면입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `expression`합니다. 형식이 단항 빼기 연산자를 정의 하는 사용자 정의 형식이 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type에 단항 빼기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NegateChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression NegateChecked (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression NegateChecked(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ NegateChecked(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NegateChecked : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.NegateChecked (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 산술 부정 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 이 고, 그렇지 않으면입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드 인수 하나를 사용 하는 것이 노드에 대 한 구현 메서드.  
  
-   경우 `expression`합니다. 형식이 단항 빼기 연산자를 정의 하는 사용자 정의 형식이 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니거나, 정확하게 하나의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="expression" />.Type에 단항 빼기 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="expression" />.Type 또는 이 형식이 nullable 값 형식인 경우 nullable이 아닌 해당 형식을 <paramref name="method" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="New">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New constructor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />입니다.</param>
        <summary>인수를 받지 않는 지정된 생성자를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.New" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 하 고 <xref:System.Linq.Expressions.NewExpression.Members%2A> 결과 속성 <xref:System.Linq.Expressions.NewExpression> 은 빈 컬렉션입니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성을 나타내는 생성자의 선언 형식과 나타냅니다 `constructor`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="constructor" />가 나타내는 생성자에 매개 변수가 하나 이상 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member New : Type -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">인수를 받지 않는 생성자가 있는 <see cref="T:System.Type" />입니다.</param>
        <summary>지정된 형식의 매개 변수가 없는 생성자를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.New" /> 속성이 지정된 형식에 대한 매개 변수 없이 생성자를 나타내는 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />로 설정된 <see cref="T:System.Reflection.ConstructorInfo" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `type` 매개 변수는 매개 변수가 없는 생성자가 있는 형식을 나타내야 합니다.  
  
 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 하 고 <xref:System.Linq.Expressions.NewExpression.Members%2A> 결과 속성 <xref:System.Linq.Expressions.NewExpression> 은 빈 컬렉션입니다. 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성이 `type`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.New%28System.Type%29> 메서드를를 <xref:System.Linq.Expressions.NewExpression> 매개 변수가 없는 생성자를 호출 하 여 사전 개체의 새 인스턴스를 생성 하는 것이 나타내는입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#10)]
 [!code-vb[System.Linq.Expressions.Expression#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />이 나타내는 형식에 매개 변수가 없는 생성자가 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />입니다.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />입니다.</param>
        <summary>지정된 인수를 사용하여 지정된 생성자를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.New" /> 및 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `arguments` 가 나타내는 생성자의 매개 변수 수가 같은 요소의 개수가 포함 되어야 합니다 `constructor`합니다. 경우 `arguments` 됩니다 `null`, 비어 간주 됩니다 및 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.NewExpression> 빈 컬렉션입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewExpression> 가 나타내는 생성자의 선언 형식을 나타내는 `constructor`합니다. <xref:System.Linq.Expressions.NewExpression.Members%2A> 속성은 빈 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="arguments" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 매개 변수에 들어 있는 요소 수가 <paramref name="constructor" />가 나타내는 생성자의 매개 변수 수와 다른 경우  
  
또는 
<paramref name="arguments" />의 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="constructor" />가 나타내는 생성자의 해당 매개 변수 형식에 적용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, ParamArray arguments As Expression()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />입니다.</param>
        <param name="arguments"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 개체의 배열입니다.</param>
        <summary>지정된 인수를 사용하여 지정된 생성자를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.New" /> 및 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `arguments` 가 나타내는 생성자의 매개 변수 수가 같은 요소의 개수가 포함 되어야 합니다 `constructor`합니다. 경우 `arguments` 됩니다 `null`, 비어 간주 됩니다 및 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.NewExpression> 빈 컬렉션입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewExpression> 가 나타내는 생성자의 선언 형식을 나타내는 `constructor`합니다. <xref:System.Linq.Expressions.NewExpression.Members%2A> 속성은 빈 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="arguments" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" />의 길이가 <paramref name="constructor" />가 나타내는 생성자의 매개 변수 수와 일치하는 경우  
  
또는 
<paramref name="arguments" />의 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="constructor" />가 나타내는 생성자의 해당 매개 변수 형식에 적용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt; members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.MemberInfo&gt; members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), members As IEnumerable(Of MemberInfo)) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, System::Collections::Generic::IEnumerable&lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * seq&lt;System.Reflection.MemberInfo&gt; -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.MemberInfo&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />입니다.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />입니다.</param>
        <param name="members"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Reflection.MemberInfo" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.NewExpression.Members" />입니다.</param>
        <summary>지정된 인수를 사용하여 지정된 생성자를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다. 생성자에서 초기화되는 필드에 액세스하는 멤버가 지정됩니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.New" />, <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 및 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewExpression.Members" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `arguments` 가 나타내는 생성자의 매개 변수 수가 같은 요소의 개수가 포함 되어야 합니다 `constructor`합니다. 경우 `arguments` 됩니다 `null`, 비어 간주 됩니다 및 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.NewExpression> 빈 컬렉션입니다.  
  
 경우 `members` 됩니다 `null`의 <xref:System.Linq.Expressions.NewExpression.Members%2A> 결과의 속성 <xref:System.Linq.Expressions.NewExpression> 빈 컬렉션입니다. 경우 `members` 아닙니다 `null`, 요소 수가 있어야 `arguments` 요소당 아니어야 `null`합니다. 각 요소 `members` 이어야 합니다는 <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> 하거나 <xref:System.Reflection.MethodInfo> 가 나타내는 생성자의 선언 형식에 인스턴스 멤버를 나타내는 `constructor`합니다. 속성이 가져야 속성을 나타내는 경우는 `get` 접근자입니다. 해당 요소 `arguments` 의 각 요소에 대해 `members` 있어야를 <xref:System.Linq.Expressions.Expression.Type%2A> 멤버의 형식에 할당할 수 있는 형식을 나타내는 속성은는 `members` 요소를 나타냅니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewExpression> 생성자 선언 형식을 나타내는 `constructor` 나타냅니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="arguments" />의 요소가 <see langword="null" />입니다.  
  
또는 
<paramref name="members" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 매개 변수에 들어 있는 요소 수가 <paramref name="constructor" />가 나타내는 생성자의 매개 변수 수와 다른 경우  
  
또는 
<paramref name="arguments" />의 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="constructor" />가 나타내는 생성자의 해당 매개 변수 형식에 적용할 수 없는 경우  
  
또는 
<paramref name="members" /> 매개 변수의 요소 수가 <paramref name="arguments" />와 다른 경우  
  
또는 
<paramref name="arguments" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 <paramref name="members" />의 해당 속성이 나타내는 멤버 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="New">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewExpression New (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments, params System.Reflection.MemberInfo[] members);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewExpression New(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments, class System.Reflection.MemberInfo[] members) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function New (constructor As ConstructorInfo, arguments As IEnumerable(Of Expression), ParamArray members As MemberInfo()) As NewExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewExpression ^ New(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments, ... cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ members);" />
      <MemberSignature Language="F#" Value="static member New : System.Reflection.ConstructorInfo * seq&lt;System.Linq.Expressions.Expression&gt; * System.Reflection.MemberInfo[] -&gt; System.Linq.Expressions.NewExpression" Usage="System.Linq.Expressions.Expression.New (constructor, arguments, members)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
        <Parameter Name="members" Type="System.Reflection.MemberInfo[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />입니다.</param>
        <param name="arguments"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />입니다.</param>
        <param name="members"><see cref="T:System.Reflection.MemberInfo" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.NewExpression.Members" /> 개체의 배열입니다.</param>
        <summary>지정된 인수를 사용하여 지정된 생성자를 호출하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewExpression" />을 만듭니다. 생성자에서 초기화되는 필드에 액세스하는 멤버가 배열로 지정됩니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.New" />, <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> 및 <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewExpression.Members" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `arguments` 가 나타내는 생성자의 매개 변수 수가 같은 요소의 개수가 포함 되어야 합니다 `constructor`합니다. 경우 `arguments` 됩니다 `null`, 비어 간주 됩니다 및 <xref:System.Linq.Expressions.NewExpression.Arguments%2A> 결과의 속성 <xref:System.Linq.Expressions.NewExpression> 빈 컬렉션입니다.  
  
 경우 `members` 됩니다 `null`의 <xref:System.Linq.Expressions.NewExpression.Members%2A> 결과의 속성 <xref:System.Linq.Expressions.NewExpression> 빈 컬렉션입니다. 경우 `members` 아닙니다 `null`, 요소 수가 있어야 `arguments` 요소당 아니어야 `null`합니다. 각 요소 `members` 이어야 합니다는 <xref:System.Reflection.PropertyInfo>, <xref:System.Reflection.FieldInfo> 하거나 <xref:System.Reflection.MethodInfo> 가 나타내는 생성자의 선언 형식에 인스턴스 멤버를 나타내는 `constructor`합니다. 속성을 나타내는 경우 속성은 연결 된 필드의 값을 검색할 수 있어야 합니다. 해당 요소 `arguments` 의 각 요소에 대해 `members` 있어야를 <xref:System.Linq.Expressions.Expression.Type%2A> 멤버의 형식에 할당할 수 있는 형식을 나타내는 속성은는 `members` 요소를 나타냅니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewExpression> 생성자 선언 형식을 나타내는 `constructor` 나타냅니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="arguments" />의 요소가 <see langword="null" />입니다.  
  
또는 
<paramref name="members" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="arguments" /> 매개 변수에 들어 있는 요소 수가 <paramref name="constructor" />가 나타내는 생성자의 매개 변수 수와 다른 경우  
  
또는 
<paramref name="arguments" />의 요소에 대한 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성을 <paramref name="constructor" />가 나타내는 생성자의 해당 매개 변수 형식에 적용할 수 없는 경우  
  
또는 
<paramref name="members" /> 매개 변수의 요소 수가 <paramref name="arguments" />와 다른 경우  
  
또는 
<paramref name="arguments" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 <paramref name="members" />의 해당 속성이 나타내는 멤버 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayBounds">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 차수의 배열을 만드는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewArrayExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">배열의 요소 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="bounds"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />입니다.</param>
        <summary>지정된 차수의 배열을 만드는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewArrayExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewArrayExpression> 차수가의 길이 같으면 배열 형식을 나타냅니다 `bounds` 가지 며 요소 형식이 고 `type`입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소 `bounds` 정수 계열 형식을 나타내야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 하는 문자열 배열을 작성을 나타내는 식 트리를 만드는 메서드가 순위가 2입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 또는 <paramref name="bounds" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="bounds" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bounds" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 정수 계열 형식을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayBounds">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayBounds (Type type, params System.Linq.Expressions.Expression[] bounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayBounds(class System.Type type, class System.Linq.Expressions.Expression[] bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayBounds(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ bounds);" />
      <MemberSignature Language="F#" Value="static member NewArrayBounds : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayBounds (type, bounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bounds" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">배열의 요소 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="bounds"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 개체의 배열입니다.</param>
        <summary>지정된 차수의 배열을 만드는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewArrayExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewArrayExpression> 차수가의 길이 같으면 배열 형식을 나타냅니다 `bounds` 가지 며 요소 형식이 고 `type`입니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소 `bounds` 정수 계열 형식을 나타내야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.NewArrayBounds%2A> 하는 문자열 배열을 작성을 나타내는 식 트리를 만드는 메서드가 순위가 2입니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#2)]
 [!code-vb[System.Linq.Expressions.Expression#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 또는 <paramref name="bounds" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="bounds" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bounds" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 정수 계열 형식을 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NewArrayInit">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1차원 배열을 만들고 요소 목록으로 초기화하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewArrayExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="type">배열의 요소 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="initializers"><see cref="T:System.Collections.Generic.IEnumerable`1" /> 컬렉션을 채우는 데 사용할 <see cref="T:System.Linq.Expressions.Expression" /> 개체가 포함된 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />입니다.</param>
        <summary>1차원 배열을 만들고 요소 목록으로 초기화하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewArrayExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소 `initializers` 가 나타내는 형식에 할당할 수 있는 형식을 나타내야 `type`도 되 면 *따옴표 붙은*합니다.  
  
> [!NOTE]
>  경우에 요소 인용 됩니다 `type` 는 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `initializers`합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewArrayExpression> 나타내는 형식의 배열 차수가 1이 고 요소 형식이 `type`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> 메서드는 1 차원 문자열 배열을 작성을 나타내는 식 트리를 만드는 문자열 식의 목록으로 초기화 됩니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="initializers" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 <paramref name="type" />이 나타내는 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NewArrayInit">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.NewArrayExpression NewArrayInit (Type type, params System.Linq.Expressions.Expression[] initializers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.NewArrayExpression NewArrayInit(class System.Type type, class System.Linq.Expressions.Expression[] initializers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::NewArrayExpression ^ NewArrayInit(Type ^ type, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ initializers);" />
      <MemberSignature Language="F#" Value="static member NewArrayInit : Type * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.NewArrayExpression" Usage="System.Linq.Expressions.Expression.NewArrayInit (type, initializers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.NewArrayExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="initializers" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">배열의 요소 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="initializers"><see cref="T:System.Linq.Expressions.Expression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> 개체의 배열입니다.</param>
        <summary>1차원 배열을 만들고 요소 목록으로 초기화하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.NewArrayExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.NewArrayExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 속성의 각 요소 `initializers` 가 나타내는 형식에 할당할 수 있는 형식을 나타내야 `type`도 되 면 *따옴표 붙은*합니다.  
  
> [!NOTE]
>  경우에 요소 인용 됩니다 `type` 는 <xref:System.Linq.Expressions.Expression>합니다. 요소에 래핑됩니다 인용을 <xref:System.Linq.Expressions.ExpressionType.Quote> 노드. 결과 노드를 <xref:System.Linq.Expressions.UnaryExpression> 해당 <xref:System.Linq.Expressions.UnaryExpression.Operand%2A> 속성이 요소의 `initializers`합니다.  
  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.NewArrayExpression> 나타내는 형식의 배열 차수가 1이 고 요소 형식이 `type`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.NewArrayInit%2A> 메서드는 1 차원 문자열 배열을 작성을 나타내는 식 트리를 만드는 문자열 식의 목록으로 초기화 됩니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#1)]
 [!code-vb[System.Linq.Expressions.Expression#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 또는 <paramref name="initializers" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="initializers" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="initializers" />에 있는 요소의 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 나타내는 형식을 <paramref name="type" /> 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.ExpressionType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Linq.Expressions.ExpressionType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NodeType As ExpressionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::ExpressionType NodeType { System::Linq::Expressions::ExpressionType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Linq.Expressions.ExpressionType" Usage="System.Linq.Expressions.Expression.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ExpressionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Linq.Expressions.Expression" />의 노드 형식을 가져옵니다.</summary>
        <value><see cref="T:System.Linq.Expressions.ExpressionType" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.NodeType%2A> 속성의 보다 특수 한 설명이 <xref:System.Linq.Expressions.Expression> 보다 해당 파생된 유형 뿐입니다. 예를 들어, 한 <xref:System.Linq.Expressions.BinaryExpression> 나누기 연산 또는 "보다 큼" 작업을 같은 이진 식의 다양 한 종류를 나타내는 데 사용할 수 있습니다. 합니다 <xref:System.Linq.Expressions.Expression.NodeType%2A> 속성으로 이러한 이진 식 설명 <xref:System.Linq.Expressions.ExpressionType.Divide> 고 <xref:System.Linq.Expressions.ExpressionType.GreaterThan>각각.  
  
 식의 정적 CLR 형식을 하는 <xref:System.Linq.Expressions.Expression> 개체가 표시 됩니다는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Not">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 보수 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <summary>비트 보수 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `expression`합니다. 형식이 단항 not 연산자를 정의 하는 사용자 정의 형식이 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
   
  
## Examples  
 다음 예제에서는 논리를 나타내는 식을 만들려면 작업 하지 않습니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#51)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type에 단항 Not 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Not (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Not(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Not(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Not : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Not (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</param>
        <summary>비트 보수 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다. 구현 메서드를 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드 인수 하나를 사용 하는 것이 노드에 대 한 구현 메서드.  
  
-   경우 `expression`합니다. 형식이 단항 not 연산자를 정의 하는 사용자 정의 형식이 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니거나, 정확하게 하나의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="expression" />.Type에 단항 Not 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="expression" />.Type 또는 이 형식이 nullable 값 형식인 경우 nullable이 아닌 해당 형식을 <paramref name="method" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="NotEqual">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>다름 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>다름 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true`합니다. 그렇지 않으면 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 항상 `false`입니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 같지 않음 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   구현 메서드는이 고, 그렇지 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건을 충족 하는 경우 노드가 리프트 된 및 노드의 유형입니다 <xref:System.Boolean>:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 다름 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression NotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, bool liftToNull, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression NotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, bool liftToNull, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotEqual (left As Expression, right As Expression, liftToNull As Boolean, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ NotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, bool liftToNull, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member NotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * bool * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.NotEqual (left, right, liftToNull, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="liftToNull" Type="System.Boolean" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="liftToNull"><see langword="true" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="true" />이고, <see langword="false" />를 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />로 설정하려면 <see langword="false" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>다름 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 속성은 `true` 하며 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성이 `liftToNull`합니다. 그렇지 않은 경우 둘 다 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 같지 않음 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   구현 메서드는이 고, 그렇지 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된; 또한 노드 형식은 nullable <xref:System.Boolean> 하는 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 <xref:System.Boolean>합니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 형식이 <xref:System.Boolean>합니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 형식이 nullable <xref:System.Boolean> 경우 `liftToNull` 됩니다 `true` 또는 <xref:System.Boolean> 경우 `liftToNull` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 다름 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnesComplement">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1의 보수를 나타내는 식을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>1의 보수를 나타내는 식을 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression OnesComplement (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression OnesComplement(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ OnesComplement(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.OnesComplement (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>1의 보수를 나타내는 식을 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Or">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="OR" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="OR" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `OR` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 정수 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은의 결과 형식은 미리 정의 된 비트 `OR` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드 형식은의 결과 형식은 미리 정의 된 비트에 해당 하는 nullable 형식을 `OR` 연산자입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 논리적 OR 연산을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#28)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 비트 <see langword="OR" /> 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Or (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Or(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Or (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Or(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Or : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Or (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 <see cref="T:System.Linq.Expressions.BinaryExpression" /> 연산을 나타내는 <see langword="OR" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Or" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `OR` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 정수 또는 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은의 결과 형식은 미리 정의 된 비트 `OR` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드 형식은의 결과 형식은 미리 정의 된 비트에 해당 하는 nullable 형식을 `OR` 연산자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 비트 <see langword="OR" /> 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 OR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 OR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 OR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member OrAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>비트 OR 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrElse">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>첫 번째 연산자가 <see cref="T:System.Linq.Expressions.BinaryExpression" />로 계산되는 경우에만 두 번째 피연산자를 계산하는 조건부 <see langword="OR" /> 연산을 나타내는 <see langword="false" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>첫 번째 피연산자가 <see cref="T:System.Linq.Expressions.BinaryExpression" />로 계산되는 경우에만 두 번째 피연산자를 계산하는 조건부 <see langword="OR" /> 연산을 나타내는 <see langword="false" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `OR` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
    > [!NOTE]
    >  조건부 `OR` C# 또는 Visual Basic의 연산자를 오버 로드할 수 없습니다. 그러나 조건부 `OR` 연산자는 비트를 사용 하 여 계산 됩니다 `OR` 연산자입니다. 따라서 사용자 정의의 오버 로드를 비트 `OR` 연산자에는이 노드 유형에 대 한 구현 메서드 일 수 있습니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식을 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상의 값이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   `left`. 형식 및 `right`합니다. 형식이 동일한 부울 형식이는 있습니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은 미리 정의 된 조건부의 결과 형식은 `OR` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable, 노드가 리프트 된입니다. 노드 형식은 미리 정의 된 조건부의 결과 형식에 해당 하는 nullable 형식을 `OR` 연산자입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 논리를 나타내는 식을 만드는 방법을 보여 줍니다 `OR` 첫 번째 피연산자가 하는 경우에 두 번째 피연산자를 계산 하는 작업 `false`합니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#29)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 비트 <see langword="OR" /> 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="left" />.Type과 <paramref name="right" />.Type이 동일한 부울 형식이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="OrElse">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression OrElse (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression OrElse(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrElse (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ OrElse(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member OrElse : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.OrElse (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>첫 번째 피연산자가 <see cref="T:System.Linq.Expressions.BinaryExpression" />로 계산되는 경우에만 두 번째 피연산자를 계산하는 조건부 <see langword="OR" /> 연산을 나타내는 <see langword="false" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 비트 오버 로드 하는 사용자 정의 유형을 나타냅니다 `OR` 연산자는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
    > [!NOTE]
    >  조건부 `OR` C# 또는 Visual Basic의 연산자를 오버 로드할 수 없습니다. 그러나 조건부 `OR` 연산자는 비트를 사용 하 여 계산 됩니다 `OR` 연산자입니다. 따라서 사용자 정의의 오버 로드를 비트 `OR` 연산자에는이 노드 유형에 대 한 구현 메서드 일 수 있습니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식을 부울 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상의 값이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   `left`. 형식 및 `right`합니다. 형식이 동일한 부울 형식이는 있습니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 노드 형식은 미리 정의 된 조건부의 결과 형식은 `OR` 연산자입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식이 nullable, 노드가 리프트 된입니다. 노드 형식은 미리 정의 된 조건부의 결과 형식에 해당 하는 nullable 형식을 `OR` 연산자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 비트 <see langword="OR" /> 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type과 <paramref name="right" />.Type이 동일한 부울 형식이 아닌 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parameter">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식 트리에서 매개 변수나 변수를 식별하는 데 사용할 수 있는 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">매개 변수 또는 변수의 형식입니다.</param>
        <summary>식 트리에서 매개 변수나 변수를 식별하는 데 사용할 수 있는 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드를 만듭니다.</summary>
        <returns>지정된 이름과 형식의 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다.는 <xref:System.Linq.Expressions.MethodCallExpression> 값을 인쇄 하는 개체를 <xref:System.Linq.Expressions.ParameterExpression> 개체입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#49)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#49](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameter">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Parameter (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Parameter(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Parameter(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Parameter : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Parameter (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">매개 변수 또는 변수의 형식입니다.</param>
        <param name="name">디버깅 또는 인쇄용으로만 사용되는 매개 변수 또는 변수의 이름입니다.</param>
        <summary>식 트리에서 매개 변수나 변수를 식별하는 데 사용할 수 있는 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.ParameterExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> 및 <see cref="P:System.Linq.Expressions.Expression.Type" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.ParameterExpression.Name" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>원래 식에서 뒤이어 1씩 감소하는 식의 할당을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>원래 식에서 뒤이어 1씩 감소하는 식의 할당을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>원래 식에서 뒤이어 1씩 감소하는 식의 할당을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>원래 식에서 뒤이어 1씩 증가하는 식의 할당을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>원래 식에서 뒤이어 1씩 증가하는 식의 할당을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PostIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PostIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PostIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PostIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PostIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>원래 식에서 뒤이어 1씩 증가하는 식의 할당을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Power">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 제곱을 구하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>숫자의 제곱을 구하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 지 수 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 둘 다 <xref:System.Double>의 메서드 구현은 <xref:System.Math.Pow%2A>합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 지수 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="left" />.Type 및/또는 <paramref name="right" />.Type이 <see cref="T:System.Double" />이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Power">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Power (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Power(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Power (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Power(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Power : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Power (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>숫자의 제곱을 구하는 동작을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Power" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 지 수 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 형식 둘 다 <xref:System.Double>의 메서드 구현은 <xref:System.Math.Pow%2A>합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 지수 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우  
  
또는 
 <paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및/또는 <paramref name="right" />.Type이 <see cref="T:System.Double" />이 아닌 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PowerAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식을 거듭제곱하고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>식을 거듭제곱하고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>식을 거듭제곱하고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowerAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression PowerAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression PowerAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowerAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ PowerAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member PowerAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.PowerAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>식을 거듭제곱하고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreDecrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식을 1씩 감소시키고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>식을 1씩 감소시키고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreDecrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreDecrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreDecrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreDecrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreDecrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreDecrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>식을 1씩 감소시키고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PreIncrementAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식을 1씩 증가시키고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>식을 1씩 증가시키고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreIncrementAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression PreIncrementAssign (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression PreIncrementAssign(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ PreIncrementAssign(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member PreIncrementAssign : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.PreIncrementAssign (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression">작업을 적용할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="method">구현 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>식을 1씩 증가시키고 결과를 다시 식에 할당하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>결과 식을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Property">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>속성에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo propertyAccessor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo propertyAccessor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ propertyAccessor);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyAccessor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyAccessor" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />입니다. 이 값은 정적 속성의 경우 null일 수 있습니다.</param>
        <param name="propertyAccessor">속성 접근자 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</param>
        <summary>속성 접근자 메서드를 통한 속성 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />으로 설정되고 <paramref name="expression" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />로 액세스되는 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />로 설정된 <paramref name="propertyAccessor" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberExpression> 값과 같음 합니다 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 의 속성 <xref:System.Linq.Expressions.MemberExpression.Member%2A>합니다.  
  
 표시 되는 메서드 `propertyAccessor` 는 `static` (`Shared` Visual basic에서), `expression` 수 `null`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="propertyAccessor" />가 나타내는 메서드가 <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니고 <paramref name="expression" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type을 <paramref name="propertyAccessor" />로 나타내는 메서드의 선언 형식에 할당할 수 없는 경우  
  
또는 
<paramref name="propertyAccessor" />가 나타내는 메서드가 속성 접근자 메서드가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, System.Reflection.PropertyInfo property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Reflection.PropertyInfo property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::Reflection::PropertyInfo ^ property);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />입니다. 이 값은 정적 속성의 경우 null일 수 있습니다.</param>
        <param name="property"><see cref="T:System.Reflection.PropertyInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />입니다.</param>
        <summary>속성에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> 및 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberExpression> 값과 같음 합니다 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 의 속성 <xref:System.Linq.Expressions.MemberExpression.Member%2A>합니다.  
  
 표시 되는 속성 `property` 은 `static` (`Shared` Visual basic에서), `expression` 수 `null`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="property" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="property" />가 나타내는 속성이 <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니고 <paramref name="expression" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expression" />.Type을 <paramref name="property" />가 나타내는 속성의 선언 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />에 이름이 <see cref="P:System.Linq.Expressions.Expression.Type" />인 속성이 포함된 <paramref name="propertyName" />입니다. 정적 속성의 경우 이 값은 <see langword="null" />일 수 있습니다.</param>
        <param name="propertyName">액세스할 속성의 이름입니다.</param>
        <summary>속성에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />으로 설정되고 <paramref name="expression" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />이 가리키는 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />로 설정된 <paramref name="propertyName" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과의 속성 <xref:System.Linq.Expressions.MemberExpression> 값과 같음는 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 의 속성을 <xref:System.Reflection.PropertyInfo> 가리키는 속성을 나타내는 `propertyName`.  
  
 이 메서드는 검색 `expression`합니다. 형식 및 이름을 가진 속성에 대 한 기본 형식 `propertyName`합니다. 공용 속성에는 public이 아닌 속성 보다 우선을 적용 됩니다. 이 메서드를 전달 하는 일치 하는 속성이 없으면 `expression` 하며 <xref:System.Reflection.PropertyInfo> 해당 속성을 나타내는 <xref:System.Linq.Expressions.Expression.Property%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성에 액세스 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#38)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="propertyName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyName" />.Type 또는 해당 기본 형식에 이름이 <paramref name="expression" />인 속성이 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, arguments As IEnumerable(Of Expression)) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="instance">속성이 속해 있는 개체입니다. 이 속성이 정적/공유 속성이면 null이어야 합니다.</param>
        <param name="indexer">인덱싱할 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />입니다.</param>
        <param name="arguments">속성을 인덱싱하는 데 사용되는 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 개체의 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>인덱싱된 속성에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.IndexExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, System.Reflection.PropertyInfo indexer, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, class System.Reflection.PropertyInfo indexer, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, indexer As PropertyInfo, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::Reflection::PropertyInfo ^ indexer, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * System.Reflection.PropertyInfo * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, indexer, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="indexer" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">속성이 속해 있는 개체입니다. 이 속성이 정적/공유 속성이면 null이어야 합니다.</param>
        <param name="indexer">인덱싱할 속성을 나타내는 <see cref="T:System.Reflection.PropertyInfo" />입니다.</param>
        <param name="arguments">속성을 인덱싱하는 데 사용되는 <see cref="T:System.Linq.Expressions.Expression" /> 개체의 배열입니다.</param>
        <summary>인덱싱된 속성에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.IndexExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.IndexExpression Property (System.Linq.Expressions.Expression instance, string propertyName, params System.Linq.Expressions.Expression[] arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.IndexExpression Property(class System.Linq.Expressions.Expression instance, string propertyName, class System.Linq.Expressions.Expression[] arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Property (instance As Expression, propertyName As String, ParamArray arguments As Expression()) As IndexExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::IndexExpression ^ Property(System::Linq::Expressions::Expression ^ instance, System::String ^ propertyName, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * string * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.IndexExpression" Usage="System.Linq.Expressions.Expression.Property (instance, propertyName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.IndexExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="arguments" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">속성이 속해 있는 개체입니다. 이 속성이 정적/공유 속성이면 null이어야 합니다.</param>
        <param name="propertyName">인덱서의 이름입니다.</param>
        <param name="arguments">속성을 인덱싱하는 데 사용되는 <see cref="T:System.Linq.Expressions.Expression" /> 개체의 배열입니다.</param>
        <summary>인덱싱된 속성에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.IndexExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.IndexExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression Property (System.Linq.Expressions.Expression expression, Type type, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression Property(class System.Linq.Expressions.Expression expression, class System.Type type, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ Property(System::Linq::Expressions::Expression ^ expression, Type ^ type, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="static member Property : System.Linq.Expressions.Expression * Type * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.Property (expression, type, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">속성의 포함 개체입니다. 이 값은 정적 속성의 경우 null일 수 있습니다.</param>
        <param name="type">속성이 포함된 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <param name="propertyName">액세스할 속성입니다.</param>
        <summary>속성에 액세스하는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.MemberExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyOrField">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.MemberExpression PropertyOrField (System.Linq.Expressions.Expression expression, string propertyOrFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.MemberExpression PropertyOrField(class System.Linq.Expressions.Expression expression, string propertyOrFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::MemberExpression ^ PropertyOrField(System::Linq::Expressions::Expression ^ expression, System::String ^ propertyOrFieldName);" />
      <MemberSignature Language="F#" Value="static member PropertyOrField : System.Linq.Expressions.Expression * string -&gt; System.Linq.Expressions.MemberExpression" Usage="System.Linq.Expressions.Expression.PropertyOrField (expression, propertyOrFieldName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.MemberExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="propertyOrFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" />에 이름이 <see cref="P:System.Linq.Expressions.Expression.Type" />인 속성 또는 필드가 포함된 <paramref name="propertyOrFieldName" />입니다. 이 값은 정적 멤버의 경우 null일 수 있습니다.</param>
        <param name="propertyOrFieldName">액세스할 속성 또는 필드의 이름입니다.</param>
        <summary>속성 또는 필드에 대한 액세스를 나타내는 <see cref="T:System.Linq.Expressions.MemberExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.MemberExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />으로 설정되고 <paramref name="expression" /> 속성이 <see cref="P:System.Linq.Expressions.MemberExpression.Member" />이 가리키는 속성 또는 필드를 나타내는 <see cref="T:System.Reflection.PropertyInfo" /> 또는 <see cref="T:System.Reflection.FieldInfo" />로 설정된 <paramref name="propertyOrFieldName" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.MemberExpression> 값과 같음를 <xref:System.Reflection.PropertyInfo.PropertyType%2A> 또는 <xref:System.Reflection.FieldInfo.FieldType%2A> 의 속성을 <xref:System.Reflection.PropertyInfo> 또는 <xref:System.Reflection.FieldInfo>각각 가리키는 필드나 속성을 나타내는 `propertyOrFieldName`.  
  
 이 메서드는 검색 `expression`합니다. 형식 및 해당 기본 형식 속성 또는 필드 이름을 가진 `propertyOrFieldName`합니다. Public 속성 및 필드는 public이 아닌 속성 및 필드 보다 우선을 적용 됩니다. 또한 속성 필드를 통해 우선을 적용 됩니다. 이 메서드를 전달 하는 일치 하는 속성 또는 필드가 없으면 `expression` 하며 <xref:System.Reflection.PropertyInfo> 또는 <xref:System.Reflection.FieldInfo> 해당 속성이 나 필드를 나타내는 <xref:System.Linq.Expressions.Expression.Property%2A> 또는 <xref:System.Linq.Expressions.Expression.Field%2A>각각.  
  
   
  
## Examples  
 다음 예제에서는 속성 또는 필드에 액세스 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#39)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="propertyOrFieldName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyOrFieldName" />.Type 또는 해당 기본 형식에 이름이 <paramref name="expression" />인 속성 또는 필드가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Quote (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Quote(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Quote(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member Quote : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Quote expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.UnaryExpression" /> 형식의 상수 값이 있는 식을 나타내는 <see cref="T:System.Linq.Expressions.Expression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 생성 된 형식을 나타내는 <xref:System.Linq.Expressions.Expression%601>형식 인수가 나타내는 형식, `expression`합니다. 형식입니다. <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 속성은 `null`입니다. 둘 다 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce">
      <MemberSignature Language="C#" Value="public virtual System.Linq.Expressions.Expression Reduce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression Reduce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Reduce" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Reduce () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Linq::Expressions::Expression ^ Reduce();" />
      <MemberSignature Language="F#" Value="abstract member Reduce : unit -&gt; System.Linq.Expressions.Expression&#xA;override this.Reduce : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.Reduce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 노드를 더 단순한 식으로 줄입니다. CanReduce가 true를 반환하면 유효한 식을 반환합니다. 이 메서드는 자체를 줄여야 하는 다른 노드를 반환할 수 있습니다.</summary>
        <returns>축소된 식입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceAndCheck">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceAndCheck ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceAndCheck() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceAndCheck" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceAndCheck () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceAndCheck();" />
      <MemberSignature Language="F#" Value="member this.ReduceAndCheck : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceAndCheck " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 노드를 더 단순한 식으로 줄입니다. CanReduce가 true를 반환하면 유효한 식을 반환합니다. 이 메서드는 자체를 줄여야 하는 다른 노드를 반환할 수 있습니다.</summary>
        <returns>축소된 식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reduce 달리이 메서드는 축소 된 노드는 특정 고정 충족 함을 확인 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceExtensions">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression ReduceExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression ReduceExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReduceExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function ReduceExtensions () As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ ReduceExtensions();" />
      <MemberSignature Language="F#" Value="member this.ReduceExtensions : unit -&gt; System.Linq.Expressions.Expression" Usage="expression.ReduceExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>알려진 노드 형식(확장명 노드가 아님)으로 식을 줄이거나 이미 알려진 형식인 경우 식을 반환합니다.</summary>
        <returns>축소된 식입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>참조 같음 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceNotEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression ReferenceNotEqual (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression ReferenceNotEqual(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceNotEqual (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ ReferenceNotEqual(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member ReferenceNotEqual : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.ReferenceNotEqual (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>참조 다름 비교를 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Rethrow">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>예외를 다시 throw하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow () As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow();" />
      <MemberSignature Language="F#" Value="static member Rethrow : unit -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>예외를 다시 throw하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>예외를 다시 throw하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Rethrow (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Rethrow(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Rethrow(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Rethrow(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Rethrow : Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Rethrow type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">식의 새 <see cref="T:System.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 예외를 다시 throw하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>예외를 다시 throw하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Return">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>return 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <summary>return 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Return이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, 이동 시 대상 레이블에 null 값이 전달되는 <paramref name="target" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Return (target As LabelTarget, value As Expression) As GotoExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <summary>return 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다. 이동 시 레이블에 전달되는 값을 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Continue이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, 이동 시 대상 레이블에 <paramref name="target" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 포함 하는 식을 생성 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.Return%2A> 메서드.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#43)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#43)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 return 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Return이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 null 값이 전달되는 <paramref name="type" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.GotoExpression Return (System.Linq.Expressions.LabelTarget target, System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.GotoExpression Return(class System.Linq.Expressions.LabelTarget target, class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::GotoExpression ^ Return(System::Linq::Expressions::LabelTarget ^ target, System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Return : System.Linq.Expressions.LabelTarget * System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.GotoExpression" Usage="System.Linq.Expressions.Expression.Return (target, value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.GotoExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Linq.Expressions.LabelTarget" />
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Linq.Expressions.LabelTarget" />이 이동할 <see cref="T:System.Linq.Expressions.GotoExpression" />입니다.</param>
        <param name="value">이동 시 연결된 레이블에 전달될 값입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 return 문을 나타내는 <see cref="T:System.Linq.Expressions.GotoExpression" />을 만듭니다. 이동 시 레이블에 전달되는 값을 지정할 수 있습니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.GotoExpression" />가 Continue이고, <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> 속성이 <see cref="P:System.Linq.Expressions.GotoExpression.Target" />으로 설정되며, <paramref name="target" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.Type" />으로 설정되고, 이동 시 대상 레이블에 <paramref name="type" />가 전달되는 <paramref name="value" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShift">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 오른쪽 시프트 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 오른쪽 시프트 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 오른쪽 시프트 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식은 정수 계열 형식 (중 하나 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>를 <xref:System.UInt32>, <xref:System.Int64>를 <xref:System.UInt64>, 또는 해당 nullable 형식) 및 `right`합니다. 형식은 <xref:System.Int32>의 메서드 구현은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 오른쪽 시프트 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 오른쪽 시프트 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 오른쪽 시프트 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RightShift">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShift (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShift(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShift (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShift(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShift : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShift (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 오른쪽 시프트 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 오른쪽 시프트 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식은 정수 계열 형식 (중 하나 <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>를 <xref:System.UInt32>, <xref:System.Int64>를 <xref:System.UInt64>, 또는 해당 nullable 형식) 및 `right`합니다. 형식은 <xref:System.Int32>의 메서드 구현은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 오른쪽 시프트 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 오른쪽 시프트 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 오른쪽 시프트 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RightShiftAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비트 오른쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>비트 오른쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>비트 오른쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightShiftAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression RightShiftAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression RightShiftAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RightShiftAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ RightShiftAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member RightShiftAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.RightShiftAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>비트 오른쪽 시프트 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RuntimeVariables">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />의 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (variables As IEnumerable(Of ParameterExpression)) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="variables"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 개체의 컬렉션입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />의 인스턴스를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RuntimeVariables">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables (params System.Linq.Expressions.ParameterExpression[] variables);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.RuntimeVariablesExpression RuntimeVariables(class System.Linq.Expressions.ParameterExpression[] variables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RuntimeVariables (ParamArray variables As ParameterExpression()) As RuntimeVariablesExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::RuntimeVariablesExpression ^ RuntimeVariables(... cli::array &lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ variables);" />
      <MemberSignature Language="F#" Value="static member RuntimeVariables : System.Linq.Expressions.ParameterExpression[] -&gt; System.Linq.Expressions.RuntimeVariablesExpression" Usage="System.Linq.Expressions.Expression.RuntimeVariables variables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.RuntimeVariablesExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variables" Type="System.Linq.Expressions.ParameterExpression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="variables"><see cref="T:System.Linq.Expressions.ParameterExpression" /> 컬렉션을 채우는 데 사용할 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> 개체의 배열입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />의 인스턴스를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 산술 빼기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 산술 빼기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 빼기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 첫 번째 인수에서 인수를 빼는 하는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#30)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 빼기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression Subtract (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression Subtract(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ Subtract(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.Subtract (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 산술 빼기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 빼기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 빼기 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssign">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하지 않는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하지 않는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하지 않는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssign">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssign (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssign(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssign (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssign(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssign : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssign (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하지 않는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractAssignChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractAssignChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractAssignChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method, System.Linq.Expressions.LambdaExpression conversion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractAssignChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method, class System.Linq.Expressions.LambdaExpression conversion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractAssignChecked (left As Expression, right As Expression, method As MethodInfo, conversion As LambdaExpression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractAssignChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method, System::Linq::Expressions::LambdaExpression ^ conversion);" />
      <MemberSignature Language="F#" Value="static member SubtractAssignChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.LambdaExpression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractAssignChecked (left, right, method, conversion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="conversion" Type="System.Linq.Expressions.LambdaExpression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <param name="conversion"><see cref="T:System.Linq.Expressions.LambdaExpression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</param>
        <summary>오버플로를 검사하는 빼기 할당 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SubtractChecked">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>오버플로를 검사하는 산술 빼기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <summary>오버플로를 검사하는 산술 빼기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙은 선택한 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우는 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 빼기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="left" />.Type 및 <paramref name="right" />.Type에 빼기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SubtractChecked">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.BinaryExpression SubtractChecked (System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.BinaryExpression SubtractChecked(class System.Linq.Expressions.Expression left, class System.Linq.Expressions.Expression right, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractChecked (left As Expression, right As Expression, method As MethodInfo) As BinaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::BinaryExpression ^ SubtractChecked(System::Linq::Expressions::Expression ^ left, System::Linq::Expressions::Expression ^ right, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member SubtractChecked : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.BinaryExpression" Usage="System.Linq.Expressions.Expression.SubtractChecked (left, right, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.BinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="right" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />입니다.</param>
        <param name="right"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</param>
        <summary>오버플로를 검사하는 산술 빼기 연산을 나타내는 <see cref="T:System.Linq.Expressions.BinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.BinaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> 및 <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 <xref:System.Linq.Expressions.BinaryExpression> 에 <xref:System.Linq.Expressions.BinaryExpression.Method%2A> 속성이 구현 메서드를 설정 합니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 그렇지 않으면 `false`합니다. <xref:System.Linq.Expressions.BinaryExpression.Conversion%2A> 속성은 `null`입니다.  
  
 다음 정보를 구현 하는 메서드를 노드 형식에 설명 및 노드 리프트 여부.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드는 두 개의 인수를 노드에 대 한 구현 메서드를 것입니다.  
  
-   그렇지 않은 경우, 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 속성에 대 `left` 또는 `right` 빼기 연산자를 오버 로드 하는 사용자 정의 유형을 나타냅니다는 <xref:System.Reflection.MethodInfo> 메서드는 구현 하는 것이 나타내는입니다.  
  
-   그렇지 않은 경우, `left`합니다. 형식 및 `right`합니다. 유형은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 구현 메서드의 해당 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `left`. 형식 및 `right`합니다. 형식이 값 형식 중 하나 이상이 null을 허용 하 고 해당 nullable이 아닌 형식과 구현 메서드의 해당 인수 유형이 같은지 집니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`:  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 null이 아닌, 노드가 리프트 하지 않습니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식이입니다.  
  
-   경우 `left`합니다. 형식 및 `right`합니다. 형식 둘 다 노드가 리프트 된 null 허용 합니다. 노드의 유형 미리 정의 된 빼기 연산자의 결과 형식에 해당 하는 nullable 형식이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="left" /> 또는 <paramref name="right" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 <see langword="Shared" />)이 아니거나, 정확히 두 개의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 빼기 연산자가 <paramref name="left" />.Type 및 <paramref name="right" />.Type에 대해 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Switch">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">각 사례에 대해 테스트할 값입니다.</param>
        <param name="cases">이 switch 식의 사례 집합입니다.</param>
        <summary>기본 사례가 없는 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Linq.Expressions.SwitchCase> 개체를 <xref:System.Linq.Expressions.SwitchExpression> 경우가 아니면 개체에는 동일한 형식에 있어야 합니다 <xref:System.Linq.Expressions.SwitchExpression> 형식이 `void`합니다.  
  
 각 <xref:System.Linq.Expressions.SwitchCase> 개체에는 암시적 `break` 문을 암시적 이동 금지 한 case 레이블 간 임을 의미 합니다.  
  
 경우 `switchValue` 일치 하지 않습니다의 경우 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 사례가 없는 스위치 문을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#34)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">각 사례에 대해 테스트할 값입니다.</param>
        <param name="defaultBody"><paramref name="switchValue" />로 일치하는 사례가 없는 경우 switch의 결과입니다.</param>
        <param name="cases">이 switch 식의 사례 집합입니다.</param>
        <summary>기본 사례가 있는 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Linq.Expressions.SwitchCase> 개체를 <xref:System.Linq.Expressions.SwitchExpression> 경우가 아니면 개체에는 동일한 형식에 있어야 합니다 <xref:System.Linq.Expressions.SwitchExpression> 형식이 `void`합니다.  
  
 각 <xref:System.Linq.Expressions.SwitchCase> 개체에는 암시적 `break` 문을 암시적 이동 금지 한 case 레이블 간 임을 의미 합니다.  
  
 하는 경우 `switchValue` 사례를 나타내는 기본 대/소문자와 일치 하지 않습니다 `defaultBody` 실행 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 사례에는 스위치 문을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, cases As IEnumerable(Of SwitchCase)) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="switchValue">각 사례에 대해 테스트할 값입니다.</param>
        <param name="defaultBody"><paramref name="switchValue" />로 일치하는 사례가 없는 경우 switch의 결과입니다.</param>
        <param name="comparison">사용할 같음 비교 메서드입니다.</param>
        <param name="cases">이 switch 식의 사례 집합입니다.</param>
        <summary>기본 사례가 있는 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Switch (switchValue As Expression, defaultBody As Expression, comparison As MethodInfo, ParamArray cases As SwitchCase()) As SwitchExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="switchValue">각 사례에 대해 테스트할 값입니다.</param>
        <param name="defaultBody"><paramref name="switchValue" />로 일치하는 사례가 없는 경우 switch의 결과입니다.</param>
        <param name="comparison">사용할 같음 비교 메서드입니다.</param>
        <param name="cases">이 switch 식의 사례 집합입니다.</param>
        <summary>기본 사례가 있는 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt; cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.SwitchCase&gt; cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * seq&lt;System.Linq.Expressions.SwitchCase&gt; -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.SwitchCase&gt;" />
      </Parameters>
      <Docs>
        <param name="type">switch의 결과 형식입니다.</param>
        <param name="switchValue">각 사례에 대해 테스트할 값입니다.</param>
        <param name="defaultBody"><paramref name="switchValue" />로 일치하는 사례가 없는 경우 switch의 결과입니다.</param>
        <param name="comparison">사용할 같음 비교 메서드입니다.</param>
        <param name="cases">이 switch 식의 사례 집합입니다.</param>
        <summary>기본 사례가 있는 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchExpression Switch (Type type, System.Linq.Expressions.Expression switchValue, System.Linq.Expressions.Expression defaultBody, System.Reflection.MethodInfo comparison, params System.Linq.Expressions.SwitchCase[] cases);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchExpression Switch(class System.Type type, class System.Linq.Expressions.Expression switchValue, class System.Linq.Expressions.Expression defaultBody, class System.Reflection.MethodInfo comparison, class System.Linq.Expressions.SwitchCase[] cases) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchExpression ^ Switch(Type ^ type, System::Linq::Expressions::Expression ^ switchValue, System::Linq::Expressions::Expression ^ defaultBody, System::Reflection::MethodInfo ^ comparison, ... cli::array &lt;System::Linq::Expressions::SwitchCase ^&gt; ^ cases);" />
      <MemberSignature Language="F#" Value="static member Switch : Type * System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Reflection.MethodInfo * System.Linq.Expressions.SwitchCase[] -&gt; System.Linq.Expressions.SwitchExpression" Usage="System.Linq.Expressions.Expression.Switch (type, switchValue, defaultBody, comparison, cases)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="switchValue" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="defaultBody" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="comparison" Type="System.Reflection.MethodInfo" />
        <Parameter Name="cases" Type="System.Linq.Expressions.SwitchCase[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">switch의 결과 형식입니다.</param>
        <param name="switchValue">각 사례에 대해 테스트할 값입니다.</param>
        <param name="defaultBody"><paramref name="switchValue" />로 일치하는 사례가 없는 경우 switch의 결과입니다.</param>
        <param name="comparison">사용할 같음 비교 메서드입니다.</param>
        <param name="cases">이 switch 식의 사례 집합입니다.</param>
        <summary>기본 사례가 있는 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 문을 나타내는 <see langword="switch" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SwitchCase">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.SwitchCase" /> 개체에 사용할 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 개체를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt; testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.Expression&gt; testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, testValues As IEnumerable(Of Expression)) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.Expression&gt; -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.Expression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">case의 본문입니다.</param>
        <param name="testValues">case의 테스트 값입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.SwitchCase" /> 개체에 사용할 <see cref="T:System.Linq.Expressions.SwitchExpression" /> 개체를 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchCase" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Linq.Expressions.SwitchCase> 개체를 <xref:System.Linq.Expressions.SwitchExpression> 경우가 아니면 개체에는 동일한 형식에 있어야 합니다 <xref:System.Linq.Expressions.SwitchExpression> 형식이 `void`합니다.  
  
 각 <xref:System.Linq.Expressions.SwitchCase> 개체에는 암시적 `break` 문을 암시적 이동 금지 한 case 레이블 간 임을 의미 합니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 사례에는 스위치 문을 나타내는 식을 만드는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#35)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchCase">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SwitchCase SwitchCase (System.Linq.Expressions.Expression body, params System.Linq.Expressions.Expression[] testValues);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SwitchCase SwitchCase(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression[] testValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchCase (body As Expression, ParamArray testValues As Expression()) As SwitchCase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SwitchCase ^ SwitchCase(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::Expression ^&gt; ^ testValues);" />
      <MemberSignature Language="F#" Value="static member SwitchCase : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression[] -&gt; System.Linq.Expressions.SwitchCase" Usage="System.Linq.Expressions.Expression.SwitchCase (body, testValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SwitchCase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="testValues" Type="System.Linq.Expressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">case의 본문입니다.</param>
        <param name="testValues">case의 테스트 값입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.SwitchCase" />에 사용할 <see cref="T:System.Linq.Expressions.SwitchExpression" />를 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.SwitchCase" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SymbolDocument">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />의 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />의 인스턴스를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />입니다.</param>
        <param name="language"><see cref="T:System.Guid" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />의 인스턴스를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> 및 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />입니다.</param>
        <param name="language"><see cref="T:System.Guid" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />입니다.</param>
        <param name="languageVendor"><see cref="T:System.Guid" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />의 인스턴스를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> 및 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymbolDocument">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.SymbolDocumentInfo SymbolDocument (string fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.SymbolDocumentInfo SymbolDocument(string fileName, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SymbolDocument (fileName As String, language As Guid, languageVendor As Guid, documentType As Guid) As SymbolDocumentInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::SymbolDocumentInfo ^ SymbolDocument(System::String ^ fileName, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="static member SymbolDocument : string * Guid * Guid * Guid -&gt; System.Linq.Expressions.SymbolDocumentInfo" Usage="System.Linq.Expressions.Expression.SymbolDocument (fileName, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.SymbolDocumentInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />입니다.</param>
        <param name="language"><see cref="T:System.Guid" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />입니다.</param>
        <param name="languageVendor"><see cref="T:System.Guid" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />입니다.</param>
        <param name="documentType"><see cref="T:System.Guid" />에 설정할 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />의 인스턴스를 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> 및 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Throw">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>예외의 throw를 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Throw (value As Expression) As UnaryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <summary>예외의 throw를 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>예외를 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다.는 <xref:System.Linq.Expressions.TryExpression> 사용 하는 개체는 <xref:System.Linq.Expressions.Expression.Throw%2A> 메서드.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Throw (System.Linq.Expressions.Expression value, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Throw(class System.Linq.Expressions.Expression value, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Throw(System::Linq::Expressions::Expression ^ value, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Throw : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Throw (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="type">식의 새 <see cref="T:System.Type" />입니다.</param>
        <summary>지정된 형식을 사용하여 예외를 throw하는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns>예외를 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Linq.Expressions.Expression" />의 텍스트 표현을 반환합니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.Expression" />의 텍스트 표현입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatch">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatch (System.Linq.Expressions.Expression body, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatch(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatch (body As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatch(System::Linq::Expressions::Expression ^ body, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatch : System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatch (body, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">try 블록의 본문입니다.</param>
        <param name="handlers">try 블록과 연결되는 catch 문을 나타내는 <see cref="T:System.Linq.Expressions.CatchBlock" /> 식을 0개 이상 포함하는 배열입니다.</param>
        <summary>원하는 수의 catch 문을 사용하고 fault 또는 finally 블록은 사용하지 않고 try 블록을 나타내는 <see cref="T:System.Linq.Expressions.TryExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.TryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.Linq.Expressions.TryExpression> catch 문이 포함 된 개체입니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#47)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#47)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCatchFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryCatchFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally, params System.Linq.Expressions.CatchBlock[] handlers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryCatchFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally, class System.Linq.Expressions.CatchBlock[] handlers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCatchFinally (body As Expression, finally As Expression, ParamArray handlers As CatchBlock()) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryCatchFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally, ... cli::array &lt;System::Linq::Expressions::CatchBlock ^&gt; ^ handlers);" />
      <MemberSignature Language="F#" Value="static member TryCatchFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression * System.Linq.Expressions.CatchBlock[] -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryCatchFinally (body, finally, handlers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="handlers" Type="System.Linq.Expressions.CatchBlock[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="body">try 블록의 본문입니다.</param>
        <param name="finally">finally 블록의 본문입니다.</param>
        <param name="handlers">try 블록과 연결되는 catch 문을 나타내는 <see cref="T:System.Linq.Expressions.CatchBlock" /> 식을 0개 이상 포함하는 배열입니다.</param>
        <summary>원하는 수의 catch 문과 finally 블록 하나를 사용하여 try 블록을 나타내는 <see cref="T:System.Linq.Expressions.TryExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.TryExpression" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 만드는 방법을 보여 줍니다는 <xref:System.Linq.Expressions.TryExpression> catch 문이 포함 된 개체 및 finally 문을 사용 합니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#48)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#48)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFault">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFault (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression fault);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFault(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression fault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFault (body As Expression, fault As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFault(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ fault);" />
      <MemberSignature Language="F#" Value="static member TryFault : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFault (body, fault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="fault" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">try 블록의 본문입니다.</param>
        <param name="fault">fault 블록의 본문입니다.</param>
        <summary>catch 문은 사용하지 않고 fault 블록을 하나 사용하여 try 블록을 나타내는 <see cref="T:System.Linq.Expressions.TryExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.TryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TryExpression TryFinally (System.Linq.Expressions.Expression body, System.Linq.Expressions.Expression finally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TryExpression TryFinally(class System.Linq.Expressions.Expression body, class System.Linq.Expressions.Expression finally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As Expression, finally As Expression) As TryExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TryExpression ^ TryFinally(System::Linq::Expressions::Expression ^ body, System::Linq::Expressions::Expression ^ finally);" />
      <MemberSignature Language="F#" Value="static member TryFinally : System.Linq.Expressions.Expression * System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.TryExpression" Usage="System.Linq.Expressions.Expression.TryFinally (body, finally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="finally" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="body">try 블록의 본문입니다.</param>
        <param name="finally">finally 블록의 본문입니다.</param>
        <summary>catch 문은 사용하지 않고 finally 블록을 하나 사용하여 try 블록을 나타내는 <see cref="T:System.Linq.Expressions.TryExpression" />을 만듭니다.</summary>
        <returns>만든 <see cref="T:System.Linq.Expressions.TryExpression" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetActionType">
      <MemberSignature Language="C#" Value="public static bool TryGetActionType (Type[] typeArgs, out Type actionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetActionType(class System.Type[] typeArgs, [out] class System.Type&amp; actionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetActionType (typeArgs As Type(), ByRef actionType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetActionType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % actionType);" />
      <MemberSignature Language="F#" Value="static member TryGetActionType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetActionType (typeArgs, actionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="actionType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">System.Action 대리자 형식의 형식 인수를 지정하는 Type 개체의 배열입니다.</param>
        <param name="actionType">이 메서드가 반환될 경우 특정 형식 인수가 있는 제네릭 System.Action 대리자 형식이 포함됩니다. <paramref name="typeArgs" />와 일치하는 제네릭 System.Action 대리자가 없을 경우 null이 포함됩니다. 이 매개 변수는 초기화되지 않고 전달됩니다.</param>
        <summary>특정 형식 인수가 있는 제네릭 System.Action 대리자 형식을 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" /> 개체를 만듭니다.</summary>
        <returns>제네릭 System.Action 대리자 형식이 특정 <paramref name="typeArgs" />에 대해 만들어졌을 경우 true이고, 그렇지 않으면 false입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFuncType">
      <MemberSignature Language="C#" Value="public static bool TryGetFuncType (Type[] typeArgs, out Type funcType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFuncType(class System.Type[] typeArgs, [out] class System.Type&amp; funcType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetFuncType (typeArgs As Type(), ByRef funcType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetFuncType(cli::array &lt;Type ^&gt; ^ typeArgs, [Runtime::InteropServices::Out] Type ^ % funcType);" />
      <MemberSignature Language="F#" Value="static member TryGetFuncType : Type[] *  -&gt; bool" Usage="System.Linq.Expressions.Expression.TryGetFuncType (typeArgs, funcType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArgs" Type="System.Type[]" />
        <Parameter Name="funcType" Type="System.Type" RefType="out" />
      </Parameters>
      <Docs>
        <param name="typeArgs">System.Func 대리자 형식의 형식 인수를 지정하는 Type 개체의 배열입니다.</param>
        <param name="funcType">이 메서드가 반환될 경우 특정 형식 인수가 있는 제네릭 System.Func 대리자 형식이 포함됩니다. <paramref name="typeArgs" />와 일치하는 제네릭 System.Func 대리자가 없을 경우 null이 포함됩니다. 이 매개 변수는 초기화되지 않고 전달됩니다.</param>
        <summary>특정 형식 인수가 있는 제네릭 System.Func 대리자 형식을 나타내는 <see cref="P:System.Linq.Expressions.Expression.Type" /> 개체를 만듭니다. 마지막 형식 인수는 생성된 대리자의 반환 형식을 지정합니다.</summary>
        <returns>제네릭 System.Func 대리자 형식이 특정 <paramref name="typeArgs" />에 대해 만들어졌을 경우 true이고, 그렇지 않으면 false입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public virtual Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ Type { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="System.Linq.Expressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Linq.Expressions.Expression" />이 나타내는 식의 정적 형식을 가져옵니다.</summary>
        <value>식의 정적 형식을 나타내는 <see cref="T:System.Type" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.NodeType%2A> 식 트리 노드를의 형식인 반면를 <xref:System.Linq.Expressions.Expression.Type%2A> 노드에서 나타내는 식의 정적 공용 언어 런타임 (CLR) 형식을 나타냅니다. 예를 들어, 다양 한 노드 형식 사용 하 여 두 개의 노드가 있습니다 동일한 <xref:System.Linq.Expressions.Expression.Type%2A>다음 코드 예제에 나와 있는 것 처럼 합니다.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/cs/program.cs#36)]
 [!code-vb[System.Linq.Expressions.ExpressionDev10#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.linq.expressions.expressiondev10/vb/module1.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression TypeAs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression TypeAs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ TypeAs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeAs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.TypeAs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="type"><see cref="T:System.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</param>
        <summary>변환에 실패하면 <see cref="T:System.Linq.Expressions.UnaryExpression" />이 제공되는 boxing 변환이나 명시적 참조를 나타내는 <see langword="null" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.Expression.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 는 `null`합니다. 합니다 <xref:System.Linq.Expressions.UnaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.UnaryExpression.IsLiftedToNull%2A> 속성은 모두 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.TypeAs%28System.Linq.Expressions.Expression%2CSystem.Type%29> 메서드를를 <xref:System.Linq.Expressions.UnaryExpression> 나타내는 nullable 정수 형식이 nullable이 아닌 정수 식의 참조 변환 합니다.  
  
 [!code-csharp[System.Linq.Expressions.Expression#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#11)]
 [!code-vb[System.Linq.Expressions.Expression#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="type" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeEqual">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeEqual (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeEqual(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeEqual(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeEqual : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeEqual (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="type"><see cref="P:System.Linq.Expressions.Expression.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />입니다.</param>
        <summary>런타임 형식 ID를 비교하는 <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> 속성은 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> 및 <see cref="T:System.Linq.Expressions.Expression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeIs">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.TypeBinaryExpression TypeIs (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.TypeBinaryExpression TypeIs(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::TypeBinaryExpression ^ TypeIs(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member TypeIs : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.TypeBinaryExpression" Usage="System.Linq.Expressions.Expression.TypeIs (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.TypeBinaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />입니다.</param>
        <param name="type"><see cref="P:System.Linq.Expressions.Expression.Type" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />입니다.</param>
        <summary><see cref="T:System.Linq.Expressions.TypeBinaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> 속성은 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> 및 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.Expression.Type%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 나타냅니다 <xref:System.Boolean>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Linq.Expressions.Expression.TypeIs%28System.Linq.Expressions.Expression%2CSystem.Type%29> 메서드를를 <xref:System.Linq.Expressions.TypeBinaryExpression> 에 대 한 문자열 값의 형식 테스트를 나타내는 <xref:System.Int32> 형식.  
  
 [!code-csharp[System.Linq.Expressions.Expression#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/CS/Expression.cs#12)]
 [!code-vb[System.Linq.Expressions.Expression#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.Expression/VB/Expression.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> 또는 <paramref name="type" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnaryPlus">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>단항 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <summary>단항 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 이 고, 그렇지 않으면입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `expression`합니다. 형식은 단항 더하기 연산자를 정의 하는 사용자 정의 형식은 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="expression" />.Type에 단항 더하기 연산자가 정의되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression UnaryPlus (System.Linq.Expressions.Expression expression, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression UnaryPlus(class System.Linq.Expressions.Expression expression, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ UnaryPlus(System::Linq::Expressions::Expression ^ expression, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member UnaryPlus : System.Linq.Expressions.Expression * System.Reflection.MethodInfo -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.UnaryPlus (expression, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="expression"><see cref="T:System.Linq.Expressions.Expression" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />입니다.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> 속성에 설정할 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</param>
        <summary>단항 더하기 연산을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" /> 속성이 <see cref="P:System.Linq.Expressions.Expression.NodeType" />이고 <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> 및 <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> 속성이 지정된 값으로 설정된 <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Linq.Expressions.UnaryExpression.Method%2A> 결과 속성 <xref:System.Linq.Expressions.UnaryExpression> 구현 방법으로 설정 됩니다. <xref:System.Linq.Expressions.Expression.Type%2A> 노드 유형의 속성입니다. 노드가 리프트 된 경우는 <xref:System.Linq.Expressions.BinaryExpression.IsLifted%2A> 하 고 <xref:System.Linq.Expressions.BinaryExpression.IsLiftedToNull%2A> 속성은 모두 `true`합니다. 이 고, 그렇지 않으면입니다.  
  
#### <a name="implementing-method"></a>메서드 구현  
 다음 규칙 작업에 대 한 구현 메서드를 결정합니다.  
  
-   경우 `method` 아닙니다 `null` void가 아닌 나타내고 `static` (`Shared` Visual Basic의) 메서드 인수 하나를 사용 하는 것이 노드에 대 한 구현 메서드.  
  
-   경우 `expression`합니다. 형식은 단항 더하기 연산자를 정의 하는 사용자 정의 형식은 <xref:System.Reflection.MethodInfo> 는 나타내는 연산자가 구현 메서드가 있습니다.  
  
-   그렇지 않은 경우, `expression`합니다. 형식은 숫자 형식, 구현 방법은 `null`합니다.  
  
#### <a name="node-type-and-lifted-versus-non-lifted"></a>노드 형식 및 비 리프트 및 리프트  
 구현 메서드가 아닌 경우 `null`:  
  
-   경우 `expression`합니다. 형식은 구현 메서드의 인수 형식에 할당할 수, 노드 리프트 되지 않습니다. 노드의 유형 구현 메서드의 반환 형식이입니다.  
  
-   다음 두 조건이 충족 되 면 노드가 리프트 된 및 형식의 노드는 구현 메서드의 반환 형식에 해당 하는 nullable 형식:  
  
    -   `expression`. 형식이 nullable 값 형식인와 구현 메서드의 인수 형식에 해당 하는 nullable이 아닌 값 형식 같습니다.  
  
    -   구현 메서드의 반환 형식은 nullable이 아닌 값 형식입니다.  
  
 구현 메서드가 `null`, 노드 유형이 `expression`합니다. 형식입니다. 경우 `expression`합니다. 형식이 nullable이 아닌, 노드가 리프트 하지 않습니다. 그렇지 않은 경우 노드가 리프트 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="expression" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 <see langword="null" />이 아니고 이것이 나타내는 메서드가 <see langword="void" />를 반환하거나, <see langword="static" />(Visual Basic의 경우 <see langword="Shared" />)이 아니거나, 정확하게 하나의 인수를 사용하지 않는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="method" />가 <see langword="null" />이고 <paramref name="expression" />.Type에 단항 더하기 연산자가 정의되지 않은 경우  
  
또는 
 <paramref name="expression" />.Type 또는 이 형식이 nullable 값 형식인 경우 nullable이 아닌 해당 형식을 <paramref name="method" />가 나타내는 메서드의 인수 형식에 할당할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.UnaryExpression Unbox (System.Linq.Expressions.Expression expression, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.UnaryExpression Unbox(class System.Linq.Expressions.Expression expression, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::UnaryExpression ^ Unbox(System::Linq::Expressions::Expression ^ expression, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Unbox : System.Linq.Expressions.Expression * Type -&gt; System.Linq.Expressions.UnaryExpression" Usage="System.Linq.Expressions.Expression.Unbox (expression, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.UnaryExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expression">unboxing할 <see cref="T:System.Linq.Expressions.Expression" />입니다.</param>
        <param name="type">식의 새 <see cref="T:System.Type" />입니다.</param>
        <summary>명시적 unboxing을 나타내는 <see cref="T:System.Linq.Expressions.UnaryExpression" />을 만듭니다.</summary>
        <returns><see cref="T:System.Linq.Expressions.UnaryExpression" />의 인스턴스입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Variable">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>식 트리에서 매개 변수나 변수를 식별하는 데 사용할 수 있는 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Variable : Type -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">매개 변수 또는 변수의 형식입니다.</param>
        <summary>식 트리에서 매개 변수나 변수를 식별하는 데 사용할 수 있는 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드를 만듭니다.</summary>
        <returns>지정된 이름과 형식의 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Variable">
      <MemberSignature Language="C#" Value="public static System.Linq.Expressions.ParameterExpression Variable (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.Expressions.ParameterExpression Variable(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::Expressions::ParameterExpression ^ Variable(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member Variable : Type * string -&gt; System.Linq.Expressions.ParameterExpression" Usage="System.Linq.Expressions.Expression.Variable (type, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.ParameterExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">매개 변수 또는 변수의 형식입니다.</param>
        <param name="name">매개 변수나 변수의 이름입니다. 이 이름은 디버깅 또는 인쇄용으로만 사용됩니다.</param>
        <summary>식 트리에서 매개 변수나 변수를 식별하는 데 사용할 수 있는 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드를 만듭니다.</summary>
        <returns>지정된 이름과 형식의 <see cref="T:System.Linq.Expressions.ParameterExpression" /> 노드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.Expressions.Expression VisitChildren (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Linq.Expressions.Expression VisitChildren(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function VisitChildren (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Linq::Expressions::Expression ^ VisitChildren(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="abstract member VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression&#xA;override this.VisitChildren : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.VisitChildren visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor"><see cref="T:System.Func`2" />의 인스턴스입니다.</param>
        <summary>노드를 줄인 다음 줄인 식에서 방문자 대리자를 호출합니다. 이 메서드는 노드를 줄일 수 없으면 예외를 throw합니다.</summary>
        <returns>방문하는 식 또는 트리에서 해당 식을 바꿀 식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 노드의 자식을 탐색 하는 논리를 제공 하려면이 메서드를 재정의 합니다. 일반적인 구현에서는 방문자를 호출 합니다. 각 자식에 방문 하 고 있으면 해당 변경, 수정 된 자식 사용 하 여 자체의 새 복사본을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>