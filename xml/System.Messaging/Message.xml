<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a95c4f6d088964d5660b767760d7575f90f4d921" /><Meta Name="ms.sourcegitcommit" Value="0b4deef443af9fe6334aa34b8a17190223bf0486" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="05/14/2019" /><Meta Name="ms.locfileid" Value="65609754" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>메시지 큐 메시지를 정의 하는 데 필요한 속성에 대 한 액세스를 제공 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Messaging.Message> 클래스 보기 또는 큐에서 메시지를 수신 하거나 큐에 메시지를 보낼 때 메시지 속성에 대해 세부적으로 제어할 필요가 있습니다.  
  
 <xref:System.Messaging.MessageQueue> 사용 하 여는 <xref:System.Messaging.Message> 클래스를 관찰 합니다. 또는 큐에서 메시지를 수신 하기 때문에 모두를 <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> 및 <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> 메서드의 새 인스턴스를 만들고를 <xref:System.Messaging.Message> 클래스 및 인스턴스 속성을 설정 합니다. <xref:System.Messaging.Message> 클래스의 읽기 전용 속성은 읽기/쓰기 속성은 전송 및 메시지를 검색에 적용 하는 동안 큐에서 메시지를 검색에 적용 합니다. 때 <xref:System.Messaging.MessageQueue> 관찰 하거나 큐에서 메시지를 받을 해당 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성 검색 되는 메시지의 속성을 결정 합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Send%2A> 메서드는 큐로 송신할 메시지에 대 한 모든 개체 형식을 지정할 수 있습니다. 사용할 수는 <xref:System.Messaging.MessageQueue> 인스턴스의 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 큐로 전송 하는 제네릭 메시지에 대 한 설정을 지정 하는 속성입니다. 설정의 형식에는 포맷터, 레이블, 암호화 및 인증 포함 됩니다. 적절 한 값을 지정할 수도 있습니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 승인 및 보고서 메시지에 응답 메시징 애플리케이션을 조정 하는 경우 멤버입니다. 사용 하는 <xref:System.Messaging.Message> 인스턴스 메시지를 보내는 큐에 액세스 하 고 단일 메시지 또는 메시지-기준-이러한 속성 중 상당수 수정 유연성을 제공 합니다. <xref:System.Messaging.Message> 속성 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>합니다.  
  
 메시지 데이터에 저장 됩니다는 <xref:System.Messaging.Message.Body%2A> 속성 및 정도 덜하지만 합니다 <xref:System.Messaging.Message.AppSpecific%2A> 및 <xref:System.Messaging.Message.Extension%2A> 속성입니다. 메시지 데이터 암호화, serialize 또는 deserialize의 내용만 <xref:System.Messaging.Message.Body%2A> 속성에 영향을 받습니다.  
  
 내용의 합니다 <xref:System.Messaging.Message.Body%2A> 속성은 메시지를 보낼 때 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 지정할 속성입니다. Serialize 된 내용에서 발견 되는 <xref:System.Messaging.Message.BodyStream%2A> 속성입니다. 설정할 수도 있습니다는 <xref:System.Messaging.Message.BodyStream%2A> 속성 직접 예를 들어 메시지의 데이터 콘텐츠로 파일을 보낼 수 있습니다. 변경할 수 있습니다 합니다 <xref:System.Messaging.Message.Body%2A> 나 <xref:System.Messaging.Message.Formatter%2A> 메시지 및 데이터를 보내기 전에 언제 든 지 속성을 직렬화할지 적절 하 게 호출 하는 경우 <xref:System.Messaging.MessageQueue.Send%2A>합니다.  
  
 정의 하는 속성을 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> 형식이 아닌 메시지에 대해서만 속성이 적용 <xref:System.Messaging.Message>합니다. 지정 하는 경우는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 에 대 한 속성을 <xref:System.Messaging.MessageQueue>, 동일한 이름의 속성으로는 <xref:System.Messaging.Message> 인스턴스가 전송 큐를 야기 하는 이러한 기본 속성이 무시 됩니다.  
  
 인스턴스의 초기 속성 값의 목록을 <xref:System.Messaging.Message>, 참조는 <xref:System.Messaging.Message.%23ctor%2A> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 메시지 본문을 서식 지정 하는 방법을 보여 줍니다 <xref:System.Messaging.BinaryMessageFormatter>합니다.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 다음 코드 예제에서는 사용 하 여 메시지 본문을 서식 지정 하는 방법을 보여 줍니다 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Messaging.Message" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Messaging.Message" /> 본문이 비어 있는 클래스입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 인스턴스를 만들려면이 오버 로드를 사용 합니다 <xref:System.Messaging.Message> 본문이 비어 있는 클래스입니다.  
  
 지정 된 <xref:System.Messaging.Message.Body%2A> 속성 또는 <xref:System.Messaging.Message.BodyStream%2A> 보내기 전에 속성을 <xref:System.Messaging.Message> 개체입니다. <xref:System.Messaging.Message.Body%2A> 속성에는 텍스트 문자열, 구조체 개체, 클래스 인스턴스를 또는 포함된 된 개체와 같은 serialize 할 수 있는 임의의 개체가 될 수 있습니다.  
  
 메시지의 콘텐츠를 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 설정 합니다 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 본문을 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 시간에 속성의 값을 <xref:System.Messaging.MessageQueue.Send%2A> 메서드를 호출는 <xref:System.Messaging.MessageQueue> 인스턴스.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되므로이 형식을 사용 하는 경우 보낸 사람 및 받는 사람 입력 동일한 개체를 할 필요는 없습니다. 합니다 <xref:System.Messaging.ActiveXMessageFormatter> 고 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 다음 표에서 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.Message>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 버전 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에 다른 우선 순위 2 메시지를 보내고 이후에 검색 합니다.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">메시지의 본문으로 serialize 될 개체입니다.</param>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Messaging.Message" /> 클래스를 사용 하는 <see cref="T:System.Messaging.XmlMessageFormatter" /> 메시지의 본문에 지정 된 개체를 serialize 하 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 인스턴스를 만들려면이 오버 로드를 사용 합니다 <xref:System.Messaging.Message> 포함 된 클래스를 <xref:System.Messaging.Message.Body%2A> 에 지정 된는 `body` 매개 변수입니다. `body` 매개 변수는 텍스트 문자열, 구조체 개체, 클래스 인스턴스를 또는 포함된 된 개체와 같은 serialize 할 수 있는 임의의 개체가 될 수 있습니다. 본문을 사용 하 여 serialize 되는 <xref:System.Messaging.XmlMessageFormatter> 변경 하지 않는 한는 <xref:System.Messaging.Message.Formatter%2A> 하기 전에 속성을 <xref:System.Messaging.Message> 보내집니다. 변경 하는 경우는 <xref:System.Messaging.Message.Body%2A> 하거나 <xref:System.Messaging.Message.Formatter%2A> 호출 전에 언제 든 지 속성 <xref:System.Messaging.MessageQueue.Send%2A>, 메시지 새 속성 값에 따라 직렬화 됩니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되므로이 형식을 사용 하는 경우 보낸 사람 및 받는 사람 입력 동일한 개체를 할 필요는 없습니다. 합니다 <xref:System.Messaging.ActiveXMessageFormatter> 고 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 다음 표에서 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.Message>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 버전 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 매개 변수입니다.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 큐를 만듭니다, 그리고 하는 순서를 포함 하 고이 검색 하는 메시지를 보냅니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">메시지의 본문으로 serialize 될 개체입니다.</param>
        <param name="formatter"><see cref="T:System.Messaging.IMessageFormatter" /> 메시지 본문을 serialize 할 포맷터를 지정 하는 합니다.</param>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Messaging.Message" /> 지정 된 포맷터를 사용 하 여 메시지의 본문에 지정된 된 개체를 serialize 할 클래스입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 인스턴스를 만들려면이 오버 로드를 사용 합니다 <xref:System.Messaging.Message> 포함 된 클래스를 <xref:System.Messaging.Message.Body%2A> 에 지정 된는 `body` 하 고 매개 변수를 사용 하 여 유효한 포맷터 본문을 직렬화 할 합니다. `body` 매개 변수는 텍스트 문자열, 구조체 개체, 클래스 인스턴스를 또는 포함된 된 개체와 같은 serialize 할 수 있는 모든 개체입니다. 변경 하는 경우는 <xref:System.Messaging.Message.Body%2A> 하거나 <xref:System.Messaging.Message.Formatter%2A> 호출 전에 언제 든 지 속성 <xref:System.Messaging.MessageQueue.Send%2A>, 메시지 새 속성 값에 따라 직렬화 됩니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되므로이 형식을 사용 하는 경우 보낸 사람 및 받는 사람 입력 동일한 개체를 할 필요는 없습니다. 합니다 <xref:System.Messaging.ActiveXMessageFormatter> 고 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 다음 표에서 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.Message>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 버전 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 매개 변수입니다.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` 매개 변수입니다.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보내는 애플리케이션으로 반환되는 승인 메시지의 형식을 가져오거나 설정합니다.</summary>
        <value>시스템이 관리 큐에 게시하는 승인 메시지의 형식과 보내는 애플리케이션으로 승인이 반환되는 조건을 나타내는 <see cref="T:System.Messaging.AcknowledgeTypes" /> 값 중 하나입니다. 기본값은 <see langword="None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> 속성 보내는 애플리케이션에 필요한 승인 메시지의 형식을 지정 합니다. 설정 된 <xref:System.Messaging.Message.AcknowledgeType%2A> 예를 들어 특정 항목-에 대 한 알림을 요청 하는 메시지, 대상 큐에 도달 하는 메시지, 검색 되는 메시지 또는 도달 또는 검색 되는 메시지를 방지 하는 제한 시간을 보내기 전에 속성 대상 큐입니다.  
  
 메시지 큐에서 승인 메시지를 보내 알림 반환 된 <xref:System.Messaging.Message.AdministrationQueue%2A> 원본 메시지에서 지정 된 속성입니다. 승인 메시지의 <xref:System.Messaging.Message.Acknowledgment%2A> 속성 나타내는 승인의 유형을 나타냅니다. 예를 들어 메시지 하기 전에 대상에 도달 하지 않았습니다 않으므로 승인 메시지를 보낼 수는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 간격이 만료 합니다 <xref:System.Messaging.Message.Acknowledgment%2A> 승인 메시지의 속성 값이 포함 됩니다 `ReachQueueTimeout`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 특히 긍정 승인을 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 무시 하도록 필터링 되는 <see cref="P:System.Messaging.Message.AcknowledgeType" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메시지가 나타내는 승인의 분류를 가져옵니다.</summary>
        <value><see cref="T:System.Messaging.Acknowledgment" /> 열거형 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 관리 큐에서 메시지를 받게 되 면 읽기는 <xref:System.Messaging.Message.Acknowledgment%2A> ; 속성을 원본 메시지의 상태를 확인 합니다.  
  
 대상 큐로 메시지를 보낼 때 메시지 큐를 요청할 수 있습니다는 승인 메시지를 게시 합니다. 예를 들어, 메시지를 배달 하지 못한 경우 오류의 원인을 나타낼 수 있습니다 메시지 도착 하 고 지정 된 제한 시간 내에 검색 되었는지 여부를 나타낼 수 있습니다. 승인 메시지를 게시 하 고 원본 메시지의 지정 된 관리 큐를 반환 하는 대상 큐 <xref:System.Messaging.Message.AdministrationQueue%2A> 속성입니다. <xref:System.Messaging.Message.Id%2A> 승인 메시지의 속성에는 원래 메시지가 아니라 승인 메시지를 식별 합니다. 승인에서 원본 메시지의 식별자를 찾을 수 있습니다 <xref:System.Messaging.Message> 인스턴스의 <xref:System.Messaging.Message.CorrelationId%2A> 속성입니다.  
  
 이 경우 <xref:System.Messaging.Message> 인스턴스는 승인 메시지를 나타내는 <xref:System.Messaging.Message.Acknowledgment%2A> 속성 승인의 유형을 지정 합니다. 그렇지 않으면 합니다 <xref:System.Messaging.Message.Acknowledgment%2A> 속성 값이 들어 `Normal`합니다.  
  
 사용 된 <xref:System.Messaging.Message.AcknowledgeType%2A> 승인이 반환 되는 상황을 지정 하 고 원본 메시지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐가 생성 한 승인 메시지를 받는 큐를 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> 시스템에서 생성 된 승인 메시지에 사용 되는 관리 큐를 지정 하는 합니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 큐는 <xref:System.Messaging.Message.AdministrationQueue%2A> 속성 비트랜잭션 큐를 사용할 수 있습니다. 관리 큐에 보낸 승인 메시지는 원본 메시지가 대상 큐에 도달했는지 여부 및 메시지가 큐에서 제거되었는지 여부를 나타낼 수 있습니다.  
  
 경우는 <xref:System.Messaging.Message.AcknowledgeType%2A> 속성에 모든 값이 아닌 다른 `None`, 보내는 애플리케이션에서 관리 큐로 사용 하 여 큐를 지정 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 특히 긍정 승인을 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.AdministrationQueue" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 관련 추가 정보를 가져오거나 설정합니다.</summary>
        <value>애플리케이션 관련 정보입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> 속성 다양 한 유형의 메시지를 구성 하는 데 사용할 수 있는 애플리케이션 관련 정보를 포함 합니다. 예를 들어 애플리케이션 관련 인덱스를 사용할 수 있습니다. 이 해석 하는 애플리케이션의 경우 <xref:System.Messaging.Message.AppSpecific%2A> 속성 정보입니다.  
  
 메시지의 본문에서 메시지 데이터를 포함 해야 가능 하면 대신 <xref:System.Messaging.Message.AppSpecific%2A> 속성입니다.  
  
 외부 큐로 작업할 때 사용 된 <xref:System.Messaging.Message.Extension%2A> 메시지 큐에 존재 하지 않는 메시지 속성을 지정 하려면 속성입니다. 와 마찬가지로 합니다 <xref:System.Messaging.Message.AppSpecific%2A> 속성의 내용을 이해 하는 애플리케이션의 책임은는 <xref:System.Messaging.Message.Extension%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.AppSpecific" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 대상 큐에 도착 하는 시간을 가져옵니다.</summary>
        <value><see cref="T:System.DateTime" /> 대상 큐에 메시지의 도착 시간을 나타내는입니다. 시간은 GMT에서 대상 큐에 상주 하는 컴퓨터의 현지 시간으로 조정 됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성 대상 큐에서 메시지를 받아야 하는 방법을 신속 하 게 나타냅니다. <xref:System.Messaging.Message.TimeToBeReceived%2A> 메시지를 보낼 때 메시지 큐에 도착할 때가 아니라 속성 타이머가 시작 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.ArrivedTime%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.ArrivedTime" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보낸 사람 ID를 메시지에 첨부할지 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value><see langword="true" /> 경우는 <see cref="P:System.Messaging.Message.SenderId" /> 이 고, 그렇지 않으면 메시지에 연결 된 <see langword="false" />합니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> 속성은 보내는 사용자의 식별자를 나타내는 바이트 배열입니다. 보낸 사람 ID는 메시지 큐에서 설정 되 고 보낸 사람에 게에 큐에 대 한 액세스 권한이 있는지 여부를 확인 하려면 수신 큐 관리자에서 사용.  
  
 ID가는 메시지 큐 해야 하지 않으며 메시지의 보낸 사람을 유효성 검사도 보낸 사람의 액세스 확인 보내는 애플리케이션에서 보낸 사람에 게 없는 경우 받는 큐에는 권한입니다. <xref:System.Messaging.Message.SenderId%2A> 은 대상 큐에 도달 했을 때 메시지 인증 된 경우에 신뢰할 수 있습니다. 큐가 인증 된 메시지만 및 중 하나를 허용 하는 경우 대상 큐에 도달 하면 메시지가 거부 된다는 합니다 <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> 또는 <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> 속성은 `false`합니다.  
  
> [!CAUTION]
>  메시지가 거부 될 경우 배달 못 한 편지 큐로 전송 되거나 (하는 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 는 `true`), 무시 됩니다. 메시지를 큐에 도달 하지 못할 때 승인을 요청할 수 있습니다. 경우에이 고, 그렇지 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 는 `false` 메시지 경고 없이 손실 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.AttachSenderId%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.AttachSenderId" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 인증되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 큐 도달 했을 때 메시지에 대 한 인증 요청 된 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> 속성은 메시지와 상호 작용 하며 인증이 요청 되었는지 확인 하려고 하는 동안 애플리케이션에 의해서만 사용 됩니다. 메시지 큐에 메시지가 인증 되었는지 합니다. 반대로, 경우 합니다 <xref:System.Messaging.Message.Authenticated%2A> 속성은 `true`, 수신 큐 관리자는 해당 메시지를 받으면 메시지를 인증 합니다.  
  
 해당 속성을 보면 메시지가 인증 실패를 확인할 수 없습니다. 메시지 큐에서 큐에 메시지가 배달 되기 전에 인증을 실패 한 메시지를 삭제 합니다. 그러나 배달이 실패 메시지 큐에 도착 하는 것을 방지 한 경우 승인 메시지를 보내도록 요청할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.Authenticated%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Authenticated" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지의 디지털 서명을 생성 하는 데 암호화 공급자의 이름을 가져오거나 설정 합니다.</summary>
        <value>메시지의 디지털 서명을 생성 하는 데 암호화 공급자의 이름입니다. 기본값은 Microsoft Base Cryptographic Provider version 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 사용 하 여 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 외부 큐를 사용 하 여 작업 하는 경우. 인증 공급자 이름 및 인증 공급자 유형 (인증 공급자)를 외부 큐로 전송 된 메시지와 메시지에 전달 되는 메시지의 디지털 서명의 유효성을 검사 하는 암호화 공급자의 메시지 큐 필요 외부 큐에서 큐입니다.  
  
 메시지를 보낼 때는 항상 설정 합니다 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 고 <xref:System.Messaging.Message.ConnectorType%2A> 속성을 함께 합니다. 메시지를 보낼 때 커넥터 유형도 설정 되지 않은 경우 인증 공급자 이름을 무시 메시지 큐입니다.  
  
 합니다 <xref:System.Messaging.Message.AuthenticationProviderName%2A> 속성 일 수 없습니다 `null`, 빈 문자열 수 있지만 ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 속성을 설정할 수 없습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException">합니다 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 로 설정 된 <see langword="null" />합니다.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지의 디지털 서명을 생성 하는 데 사용 되는 암호화 공급자의 형식을 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Messaging.CryptographicProviderType" /> 값 중 하나입니다. 기본값은 <see langword="RSA_FULL" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 사용 하는 <xref:System.Messaging.Message.AuthenticationProviderType%2A> 암호화 서비스 공급자가 메시지와 연결 되도록 외부 큐를 사용 하 여 작업 하는 경우에 속성입니다. 인증 공급자 이름 및 인증 공급자 유형 (인증 공급자)를 외부 큐로 전송 된 메시지와 메시지에 전달 되는 메시지의 디지털 서명의 유효성을 검사 하는 암호화 공급자의 메시지 큐 필요 외부 큐에서 큐입니다.  
  
 만 `RsaFull` 메시징을 사용 하 여 사용할 것입니다.  
  
 메시지를 보낼 때는 항상 설정 합니다 <xref:System.Messaging.Message.AuthenticationProviderType%2A> 고 <xref:System.Messaging.Message.ConnectorType%2A> 속성을 함께 합니다. 메시지를 보낼 때 커넥터 유형도 설정 되지 않은 경우 인증 공급자 유형을 무시 메시지 큐입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 속성을 설정할 수 없습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지의 내용을 가져오거나 설정합니다.</summary>
        <value>메시지 콘텐츠를 지정 하는 개체입니다. 개체는 문자열, 날짜, 통화, 숫자, 바이트 배열 또는 관리 되는 개체 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 <xref:System.Messaging.Message.Body%2A> 속성은 일반적으로 메시지를 사용 하 여 관련 데이터를 포함 합니다. 애플리케이션별 데이터를 보낼 수도 있습니다 하지만 <xref:System.Messaging.Message.AppSpecific%2A> 및 <xref:System.Messaging.Message.Extension%2A> 속성을 메시지 데이터를 포함 해야는 <xref:System.Messaging.Message.Body%2A> 가능할 때마다 메시지의 합니다. 만 <xref:System.Messaging.Message.Body%2A> 속성 내용을 serialize 되거나 암호화 됩니다.  
  
 <xref:System.Messaging.Message.Body%2A> 속성 크기가 4MB를 넘지 않는 개체를 포함할 수 있습니다. 사용 하는 경우 <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> 형식이 아닌 개체를 보낼 <xref:System.Messaging.Message> 에 <xref:System.Messaging.MessageQueue>, 해당 개체에 배치 됩니다는 <xref:System.Messaging.Message.Body%2A> 속성을 <xref:System.Messaging.Message> 에서 반환한 인스턴스 <xref:System.Messaging.MessageQueue.Peek%2A> 또는 <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 문자열 인수 `MessageQueue.Send("hello.")` 은 예제는 이러한 일반 개체입니다.  
  
 <xref:System.Messaging.Message.BodyType%2A> 속성 유형의 메시지 본문에 저장 된 정보를 나타냅니다. 메시지 큐의 형식을 식별 하기 위해이 정보를 사용 합니다 <xref:System.Messaging.Message.Body%2A> 속성 내용입니다.  
  
 지정 된 <xref:System.Messaging.Message.Body%2A> 속성 또는 <xref:System.Messaging.Message.BodyStream%2A> 보내기 전에 속성을 <xref:System.Messaging.Message> 개체입니다. <xref:System.Messaging.Message.Body%2A> 속성은 모든 텍스트 문자열 같은 직렬화 가능 개체, 구조체, 클래스 인스턴스 또는 포함 된 개체 수 있습니다.  
  
 메시지의 콘텐츠를 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 설정 합니다 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.Send%2A> 메서드를 호출 합니다 <xref:System.Messaging.MessageQueue> 인스턴스를 본문에 포함 된 포맷터를 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 속성. 에 대 한 값을 지정 하지 않고 메시지를 보내기 합니다 <xref:System.Messaging.Message.Formatter%2A> 속성을 포맷터의 기본값은 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
> [!NOTE]
>  메시지의 본문을 설정 하려고 <xref:System.Decimal.MaxValue> 하면를 <xref:System.OverflowException> 때를 `Send` 메서드를 <xref:System.Messaging.MessageQueue> 클래스 라고 및 <xref:System.Messaging.ActiveXMessageFormatter> 사용 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에 다른 우선 순위 2 메시지를 보내고 이후에 검색 합니다.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.Formatter" /> 속성은 <see langword="null" />입니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Body" /> 속성입니다.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지의 본문에서 정보를 가져오거나 설정 합니다.</summary>
        <value>A <see cref="T:System.IO.Stream" /> 에 포함 된 serialize 된 정보를 포함 하는 <see cref="P:System.Messaging.Message.Body" /> 메시지.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지의 본문 구성 될 수 있습니다-모든 종류의 예를 들어, 문자열, 날짜, 통화, 숫자, 바이트 배열 또는 관리 되는 개체입니다. 이 정보로 serialize 되는 <xref:System.IO.Stream> 를 큐에 전달 하도록 합니다.  
  
 지정 된 <xref:System.Messaging.Message.Body%2A> 속성 또는 <xref:System.Messaging.Message.BodyStream%2A> 보내기 전에 속성을 <xref:System.Messaging.Message> 개체입니다. 설정 하는 경우는 <xref:System.Messaging.Message.Body%2A> 속성 내용으로 serialize 되는 <xref:System.Messaging.Message.BodyStream%2A> 속성입니다. 그러나 작성 하도록 선택할 수는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 직접. 예를 들어 파일에 대 한 연결을 열고 메시지의 본문으로 해당 콘텐츠를 스트리밍 하려는 경우 유용 합니다.  
  
 메시지의 콘텐츠를 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 설정 합니다 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.Send%2A> 메서드를 호출 합니다 <xref:System.Messaging.MessageQueue> 인스턴스를 본문에 포함 된 포맷터를 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 속성. 에 대 한 값을 지정 하지 않고 메시지를 보내기 합니다 <xref:System.Messaging.Message.Formatter%2A> 속성을 포맷터의 기본값은 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 설정 하는 경우는 <xref:System.Messaging.Message.UseEncryption%2A> 속성을 `true` 이 메시지의 본문에 대 한 메시지는 암호화는 전송 될 때, 설정한 때가 아니라는 <xref:System.Messaging.Message.Body%2A> 속성입니다. 따라서는 <xref:System.Messaging.Message.BodyStream%2A> 속성 암호화 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Body" /> 속성입니다.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 본문에 포함되는 데이터 형식을 가져오거나 설정합니다.</summary>
        <value>메시지 본문의 실제 형식 문자열, 날짜, 통화 또는 숫자와 같은 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialize 된 스트림 또는 개체로 메시지 큐 본문 콘텐츠를 인식합니다. 합니다 <xref:System.Messaging.Message.BodyType%2A> 속성 내에서 개체의 유형을 나타냅니다는 <xref:System.Messaging.Message.Body%2A> 메시지의 속성입니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 메시지 본문에서 네이티브 형식과 개체 간에 바인딩을 수행 합니다. 사용 하는 경우는 <xref:System.Messaging.XmlMessageFormatter>, 포맷터 집합을 <xref:System.Messaging.Message.BodyType%2A> 속성이 있습니다.  
  
 다른 포맷터는 또한 다음 C# 코드에 표시 된 것 처럼 바인딩 기능을 제공할 수 있습니다.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.BodyType%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Body" /> 속성입니다.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>일반적으로 메시지 큐에서 설정된 일부 메시지 속성이 보내는 애플리케이션에서 설정되었음을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>애플리케이션에서 정의되고 커넥터 애플리케이션 또는 메시지 암호화와 함께 사용되는 <see cref="T:System.Guid" />입니다. 이 <see cref="T:System.Guid" />를 사용하면 보내는 애플리케이션에서 설정되었지만 일반적으로 메시지 큐에서 설정되는 메시지 속성을 받는 애플리케이션에서 해석할 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 <xref:System.Messaging.Message.ConnectorType%2A> 때마다 메시지 큐에서 일반적으로 설정 된 메시지 속성을 설정 하는 애플리케이션 속성을 설정 합니다. 애플리케이션에서는 보통는 <xref:System.Messaging.Message.ConnectorType%2A> 다음 두 가지 경우에서:  
  
-   때마다 커넥터 애플리케이션에 메시지를 전달 합니다. <xref:System.Messaging.Message.ConnectorType%2A> 송신 및 수신 애플리케이션이 메시지의 보안 및 승인 속성을 해석 하는 방법을 지시 합니다.  
  
-   때마다를 보내는 애플리케이션 보다는 메시지 큐에서 메시지를 암호화합니다. 합니다 <xref:System.Messaging.Message.ConnectorType%2A> 메시지 큐를 사용 하도록 지시 합니다 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 메시지를 해독 하려면 속성 값입니다.  
  
 설정 해야 합니다는 <xref:System.Messaging.Message.ConnectorType%2A> 다음 속성 중 하나를 설정 하는 경우 속성 (그렇지 않은 경우 큐이 속성을 무시 이러한 메시지를 보낼 때).  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.ConnectorType" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>원본 메시지를 참조하기 위해 승인, 보고 및 응답 메시지에서 사용하는 메시지 식별자를 가져오거나 설정합니다.</summary>
        <value>지정 된 메시지 식별자를 <see cref="P:System.Messaging.Message.Id" /> 원본 메시지의 속성입니다. 메시지 큐에서는 승인 또는 보고 메시지를 생성할 때 상관 관계 식별자를 사용하고 애플리케이션에서는 응답 메시지를 생성할 때 해당 식별자를 사용합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐를 승인 또는 보고 메시지를 생성할 때에 상관 관계 식별자 속성을 사용 하 여 원본 메시지의 메시지 식별자를 지정 합니다. 이러한 방식으로 상관 관계 식별자는 보고 메시지나 승인 메시지를 원본 메시지에 연결합니다.  
  
 보내는 애플리케이션 일치 시킬 수 있습니다 승인 또는 원본 메시지를 사용 하 여 보고서를 사용 하 여 합니다 <xref:System.Messaging.Message.CorrelationId%2A> 원래 메시지를 식별 하기 위해 속성 <xref:System.Messaging.Message.Id%2A> 속성입니다.  
  
 커넥터 애플리케이션 설정 해야 합니다는 <xref:System.Messaging.Message.CorrelationId%2A> 원본 메시지의 메시지 식별자로 승인 및 보고서 메시지의 속성입니다.  
  
 애플리케이션 응답 메시지는 보내는 애플리케이션에서 보내는 경우 설정할 수 있습니다는 <xref:System.Messaging.Message.CorrelationId%2A> 원본 메시지의 메시지 식별자로 응답 메시지의 속성입니다. 보내는 애플리케이션에서 보낸 메시지에 응답 메시지를 일치 시킬 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 특히 긍정 승인을 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.CorrelationId" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" />이 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>의도 한 대상 큐를 메시지를 가져옵니다.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> 의 의도 한 대상 큐 메시지를 지정 하는 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> 속성은 가장 일반적으로 업무 일지 나 배달 못 한 편지 큐에 도착 한 메시지의 원래 대상을 확인 하는 데 사용 됩니다. 일반적으로 필요가 없습니다이 속성을 검사할 하므로 일반적으로 대상 큐에서 메시지를 검색 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.DestinationQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.DestinationQueue" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션에서 암호화된 메시지를 외부 큐로 보낸 경우 해당 메시지를 암호화하는 데 사용하는 대칭 키를 가져오거나 설정합니다.</summary>
        <value>메시지를 암호화 하는 데 사용 하는 대상 대칭 키를 지정 하는 바이트 값의 배열입니다. 기본값은 길이가 0 인 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 가지 시나리오를 사용 해야는 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성입니다. 첫 번째 경우 응용 프로그램 대신 메시지 큐에서 메시지를 암호화 합니다. 두 번째 메시지 큐가 아닌 큐 시스템에 암호화 된 메시지를 보내면 됩니다.  
  
 이 속성을 설정 하기 전에 수신 큐 관리자의 공개 키를 사용 하 여 대칭 키를 암호화 해야 합니다. 애플리케이션에서 암호화 된 메시지를 보낼 때 수신 큐 관리자를 대상 큐에 보내기 전에 메시지를 해독 하려면 대칭 키를 사용 합니다.  
  
 외부 큐로 메시지를 보내는 경우 메시지 수신 애플리케이션에 연결 된 대칭 키로 암호화 된 메시지를 전달 하는 적절 한 커넥터 애플리케이션에서 먼저 수신 됩니다. 대칭 키를 사용 하는 메시지의 암호를 해독 하는 수신 애플리케이션에서 수행 됩니다.  
  
 설정한 경우 합니다 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성을 설정 해야 합니다 <xref:System.Messaging.Message.ConnectorType%2A> 속성입니다. 메시지를 보낼 때 메시지 큐 무시 합니다 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성 경우는 <xref:System.Messaging.Message.ConnectorType%2A> 속성이 설정 되어 있지.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> 속성의 최대 배열 크기는 256입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" />이 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에서 메시지를 인증 하는 데 사용 하는 디지털 서명을 가져오거나 설정 합니다.</summary>
        <value>메시지를 인증 하는 데 Message Queuing 1.0 디지털 서명을 지정 하는 바이트 값의 배열입니다. 기본값은 길이가 0 인 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 메시지 큐 버전 1.0에서 보낸 메시지를 인증할 때 디지털 서명을 사용 합니다. 대부분의 경우에서 메시지 큐 생성 및 설정의 <xref:System.Messaging.Message.DigitalSignature%2A> 속성이 보내는 애플리케이션 인증을 요청 합니다. 수신 애플리케이션이이 속성을 사용 하 여 메시지에 첨부 된 디지털 서명을 검색 합니다.  
  
 만 사용할 수 있습니다는 <xref:System.Messaging.Message.DigitalSignature%2A> 메시지 큐 버전 2.0을 실행 하는 경우에 속성입니다. 인증을 요청할 때 보내는 애플리케이션 버전 1.0 서명을 메시지 큐를 지정 해야 합니다. 보내는 애플리케이션 메시지 큐 버전 2.0 서명의 보내는 경우이 속성에는 4 바이트를 0이 포함 된 각 버퍼를 포함 합니다.  
  
 합니다 <xref:System.Messaging.Message.DigitalSignature%2A> 속성을 함께 <xref:System.Messaging.Message.SenderCertificate%2A> 속성 에서도 커넥터 애플리케이션에서 메시지를 보낼 때. 이 시나리오는 커넥터 응용 프로그램 보다는 메시지 큐-디지털 서명, 메시지를 보내는 사용자의 인증서를 기반을 생성 합니다.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> 속성의 최대 배열 크기는 256입니다.  
  
 설정한 경우 합니다 <xref:System.Messaging.Message.DigitalSignature%2A> 속성을 설정 해야 합니다 <xref:System.Messaging.Message.ConnectorType%2A> 속성입니다. 메시지를 보낼 때 메시지 큐 무시 합니다 <xref:System.Messaging.Message.DigitalSignature%2A> 속성 경우는 <xref:System.Messaging.Message.ConnectorType%2A> 속성이 설정 되어 있지.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.DigitalSignature" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DigitalSignature" /> 속성은 <see langword="null" />입니다.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개인 메시지의 본문을 암호화 하는 데 사용 된 암호화 알고리즘을 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Messaging.EncryptionAlgorithm" /> 열거형 값 중 하나입니다. 기본값은 <see langword="RC2" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개인의 경우 메시지 (암호화)를 보내고 받을 때 암호가 해독 하기 전에 암호화 됩니다. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> 속성 개인 메시지의 메시지 본문을 암호화 하는 데 사용 된 알고리즘을 지정 합니다.  
  
 큐에서는 들어오는 메시지를 암호화할 수 있습니다. 애플리케이션 개인 메시지만 허용 하는 큐에 암호화 되지 않은 (private이 아닌) 메시지를 보냅니다. private이 아닌 메시지만 허용 하는 개인 메시지 큐로 보내는 경우, 큐 메시지를 거부 합니다. 보내는 애플리케이션으로 부정 승인 메시지 이러한 경우 반환 되도록 요청할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지에 연결된 애플리케이션 정의 추가 정보를 가져오거나 설정합니다.</summary>
        <value>메시지와 관련된 애플리케이션 정의 정보를 제공하는 바이트 배열 값입니다. 기본값은 길이가 0 인 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> 속성은 메시지와 연결 된 큰 이진 개체와 같은 애플리케이션 정의 정보를 제공 합니다. 내용을 해석 하는 수신 애플리케이션의 담당 합니다 <xref:System.Messaging.Message.Extension%2A> 속성입니다.  
  
 가능한 경우 메시지 데이터를 포함 해야 합니다 <xref:System.Messaging.Message.Body%2A> 메시지의 속성 대신 <xref:System.Messaging.Message.Extension%2A> 속성입니다.  
  
 외부 큐로 작업할 때 사용 된 <xref:System.Messaging.Message.Extension%2A> 메시지 큐에 존재 하지 않는 메시지 속성을 지정 하려면 속성입니다.  
  
 외부 큐 Microsoft Message Queuing 이외의 큐 시스템에 존재합니다. 커넥터 애플리케이션을 통해 이러한 큐를 사용 하 여 메시지 큐는 통신합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Extension" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Extension" /> 속성은 <see langword="null" />입니다.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>에 개체를 serialize 하거나 메시지 본문에서 개체를 deserialize 하는 데 사용 하는 포맷터를 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Messaging.IMessageFormatter" /> 쓰거나 메시지 본문에서 읽을 스트림을 생성 합니다. 기본값은 <see cref="T:System.Messaging.XmlMessageFormatter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Messaging.Message.Formatter%2A> 읽고 메시지를 쓸 때 속성입니다. 큐에 메시지를 보내면 포맷터가 serialize 된 <xref:System.Messaging.Message.Body%2A> 스트림으로 메시지 큐에 보낼 수 있는 속성입니다. 포맷터에 메시지 데이터를 큐에서 읽을 때의 <xref:System.Messaging.Message.Body%2A> 속성입니다.  
  
 메시지의 콘텐츠를 직접 작성 하지 않는 경우는 <xref:System.Messaging.Message.BodyStream%2A> 속성을 설정 합니다 <xref:System.Messaging.Message.Formatter%2A> 메시지를 보내기 전에 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.Send%2A> 메서드를 호출 합니다 <xref:System.Messaging.MessageQueue> 인스턴스를 본문에 포함 된 포맷터를 사용 하 여 serialize 되는 <xref:System.Messaging.Message.Formatter%2A> 속성. 에 대 한 값을 지정 하지 않고 메시지를 보내기 합니다 <xref:System.Messaging.Message.Formatter%2A> 속성을 포맷터의 기본값은 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되므로이 형식을 사용 하는 경우 보낸 사람 및 받는 사람 입력 동일한 개체를 할 필요는 없습니다. 합니다 <xref:System.Messaging.ActiveXMessageFormatter> 고 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 메시지 본문을 서식 지정 하는 방법을 보여 줍니다 <xref:System.Messaging.BinaryMessageFormatter>합니다.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 다음 코드 예제에서는 사용 하 여 메시지 본문을 서식 지정 하는 방법을 보여 줍니다 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Formatter" /> 속성은 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 인증할 때 사용 하 여 메시지 큐는 해시 알고리즘 또는 메시지의 디지털 서명을 만드는 값을 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Messaging.HashAlgorithm" /> 열거형 값 중 하나입니다. Windows XP에 대 한 기본값은 <see langword="SHA" />합니다. 그렇지 않으면 기본값은 <see langword="MD5" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 원본 컴퓨터, 메시지 큐 메시지에 대 한 디지털 서명을 만들 때 해시 알고리즘을 사용 합니다. 대상 큐 관리자 수신 될 때 메시지를 인증 하는 같은 해시 알고리즘을 사용 하는 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.HashAlgorithm" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지의 식별자를 가져옵니다.</summary>
        <value>메시지의 고유 식별자를 메시지 큐에서 생성 되는입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 메시지를 보내면 메시지 식별자를 생성 합니다. 식별자는 20 바이트로 구성 되며 두 항목: 컴퓨터 <xref:System.Guid> 보내는 컴퓨터 및 컴퓨터의 메시지에 대 한 고유 식별자입니다. 이 두 항목을 결합하여 네트워크에서 고유한 메시지 식별자를 만듭니다.  
  
 메시지 큐에서는 승인 및 보고 메시지를 비롯 한 모든 메시지에 대 한 메시지 식별자를 생성 합니다. 승인 메시지를 일반적으로 원래, 보낸 메시지의 도착 여부에 대 한 응답의 메시지 큐에서 전송 됩니다. 찾을 수 있습니다는 <xref:System.Messaging.Message.Id%2A> 에서 원래 메시지의 속성 값을 <xref:System.Messaging.Message.CorrelationId%2A> 승인 메시지의 속성입니다.  
  
 사용할 수도 있습니다는 <xref:System.Messaging.Message.Id%2A> 응답 큐로 응답 메시지를 보낼 때 속성입니다. 응답 메시지의 원본 메시지의 식별자를 포함 하려면 설정 합니다 <xref:System.Messaging.Message.CorrelationId%2A> 응답 메시지의 속성을 <xref:System.Messaging.Message.Id%2A> 원본 메시지의 속성입니다. 응답 메시지를 읽는 애플리케이션 원본 메시지를 식별 하는 응답 메시지의 상관 관계 식별자를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 특히 긍정 승인을 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Id" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>시간 제한이 없도록 지정 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 및 <xref:System.Messaging.Message.TimeToReachQueue%2A> 제한 시간을 지정 하는 값이 필요 합니다. 전자의 경우의 제한 시간은 메시지가 큐에서 받을 수 있는 최대 시간입니다. 후자의 경우 제한 시간에는 큐에 도달 하는 메시지에 허용 된 시간입니다. 두 경우 모두 초 수로 제한 시간을 지정 하거나 사용할 수 있습니다 <xref:System.Messaging.Message.InfiniteTimeout> 시간 제한이 없도록 나타냅니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.Message.InfiniteTimeout> 필드입니다.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 트랜잭션에서 보낸 첫 번째 메시지 인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 메시지가 트랜잭션에서 보낸 첫 번째 메시지 이면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 수신 애플리케이션 사용을 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 속성을 통해 메시지가 단일 큐에 단일 트랜잭션에서 보낸 첫 번째 메시지 인지를 확인 합니다.  
  
 이 속성이 이상 메시지 큐 버전 2.0에만 사용할 수 있습니다.  
  
 트랜잭션 경계를 확인 하려면 사용 합니다 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 두 개의 다른 속성과 함께 속성: <xref:System.Messaging.Message.IsLastInTransaction%2A> 및 <xref:System.Messaging.Message.TransactionId%2A>합니다. 트랜잭션에서 보낸 마지막 메시지 인지 여부를 확인 하는 전자를 사용 하 고 트랜잭션 식별자를 검색할 후자를 사용 합니다.  
  
 경우에 트랜잭션에서 하나의 메시지를 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성이 둘 다로 설정 됩니다 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 트랜잭션에서 보낸 마지막 메시지 인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 메시지가 단일 트랜잭션에서 보낸 마지막 메시지 이면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 수신 애플리케이션 사용을 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성을 통해 메시지가 단일 큐에 단일 트랜잭션에서 보낸 마지막 메시지 인지를 확인 합니다.  
  
 이 속성이 이상 메시지 큐 버전 2.0에만 사용할 수 있습니다.  
  
 트랜잭션 경계를 확인 하려면 사용 합니다 <xref:System.Messaging.Message.IsLastInTransaction%2A> 두 개의 다른 속성과 함께 속성: <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.TransactionId%2A>합니다. 전자를 사용 하 여 트랜잭션에서 보낸 첫 번째 메시지 인지 여부를 확인 하 고 트랜잭션의 식별자를 검색할 후자를 사용 합니다.  
  
 경우에 트랜잭션에서 하나의 메시지를 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성이 둘 다로 설정 됩니다 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.IsLastInTransaction%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.IsLastInTransaction" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 설명하는 애플리케이션 정의 유니코드 문자열을 가져오거나 설정합니다.</summary>
        <value>메시지의 레이블입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 레이블은 여러 용도로 사용할 수 있습니다. 예를 들어 메시지 레이블을 사용하여 해당 내용을 표시하거나 레이블 값을 기반으로 메시지를 선택적으로 처리할 수 있습니다. 레이블을은 메시지에서 고유할 필요가 없습니다.  
  
 메시지 큐와 메시지 레이블은 읽을 수 있는 용어로 만들어진 메시지나 큐를 식별할 수 있도록 애플리케이션 정의 값을 나타냅니다. 메시지 큐 애플리케이션에 내포 된 의미가 없습니다 있는 레이블 내용을 해석 하는 애플리케이션의 담당 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.Label%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Label" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0에서에서 도입 되었습니다. 메시지의 조회 식별자를 가져옵니다.</summary>
        <value>메시지 큐에서 생성 되는 해당 메시지가 있는 큐에 고유 하며 메시지의 조회 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> 속성은 메시지의 조회 식별자에 대 한 읽기 전용 액세스를 제공 합니다. MSMQ 3.0에서 도입 된 조회 식별자는 메시지 큐에서 생성 되 고 메시지 큐에 배치 되 면 각 메시지에 할당 되는 64 비트 식별자가입니다. 조회 식별자는 메시지를 보낼 때 생성 되는 메시지 식별자로 같지는 않습니다.  
  
 메시지 큐는 커넥터 및 보내는 큐 시스템에서 생성 된 저널에 배달 못 한 편지, 뿐만 아니라 대상 애플리케이션 생성, 관리 및 보고서 큐를 포함 하 여 모든 큐에 배치 되는 모든 메시지에 대 한 조회 식별자를 생성 합니다. 즉, 보내는 애플리케이션에서 보내고 메시지 큐에서 메시지를 모두 포함 됩니다. 조회 식별자는 큐에 고유 하며 큐 외부에서는 의미가 없습니다.  
  
 여러 대상 큐로 메시지를 보내는 경우, 컴퓨터 저널 또는 저널 큐에서 메시지의 복사본이 저장 되는 경우 각 큐에 배치 되는 경우 메시지의 각 복사본이 자체 조회 식별자를 해야 합니다.  
  
 <xref:System.Messaging.Message.LookupId%2A> 속성 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
 조회 식별자를 큐에서 특정 메시지를 읽는 데 사용 됩니다. 메시지의 조회 식별자가 확인 되 면 수신 애플리케이션이 호출할 수는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 또는 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 해당 메시지에 직접 이동 하 고 보거나 큐 맨 앞에 시작 해야 하는 커서와 달리 큐에서 검색 하는 함수 및 큐의 끝 쪽으로 이동  
  
 큐의 메시지 조회 식별자를 가져오는 하는 것은 애플리케이션의 책임입니다. 조회 식별자를 가져오는 한 가지 가능한 방법 큐에 배치 될 때 각 메시지의 식별자를 캐시 하는 구성 요소를 호출 하는 대상 큐에 대 한 트리거를 만드는 것입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치 되지 않았습니다.</exception>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.LookupId" /> 속성입니다.</exception>
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 형식(<see langword="Normal" />, <see langword="Acknowledgment" /> 또는 <see langword="Report" />)를 가져옵니다.</summary>
        <value><see cref="P:System.Messaging.Message.MessageType" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 메시지 큐는 메시지를 보낼 때이 속성을 설정 합니다. 메시지 큐 메시지는 다음 형식 중 하나입니다.  
  
-   `Normal`를 애플리케이션에서 큐로 보낸 일반 메시지 또는 응답 메시지를 보내는 애플리케이션에 반환 합니다.  
  
-   `Acknowledgement`를 메시지 큐 송신 애플리케이션에서 요청할 때마다 생성 됩니다. 예를 들어 메시지 큐는 원본 메시지가 도착하거나 원본 메시지를 읽었다는 것을 나타내는 긍정 또는 부정 메시지를 생성할 수 있습니다. 메시지 큐는 보내는 애플리케이션이 지정한 관리 큐에 적절한 승인 메시지를 반환합니다.  
  
-   `Report`를 메시지 큐 보고 큐가 소스 큐 관리자에서 정의 될 때마다 생성 됩니다. 추적 기능이 활성화되어 있으면 원본 메시지가 메시지 큐 서버에 들어가거나 나올 때마다 메시지 큐는 보고서 큐에 보고 메시지를 보냅니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.MessageType%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.MessageType" /> 속성입니다.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 큐에 배치하는 위치를 결정하는 메시지 우선 순위를 가져오거나 설정합니다.</summary>
        <value>중 하나는 <see cref="T:System.Messaging.MessagePriority" /> 비트랜잭션 메시지의 우선 순위 수준을 나타내는 값입니다. 기본값은 <see langword="Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> 어떻게 메시지 큐 메시지를 처리 목적지에 도착 하는 동안 하는 속성에 영향을 줍니다. 높은 우선 순위의 메시지는 보내는 동안 우선 순위가 부여되고 대상 큐의 앞 부분에 삽입됩니다. 우선 순위가 같은 메시지는 도착 시간에 따라 큐에 배치됩니다.  
  
 비트랜잭션 메시지에 대해서만 우선 순위를 설정할 수 있습니다. 트랜잭션 메시지에 대 한 우선 순위를 자동으로 설정 하는 메시지 큐 `Lowest`, 무시할 트랜잭션 메시지 우선 순위에 이르게 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에 다른 우선 순위 2 메시지를 보내고 이후에 검색 합니다.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Priority" /> 속성입니다.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 컴퓨터 오류 또는 네트워크 문제가 발생할 경우 배달할 보장 되는지 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value><see langword="true" /> (메시지를 보내는 동안 디스크에 저장)를 통해 해당 메시지의 배달이 보장 되; <see langword="false" /> 되는 경우. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A> 속성 메시지 배달 보장 되는지 여부를-컴퓨터가 메시지가 대상 큐에는 충돌 하는 경우에 나타냅니다.  
  
 메시지 배달을 보장 되는 경우 메시지는 로컬로 저장 경로의 모든 단계에서 다음 컴퓨터를 성공적으로 전달 될 때까지. 설정 된 <xref:System.Messaging.Message.Recoverable%2A> 속성을 `true` 처리량에 영향을 줄 수 있습니다.  
  
 트랜잭션 메시지 이면 메시지 큐 메시지의 값에 관계 없이 복구할 수 있는 여 <xref:System.Messaging.Message.Recoverable%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.Recoverable%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.Recoverable" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션에서 생성한 응답 메시지를 받는 큐를 가져오거나 설정합니다.</summary>
        <value>애플리케이션에서 생성한 응답 메시지가 반환되는 <see cref="T:System.Messaging.MessageQueue" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> 수신 애플리케이션이 보내는 애플리케이션에 반환 하는 애플리케이션에서 생성 한 응답 메시지를 받는 큐를 식별 하는 속성입니다. 보내는 애플리케이션은 메시지를 보낼 때 응답 큐를 지정합니다. 사용 가능한 모든 큐는 응답 큐로 지정할 수 있습니다.  
  
 응답 큐에 반환된 메시지는 애플리케이션 관련 메시지입니다. 해당 애플리케이션에서는 메시지의 내용뿐만 아니라 메시지를 받을 때 취할 동작을 정의해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.ResponseQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.ResponseQueue" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지에 대 한 보안 컨텍스트를 가져오거나 설정 합니다.</summary>
        <value><see cref="T:System.Messaging.SecurityContext" /> 속성이 이전에 설정 된 경우 메시지에 대 한 보안 컨텍스트를 포함 하는 개체, 그렇지 않으면 NULL입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 인증에 사용 된 보안 인증서를 가져오거나 설정 합니다.</summary>
        <value>메시지 큐 메시지의 보낸 사람을 확인 하는 보안 인증서를 나타내는 바이트 값의 배열입니다. 기본값은 길이가 0 인 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 수신 애플리케이션이 사용 하는 <xref:System.Messaging.Message.SenderCertificate%2A> 메시지에 외부 보안 인증서를 포함 하는 경우 속성입니다.  
  
 메시지 큐 내부 또는 외부 보안 인증서를 사용 하 여 메시지를 인증할 수 있습니다. 메시지 큐는 메시지 무결성을 확인 하는 데 사용 되는 내부 인증서를 제공 합니다. 인증 기관을 통해 액세스할 수 있는 외부 인증서를 제공 합니다 <xref:System.Messaging.Message.SenderCertificate%2A> 메시지의 속성입니다. 메시지를 인증할 메시지 큐를 허용 하는 것 외에도 외부 인증서를 받는 애플리케이션 보낸 사람에 게 추가 확인을 허용 합니다. 내부 인증서에 수신 애플리케이션에 사용할 수 없는 값입니다.  
  
 외부 인증서를 메시지 큐 시스템의 디렉터리 서비스를 사용 하 여 등록 되어야 합니다. 외부 인증서를 인증 기관 인증서 사용자, 공개 키 인증서 사용자 및 인증 기관의 서명, 인증서의 유효 기간에 대 한 정보를 포함합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.SenderCertificate" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보내는 사용자의 식별자를 가져옵니다.</summary>
        <value>보낸 사람을 식별 하는 바이트 값의 배열입니다. 수신 큐 관리자 및 큐에 대 한 액세스 권한을 보낸 사람의 메시지 보낸 사람을 확인 하려면 메시지를 인증할 때 식별자를 사용 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Messaging.Message.AttachSenderId%2A> 속성은 `false`에 지정 된 보낸 사람 식별자는 <xref:System.Messaging.Message.SenderId%2A> 속성은 전송 될 때 메시지에 첨부 하지. 표시 메시지 큐 대상 큐로 메시지를 보낼 때 보낸 사람에 게 확인 하지 않음이 됩니다. 경우는 <xref:System.Messaging.Message.AttachSenderId%2A> 속성은 `true`, <xref:System.Messaging.Message.SenderId%2A> 메시지가 인증 되었는지 하는 경우에 신뢰할 수 있는 속성 값이 있습니다. 사용 합니다 <xref:System.Messaging.Message.Authenticated%2A> 속성과 함께 <xref:System.Messaging.Message.SenderId%2A> 속성을 통해 보낸 사람의 액세스 권한을 확인 합니다.  
  
 커넥터 애플리케이션은 메시지 큐와 큐 다른 시스템 간의 통신을 제공 하는 커넥터 서버를 사용 하는 애플리케이션. 메시지 큐에 보낸 사람 id를 제공 하려면 커넥터 애플리케이션에 필요 합니다. 설정 해야 합니다는 <xref:System.Messaging.Message.ConnectorType%2A> 커넥터 애플리케이션을 통해 메시지를 보낼 때 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.SenderId" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐 메시지를 보내는 데의 버전을 가져옵니다.</summary>
        <value>메시지 큐 메시지를 보내는 데의 버전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> 속성은 특정 기능에 대 한 중요 합니다. 예를 들어, 트랜잭션 처리는만 Message Queuing 2.0 이상에서 지원 하 고 디지털 서명을 MSMQ 1.0에서 보낸 메시지를 인증할 사용 됩니다.  
  
 전송 큐 관리자 집합의 <xref:System.Messaging.Message.SenderVersion%2A> 메시지를 보낼 때 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.SenderVersion%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.SenderVersion" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보내는 컴퓨터의 소스 큐 관리자가 메시지를 보낸 날짜 및 시간을 가져옵니다.</summary>
        <value><see cref="T:System.DateTime" /> 메시지를 보낸 시간을 나타내는입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A> 속성은이 컴퓨터의 현지 시간으로 조정 됩니다의 인스턴스는 <xref:System.Messaging.Message> 클래스를 만들었습니다. 이 표준 시간대는 원본 및 대상 큐를 다른 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.SentTime%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.SentTime" /> 속성입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 원본이 되는 컴퓨터를 가져옵니다.</summary>
        <value>메시지를 보낸 컴퓨터의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식의 합니다 <xref:System.Messaging.Message.SourceMachine%2A> 속성 앞에 두 개의 슬래시를 포함 하지 않습니다 (\\\\). 예를 들어 `myServer` 유효한 <xref:System.Messaging.Message.SourceMachine%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.SourceMachine%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.SourceMachine" /> 속성입니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">컴퓨터 정보 또는 디렉터리 서비스에 액세스할 수 없습니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 대상 큐에서 수신 하는 데 최대 기간을 가져오거나 설정 합니다.</summary>
        <value>보낸 메시지를 대상 큐에서 받는 총 시간입니다. 기본값은 <see cref="F:System.Messaging.Message.InfiniteTimeout" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성 보낸 메시지를 대상 큐에서 받는 총 시간을 지정 합니다. 제한 시간 대상 큐에 메시지가 수신 되기 전에 큐에 대기 시간을 검색 하는 데 걸린 시간을 포함 합니다.  
  
> [!CAUTION]
>  종속 클라이언트 컴퓨터를 사용 하는 경우 메시지 큐를 실행 하는 서버의 클록을 사용 하 여 클라이언트 컴퓨터의 시계가 동기화 해야 합니다. 그렇지 않으면 예기치 않은 동작이 발생할 수 있습니다 메시지를 보낼 때 해당 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성은 <xref:System.Messaging.Message.InfiniteTimeout>합니다.  
  
 으로 지정한 간격이 하는 경우는 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성 메시지 큐에서 제거 되기 전에 만료, 두 가지 방법 중 하나에서 메시지를 메시지 큐 삭제 합니다. 메시지의 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성이 `true`이면 배달 못 한 편지 큐로 메시지가 보내집니다. 하는 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 는 `false`, 메시지가 무시 됩니다.  
  
 메시지의 설정할 수 있습니다 <xref:System.Messaging.Message.AcknowledgeType%2A> 타이머가 만료 되기 전에 메시지를 검색 되지 않으면 속성을 메시지를 보내도록 메시지 큐는 부정 승인을 다시 보내는 애플리케이션입니다.  
  
 지정 된 값을 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성을 사용 하면 지정 된 값 보다 작습니다를 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성을 <xref:System.Messaging.Message.TimeToBeReceived%2A> 우선적으로 적용 합니다.  
  
 단일 트랜잭션에서 여러 개의 메시지를 보내면 메시지 큐에서 사용 하 여 <xref:System.Messaging.Message.TimeToBeReceived%2A> 첫 번째 메시지의 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException">지정 된 값 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 올바르지 않습니다.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 큐에 도달하기까지의 최대 시간을 가져오거나 설정합니다.</summary>
        <value>메시지가 대상 큐에 도달 하는 데 시간 제한 시간에서 메시지 부터는 보내집니다. 기본값은 <see cref="F:System.Messaging.Message.InfiniteTimeout" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 으로 지정한 간격이 하는 경우는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성 만료 메시지 대상에 도달 하기 전에, 메시지 큐 두 가지 방법 중 하나에서 메시지를 삭제 합니다. 메시지의 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성이 `true`이면 배달 못 한 편지 큐로 메시지가 보내집니다. 하는 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 는 `false`, 메시지는 무시 됩니다.  
  
 메시지의 설정할 수 있습니다 <xref:System.Messaging.Message.AcknowledgeType%2A> 타이머가 만료 되기 전에 메시지가 도착 하지 않으면 속성을 메시지를 보내도록 메시지 큐는 부정 승인을 다시 보내는 애플리케이션입니다.  
  
 경우는 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성을 0 초로 설정 하면 메시지 큐가 한 번 해당 대상으로 메시지를 보낼 큐 메시지에 대 한 대기 중인 경우. 큐는 로컬 메시지를 항상 큐에 도달 합니다.  
  
 하 여 지정 된 값을 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성에 지정 된 값 보다 큽니다.는 <xref:System.Messaging.Message.TimeToBeReceived%2A> 속성을 <xref:System.Messaging.Message.TimeToBeReceived%2A> 우선적으로 적용 합니다.  
  
 단일 트랜잭션에서 여러 개의 메시지를 보내면 메시지 큐에서 사용 하 여 <xref:System.Messaging.Message.TimeToReachQueue%2A> 첫 번째 메시지의 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.TimeToReachQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 속성입니다.</exception>
        <exception cref="T:System.ArgumentException">지정 된 값 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 올바르지 않습니다. 음수를 나타낼 수도 있습니다.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지가 일부인 트랜잭션의 식별자를 가져옵니다.</summary>
        <value>메시지에 연결 된 트랜잭션에 대 한 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 애플리케이션 사용 하 여 수신 된 <xref:System.Messaging.Message.TransactionId%2A> ; 속성을 특정 트랜잭션의 일부로 메시지를 보냈음을 확인 합니다. 트랜잭션 식별자 뒤에 4 바이트 트랜잭션 시퀀스 번호를 보내는 컴퓨터 (첫 번째 16 비트)의 식별자를 포함 합니다.  
  
 이 속성이 이상 메시지 큐 버전 2.0에 대해서만 사용할 수 있습니다.  
  
 트랜잭션 식별자는 같지 않을 고유한 트랜잭션 시퀀스 번호는 지속적이 지 이므로 2에서 다시 시작 됩니다 <sup>20</sup>합니다. 메시지 큐는 후속 트랜잭션은 다른 트랜잭션의 시퀀스 번호 되어만 보장 합니다.  
  
 사용할 수는 <xref:System.Messaging.Message.TransactionId%2A> 와 함께 속성을 <xref:System.Messaging.Message.IsFirstInTransaction%2A> 및 <xref:System.Messaging.Message.IsLastInTransaction%2A> 트랜잭션 경계를 확인 하는 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.TransactionId%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.TransactionId" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>원본 컴퓨터의 트랜잭션 상태 큐를 가져옵니다.</summary>
        <value>보내는 애플리케이션으로 승인 메시지를 다시 보내는 데 사용되는 소스 컴퓨터의 트랜잭션 상태 큐입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> 커넥터 애플리케이션에서 읽기-수신 확인을 수신 하는 원본 컴퓨터에서 트랜잭션 큐를 식별 하는 속성입니다. 메시지 큐의 속성을 설정 하 고 커넥터 애플리케이션 외부 큐로 보낸 트랜잭션 메시지를 검색할 때 속성을 사용 합니다.  
  
 외부 큐 Microsoft Message Queuing 이외의 큐 시스템에 존재합니다. 커넥터 애플리케이션을 통해 이러한 큐를 사용 하 여 메시지 큐는 통신합니다.  
  
 커넥터 애플리케이션 트랜잭션 상태 큐를 사용 하 여 보내는 애플리케이션에 다시 승인 메시지를 전송할 수 있습니다. 트랜잭션 상태 큐는 보내는 애플리케이션에서 다른 승인을 요청 하지 않는 경우에 이러한 승인을 받아야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지의 값을 표시 <xref:System.Messaging.Message.TransactionStatusQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지를 보내지 않은 합니다. 이 속성은 큐에서 검색 된 메시지 에서만 읽을 수 있습니다.  
  
또는 
메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정 하는 값을 가져오거나 설정 합니다. 메시지 되었습니다 (여부 이어야 합니다)를 보내기 전에 인증 합니다.</summary>
        <value>보내는 애플리케이션에서 메시지에 대한 인증을 요청하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> 속성 메시지를 인증 해야 하는지 여부를 지정 합니다. 보내는 애플리케이션 인증을 요청 하는 경우 메시지 큐 디지털 서명을 만들고 전송 된 메시지에 서명 하 고 수신 되 면 메시지를 인증 하는 데 사용 합니다.  
  
 하는 경우 <xref:System.Messaging.Message.UseAuthentication%2A> 는 `false` 인증 된 메시지만 허용 하는 큐에 메시지를 큐에 도달 하면 메시지는 거부 됩니다.  
  
 해당 속성을 보면 메시지가 인증 실패를 확인할 수 없습니다. 메시지 큐는 큐에 메시지가 배달 되기 전에 이러한 메시지를 삭제 합니다. 그러나 배달이 실패 메시지를 큐에 도착 하는 것을 방지 한 경우 승인 메시지를 보내도록 요청할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.UseAuthentication" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>배달 못 한 편지 큐로 배달할 수 없는 메시지의 복사본을 보낼지 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value><see langword="true" /> 메시지의 배달이 실패를 배달 못 한 편지 큐로 송신할 메시지의 복사본을 유발 하는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Messaging.Message.UseJournalQueue%2A> 고 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성 메시지 큐 메시지를 추적 하는 방법을 지정 합니다. 하는 경우 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 는 `true`, (비트랜잭션 메시지의 경우)의 배달이 실패 하면 메시지가 메시지를 배달 하지 못한 컴퓨터 비트랜잭션 배달 못 한 편지 큐로 전송 합니다. 배달 하지 못한 메시지 타이머가 만료 되는 경우 예를 들어 때문일 수 있습니다.  
  
 트랜잭션 메시지를 배달 하지 못한 경우 메시지 큐 모든 음수이 고 의심 스러운 경우에서 원본 컴퓨터 트랜잭션 배달 못 한 편지 큐로 메시지를 보냅니다.  
  
 배달 못 한 편지 큐에서 메시지를 저장할 때 정기적으로 메시지를 제거 하는 더 이상 필요 없는 큐의 선택을 취소 해야 합니다. 메시지 큐가 있는 컴퓨터에 대 한 크기 할당량에 대 한 배달 못 한 편지 큐 수에 저장 합니다. 컴퓨터 할당량 관리자가 설정 되 고 전체 컴퓨터 뿐 아니라 단일 큐의에서 메시지를 저장 하는 데 할당 된 크기를 나타냅니다.  
  
 저널 또는 배달 못 한 편지 큐를 만들지 마십시오. 이 메시지 큐를 생성 하는 두 시스템 큐입니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 비공개로 설정 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value>메시지 큐에서 메시지를 암호화하도록 요청하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개인 메시지의 경우 해당 본문을 보내고 받을 때 암호 해독 하기 전에 암호화 됩니다. 개인 메시지를 보내려고 보내는 애플리케이션에서 암호화를 사용 하도록 지정 해야 하 고, 필요에 따라 암호화 알고리즘입니다.  
  
 개인 메시지를 보내는 애플리케이션 메시지 암호화를 수행할 필요가 없습니다. 애플리케이션 디렉터리 서비스에 대 한 액세스 권한이 있는 Microsoft Windows 2000 enterprise, 메시지를 보내는 경우 메시지 큐를 메시지 본문을 암호화할 수 있습니다. 개인 메시지를 받을 때 수신 큐 관리자는 항상 메시지 본문을 해독 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.UseEncryption%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.UseEncryption" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지의 복사본을 원래 컴퓨터의 컴퓨터 업무 일지에 유지할지 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value><see langword="true" /> 메시지 뒤에 해당 메시지의 복사본이 원래 컴퓨터의 컴퓨터 업무 일지에 보관 하도록 요청 전송한 (다음 서버에 원본 컴퓨터)에서; 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Messaging.Message.UseJournalQueue%2A> 고 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성 메시지 큐 메시지를 추적 하는 방법을 지정 합니다. 하는 경우 <xref:System.Messaging.Message.UseJournalQueue%2A> 는 `true`, 다음 복사본이 메시지가 전송 되는 각 단계에서 원본 컴퓨터의 컴퓨터 업무 일지에 보관 됩니다.  
  
 전송된 된 메시지 대상 큐가 원격 컴퓨터의 경우에 업무 일지 큐에 복사 됩니다. 메시지를 큐에 직접 보내집니다 대상 로컬 컴퓨터의 경우 저널링 할 중간 단계가 있습니다.  
  
 업무 일지 큐에 메시지를 저장할 때 큐 메시지는 더 이상 필요 없는 제거를 주기적으로 지웁니다. 메시지 큐가 있는 컴퓨터에 대 한 할당량에 대 한 업무 일지 큐 수에 저장 합니다. (컴퓨터 할당량 관리자가 설정 됩니다.)  
  
 저널 또는 배달 못 한 편지 큐를 만들지 마십시오. 이 메시지 큐를 생성 하는 두 시스템 큐입니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.UseJournalQueue%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.UseJournalQueue" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>대상 큐로 이동할 때 메시지를 추적할지 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value><see langword="true" /> 각 중간 단계는 원본 메시지를 이동 하는 과정에서 대상 큐로 시스템의 보고서 큐로 전송할 보고서를 생성 하는 경우 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> 속성 대상 큐로 이동할 때 메시지의 경로 추적할지 여부를 지정 합니다. 경우 `true`, 메시지 큐 라우팅 서버를 통해 메시지가 전달 될 때마다 보고서 큐로에 (메시지 큐에서 생성) 하는 보고서 메시지가 발송 됩니다. 보고서 큐를 사용 하는 소스 큐 관리자에서 지정 됩니다. 보고서 큐 메시지 큐에서 생성 된 메시지를 보고 하려면 제한 되지 않습니다. 애플리케이션에서 생성 된 메시지는 또한 보고서 큐로 보낼 수 있습니다.  
  
 추적을 사용 하 여 Active Directory를 설정 하 고 메시지 큐 엔터프라이즈를 위한 보고서 큐를 지정 해야 합니다. 관리자는 이러한 설정을 구성합니다.  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지의 값을 설정 <xref:System.Messaging.Message.UseTracing%2A> 속성입니다.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메시지 큐를 무시 하도록 필터링 됩니다는 <see cref="P:System.Messaging.Message.UseTracing" /> 속성입니다.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>
