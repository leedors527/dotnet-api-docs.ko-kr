<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a914a8824c1f787c1a3c58550df7e14134e3fa46" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58562305" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>앞으로만 이동 가능한 커서를 제공하여 메시지 큐에 있는 메시지를 열거합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Messaging.MessageEnumerator> 큐의 메시지를 사용 하 여 동적 상호 작용 합니다. 메서드를 통해 사용할 수는 <xref:System.Messaging.MessageQueue> 클래스 중 하나를 반환할 수는 <xref:System.Messaging.MessageEnumerator> 가리키는 큐에 배열 시 큐의 특정된 시점 스냅숏에 복사본을 포함 하는 메시지의 동적 목록이 지정된 된 메서드를 호출한 합니다.  
  
 정적 스냅샷 달리 열거자를 사용 하면 컬렉션을 수정할 수 있습니다. 사용 하는 <xref:System.Messaging.MessageEnumerator>, 큐에서 메시지를 제거할 수 있습니다 및 큐에 변경 내용이 즉시 반영 됩니다.  
  
 열거자는 큐를 쿼리할 때 메시지 큐에서 제거 되지 않습니다. 현재 커서 위치에 있는 메시지에 대 한 정보를 반환 하지만 큐에서 해당 메시지를 유지 합니다.  
  
 <xref:System.Messaging.MessageEnumerator> 동적 목록 헤드에 초기화 하는 커서입니다. 목록 순서가 큐에서 메시지의 순서가 동일 메시지 우선 순위에 따라 합니다. 호출 하 여 첫 번째 메시지를 큐에 커서를 이동할 수 있습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A>합니다. 열거자가 초기화 된 후 사용할 수 있습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 나머지 메시지를 단계별로 진행 합니다. 제한 시간을 전달 하 여 사용할 수 있으려면 메시지를 기다려야 하는지 여부를 지정할 수 있습니다는 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 메서드.  
  
 열거자 동적 이기 때문에 (예를 들어 낮은 우선 순위)로 인해 커서의 현재 위치 뒤에 추가 된 메시지를 열거자에서 액세스할 수 있습니다. 커서의 현재 위치에 액세스할 수 없습니다 전에 삽입 되는 메시지입니다. 여 뒤로 이동 하는 것이 불가능 한 <xref:System.Messaging.MessageEnumerator>합니다. 커서는 정방향 전용 이동할 수 있습니다. <xref:System.Messaging.MessageEnumerator.Reset%2A> 메서드를 사용 하면 다시 큐의 시작 부분에 커서를 놓습니다.  
  
 인스턴스의 <xref:System.Messaging.MessageEnumerator> 특정된 큐에 대 한 독립적으로 작동 합니다. 두 개를 만들 수 있습니다 <xref:System.Messaging.MessageEnumerator> 동일한 큐에 적용 되는 인스턴스. 변경 내용을 하나 <xref:System.Messaging.MessageEnumerator> 큐의 메시지에 게 즉시 반영 됩니다에 두 번째 열거자가 첫 번째 앞에 위치 하는 경우. 그러나 두 열거자는 동일한 위치에 있고 해당 위치에서 메시지를 제거 하는 중에 하는 경우 예외가 throw 됩니다 다른 열거자의 값을 가져오려고 시도 하는 경우는 <xref:System.Messaging.MessageEnumerator.Current%2A> 지금 삭제 메시지의 속성입니다.  
  
> [!NOTE]
>  인스턴스를 만들면 <xref:System.Messaging.MessageQueue> 사용 하 여 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> 로 `true`, 큐에 연결 해야 하는 동안 다른 응용 프로그램에 열거자에 메시지를 수정할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 큐에서 메시지의 동적 목록을 가져옵니다 및 포함 된 모든 메시지를 계산 합니다 <xref:System.Messaging.Message.Priority%2A> 속성이 설정 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>합니다.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 열거자와 관련된 리소스를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 운영 체제는 큐에 대해 열린 핸들이 커서의 수명 동안 유지합니다. 열거자를 사용 하 여 작업을 마치면 호출 <xref:System.Messaging.MessageEnumerator.Close%2A> 핸들과 연관 하 여 리소스를 해제 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 열거자가 가리키는 현재 <see cref="T:System.Messaging.Message" />를 가져옵니다.</summary>
        <value>현재 메시지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열거자가 만들어진 첫 번째 메시지 앞에 큐의 헤드를 가리킵니다. 이 경우 <xref:System.Messaging.MessageEnumerator.Current%2A> 잘못 되었으며 액세스 하는 경우 예외가 throw 됩니다. 호출 해야 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 를 큐에 첫 번째 메시지에 커서를 놓습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.MessageEnumerator.Current" />를 처음 호출하기 전에 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />를 호출하여 즉, 커서가 메시지 열거형의 첫 번째 요소 앞에 배치된 경우  
  
또는 
<see cref="P:System.Messaging.MessageEnumerator.Current" />를 호출하여 <see langword="false" />를 반환한 후에 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />를 호출한 경우(커서가 메시지 열거형의 마지막 요소 뒤에 배치됨을 나타냄)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">열거자가 현재 가리키고 있는 메시지가 더 이상 없는 경우 삭제되었을 수 있습니다.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 메시지를 찾는 데 사용되는 네이티브 메시지 큐 커서 핸들을 가져옵니다.</summary>
        <value>기본 커서 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 열거형 기본 핸들을 포함합니다. 열거자를 사용 하 여 작업을 마치면 호출 <xref:System.Messaging.MessageEnumerator.Close%2A> 이 리소스를 해제 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">핸들이 없는 경우</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageEnumerator" />에서 사용하는 리소스를 해제합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageEnumerator" />에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Messaging.MessageEnumerator.Dispose%2A> 에서 사용 하는 리소스는 <xref:System.Messaging.MessageEnumerator> 다른 용도로 다시 할당 될 수 있습니다. 에 대 한 자세한 내용은 <xref:System.Messaging.MessageEnumerator.Dispose%2A>를 참조 하세요 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">관리되지 않는 리소스 정리</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary><see cref="T:System.Messaging.MessageEnumerator" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 <xref:System.Messaging.MessageEnumerator.Dispose%2A> 메서드 및 <xref:System.Object.Finalize%2A> 메서드. `Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드를 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A> 호출 `Dispose` 사용 하 여 `disposing` 로 `false`합니다.  
  
 `disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Messaging.MessageEnumerator>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다. 이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />는 다른 개체에서 여러 번 호출할 수 있습니다. <see langword="Dispose(Boolean)" />를 재정의할 때 이전 <see langword="Dispose" /> 호출에서 삭제된 개체를 참조하지 않도록 주의하십시오. 구현 하는 방법에 대 한 자세한 내용은 <see langword="Dispose" />를 참조 하세요 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see langword="Finalize" />를 참조 하십시오 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Finalize 메서드 재정의](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))합니다.</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Dispose 메서드 구현</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">관리되지 않는 리소스 정리</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>열거자에서 보유하는 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
이 메서드는 <xref:System.Object.Finalize>를 재정의합니다. 응용 프로그램 코드는이 메서드를 호출 하지 개체의 Finalize 메서드를 호출 하 여 가비지 수집기에 의해 종료를 사용 하지 않도록 설정 된 경우가 아니면 자동으로 가비지를 수집 하는 동안 호출 됩니다는 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 메서드.

자세한 내용은 [Finalize 메서드 및 소멸자](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100))를 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md), 및 [Finalize 메서드 재정의](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))합니다.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>열거자를 큐의 다음 메시지로 이동합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가능한 경우 열거자를 큐의 다음 메시지로 이동합니다.</summary>
        <returns>열거자가 성공적으로 다음 메시지로 이동하면 <see langword="true" />를 반환하고, 큐의 끝에 도달하면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 큐에 메시지가 없는 경우 즉시 반환 됩니다. 지정 된 대기 하는 다른 오버 로드가 <xref:System.TimeSpan> 메시지 도착에 대 한 합니다.  
  
 큐가 비어 있거나 컬렉션에서 마지막 요소 뒤로 이동 했기 때문에 메시지를 현재 사용할 수 없는 경우 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 반환 `false` 호출 방법입니다.  
  
 를 만들면는 개념적으로 열거자가 첫 번째 메시지 큐 및 처음 호출 하기 전에 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 뷰로 큐의 첫 번째 메시지를 가져옵니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐에 대한 특정 예외가 throw된 경우</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">열거자가 큐의 끝에 배치되는 경우 메시지를 사용할 수 있을 때까지 대기하는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>열거자를 큐의 다음 메시지로 이동합니다. 열거자가 큐의 끝에 배치되는 경우 <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />는 메시지를 사용할 수 있거나 지정된 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>열거자가 다음 메시지로 이동하면 <see langword="true" />를 반환하고, 해당 열거자가 큐의 끝에 도달하고 <paramref name="timeout" /> 매개 변수에서 지정한 시간 내에 메시지를 사용할 수 없으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드에는 큐에 메시지가 없는 경우 또는 커서 큐의 끝에 도달한 경우 대기 합니다. 큐가 비어 있거나 컬렉션에서 마지막 요소 뒤로 이동 했기 때문에 메시지를 현재 사용할 수 없는 경우 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 지정된 된 제한 시간을 대기 합니다.  
  
 커서가 이미 큐의 끝에 있으면 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 만 반환 `true` 보다 우선 순위가 낮은 모든 메시지가 현재 큐에 지정된 된 시간 간격 내에서 새 메시지가 도착 하면 및 큐의 끝에 배치 됩니다. 매개 변수가 없는 오버 로드는 더 이상 메시지가 큐에 있는 경우 즉시 반환 됩니다.  
  
 를 만들면는 개념적으로 열거자가 열거형 및 첫 번째 호출의 첫 번째 메시지 앞 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 뷰로 열거형의 첫 번째 메시지를 제공 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">제한 시간 매개 변수에 지정된 값이 올바르지 않은 경우 (예: 음수가 지정된 경우)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐에 대한 특정 예외가 throw된 경우  
  
또는 
제한 시간이 만료된 경우</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 메시지를 제거하면 큐에서도 해당 메시지가 삭제됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 오버 로드에 대해 설명 된 동작을 적용할 수 경우에만 합니다 <xref:System.Messaging.MessageEnumerator> 인스턴스를 사용 하 여 검색 하는 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>합니다. 사용 하지 마세요 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 의 인스턴스를 검색 <xref:System.Messaging.MessageEnumerator> 으로이 메서드는 사용 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>트랜잭션 큐 및 비트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 커서의 현재 위치에서 메시지를 반환 합니다.  
  
 큐 저널링을 사용 하는 경우 처럼 업무 일지 큐에 유지 해야 하는 복사 하면 메시지를 제거 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 하지 않습니다.  
  
 현재 메시지를 제거 하면 커서는 다음 메시지로 이동 합니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.  
  
 트랜잭션 큐에이 오버 로드를 호출 하는 경우 메시지 큐는 단일 내부 트랜잭션을 만듭니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">메시지가 제거되는 트랜잭션을 지정하는 <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체입니다.</param>
        <summary>트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다 `transaction` 매개 변수입니다.  
  
 큐 저널링을 사용 하는 경우 처럼 업무 일지 큐에 유지 해야 하는 복사 하면 메시지를 제거 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 하지 않습니다.  
  
 트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐로 작업할 때 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다. 제거는 트랜잭션이 커밋될 때까지 복구할 수 없는 아닙니다.  
  
 현재 메시지를 제거 하면 커서는 다음 메시지로 이동 합니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 큐에 도착하는 메시지에 대해 제한 시간이 지정되지 않았습니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 정의한 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다 `transactionType` 매개 변수입니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 큐 저널링을 사용 하는 경우 처럼 업무 일지 큐에 유지 해야 하는 복사 하면 메시지를 제거 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 하지 않습니다.  
  
 트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐로 작업할 때 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다. 제거는 트랜잭션이 커밋될 때까지 복구할 수 없는 아닙니다.  
  
 현재 메시지를 제거 하면 커서는 다음 메시지로 이동 합니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">큐에 메시지가 도착할 때까지 대기하는 시간 간격입니다.</param>
        <summary>큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다. 제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 커서의 현재 위치에서 메시지를 반환 합니다. 메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐 끝에 있는 경우는 `timeout` 매개 변수가 만료 되었습니다.  
  
 큐 저널링을 사용 하는 경우 처럼 업무 일지 큐에 유지 해야 하는 복사 하면 메시지를 제거 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 하지 않습니다.  
  
 현재 메시지를 제거 하면 커서는 다음 메시지로 이동 합니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.  
  
 트랜잭션 큐에이 오버 로드를 호출 하는 경우 메시지 큐는 단일 내부 트랜잭션을 만듭니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료된 경우</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지가 제거될 때까지 대기하는 시간 간격입니다.</param>
        <param name="transaction">메시지의 트랜잭션 컨텍스트를 지정하는 <see cref="T:System.Messaging.MessageQueueTransaction" /> 개체입니다.</param>
        <summary>트랜잭션 큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다. 제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 커서의 현재 위치에서 메시지를 반환 합니다. 메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐 끝에 있는 경우는 `timeout` 매개 변수가 만료 되었습니다.  
  
 트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐로 작업할 때 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다. 제거는 트랜잭션이 커밋될 때까지 복구할 수 없는 아닙니다.  
  
 큐 저널링을 사용 하는 경우 처럼 업무 일지 큐에 유지 해야 하는 복사 하면 메시지를 제거 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 하지 않습니다.  
  
 현재 메시지를 제거 하면 커서는 다음 메시지로 이동 합니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료된 경우</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지가 제거될 때까지 대기하는 시간 간격입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>큐에서 현재 메시지를 제거하고 호출 응용 프로그램에 해당 메시지를 반환합니다. 제거할 메시지가 있으면 메서드는 해당 메시지를 즉시 반환합니다. 제거할 메시지가 없으면 메서드는 새 메시지가 도착할 때까지 지정한 제한 시간 동안 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 제거 하 고 정의한 트랜잭션 컨텍스트를 사용 하 여 커서의 현재 위치에서 메시지를 반환 합니다 `transactionType` 매개 변수입니다. 메서드의이 오버 로드는 메시지를 사용할 수 있거나으로 지정한 간격이 될 때까지 대기 커서가 큐 끝에 있는 경우는 `timeout` 매개 변수가 만료 되었습니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 큐 저널링을 사용 하는 경우 처럼 업무 일지 큐에 유지 해야 하는 복사 하면 메시지를 제거 합니다 <xref:System.Messaging.MessageQueue> 클래스의 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 하지 않습니다.  
  
 트랜잭션 롤백 하면를 호출 하 여 제거 된 모든 메시지 트랜잭션 큐로 작업할 때 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 큐로 반환 되도록 합니다. 제거는 트랜잭션이 커밋될 때까지 복구할 수 없는 아닙니다.  
  
 현재 메시지를 제거 하면 커서는 다음 메시지로 이동 합니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료된 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 열거자가 큐의 처음을 가리키도록 다시 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열거자는 앞쪽 방향 으로만 이동할 수 있습니다. 이 메서드를 사용 하 여 큐의 시작 부분부터 시작 합니다.  
  
 호출 후 <xref:System.Messaging.MessageEnumerator.Reset%2A>, 커서가 첫 번째 메시지를 가리킵니다. 호출할 필요가 없습니다 <xref:System.Messaging.MessageEnumerator.MoveNext%2A> 호출한 후 <xref:System.Messaging.MessageEnumerator.Reset%2A> 첫 번째 메시지를 큐에 커서를 앞으로 이동 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 커서 위치에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</summary>
        <value>현재 커서 위치에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Messaging.MessageEnumerator.MoveNext" />를 처음 호출하기 전에 이 속성에 액세스한 경우. 커서가 메시지 열거형의 첫 번째 요소 앞에 있는 경우 -또는- <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />를 호출하여 false가 반환된 후에 이 속성에 액세스한 경우(커서가 메시지 열거형의 마지막 요소 뒤에 위치함을 나타냄)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">열거자가 현재 가리키고 있는 메시지가 더 이상 없는 경우 삭제되었을 수 있습니다.</exception>
      </Docs>
    </Member>
  </Members>
</Type>