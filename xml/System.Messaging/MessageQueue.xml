<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c8808f9b24a0033f7e651cfb7ad822efd72cd1ca" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53300702" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>메시지 큐 서버에 있는 큐에 대한 액세스를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 기술을 실행 중인 애플리케이션을 서로 다른 시간에 유형이 다른 네트워크와 일시적으로 오프 라인 상태일 수 있는 시스템 간에 통신할 수 있습니다. 애플리케이션 송신, 수신 또는 피킹 큐에서 메시지 (제거 하지 않고 읽기). 메시지 큐의 선택적 구성 요소는 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 및 Windows NT 별도로 설치 해야 합니다.  
  
 <xref:System.Messaging.MessageQueue> 클래스는 메시지 큐 래퍼입니다. 메시지 큐를 사용 하 여 여러 버전의 <xref:System.Messaging.MessageQueue> 사용 중인 운영 체제에 따라, 클래스 약간 다른 동작이 발생할 수 있습니다. 메시지 큐의 각 버전의 특정 기능에 대 한 정보를 msdn에서 Platform SDK에서 "What is 메시지 큐에서 새" 항목을 참조 합니다.  
  
 <xref:System.Messaging.MessageQueue> 클래스는 메시지 큐에 대 한 참조를 제공 합니다. 경로 지정할 수 있습니다는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자는 기존 리소스에 연결할 서버에서 새 큐를 만들 수 있습니다. 호출 하기 전에 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, 또는 <xref:System.Messaging.MessageQueue.Receive%2A>의 새 인스턴스를 연결 해야 합니다는 <xref:System.Messaging.MessageQueue> 기존 큐를 사용 하 여 클래스입니다. 같은 큐 속성을 조작할 수는 해당 시점 <xref:System.Messaging.MessageQueue.Category%2A> 고 <xref:System.Messaging.MessageQueue.Label%2A>입니다.  
  
 <xref:System.Messaging.MessageQueue> 두 가지 유형의 메시지 검색을 지원 합니다: 동기 및 비동기입니다. 동기 메서드인 <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.Receive%2A>, 프로세스 스레드가 큐에 도착 하는 새 메시지에 대해 지정 된 시간 간격을 대기 합니다. 비동기 메서드는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 고 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 기본 애플리케이션 작업을 큐에 메시지가 도착할 때까지 별도 스레드에서 계속 허용 합니다. 이러한 메서드는 스레드 간의 의사 소통이 콜백 개체 및 상태 개체를 사용 하 여 작동 합니다.  
  
 새 인스턴스를 만들 때의 <xref:System.Messaging.MessageQueue> 클래스를 작성 하지 않으려면 새 큐입니다. 대신 사용할 수는 <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, 및 <xref:System.Messaging.MessageQueue.Purge%2A> 서버의 큐를 관리 하는 방법입니다.  
  
 와 달리 <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> 및 <xref:System.Messaging.MessageQueue.Delete%28System.String%29> 됩니다 `static` 멤버의 새 인스턴스를 만들지 않고 호출할 수 있습니다 이므로 <xref:System.Messaging.MessageQueue> 클래스.  
  
 설정할 수 있습니다 합니다 <xref:System.Messaging.MessageQueue> 개체의 <xref:System.Messaging.MessageQueue.Path%2A> 세 가지 이름 중 하나를 사용 하 여 속성: 이름, 합니다 <xref:System.Messaging.MessageQueue.FormatName%2A>, 또는 <xref:System.Messaging.MessageQueue.Label%2A>합니다. 큐의에 정의 된 이름이 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성은 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 공개 큐에 대 한 및 <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> 개인 큐에 대 한 합니다. <xref:System.Messaging.MessageQueue.FormatName%2A> 속성 메시지 큐 오프 라인 액세스를 허용 합니다. 마지막으로 큐의 사용할 수 있습니다 <xref:System.Messaging.MessageQueue.Label%2A> 큐의 설정 하려면 속성 <xref:System.Messaging.MessageQueue.Path%2A>합니다.  
  
 인스턴스의 초기 속성 값의 목록을 <xref:System.Messaging.MessageQueue>, 참조는 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름을 구문 형식을 사용 하 여 개체입니다. 각각의 경우에서 경로가 생성자에 정의 된 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 다음 코드 예제에서는 큐에 메시지를 보내고 라고 하는 애플리케이션 관련 클래스를 사용 하 여 큐에서 메시지를 받을 `Order`합니다.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>만 <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> 메서드는 스레드로부터 안전 합니다.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다. 기본 생성자가 새 인스턴스를 초기화하면, 이 인스턴스를 사용하기 전에 인스턴스의 <see cref="P:System.Messaging.MessageQueue.Path" /> 속성을 설정해야 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 인스턴스를 만들려면이 오버 로드를 사용 합니다 <xref:System.Messaging.MessageQueue> 즉시 큐 메시지 큐 서버에 연결 되지 않은 클래스입니다. 이 인스턴스를 사용 하기 전에 연결 해야 하는 기존 메시지 큐 설정 하 여는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다. 설정할 수 있습니다는 <xref:System.Messaging.MessageQueue> 에 대 한 참조를 <xref:System.Messaging.MessageQueue.Create%28System.String%29> 함으로써 새 메시지 큐를 만드는 메서드의 반환 값입니다.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 인스턴스화합니다는 <xref:System.Messaging.MessageQueue> ; 클래스는 새 메시지 큐를 만들지 않습니다.  
  
 다음 표에서 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다. 모든 필터 값으로 설정 됩니다 `true`합니다.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue>합니다.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치입니다.</param>
        <summary>지정된 경로에 있는 메시지 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 연결 하려는 경우이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue> 경로, 형식 이름 또는 레이블을 알고 특정 메시지 큐 인스턴스. 큐를 참조 하는 첫 번째 애플리케이션에 대 한 배타적 액세스 권한을 부여 하려는 경우 설정 해야 합니다는 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 속성을 `true` 또는 읽기 액세스 제한 매개 변수를 전달 하는 생성자를 사용 합니다.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 인스턴스화합니다는 <xref:System.Messaging.MessageQueue> ; 클래스는 새 메시지 큐를 만들지 않습니다. 새 큐를 만들려면 메시지 큐에서 사용 하 여 <xref:System.Messaging.MessageQueue.Create%28System.String%29>입니다.  
  
 구문의 `path` 매개 변수 유형에 따라 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 다음 표에 나와 있는 것 처럼 큐 경로 설명 합니다.  
  
|참조|구문|예|  
|---------------|------------|-------------|  
|형식 이름|`FormatName:` [ *형식 이름을* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|레이블|`Label:` [ *레이블* ]|`Label:` TheLabel|  
  
 오프 라인으로 작업 하면 형식 이름 구문을 하지 생성자에 대 한 경로 이름 구문을 사용 해야 합니다. 그렇지 않은 경우 주 도메인 컨트롤러를 형식 이름으로 경로 확인할 수 없기 때문에 예외가 throw 됩니다.  
  
 다음 표에서 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다. 이러한 값은 지정 된 경로 사용 하 여 메시지 큐의 속성에 기반을 `path` 매개 변수입니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`를 메시지 큐의 개인 정보 수준 설정 "본문" 이면 그렇지 않으면 `false`합니다.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|메시지 큐의 컴퓨터 이름 속성의 값입니다.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>를 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>를 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`를 메시지 큐 개체의 저널 설정을 사용 합니다. 그렇지 않으면 `false`합니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름을 구문 형식을 사용 하 여 개체입니다. 각각의 경우에서 경로가 생성자에 정의 된 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 유효하지 않습니다(예: 속성을 설정하지 않은 경우).</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="sharedModeDenyReceive">첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 경로에 위치하고 읽기 액세스 제한이 설정된 메시지 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 연결 하려는 경우이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue> 경로, 형식 이름 또는 레이블을 알고 특정 메시지 큐에 있습니다. 큐를 참조 하는 첫 번째 애플리케이션에 대 한 배타적 액세스 권한을 부여 하려는 경우, 설정 된 `sharedModeDenyReceive` 매개 변수를 `true`입니다. 그렇지 않으면 설정 `sharedModeDenyReceive` 하 `false` 만 있는 생성자를 사용 하거나는 `path` 매개 변수.  
  
 설정 `sharedModeDenyReceive` 에 `true` 메시지 큐를 다른 애플리케이션을 포함 하 여 액세스 하는 모든 개체에 영향을 줍니다. 매개 변수의 효과이 애플리케이션에 제한 되지 않습니다.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자의 새 인스턴스를 만듭니다는 <xref:System.Messaging.MessageQueue> ; 클래스는 새 메시지 큐를 만들지 않습니다. 새 큐를 만들려면 메시지 큐에서 사용 하 여 <xref:System.Messaging.MessageQueue.Create%28System.String%29>입니다.  
  
 구문의 `path` 매개 변수는 큐의 유형에 따라 다릅니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 또는 큐 경로 설명 하는 형식 이름 또는 메시지 큐의 레이블을 사용할 수 있습니다.  
  
|참조|구문|예|  
|---------------|------------|-------------|  
|형식 이름|`FormatName:` [ *형식 이름을* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|레이블|`Label:` [ *레이블* ]|`Label:` TheLabel|  
  
 오프 라인으로 작업을 이름 구문이 아니라, 형식 이름 구문을 사용 해야 합니다. 그렇지 않은 경우 (Active Directory 상주 하는) 주 도메인 컨트롤러를 형식 이름으로 경로 확인할 수 없기 때문에 예외가 throw 됩니다.  
  
 경우는 <xref:System.Messaging.MessageQueue> 큐를 사용 하 여는 `sharedModeDenyReceive` 매개 변수 설정 `true`모든 <xref:System.Messaging.MessageQueue> 이후에 큐에서 읽으려 할 때마다 생성 하는 <xref:System.Messaging.MessageQueueException> 공유 위반으로 인해 합니다. <xref:System.Messaging.MessageQueueException> 경우에 throw 되는 <xref:System.Messaging.MessageQueue> 다른 단독 모드로 큐에 액세스 하려고 <xref:System.Messaging.MessageQueue> 이미 큐에 대 한 비독점적 액세스 합니다.  
  
 다음 표에서 인스턴스에 대 한 초기 속성 값을 보여 줍니다. <xref:System.Messaging.MessageQueue>합니다. 이러한 값은 지정 된 경로 사용 하 여 메시지 큐 큐의 속성에 기초 합니다 `path` 매개 변수입니다.  
  
|속성|초기 값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.DefaultPropertiesToSend> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`를 메시지 큐의 개인 정보 수준 설정 "본문" 이면 그렇지 않으면 `false`합니다.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|메시지 큐의 컴퓨터 이름 속성의 값입니다.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|기본 생성자가 설정한 값은 <xref:System.Messaging.MessagePropertyFilter> 클래스입니다.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>를 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>를 생성자에 의해 설정 되지 않은 경우.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`sharedModeDenyReceive` 매개 변수의 값입니다.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`를 메시지 큐 개체의 저널 설정을 사용 합니다. 그렇지 않으면 `false`합니다.|  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 단독 액세스를 사용 하 여 해당 경로 설정 하 고 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 유효하지 않습니다(예: 속성을 설정하지 않은 경우).</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="sharedModeDenyReceive">첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="enableCache">연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 단독 액세스 및 연결 캐싱을 사용 하도록 설정 합니다.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 위치로, 로컬 컴퓨터로 지정하려면 "."을 사용합니다.</param>
        <param name="sharedModeDenyReceive">첫 번째로 큐에 액세스하는 응용 프로그램에 단독 읽기 권한을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="enableCache">연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="accessMode"><see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 액세스 모드를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Messaging.QueueAccessMode" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐에 대 한 기본 액세스 모드 `QueueAccessMode.SendAndReceive`생성자를 호출할 때 별도로 지정 하지 않으면, 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐가 인증된 메시지만 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>큐가 인증된 메시지만 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 인증에는 메시지 무결성을 보장 하 고 메시지를 보낸 사람을 확인 하는 방법을 제공 합니다. 인증 요청을 보내는 애플리케이션 메시지의 인증 수준을 설정 합니다.  
  
 설정한 경우 <xref:System.Messaging.MessageQueue.Authenticate%2A> 하 `true`를 제한 하는이 뿐만 아니라를 서버의 큐에 대 한 액세스 <xref:System.Messaging.MessageQueue> 인스턴스. 동일한 메시지 큐에 대해 작동 하는 모든 클라이언트 영향을 받습니다.  
  
 인증 된 메시지만 허용 하는 큐에서 인증 되지 않은 메시지를 거부 합니다. 요청 거부 메시지에 대 한 알림을 보내는 애플리케이션을 설정할 수는 <xref:System.Messaging.Message.AcknowledgeType%2A> 메시지의 속성입니다. 있기 때문에 메시지가 거부 없음 다른 표시 보내는 애플리케이션 배달 못 한 편지 큐로 보낼 수 있는지를 요청 하지 않으면 메시지가 손실 수 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.Authenticate%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>네트워크에서 공개 큐의 메시지를 라우팅하는 데 사용하는 기본 우선 순위 메시지 큐를 가져오거나 설정합니다.</summary>
        <value>(공개) 큐에 보내진 모든 메시지에 대한 단일 기본 우선 순위입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐의 기본 우선 순위 큐 네트워크를 통과 하는 처리 방법 라우팅 메시지에 지정 합니다. 설정할 수 있습니다는 <xref:System.Messaging.MessageQueue.BasePriority%2A> 속성을 다른 큐로 전송 하는 것 보다 지정 된 큐로 보낸 모든 메시지에 더 높은 또는 더 낮은 우선 순위를 부여 합니다. 메시지 큐를 수정이 속성을 설정 합니다. 따라서 다른 <xref:System.Messaging.MessageQueue> 인스턴스는 변경 내용의 영향입니다.  
  
 메시지 큐 <xref:System.Messaging.MessageQueue.BasePriority%2A> 관련이 없는 <xref:System.Messaging.Message.Priority%2A> 들어오는 메시지 큐에 배치 되는 순서를 지정 하는 메시지의 속성입니다.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> 공개 큐에만 형식 이름을 사용 하 여 경로가 지정 된 적용 됩니다. 개인 큐의 기본 우선 순위는 항상 0입니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.BasePriority%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">기본 우선 순위가 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>메시지 큐가 메시지 피킹(peeking)을 시작하도록 한 후, 작업을 마치면 이벤트 처리기에 알리도록 하여 비동기 피킹(peeking) 작업을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>시간 제한이 없는 비동기 피킹(peeking) 작업을 시작합니다. 큐에서 메시지를 사용할 수 있을 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리를 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지 큐에서 사용 가능 해지면 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업을 시작합니다. 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 사용 하 여 결과 검색 하는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 은 비동기 호출할 수는 현재 실행 스레드를 차단 하지 않고 큐를 피킹할 합니다. 큐에 동기적으로 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 하는 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `false`완료 이벤트를 발생 하지 않지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 합니다 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자를 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에 비동기 작업을 시작 하려면 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하 고 예제는 메시지를 피킹합니다 화면으로 해당 본문을 작성 합니다. 이 예제에서는 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 새 비동기 작업을 시작 하려면 다시 합니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>시간 제한이 지정된 비동기 피킹(peeking) 작업을 시작합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리를 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지를 큐 또는 지정된 된 시간 간격이 만료 될 때 제공 되는 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업을 시작합니다. 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 사용 하 여 결과 검색 하는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 은 비동기 호출할 수는 현재 실행 스레드를 차단 하지 않고 큐를 피킹할 합니다. 큐에 동기적으로 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드 제한 시간을 지정합니다. 으로 지정한 간격이 경우는 `timeout` 만료 된 매개 변수를이 구성 요소는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트. 메시지가 없으므로에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 하는 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `false`완료 이벤트를 발생 하지 않지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 경로 사용 하 여 비동기 작업을 ". \myQueue"입니다. 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 하 고는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자입니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업을 시작 하려면 1 분의 시간 제한으로 호출 됩니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하거나 제한 시간이 만료, 하나 있고, 해당 본문 화면에 기록 됩니다 하는 경우 메시지를 검색 합니다. 그런 다음 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 동일한 제한 시간을 사용 하 여 새 비동기 작업을 시작 하기 위해 다시 호출 됩니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 애플리케이션에서 지정합니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 피킹(peeking) 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리를 사용 하 여 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면는 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지를 큐 또는 지정된 된 시간 간격이 만료 될 때 제공 되는 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 작업의 수명 주기 동안 유지 됩니다 하는 작업을 사용 하 여 정보를 연결 하려면이 오버 로드를 사용 합니다. 이벤트 처리기를 확인 하 여이 정보에 액세스할 수 합니다 <xref:System.IAsyncResult.AsyncState%2A> 의 속성을 <xref:System.IAsyncResult> 작업과 연결 된입니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 작업을 시작합니다. 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 사용 하 여 결과 검색 하는 <xref:System.Messaging.PeekCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 은 비동기 호출할 수는 현재 실행 스레드를 차단 하지 않고 큐를 피킹할 합니다. 큐에 동기적으로 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환을 <xref:System.IAsyncResult> 는 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드 제한 시간 및 상태 개체를 지정합니다. 으로 지정한 간격이 경우는 `timeout` 만료 된 매개 변수를이 구성 요소는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트. 메시지가 없으므로에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 작업 상태 정보를 연결 하는 상태 개체입니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 작업을 시작 하려면 여러 번, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다. 이 시나리오의 예시 예제 섹션을 참조 하세요.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드가 시작 될 경우 콜백이 비동기 시나리오에서 다른 스레드에서 상태 개체 마샬링되고 이벤트의 정보와 함께 다시 전달 합니다.  
  
 하는 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `false`완료 이벤트를 발생 하지 않지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 경로 사용 하 여 비동기 작업을 ". \myQueue"입니다. 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 하 고는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자입니다. <xref:System.Messaging.MessageQueue.BeginPeek%2A> 라고, 1 분의 시간 제한으로 합니다. 호출할 때마다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 해당 특정 작업을 식별 하는 연결 된 고유한 정수에 있습니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하거나 제한 시간이 만료 메시지에 있는 경우 검색 되 고 해당 본문 및 작업 관련 정수 식별자를 화면에 기록 됩니다. 그런 다음 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 동일한 시간 제한 및 방금 완료 된 작업의 연결 된 정수를 사용 하 여 새 비동기 작업을 시작 하기 위해 다시 호출 됩니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 애플리케이션에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신할 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 피킹(peeking) 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 또는 지정된 된 시간 간격이 만료 되 면 경우에 사용 가능 해지면 콜백 매개 변수에 지정 된 콜백은 직접 호출이 오버 로드를 사용 하는 경우 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면이 구성 요소에 의존 합니다 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 은 비동기 호출할 수는 현재 실행 스레드를 차단 하지 않고 큐를 피킹할 합니다. 큐에 동기적으로 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환을 <xref:System.IAsyncResult> 는 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 작업 상태 정보를 연결 하는 상태 개체입니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 작업을 시작 하려면 여러 번, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 작업을 만듭니다. 다음 코드 예제에서는 보내는 로컬 메시지 큐에 메시지를 호출 <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>전달: 10 초의 시간 제한 값을;는 특정 메시지; 및의 새 인스턴스를 식별 하는 고유한 정수 <xref:System.AsyncCallback> 식별 하는 이벤트 처리기 `MyPeekCompleted`. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하면 이벤트 처리기는 메시지를 피킹합니다 하 고 화면에 메시지 본문 및 정수 메시지 식별자를 기록 합니다.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 값 중 하나입니다. 이 값은 큐의 현재 메시지를 피킹할지 또는 다음 메시지를 피킹할지 여부를 나타냅니다.</param>
        <param name="state">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 애플리케이션에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신하는 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>지정된 제한 시간이 있고 지정된 커서, 지정된 피킹(peeking) 작업 및 지정된 상태 개체를 사용하는 비동기 피킹(peeking) 작업을 초기화합니다. 상태 개체는 전체 작업 기간 동안 관련 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하는 경우 콜백 매개 변수에 지정 된 콜백 메시지를 큐 또는 지정된 된 시간 간격이 만료 될 때 사용할 수 있을 때 직접 호출 됩니다. <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 시키려면이 구성 요소에 의존 합니다 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 은 비동기 호출할 수는 현재 실행 스레드를 차단 하지 않고 큐를 피킹할 합니다. 큐에 동기적으로 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 반환 된 <xref:System.IAsyncResult> 메서드에 의해 시작 된 비동기 작업을 식별 하는 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 이 예에서 사용 하 여를 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 작업 상태 정보를 연결 하는 상태 개체입니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 여러 작업을 시작 하려면 여러 번, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" /> 매개 변수에 대해 <see langword="PeekAction.Current" /> 또는 <see langword="PeekAction.Next" /> 이외의 값을 지정했습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>메시지 큐가 메시지 수신을 시작하도록 한 후, 작업을 마치면 이벤트 처리기에 알리도록 하여 비동기 수신 작업을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>시간 제한이 없는 비동기 수신 작업을 시작합니다. 큐에서 메시지를 사용할 수 있을 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리를 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 메시지를 큐에서 제거 된 경우.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 작업을 수신 하는 비동기 시작 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>입니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 은 비동기 호출할 수 있습니다 현재 실행 스레드를 차단 하지 않고 큐에서 메시지를 수신 하는 것입니다. 동기적으로 메시지를 받고, 사용 된 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 하는 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `false`완료 이벤트를 발생 하지 않지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 비동기 호출을 사용 하지 않는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 트랜잭션 및 (동기) 및 <xref:System.Messaging.MessageQueue.Receive%2A> 보기 작업에 대해 만든 이벤트 처리기에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 요청을 연결 합니다. "MyQueue"를 호출 하는 로컬 컴퓨터에는 큐가 가정 합니다. 합니다 `Main` 함수를 처리 하는 비동기 작업을 시작 합니다 `MyReceiveCompleted` 루틴입니다. `MyReceiveCompleted` 현재 메시지를 처리 하 고 새 시작 비동기 수신 작업입니다.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 다음 코드 예제에서는 비동기 요청을 큐입니다. 에 대 한 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 사용 하 여는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 해당 반환 값에서입니다. `Main` 루틴 모든 비동기 작업 종료 완료 될 때까지 대기 합니다.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>시간 제한이 지정된 비동기 수신 작업을 시작합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리를 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지를 큐 또는 지정된 된 시간 간격이 만료 될 때 제공 되는 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 작업을 수신 하는 비동기 시작 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 은 비동기 호출할 수 있습니다 현재 실행 스레드를 차단 하지 않고 큐에서 메시지를 수신 하는 것입니다. 동기적으로 메시지를 받고, 사용 된 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 하는 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `false`완료 이벤트를 발생 하지 않지만 호출할 때 예외가 throw 됩니다, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드 제한 시간을 지정합니다. 으로 지정한 간격이 경우는 `timeout` 만료 된 매개 변수를이 구성 요소는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트. 메시지가 없으므로에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 비동기 호출을 사용 하지 않는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 트랜잭션 및 (동기) 및 <xref:System.Messaging.MessageQueue.Receive%2A> 보기 작업에 대해 만든 이벤트 처리기에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 작업을 수신 합니다. 코드 예제에서는 이벤트 처리기를 만듭니다 `MyReceiveCompleted`에 연결 하 고는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자입니다. 다음 코드 예제에서는 보내는 로컬 메시지 큐에 메시지를 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>10 초의 시간 제한 값을 전달 합니다. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기가 메시지를 받고 메시지 본문을 화면에 씁니다.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 (예: 값이 음수인 경우)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 애플리케이션에서 지정합니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 수신 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 처리를 사용 하 여 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지를 큐 또는 지정된 된 시간 간격이 만료 될 때 제공 되는 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 작업의 수명 주기 동안 유지 됩니다 하는 작업을 사용 하 여 정보를 연결 하려면이 오버 로드를 사용 합니다. 이벤트 처리기를 확인 하 여이 정보를 검색할 수는 <xref:System.IAsyncResult.AsyncState%2A> 의 속성을 <xref:System.IAsyncResult> 작업과 연결 된 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 작업을 수신 하는 비동기 시작 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 은 비동기 호출할 수 있습니다 현재 실행 스레드를 차단 하지 않고 큐에서 메시지를 수신 하는 것입니다. 동기적으로 메시지를 받고, 사용 된 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 이 오버 로드 제한 시간 및 상태 개체를 지정합니다. 으로 지정한 간격이 경우는 `timeout` 만료 된 매개 변수를이 구성 요소는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트. 메시지가 없으므로에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외가 throw 됩니다.  
  
 작업 상태 정보를 연결 하는 상태 개체입니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 작업을 시작 하려면 여러 번, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드가 시작 될 경우 콜백이 비동기 시나리오에서 다른 스레드에서 상태 개체 마샬링되고 이벤트의 정보와 함께 다시 전달 합니다.  
  
 비동기 호출을 사용 하지 않는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 트랜잭션 및 (동기) 및 <xref:System.Messaging.MessageQueue.Receive%2A> 보기 작업에 대해 만든 이벤트 처리기에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 작업을 수신 합니다. 코드 예제에서는 이벤트 처리기를 만듭니다 `MyReceiveCompleted`에 연결 하 고는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자입니다. 다음 코드 예제에서는 보내는 로컬 메시지 큐에 메시지를 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>10 초가 고 해당 특정 메시지를 식별 하는 고유한 정수 시간 제한 값을 전달 합니다. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기가 메시지를 받고 메시지 본문과 정수 메시지 식별자를 화면에 씁니다.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="stateObject">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 애플리케이션에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신할 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>시간 제한 및 상태 개체가 지정되어 있는 비동기 수신 작업을 시작합니다. 이는 작업의 수명이 지속되는 동안 관련된 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 또는 지정된 된 시간 간격이 만료 되 면 경우에 사용 가능 해지면 콜백 매개 변수에 지정 된 콜백은 직접 호출이 오버 로드를 사용 하는 경우 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면이 구성 요소에 의존 합니다 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 작업을 수신 하는 비동기 시작 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 은 비동기 호출할 수 있습니다 현재 실행 스레드를 차단 하지 않고 큐에서 메시지를 수신 하는 것입니다. 동기적으로 메시지를 받고, 사용 된 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 사용 하는 예제의 경우는 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 작업 상태 정보를 연결 하는 상태 개체입니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 작업을 시작 하려면 여러 번, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드가 시작 될 경우 콜백이 비동기 시나리오에서 다른 스레드에서 상태 개체 마샬링되고 이벤트의 정보와 함께 다시 전달 합니다.  
  
 비동기 호출을 사용 하지 않는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 트랜잭션 및 (동기) 및 <xref:System.Messaging.MessageQueue.Receive%2A> 보기 작업에 대해 만든 이벤트 처리기에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 작업을 수신 합니다. 다음 코드 예제에서는 보내는 로컬 메시지 큐에 메시지를 호출 <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>전달: 10 초의 시간 제한 값을;는 특정 메시지; 및의 새 인스턴스를 식별 하는 고유한 정수 <xref:System.AsyncCallback> 식별 하는 이벤트 처리기 `MyReceiveCompleted`. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면 이벤트 처리기가 메시지를 받고 메시지 본문과 정수 메시지 식별자를 화면에 씁니다.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">메시지를 사용할 수 있을 때까지 기다리는 시간 간격을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="state">비동기 작업과 관련된 정보가 들어 있는 상태 개체이며 애플리케이션에서 지정합니다.</param>
        <param name="callback">비동기 작업 완료에 대한 알림을 수신하는 <see cref="T:System.AsyncCallback" />입니다.</param>
        <summary>지정된 제한 시간이 있고 지정된 커서 및 지정된 상태 개체를 사용하는 비동기 수신 작업을 초기화합니다. 상태 개체는 전체 작업 기간 동안 관련 정보를 제공합니다. 이 오버로드는 콜백을 통해 해당 작업의 이벤트 처리기 ID에 대한 알림을 수신합니다. 큐에서 메시지를 사용할 수 있거나 시간 초과가 발생할 때까지 작업이 완료되지 않습니다.</summary>
        <returns>게시된 비동기 요청을 식별하는 <see cref="T:System.IAsyncResult" /> 입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 또는 지정된 된 시간 간격이 만료 되 면 경우에 사용 가능 해지면 콜백 매개 변수에 지정 된 콜백은 직접 호출이 오버 로드를 사용 하는 경우 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하지 않습니다. 다른 오버 로드 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시키려면이 구성 요소에 의존 합니다 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트입니다.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또한,는 메시지를 큐에 이미 있는 경우 발생 합니다.  
  
 사용할 <xref:System.Messaging.MessageQueue.BeginReceive%2A>, 비동기 작업의 결과 처리 하는 이벤트 처리기를 만듭니다 및 이벤트 대리자를 사용 하 여 연결 합니다. <xref:System.Messaging.MessageQueue.BeginReceive%2A> 작업을 수신 하는 비동기 시작 합니다 <xref:System.Messaging.MessageQueue> 의 발생을 통해 알림을 받은 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 도착할 때. 합니다 <xref:System.Messaging.MessageQueue> 메시지를 호출 하 여 액세스할 수 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 또는 사용 하 여 결과 검색 하는 <xref:System.Messaging.ReceiveCompletedEventArgs>합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 메서드가 즉시 반환 하지만, 이벤트 처리기가 호출 될 때까지 비동기 작업이 완료 되지 합니다.  
  
 때문에 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 은 비동기 호출할 수 있습니다 현재 실행 스레드를 차단 하지 않고 큐에서 메시지를 수신 하는 것입니다. 동기적으로 메시지를 받고, 사용 된 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드.  
  
 비동기 작업이 완료 되 면를 호출할 수 있습니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 또는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 알림을 수신할 이벤트 처리기에 다시 합니다.  
  
 합니다 <xref:System.IAsyncResult> 는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 반환 메서드를 시작 하는 비동기 작업을 식별 합니다. 사용할 수 있습니다 <xref:System.IAsyncResult> 작업의 수명 주기 동안 일반적으로 사용 하지 않는 있지만 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 라고 합니다. 그러나 여러 비동기 작업을 시작 하는 경우 배치할 수 있습니다 해당 <xref:System.IAsyncResult> 배열 값 및 모든 작업 또는 모든 작업이 완료 되기를 기다려야 하는지 여부를 지정 합니다. 이 예에서 사용 하 여를 <xref:System.IAsyncResult.AsyncWaitHandle%2A> 의 속성을 <xref:System.IAsyncResult> 완료 작업을 식별 합니다.  
  
 작업 상태 정보를 연결 하는 상태 개체입니다. 예를 들어, 호출 하는 경우 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 여러 작업을 시작 하려면 여러 번, 사용자가 정의한 개별 상태 개체를 통해 각 작업을 식별할 수 있습니다.  
  
 또한 프로세스 스레드 간에 정보를 전달 하는 상태 개체를 사용할 수 있습니다. 스레드가 시작 될 경우 콜백이 비동기 시나리오에서 다른 스레드에서 상태 개체 마샬링되고 이벤트의 정보와 함께 다시 전달 합니다.  
  
 비동기 호출을 사용 하지 않는 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 트랜잭션과 합니다. 트랜잭션 비동기 작업을 수행 하려는 경우 호출할 <xref:System.Messaging.MessageQueue.BeginPeek%2A>, 트랜잭션 및 (동기) 및 <xref:System.Messaging.MessageQueue.Receive%2A> 보기 작업에 대해 만든 이벤트 처리기에서 메서드. 이벤트 처리기는 다음 C# 코드에 표시 된 대로 기능을 포함할 수 있습니다.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" />를 읽을 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" />가 있고 응용 프로그램에서 이 큐를 읽을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 응용 프로그램은 큐에서 메시지를 받거나 피킹할 수 있는지 여부를 나타냅니다. 하는 경우 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `true`는 <xref:System.Messaging.MessageQueue> 받거나 큐에서 메시지를 피킹할 수 있습니다. 그렇지 않으면 불가능합니다.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> 됩니다 `false` 큐의 단독 액세스를 사용 하 여 이미 열려 있으면 (비독점적 액세스 및이 사용 하 여 열려 있는 경우 또는 <xref:System.Messaging.MessageQueue> 단독 액세스 요청), 응용 프로그램에 액세스할 수 있는 충분 한 권한이 없는 경우 또는 합니다. 애플리케이션 큐에서 읽은 하려고 하는 경우 때 <xref:System.Messaging.MessageQueue.CanRead%2A> 는 `false`에 액세스가 거부 되었습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.CanRead%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" />에 쓸 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" />가 있고 응용 프로그램이 여기에 쓸 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 응용 프로그램은 큐에 메시지를 보낼 수 있는지 여부를 나타냅니다. 하는 경우 <xref:System.Messaging.MessageQueue.CanWrite%2A> 됩니다 `true`, <xref:System.Messaging.MessageQueue> 큐에 메시지를 보낼 수 있습니다. 그렇지 않으면 불가능합니다.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> 됩니다 `false` 큐가 배타적인 쓰기 액세스를 사용 하 여 이미 열려 있으면 (비독점적 액세스 및이 사용 하 여 열려 있는 경우 또는 <xref:System.Messaging.MessageQueue> 단독 액세스 요청), 응용 프로그램에 액세스할 수 있는 충분 한 권한이 없는 경우 또는 합니다. 애플리케이션 큐에 쓰기를 시도 하는 경우 때 <xref:System.Messaging.MessageQueue.CanWrite%2A> 는 `false`에 액세스가 거부 되었습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.CanWrite%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐 범주를 가져오거나 설정합니다.</summary>
        <value>큐 범주(메시지 큐 형식 식별자)를 나타내는 <see cref="T:System.Guid" />입니다. 여기서 애플리케이션을 사용하여 큐를 분류할 수 있습니다. 기본값은 <see langword="Guid.empty" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐 범주에는 애플리케이션을 큐를 분류할 수 있습니다. 예를 들어, 하나의 범주와 다른 모든 주문 큐에서 모든 청구 큐를 배치할 수 있습니다.  
  
 <xref:System.Messaging.MessageQueue.Category%2A> 속성은 메시지 큐 형식 ID 속성 (즉, 읽기/쓰기)에 대 한 액세스를 제공을 통해 액세스할 수 합니다 **큐 속성** 컴퓨터 관리 콘솔의 대화 상자. 새 범주를 정의할 수 있습니다. 사용할 수 있지만 <xref:System.Guid.NewGuid%2A> 는 모든 고유 범주 값을 만들려면 <xref:System.Guid> 값, 이러한 작업이 필요는 없습니다. 범주 값이 제거 되지 않은 다른 모든 다른 범주에만 구별 되도록 <xref:System.Guid> 값입니다. 예를 들어, 할당할 수 있습니다 {00000000-0000-0000-0000-000000000001} 으로 <xref:System.Messaging.MessageQueue.Category%2A> 큐 집합이 하나에 대 한 및 {00000000-0000-0000-0000-000000000002} 로 <xref:System.Messaging.MessageQueue.Category%2A> 다른 집합에 대 한 합니다.  
  
 설정 하는 데 필요한 것은 <xref:System.Messaging.MessageQueue.Category%2A>합니다. 값은 `null`이 될 수 있습니다.  
  
 메시지 큐를 수정이 속성을 설정 합니다. 따라서 다른 <xref:System.Messaging.MessageQueue> 인스턴스는 변경 내용의 영향입니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.Category%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">우선 순위 범주가 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>연결 캐시를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 캐시에 저장 된 형식 이름을 제거 되 고 캐시에 저장 하 고 열 핸들 닫힙니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>를 호출합니다.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 할당한 리소스를 모두 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> 연결 된 모든 리소스를 해제를 <xref:System.Messaging.MessageQueue>, 해당 하는 경우 공유 리소스를 포함 합니다. 시스템 다시 획득 이러한 리소스가 자동으로 계속 사용 가능한 경우, 예를 들어 호출 하는 경우는 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 다음 C# 코드와 같이 메서드.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 호출 하는 경우 <xref:System.Messaging.MessageQueue.Close%2A>모든 <xref:System.Messaging.MessageQueue> out 메시지 큐를 직접 액세스 하는 속성의 선택을 취소 합니다. 합니다 <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>를 <xref:System.Messaging.MessageQueue.Formatter%2A>, 및 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 모두 그대로 유지 됩니다.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> 읽기 무료 및 공유 될 수 있기 때문에 큐에 쓰기 핸들 항상 않습니다. 확인 하려면 다음 단계를 수행할 수 있습니다 <xref:System.Messaging.MessageQueue.Close%2A> 큐에 읽기 및 쓰기 핸들을 해제 합니다.  
  
-   만들기는 <xref:System.Messaging.MessageQueue> 단독 액세스를 사용 하 여 합니다. 이렇게 하려면 호출을 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> 또는 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 생성자 및 집합 합니다 `sharedModeDenyReceive` 매개 변수를 `true`.  
  
-   만들기는 <xref:System.Messaging.MessageQueue> 연결 캐싱을 사용 하지 않도록 설정 합니다. 이렇게 하려면 호출을 <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> 집합과 생성자는 `enableConnectionCache` 매개 변수를 `false`.  
  
-   연결 캐싱을 사용 하지 않도록 설정 합니다. 이렇게 하려면 설정 합니다 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 속성을 `false`입니다.  
  
 호출 해야 <xref:System.Messaging.MessageQueue.Close%2A> 메시지 큐 서버에 있는 큐를 삭제 하기 전에 큐에 대 한 합니다. 이 고, 그렇지 큐로 전송 된 메시지 예외를 throw 하거나 배달 못 한 편지 큐에 나타날 수 없습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐를 닫습니다.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>메시지 큐 서버의 지정된 경로에 새 큐를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">만들 큐의 경로입니다.</param>
        <summary>지정된 경로에 비트랜잭션 메시지 큐를 만듭니다.</summary>
        <returns>새 큐를 나타내는 <see cref="T:System.Messaging.MessageQueue" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 비트랜잭션 메시지 큐를 만듭니다.  
  
 새 인스턴스를 만들려고 합니다 <xref:System.Messaging.MessageQueue> 기존 큐에 바인딩할를 사용 하 여 애플리케이션에서 클래스를 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자. 메시지 큐에서 새 큐를 만들려면 호출 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 구문은 `path` 매개 변수 유형에 따라 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
  
 사용 하 여 "." 로컬 컴퓨터에 대 한 합니다. 자세한 구문에 대 한 참조를 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 공용 및 개인 큐를 만듭니다. 선택한 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 경로에 큐가 이미 존재합니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">만들 큐의 경로입니다.</param>
        <param name="transactional">트랜잭션 큐를 만들려면 <see langword="true" />이고, 비트랜잭션 큐를 만들려면 <see langword="false" />입니다.</param>
        <summary>지정된 경로에 트랜잭션 또는 비트랜잭션 메시지 큐를 만듭니다.</summary>
        <returns>새 큐를 나타내는 <see cref="T:System.Messaging.MessageQueue" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐에 트랜잭션 큐를 만들려면이 오버 로드를 사용할 수 있습니다. 설정 하 여 비트랜잭션 큐를 만들 수 있습니다 합니다 `transactional` 매개 변수를 `false` 의 다른 오버 로드를 호출 하 여 <xref:System.Messaging.MessageQueue.Create%28System.String%29>입니다.  
  
 새 인스턴스를 만들려고 합니다 <xref:System.Messaging.MessageQueue> 기존 큐에 바인딩할를 사용 하 여 애플리케이션에서 클래스를 <xref:System.Messaging.MessageQueue.%23ctor%2A> 생성자. 메시지 큐에서 새 큐를 만들려면 호출 <xref:System.Messaging.MessageQueue.Create%28System.String%29>합니다.  
  
 구문은 `path` 매개 변수 유형에 따라 큐의 해당 참조는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
  
 사용 하 여 "." 로컬 컴퓨터에 대 한 합니다. 자세한 구문에 대 한 참조를 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 공용 및 개인 트랜잭션 큐를 만듭니다. 선택한 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 경로에 큐가 이미 존재합니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 메시지 큐의 새 <see cref="T:System.Messaging.Cursor" />를 만듭니다.</summary>
        <returns>현재 메시지 큐의 새 <see cref="T:System.Messaging.Cursor" />입니다. 이 커서는 큐의 메시지를 읽을 때 큐의 특정 위치를 유지하는 데 사용됩니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에서 큐가 만들어진 날짜와 시간을 가져옵니다.</summary>
        <value>큐가 만들어진 날짜와 시간을 나타내는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> 메시지 큐 서버의 큐에 참조를 <xref:System.Messaging.MessageQueue> 인스턴스.  
  
 큐가 있는 경우이 속성 큐 존재 하는 서버의 로컬 시간으로 조정 된 큐를 만든 시간을 나타냅니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.CreateTime%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 큐에 메시지를 보낼 때 기본적으로 사용되는 메시지 속성 값을 가져오거나 설정합니다.</summary>
        <value>애플리케이션에서 <see cref="T:System.Messaging.DefaultPropertiesToSend" /> 인스턴스 이외의 개체를 큐에 보낼 때 사용된 기본 메시지 큐 메시지 속성 값이 포함된 <see cref="T:System.Messaging.Message" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식 없는 모든 개체를 보내면 <xref:System.Messaging.Message> 큐에는 <xref:System.Messaging.MessageQueue> 메시지 큐 메시지에 개체를 삽입 합니다. 이때를 <xref:System.Messaging.MessageQueue> 에 지정 된 속성 값을 메시지에 적용 되는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성입니다. 반대로, 보내는 경우는 <xref:System.Messaging.Message> 큐에 이러한 속성이 이미 지정 되어 인스턴스 자체에 대 한 따라서 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 무시 됩니다는 <xref:System.Messaging.Message>합니다.  
  
 통해 속성을 설정할 수 있지만 합니다 <xref:System.Messaging.MessageQueue> 개체는 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 큐 자체 큐에 전송 되는 메시지의 속성을 가리킵니다.  
  
 속성에 대 한 기본 값은 다음 표에 표시 됩니다.  
  
|속성|기본값|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|영 (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|바이트는 길이가 0 인 배열|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|빈 문자열 ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지를 보낼 기본 속성을 확인 하는 메시지의 우선 순위를 사용 합니다.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">큐에 대한 기본 속성을 설정할 수 없습니다(예: 속성 중 하나가 잘못된 경우).</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">삭제할 큐의 위치입니다.</param>
        <summary>메시지 큐 서버에 있는 큐를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구문은 `path` 매개 변수는 큐의 유형에 따라 다릅니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
  
 자세한 구문에 대 한 참조를 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 사용할 수 있습니다 합니다 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 큐 경로 설명 합니다.  
  
|참조|구문|  
|---------------|------------|  
|형식 이름|FormatName: [ *형식 이름을* ]|  
|레이블|레이블: [ *레이블* ]|  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 있는 경우 다음 코드 예제는 메시지 큐의 큐를 삭제 합니다.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><paramref name="path" /> 매개 변수에 대한 구문이 잘못된 경우.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 메시지 큐에서 메시지를 받기 위한 단독 액세스 권한을 갖는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 <see cref="T:System.Messaging.MessageQueue" />가 큐에서 메시지를 받기 위한 단독 권한을 갖는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 이 참조 하는 큐의 공유 모드를 지정 <xref:System.Messaging.MessageQueue>합니다. 설정 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 하 `true` 만 나타내기 위해이 <xref:System.Messaging.MessageQueue> 지정 된 큐에서 메시지를 받거나 피킹에 액세스할 수 있어야 <xref:System.Messaging.MessageQueue.Path%2A>합니다. 다른 경우 <xref:System.Messaging.MessageQueue> 또는 다른 애플리케이션은 동일한 큐 리소스에 해당 인스턴스를 사용 하 여 연결 또는 애플리케이션을 피킹하거나 받을 메시지를 수 있지만 이러한 계속 보낼 수 있습니다.  
  
 하는 경우 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 는 `false`, 큐가 여러 애플리케이션, 보기, 메시지 송수신에 사용할 수 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />에서 사용하는 리소스(메모리 제외)를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 사용을 마치면 <xref:System.Messaging.MessageQueue>를 호출합니다. <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 메서드를 사용하면 <xref:System.Messaging.MessageQueue>를 사용할 수 없게 됩니다. 호출한 후 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Messaging.MessageQueue> 차지 했던 메모리를 가비지 수집에 의해 회수 될 수 있도록 합니다.  
  
 호출 해야 <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> 에 대 한 마지막 참조를 해제 하기 전에 <xref:System.Messaging.MessageQueue>합니다. 이 고, 그렇지 리소스를 <xref:System.Messaging.MessageQueue> 가 사용 하 여 확보 되지 것입니다. 가비지 컬렉션 호출 될 때까지 <xref:System.Messaging.MessageQueue> 개체의 소멸자입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결 캐시가 애플리케이션에 의해 유지 관리될지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>연결 캐시를 만들어 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 캐시는 처리 큐에 쓰기 또는 읽기를 포함 하는 구조에 대 한 참조의 목록입니다. 때 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 됩니다 `true`, <xref:System.Messaging.MessageQueue> 호출할 때마다 캐시에서 처리를 활용 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, 또는 <xref:System.Messaging.MessageQueue.Receive%2A>, 열린 새 핸들 대신 합니다. 이 경우 성능을 향상 시킬 수 있습니다. 분리도 연결 캐시를 사용 하는 <xref:System.Messaging.MessageQueue> 네트워크 토폴로지 변경으로 인해 합니다.  
  
 큐에 새 연결을 만들면 연결 캐시가 꽉는 <xref:System.Messaging.MessageQueue> 새 연결을 사용 하 여 가장 최근에 액세스 된 구조를 덮어씁니다. 호출 하 여 완전히 캐시를 지울 수 <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, 예를 들어, 이전 읽기 및 쓰기 핸들을 사용할 더 이상 사용 하는 큐의 형식 이름이 변경 된 경우.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 비개인(암호화되지 않은) 메시지만 허용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Messaging.EncryptionRequired" /> 값 중 하나입니다. 기본값은 <see langword="None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐에 전송 된 메시지에는 암호화가 필요한을 지정 하면 메시지 본문만 암호화 됩니다. 다른 멤버 (예를 들어 합니다 <xref:System.Messaging.Message.Label%2A> 및 <xref:System.Messaging.Message.SenderId%2A> 속성)를 암호화할 수 없습니다.  
  
 메시지 큐를 수정이 속성을 설정 합니다. 따라서 다른 <xref:System.Messaging.MessageQueue> 인스턴스는 변경 내용의 영향입니다.  
  
 개인 메시지를 통해 메시지를 암호화 합니다. 큐의 암호화 요구 사항 수를 지정할 수 있습니다 `None`, `Body`, 또는 `Optional` 설정 하 여는 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 속성 적절 하 게 합니다. <xref:System.Messaging.Message.UseEncryption%2A> 설정은 메시지 큐의 암호화 요구 사항 일치 해야 합니다. 메시지 암호화 되지 않았지만 큐를 지정 하는 경우 `Body`, 메시지 암호화 되어 있지만 큐를 지정 하는 경우 또는 `None`, 큐에서 메시지는 거부 됩니다. 이 이벤트의 부정 승인 메시지를 요청 하는 송신 애플리케이션 메시지 큐는 보내는 애플리케이션 메시지의 거부를 나타냅니다. 경우는 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 속성은 `true`, 암호화 실패 한 메시지는 배달 못 한 편지 큐로 보내집니다. 그렇지 않은 경우 메시지가 손실 됩니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />는 종료한 후 최종 결과를 검색해 올 비동기 피킹(peeking) 작업을 식별합니다.</param>
        <summary>지정된 비동기 피킹(peeking) 작업을 완료합니다.</summary>
        <returns>완료된 비동기 작업과 관련된 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 에 의해 시작 된 작업을 완료 합니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 호출 합니다. 이렇게 하려면 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 는 메시지를 피킹합니다.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 그러면 제한 시간을 지정할 수는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트를 큐에 메시지가 표시 되기 전에 제한 시간이 발생 하는 경우 발생 합니다. 메시지가 큐에 대 한 후속 호출에서 도착 시간 초과가 발생 하는 경우 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 예외를 throw 합니다.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 발생 시킨 메시지를 읽는 데 사용 되는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 합니다.  
  
 비동기적으로 메시지를 피킹할 수 계속 하려면 다시 호출 하면 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 호출한 후 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 합니다 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자를 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에 비동기 작업을 시작 하려면 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하 고 예제는 메시지를 피킹합니다 화면으로 해당 본문을 작성 합니다. 이 예제에서는 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 새 비동기 작업을 시작 하려면 다시 합니다.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 매개 변수의 구문이 잘못된 경우.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />는 종료한 후 최종 결과를 검색해 올 비동기 수신 작업을 식별합니다.</param>
        <summary>지정된 비동기 수신 작업을 완료합니다.</summary>
        <returns>완료된 비동기 작업과 관련된 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 에 의해 시작 된 작업을 완료 합니다 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 호출 합니다. 이렇게 하려면 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 메시지를 받습니다.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 그러면 제한 시간을 지정할 수는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트를 큐에 메시지가 표시 되기 전에 제한 시간이 발생 하는 경우 발생 합니다. 메시지가 큐에 대 한 후속 호출에서 도착 시간 초과가 발생 하는 경우 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 예외를 throw 합니다.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 메시지를 발생 시킨 (큐에서 제거) 읽는 데 사용 되는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 합니다.  
  
 계속 비동기적으로 메시지를 수신 하려는 경우 다시 호출 하면 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 호출한 후 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 요청을 연결 합니다. "MyQueue"를 호출 하는 로컬 컴퓨터에는 큐가 가정 합니다. 합니다 `Main` 함수를 처리 하는 비동기 작업을 시작 합니다 `MyReceiveCompleted` 루틴입니다. `MyReceiveCompleted` 현재 메시지를 처리 하 고 새 시작 비동기 수신 작업입니다.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 매개 변수의 구문이 잘못된 경우.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">찾을 큐의 위치입니다.</param>
        <summary>지정된 경로에 메시지 큐가 있는지 여부를 확인합니다.</summary>
        <returns>지정된 경로에 큐가 있으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 메서드 메시지 큐가 지정된 된 경로에 있는지 여부를 결정 합니다. 지정 된 형식 이름의 큐가 있는지 확인 하려면 방법이 없습니다. 형식 이름 구문 및 다른 경로 구문 형식에 대 한 자세한 내용은 참조는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 비용이 많이 드는 작업이입니다. 애플리케이션 내에서 필요한 경우에 사용 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 메서드를 지원 하지 않습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 접두사입니다.  
  
 구문은 `path` 매개 변수는 다음 표에 나와 있는 것 처럼 큐의 유형에 따라 다릅니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> 원격 개인 큐의 존재 여부를 확인 하려면 호출할 수 없습니다.  
  
 자세한 구문에 대 한 참조를 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다.  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.Label%2A> 큐 경로 설명 합니다.  
  
|참조|구문|  
|---------------|------------|  
|레이블|레이블: [ `label` ]|  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐가 존재 하 고 다음 삭제 여부를 확인 합니다.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 구문이 잘못되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
또는 
<see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> 메서드가 원격 개인 큐에서 호출되는 경우</exception>
        <exception cref="T:System.InvalidOperationException">큐가 있는지 여부를 확인할 때 애플리케이션이 형식 이름 구문을 사용했습니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐를 작성할 때 메시지 큐가 발생시킨 고유한 큐 이름을 가져옵니다.</summary>
        <value>네트워크에서 고유한 큐 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> 속성 큐의 형식 이름을 포함 합니다. 메시지 큐 큐를 열고 및 액세스 하는 방법을 식별 하는 형식 이름을 사용 합니다. 큐의 특징 대부분을 달리 형식 이름을 아니므로 메시지 큐 애플리케이션 큐 속성을 메시지 큐 관리 도구를 통해 액세스할 수 없습니다. 형식 이름은 큐에 대해 고유한 이름을 단순히 메시지 큐는 큐 또는 나중에 애플리케이션을 생성 하는 만들 때 생성 됩니다.  
  
 경로 이름 구문을 사용 하 여 경로 지정 하는 경우 (같은 `myComputer\myQueue`)를 읽거나 큐에 쓸 때 형식 이름 구문을 사용 하는 대신 주 도메인 컨트롤러 (사용 하는 Active Directory)는 다음과 같이 변환 됩니다.는 <xref:System.Messaging.MessageQueue.Path%2A> 에 연결된 <xref:System.Messaging.MessageQueue.FormatName%2A> 큐에 액세스 하기 전에 합니다. 애플리케이션을 오프 라인으로 작업 하는 경우에 형식의 이름 구문만;을 사용 해야 합니다. 이 고, 그렇지 주 도메인 컨트롤러는 경로 변환 하는 데 사용할 수 없습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.FormatName%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" />이 설정되지 않은 경우  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 읽거나 쓴 메시지 본문으로 개체를 serialize하거나 그 메시지 본문에서 개체를 deserialize하는 데 사용되는 포맷터를 가져오거나 설정합니다.</summary>
        <value>메시지 본문에서 쓰거나 읽는 스트림을 만드는 <see cref="T:System.Messaging.IMessageFormatter" />입니다. 기본값은 <see cref="T:System.Messaging.XmlMessageFormatter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> 속성 응용 프로그램 읽기 또는 큐에 기록할 때 메시지를 변환 하는 포맷터 개체의 인스턴스를 포함 합니다.  
  
 애플리케이션 큐에 메시지를 보내면, 포맷터 개체를 스트림으로 serialize 하 고 메시지 본문에 삽입 합니다. 포맷터에 메시지 데이터를 큐에서 읽을 때 합니다 <xref:System.Messaging.Message.Body%2A> 의 속성을 <xref:System.Messaging.Message>입니다.  
  
 <xref:System.Messaging.XmlMessageFormatter> 는 느슨하게 결합 되므로이 형식을 사용 하는 경우 보낸 사람 및 받는 사람 입력 동일한 개체를 할 필요는 없습니다. 합니다 <xref:System.Messaging.ActiveXMessageFormatter> 고 <xref:System.Messaging.BinaryMessageFormatter> 이진 표현으로 데이터를 직렬화 합니다. <xref:System.Messaging.ActiveXMessageFormatter> COM 구성 요소를 받거나 보낼 때 사용 됩니다.  
  
 <xref:System.Messaging.BinaryMessageFormatter> 및 <xref:System.Messaging.ActiveXMessageFormatter> 보다 더 빠른 처리량을 제공 합니다 <xref:System.Messaging.XmlMessageFormatter>합니다. <xref:System.Messaging.ActiveXMessageFormatter> Visual Basic 6.0 메시지 큐 응용 프로그램과 상호 운용성을 허용 합니다.  
  
 애플리케이션 큐에 메시지를 보낼 때 합니다 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 기본 메시지 속성을 사용 하는 해당 메시지에만 적용 됩니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>합니다. 보내는 경우는 <xref:System.Messaging.Message> 큐에 메시지 큐에서 사용에 정의 된 포맷터는 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 대신 본문을 serialize 할 속성입니다.  
  
 합니다 <xref:System.Messaging.MessageQueue> 클래스는 항상 사용을 <xref:System.Messaging.Message> 받거나 큐에서 메시지 보기. 사용 하 여 메시지가 deserialize 되는 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 사용 하 여 메시지 본문을 서식 지정 하는 방법을 보여 줍니다 <xref:System.Messaging.BinaryMessageFormatter>합니다.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 다음 코드 예제에서는 사용 하 여 메시지 본문을 서식 지정 하는 방법을 보여 줍니다 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 있는 메시지를 모두 반환합니다.</summary>
        <returns>큐에 있는 모든 메시지를 메시지 큐에서 표시되는 것과 동일한 순서로 나타내는 <see cref="T:System.Messaging.Message" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 이러한 메시지에 큐의 메시지, 동적이 아닌 링크의 정적 스냅숏을 반환합니다. 따라서 큐의 메시지를 수정 하는 배열을 사용할 수 없습니다. (예: 메시지를 삭제 하는 기능) 큐를 사용 하 여 실시간으로 동적 상호 작용을 원한다 면 호출 된 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 큐에서 메시지의 동적 목록을 반환 하는 메서드.  
  
 때문에 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 메서드가 호출 된 시점에 큐에서 메시지의 복사본을 반환 합니다, 큐에 도착 하는 새 메시지 또는 메시지 큐에서 제거 되는 배열 반영 하지 않습니다.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> 의해 필터링 되지 않은 속성만 검색 된 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐의 메시지를 열거합니다. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" />은 사용되지 않습니다. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />를 대신 사용해야 합니다.</summary>
        <returns>큐에 있는 메시지에 대한 동적 연결을 제공하는 <see cref="T:System.Collections.IEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetEnumerator%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">큐가 포함된 컴퓨터의 이름이며 앞에 백슬래시 두 개(\\\\)가 없습니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐가 있는 컴퓨터의 식별자를 가져옵니다.</summary>
        <returns>큐가 있는 컴퓨터의 고유 식별자를 나타내는 <see cref="T:System.Guid" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컴퓨터의 식별자를 사용 하 여 다른 두 가지 용도로: 컴퓨터 저널을 읽고 보안 인증서를 설정 합니다. 그러나 호출할 수 없습니다 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> 작업 하는 경우 오프 라인 애플리케이션에 도메인 컨트롤러에서 디렉터리 서비스에 액세스할 수 있어야 하기 때문에 원격 컴퓨터에 대 한 합니다.  
  
 컴퓨터 식별자 (또는 컴퓨터 identifier)를 <xref:System.Guid> 메시지 큐 엔터프라이즈에 컴퓨터가 추가 될 때 만들어지는 합니다. 메시지 큐에서는 사용 하 여 컴퓨터 식별자를 `Machine` 하 고 `Journal` 키워드 구문을 컴퓨터 저널의 형식 이름을 만드는 데 `Machine=<computeridentifier>;Journal`합니다. 컴퓨터 저널을 라고도 하는 업무 일지 큐로는 복사본을 저장 하는 시스템 큐 애플리케이션에서 생성 된 경우 메시지를 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 속성은 `true`합니다.  
  
 이 구문은 업무 일지 큐에 대 한 형식 이름을 생성 하는 경우에 유효 합니다. 경로 이름 구문은 `MachineName` \\ `Journal$`합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>를 호출합니다.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">오프라인으로 작업하는 경우와 같이 디렉터리 서비스를 사용할 수 없기 때문에 컴퓨터 식별자를 검색할 수 없습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 있는 모든 메시지에 대해 열거자 개체를 만듭니다. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />은 사용되지 않습니다. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />를 대신 사용해야 합니다.</summary>
        <returns>큐에 있는 메시지를 보유하는 <see cref="T:System.Messaging.MessageEnumerator" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 큐에 있는 모든 메시지의 동적 목록을 만듭니다. 제거할 수 있습니다 큐에서 열거자의 현재 위치에서 메시지를 호출 하 여 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 에 대 한 합니다 <xref:System.Messaging.MessageEnumerator> 는 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> 반환 합니다.  
  
 커서 큐에 메시지의 동적 목록과 사용 하 여 연결 이므로 열거형 메시지 현재 커서 위치 초과 하는 경우 큐에서 메시지에 대 한 수정 내용을 반영 합니다. 예를 들어, 열거자 우선 순위가 낮은 메시지 보다 커서의 현재 위치 뒤에 배치 하지만 해당 위치 앞에 삽입 하는 우선 순위가 높은 메시지가 아닌에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다 열거형 하므로 커서를 다시 목록의 시작 부분에 호출 하 여 이동 <xref:System.Messaging.MessageEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator>합니다.  
  
 열거형에 있는 메시지의 순서 우선 순위가 높은 메시지 우선 순위가 낮은 항목 보다 먼저 나타납니다 있으므로 큐에 순서를 반영 합니다.  
  
 호출에 대 한 동적 연결 하지 않고 큐에서 메시지의 정적 스냅숏을 원한다 면 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>합니다. 이 메서드는 배열을 반환 <xref:System.Messaging.Message> 메서드가 호출 된 시간에 메시지를 나타내는 개체입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 메시지의 동적 목록을 가져옵니다 및 포함 된 모든 메시지를 계산 합니다 <xref:System.Messaging.Message.Priority%2A> 속성이 설정 <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>합니다.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 있는 모든 메시지에 대해 열거자 개체를 만듭니다.</summary>
        <returns>큐에 있는 메시지를 보유하는 <see cref="T:System.Messaging.MessageEnumerator" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 큐에 있는 모든 메시지의 동적 목록을 만듭니다. 제거할 수 있습니다 큐에서 열거자의 현재 위치에서 메시지를 호출 하 여 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> 에 대 한 합니다 <xref:System.Messaging.MessageEnumerator> 는 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> 반환 합니다.  
  
 커서 큐에 메시지의 동적 목록과 사용 하 여 연결 이므로 열거형 메시지 현재 커서 위치 초과 하는 경우 큐에서 메시지에 대 한 수정 내용을 반영 합니다. 예를 들어, 열거자 우선 순위가 낮은 메시지 보다 커서의 현재 위치 뒤에 배치 하지만 해당 위치 앞에 삽입 하는 우선 순위가 높은 메시지가 아닌에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다 열거형 하므로 커서를 다시 목록의 시작 부분에 호출 하 여 이동 <xref:System.Messaging.MessageEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageEnumerator>합니다.  
  
 열거형에 있는 메시지의 순서 우선 순위가 높은 메시지 우선 순위가 낮은 항목 보다 먼저 나타납니다 있으므로 큐에 순서를 반영 합니다.  
  
 호출에 대 한 동적 연결 하지 않고 큐에서 메시지의 정적 스냅숏을 원한다 면 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>합니다. 이 메서드는 배열을 반환 <xref:System.Messaging.Message> 메서드가 호출 된 시간에 메시지를 나타내는 개체입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>네트워크에 있는 공개 큐의 동적 목록에 대한 열거자 개체를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>앞으로만 이동 가능한 커서 의미 체계 기능을 제공하여 네트워크에 있는 모든 공개 큐를 열거합니다.</summary>
        <returns>네트워크에 있는 모든 공개 메시지 큐의 동적 목록을 제공하는 <see cref="T:System.Messaging.MessageQueueEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 네트워크에 있는 모든 공개 큐의 열거형을 반환 합니다.  
  
 커서가 동적 목록과 관련 되어 있으므로 열거형 삭제 또는 커서의 현재 위치 뒤에 추가 하는 큐에 대 한 큐 목록에 대 한 수정 내용을 반영 합니다. 추가 또는 삭제는 커서의 현재 위치 앞에 배치 하는 큐의 반영 되지 않습니다. 예를 들어, 열거자의 커서 위치 뒤에 추가 큐 있지만 아닌 해당 위치 앞에 삽입에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다 열거형 하므로 커서를 다시 목록의 시작 부분에 호출 하 여 이동 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageQueueEnumerator>합니다.  
  
 네트워크에서 큐의 정의 된 순서가 있지 않습니다. 열거자 정렬 되지 않은, 예를 들어, 컴퓨터, 레이블, 공용 또는 개인 상태 또는 기타 액세스 가능한 기준으로 합니다.  
  
 동적 연결을 보다는 네트워크에 있는 큐의 정적 스냅숏을 원한다 면 호출 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 또는 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>합니다. 이러한 두 메서드는 각각의 배열을 반환 <xref:System.Messaging.MessageQueue> 메서드가 호출 된 시간에 큐를 나타내는 개체입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 네트워크의 모든 메시지 큐를 통해 반복 하 고 각 큐에 대 한 경로 검사 합니다. 마지막으로 네트워크에서 공개 큐의 수를 표시합니다.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">사용 가능한 메시지 큐를 필터링하는 데 사용되는 기준이 포함된 <see cref="T:System.Messaging.MessageQueueCriteria" />입니다.</param>
        <summary>앞으로만 이동 가능한 커서 의미 체계 기능 제공하여 네트워크에 있는 공개 큐 중 지정된 기준을 만족하는 큐를 모두 열거합니다.</summary>
        <returns>네트워크에 있는 공개 메시지 큐 중 <paramref name="criteria" /> 매개 변수가 지정한 제한 사항을 만족시키는 큐에 대한 동적 목록을 제공하는 <see cref="T:System.Messaging.MessageQueueEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> 애플리케이션 조건에 정의 된 조건을 충족 하는 네트워크에 있는 모든 공개 큐의 목록을 반환 합니다. 를 포함 하는 조건을 작성 또는 수정 시간, 컴퓨터 이름, 레이블, 범주 또는 이러한 조건의 조합을 예를 들어, 큐를 지정할 수 있습니다.  
  
 커서와 동적 목록과 사용 하 여 연결 된 있으므로 열거형에는 커서의 현재 위치 뒤에 발생 하는 큐에 대 한 수정 내용을 반영 합니다. 커서의 현재 위치 앞에 있는 큐에 변경 내용이 반영 되지 않습니다. 예를 들어, 열거자의 커서 위치 뒤에 추가 큐 있지만 아닌 해당 위치 앞에 삽입에 자동으로 액세스할 수 있습니다. 그러나 다시 설정할 수 있습니다 열거형 하므로 커서를 다시 목록의 시작 부분에 호출 하 여 이동 <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> 에 대 한는 <xref:System.Messaging.MessageQueueEnumerator>합니다.  
  
 네트워크에서 큐의 정의 된 순서가 있지 않습니다. 열거자 정렬 되지 않은, 예를 들어, 컴퓨터, 레이블, 공용 또는 개인 상태 또는 기타 액세스 가능한 기준으로 합니다.  
  
 동적 연결을 보다는 네트워크에 있는 큐의 정적 스냅숏을 원한다 면에 조건을 지정 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 호출 또는 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>합니다. 이러한 두 메서드는 각각의 배열을 반환 <xref:System.Messaging.MessageQueue> 메서드가 호출 된 시간에 큐를 나타내는 개체입니다. 호출 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, 또는 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 호출할 때와 동일한 결과 제공 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 의 필터링 조건을 사용 하 여 <xref:System.Messaging.MessageQueue.Category%2A>를 <xref:System.Messaging.MessageQueue.Label%2A>, 및 <xref:System.Messaging.MessageQueue.MachineName%2A>, 각각.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐를 통해 반복 하 고 "MyComputer" 컴퓨터에 있는 마지막 날에 생성 된 각 큐의 경로 표시 합니다.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">개인 큐를 검색할 컴퓨터입니다.</param>
        <summary>지정된 컴퓨터에 있는 개인 큐를 모두 검색합니다.</summary>
        <returns>검색된 개인 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> 지정한 컴퓨터에 있는 큐의 정적 스냅숏을 검색합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 매개 변수가 <see langword="null" />이거나 빈 문자열("")입니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>네트워크에 있는 공개 큐를 모두 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>네트워크에 있는 공개 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네트워크에 있는 모든 공개 큐의 전체 목록을 원하는 경우이 오버 로드를 사용 합니다. 와 같은 특정 조건을 기준으로 목록을 제한 하려는 경우 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, 또는이 메서드의 다른 오버 로드를 사용 하는 마지막으로 수정한 시간입니다. (사용할 수 있습니다 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>하십시오 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 또는 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">큐를 필터링하는 데 사용되는 기준이 포함된 <see cref="T:System.Messaging.MessageQueueCriteria" />입니다.</param>
        <summary>네트워크에 있는 공개 큐 중 지정된 기준을 만족시키는 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 레이블, 범주 또는 컴퓨터 이름으로 네트워크에 있는 모든 공개 큐를 필터링 하려는 경우는 <xref:System.Messaging.MessageQueue> 해당 기능을 제공 하는 특정 메서드를 포함 하는 클래스 (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>를 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, 및 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>각각). 이 오버 로드를 사용 하 여 (예를 들어, 하려는 경우 레이블을 범주를 지정 합니다.) 이러한 조건 중 하나 이상 충족 하는 네트워크에서 공개 큐를 모든 목록을 가져옵니다. 필터링 할 수도 있습니다 메시지 조건으로 이외의 <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, 및 <xref:System.Messaging.MessageQueue.MachineName%2A>합니다. 예를 들어 큐의 마지막 수정 시간을 기준으로 필터링 하려면이 오버 로드를 사용 합니다. 새 인스턴스를 만들기만 하면 됩니다 합니다 <xref:System.Messaging.MessageQueueCriteria> 클래스 인스턴스의 적절 한 속성을 설정 하 고로 인스턴스를 전달 합니다 `criteria` 매개 변수입니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">검색할 큐 집합을 그룹화하는 <see cref="T:System.Guid" />입니다.</param>
        <summary>네트워크에 있는 공개 큐 중 지정된 범주에 속한 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 범주별으로 공개 큐를 필터링 합니다. <xref:System.Messaging.MessageQueue.Category%2A> 속성은 메시지 큐 형식의 ID 속성 (즉, 읽기/쓰기) 특정 큐에 대 한 액세스를 제공 합니다. 사용할 수 있지만 <xref:System.Guid.NewGuid%2A> 는 모든 고유 범주 값을 만들려면 <xref:System.Guid> 값 필요는 없습니다. 범주 값이 제거 되지 않은 다른 모든 다른 범주에만 구별 되도록 <xref:System.Guid> 값입니다. 예를 들어, 할당할 수 있습니다 {00000000-0000-0000-0000-000000000001} 으로 <xref:System.Messaging.MessageQueue.Category%2A> 큐 집합이 하나에 대 한 및 {00000000-0000-0000-0000-000000000002} 로 <xref:System.Messaging.MessageQueue.Category%2A> 다른 집합에 대 한 합니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>입니다. 일부로 범주를 지정할 수 있습니다는 <xref:System.Messaging.MessageQueueCriteria> 메서드로 전달 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">검색할 큐 집합을 그룹화하는 레이블입니다.</param>
        <summary>네트워크에 있는 공개 큐 중 지정된 레이블이 있는 큐를 모두 검색합니다.</summary>
        <returns>검색된 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 레이블에 의해 공개 큐를 필터링 하려면이 메서드를 사용 합니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>입니다. 일부분으로 레이블을 지정할 수 있습니다는 <xref:System.Messaging.MessageQueueCriteria> 메서드로 전달 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">검색할 공개 큐 집합을 포함하는 컴퓨터의 이름입니다.</param>
        <summary>지정된 컴퓨터에 있는 공개 큐를 모두 검색합니다.</summary>
        <returns>컴퓨터에 있는 공개 큐를 참조하는 <see cref="T:System.Messaging.MessageQueue" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 컴퓨터에서 공개 큐를 필터링 합니다.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> 큐의 정적 스냅숏을 검색합니다. 큐의 동적 목록을 사용 하 여 상호 작용을 사용 하 여 <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>입니다. 일부로 컴퓨터 이름을 지정할 수 있습니다는 <xref:System.Messaging.MessageQueueCriteria> 메서드로 전달 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|아니요|  
|로컬 컴퓨터와 직접 형식 이름|아니요|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐 목록을 검색합니다.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 매개 변수의 구문이 잘못되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 호출 시 MSMQ가 현재 사용자(스레드 ID)와 연결된 보안 컨텍스트를 검색합니다.</summary>
        <returns>보안 컨텍스트를 포함하는 <see cref="T:System.Messaging.SecurityContext" /> 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 고유한 메시지 큐 식별자를 가져옵니다.</summary>
        <value>메시지 큐 애플리케이션에 의해 생성된 메시지 식별자를 나타내는 <see cref="P:System.Messaging.MessageQueue.Id" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐는 <xref:System.Messaging.MessageQueue.Id%2A> 큐를 만들 때 속성입니다. 이 속성은 공개 큐에 사용할 수만 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.Id%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에 크기 제한이 없도록 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 설정할 때 자주 사용 됩니다 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 또는 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.InfiniteQueueSize> 멤버입니다.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 피킹하거나 받는 메서드에 시간 제한이 없도록 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> 두 가지 유형의 메시지 검색을 지원 합니다: 동기 및 비동기입니다. 동기 메서드인 <xref:System.Messaging.MessageQueue.Peek%2A> 및 <xref:System.Messaging.MessageQueue.Receive%2A>, 프로세스 스레드가 큐에 도착 하는 새 메시지에 대해 지정 된 시간 간격을 대기 합니다. 지정 된 시간 간격이 <xref:System.Messaging.MessageQueue.InfiniteTimeout>, 새 메시지가 있을 때까지 프로세스 스레드가 차단 됩니다. 다른 한편 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 고 <xref:System.Messaging.MessageQueue.BeginReceive%2A> (비동기 메서드), 기본 애플리케이션 작업을 큐에 메시지가 도착할 때까지 별도 스레드에서 계속 허용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 멤버입니다.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐 설명을 가져오거나 설정합니다.</summary>
        <value>메시지 큐의 레이블입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 레이블의 최대 길이 124 자입니다.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> 속성이 모든 큐에서 고유할 필요는 없습니다. 그러나 동일한 여러 큐를 공유 하는 경우 <xref:System.Messaging.MessageQueue.Label%2A>를 사용할 수 없습니다는 <xref:System.Messaging.MessageQueue.Send%28System.Object%29> 이들 모두에 메시지를 브로드캐스팅하는 방법입니다. 레이블 구문을 사용 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 메시지를 보낼 때 속성에는 예외가 발생 하는 경우는 <xref:System.Messaging.MessageQueue.Label%2A> 고유 하지 않습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.Label%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">레이블이 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 속성이 마지막으로 수정된 시간을 가져옵니다.</summary>
        <value>큐의 속성이 마지막으로 수정된 시간을 알려주는 <see cref="T:System.DateTime" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐를 만들 때 마지막으로 수정한 시간 포함 임의의 <xref:System.Messaging.MessageQueue> 와 같은 메시지 큐를 수정 하는 속성 <xref:System.Messaging.MessageQueue.BasePriority%2A>합니다. 값을 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성 로컬 컴퓨터의 시스템 시간을 나타냅니다.  
  
 호출 해야 합니다 <xref:System.Messaging.MessageQueue.Refresh%2A> 시작 하기 전에 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성 수정에를 사용 하 여 연결 하는 고, 그렇지 <xref:System.Messaging.MessageQueue> 현재 되지 않을 수 있습니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐가 있는 컴퓨터의 이름을 가져오거나 설정합니다.</summary>
        <value>큐가 있는 컴퓨터의 이름입니다. 메시지 큐의 기본값은 "."이며, 이는 로컬 컴퓨터를 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Messaging.MessageQueue.MachineName%2A> 큐의 이름 구문 필수 구성 요소인 <xref:System.Messaging.MessageQueue.Path%2A>합니다. 다음 표에서 해당 이름을 사용 하 여 큐 경로 식별 하려는 경우 지정 된 형식의 큐에 대 한 사용 해야 하는 구문을 보여 줍니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 사용 하 여 "."를 지정할 때 로컬 컴퓨터에 대 한는 <xref:System.Messaging.MessageQueue.MachineName%2A>합니다. 컴퓨터 이름에만이 속성에 대 한 예를 들어 인식 `Server0`합니다. <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 IP 주소 형식은 지원 하지 않습니다.  
  
 정의 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 의 측면에서 <xref:System.Messaging.MessageQueue.MachineName%2A>, 애플리케이션 도메인 컨트롤러는 경로 변환에 대 한 필수 사항 이므로 오프 라인으로 작업 하는 경우 예외를 throw 합니다. 따라서 사용 해야 합니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 에 대 한는 <xref:System.Messaging.MessageQueue.Path%2A> 오프 라인으로 작업 하는 경우에 구문이 있습니다.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성 관련 됩니다. 변경 된 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 원인의 <xref:System.Messaging.MessageQueue.Path%2A> 변경할 속성입니다. 새에서 빌드되어 <xref:System.Messaging.MessageQueue.MachineName%2A> 하며 <xref:System.Messaging.MessageQueue.QueueName%2A>합니다. 변경 합니다 <xref:System.Messaging.MessageQueue.Path%2A> (예: 형식 이름 구문을 사용 하 여) 다시 설정 합니다 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 새 큐를 참조 하는 속성입니다. 경우는 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성이 비어 있으면는 <xref:System.Messaging.MessageQueue.Path%2A> 지정할 컴퓨터의 업무 일지 큐에 설정 됩니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.MessageQueue.MachineName" />이 <see langword="null" />인 경우        
또는

컴퓨터 이름이 잘못되었습니다(예: 구문이 잘못된 경우).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>업무 일지 큐의 최대 크기를 가져오거나 설정합니다.</summary>
        <value>업무 일지 큐의 최대 크기입니다(단위: KB). 메시지 큐에서는 기본적으로 제한이 없도록 지정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 메시지 큐 저널 저장소 제한에 대 한 액세스를 제공합니다. 인 경우에만 관련 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 는 `true`합니다. 메시지 큐를 수정이 속성을 설정 합니다. 따라서 다른 <xref:System.Messaging.MessageQueue> 인스턴스는 변경 내용의 영향  
  
 저널 또는 배달 못 한 편지 큐에서 메시지를 저장 하는 경우 정기적으로 큐에서 더 이상 필요 없는 메시지를 제거 하려면을 지워야 합니다. 이러한 큐의 메시지 큐가 있는 컴퓨터에 대 한 메시지 할당량에 대해 계산 합니다. (관리자 컴퓨터 할당량을 설정 합니다.)  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">업무 일지 큐의 최대 크기가 잘못된 값으로 설정되었습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 최대 크기를 가져오거나 설정합니다.</summary>
        <value>큐의 최대 크기입니다(단위: KB). 메시지 큐에서는 기본적으로 제한이 없도록 지정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 는 메시지 큐 메시지 저장소 한도 관리자를 정의 하는 컴퓨터의 메시지 할당량을 별도로에 대 한 액세스를 제공 합니다. 메시지 할당량에 대 한 자세한 내용은 참조 하세요. <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>합니다.  
  
 메시지 큐를 수정이 속성을 설정 합니다. 따라서 다른 <xref:System.Messaging.MessageQueue> 인스턴스는 변경 내용의 영향  
  
 최대 큐 크기 또는 컴퓨터 메시지 할당량을 초과 하려고 하는 경우 메시지가 손실 될 수 있습니다. 큐 할당량에 도달 하면 메시지 큐는 부정 승인 메시지를 반환 하 여 큐가 꽉 차면를 보내는 애플리케이션의 관리 큐를 알립니다. 큐에서 메시지의 총 크기 제한 아래로 떨어질 때까지 부정 승인을 보내도록 메시지 큐 계속 됩니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">큐의 최대 크기에 음수 값이 포함된 경우입니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지를 받거나 또는 피킹하는 데 필요한 속성 필터를 가져오거나 설정합니다.</summary>
        <value>큐가 각각의 메시지에 대해 받거나 피킹하는 속성 집합을 필터링하는 데 사용되는 <see cref="T:System.Messaging.MessagePropertyFilter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필터는 메시지 속성을 제한 하는 부울 값의 집합입니다는 <xref:System.Messaging.MessageQueue> 받거나 피킹하 합니다. 경우는 <xref:System.Messaging.MessageQueue> 받거나 피킹하는 메시지 서버 큐에서는 속성만 검색 합니다 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 값은 `true`.  
  
 다음에 대 한 초기 속성 값이 표시는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 속성입니다. 이러한 설정은 호출과 동일 <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> 에 <xref:System.Messaging.MessagePropertyFilter>합니다.  
  
|속성|기본값|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 바이트|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 바이트|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 바이트|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> 받을 메시지의 속성을 제한 합니다.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">필터가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐에 연결된 멀티캐스트 주소를 가져오거나 설정합니다.</summary>
        <value>아래 형식으로 된 올바른 멀티캐스트 주소가 들어 있는 <see cref="T:System.String" />이거나, 큐가 멀티캐스트 주소에 연결되지 않았음을 나타내는 <see langword="null" />입니다.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 비트랜잭션 큐 메시지를 보낼 때 사용할 수 있는 멀티 캐스트 주소를 사용 하 여 연결 속성을 사용 합니다. 멀티 캐스트 주소를 사용 하 여 트랜잭션 큐를 연결할 수 없습니다. 보내는 애플리케이션 메시지를 보내면 멀티 캐스트 주소를, 메시지 큐 메시지의 복사본이 해당 주소와 연결 된 모든 큐에 보냅니다.  
  
 IP 멀티 캐스트 주소 224.0.0.0에서 239.255.255.255 1110 같음으로 처음 네 개의 상위 비트는 설정에 해당 하는 클래스 D 범위 내에 있어야 합니다. 그러나 특정 범위의이 범위의 주소는 예약 되지 않은 및 멀티 캐스트 메시지를 보내는 데 사용할 수 있습니다. 예약 된 멀티 캐스트 주소의 최신 목록에 대 한 참조를 [번호 기관 IANA (Internet Assigned) 인터넷에 대 한 멀티 캐스트 주소](https://go.microsoft.com/fwlink/?linkid=3859) 웹 페이지입니다. 포트 번호에 제한은 없습니다.  
  
 여러 원본 컴퓨터 멀티 캐스트 메시지를 보내는 경우 특정 큐를 하나의 원본 컴퓨터에서 메시지를 수신 하려는 각 원본 컴퓨터 IP 주소와 포트 번호의 다양 한 조합에 메시지를 보내야 합니다.  
  
 멀티 캐스트 주소에서 큐를 분리 하려면 설정의 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> 속성을 빈 문자열로 합니다. 설정 하지 마십시오 `null`처럼 그러면는 <xref:System.ArgumentNullException>합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐의 경로를 가져오거나 설정합니다. <see cref="P:System.Messaging.MessageQueue.Path" />를 설정하면 <see cref="T:System.Messaging.MessageQueue" />가 새 큐를 가리킵니다.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐입니다. 기본값은 사용하는 <see cref="M:System.Messaging.MessageQueue.#ctor" /> 생성자에 따라 달라지는데, <see langword="null" />이거나 생성자의 <paramref name="path" /> 매개 변수에 의해 지정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구문은 <xref:System.Messaging.MessageQueue.Path%2A> 속성 유형에 따라 큐의 해당 지점에는 다음 표에 나와 있는 것 처럼 합니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
|컴퓨터 저널 큐|`MachineName`\\`Journal$`|  
|컴퓨터 배달 못 한 편지 큐|`MachineName`\\`Deadletter$`|  
|컴퓨터 트랜잭션 배달 못 한 편지 큐|`MachineName`\\`XactDeadletter$`|  
  
 사용 하 여 "."를 로컬 컴퓨터를 나타내는입니다.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성 관련 됩니다. 변경 된 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성 원인의 <xref:System.Messaging.MessageQueue.Path%2A> 변경할 속성입니다. 새에서 빌드되어 <xref:System.Messaging.MessageQueue.MachineName%2A> 하며 <xref:System.Messaging.MessageQueue.QueueName%2A>합니다. 변경 합니다 <xref:System.Messaging.MessageQueue.Path%2A> (예: 형식 이름 구문을 사용 하 여) 다시 설정 합니다 <xref:System.Messaging.MessageQueue.MachineName%2A> 및 <xref:System.Messaging.MessageQueue.QueueName%2A> 새 큐를 참조 하는 속성입니다.  
  
 사용할 수 있습니다는 <xref:System.Messaging.MessageQueue.FormatName%2A> 또는 <xref:System.Messaging.MessageQueue.Label%2A> 다음 표에 나와 있는 것 처럼 큐 경로 설명 합니다.  
  
|참조|구문|예|  
|---------------|------------|-------------|  
|형식 이름|`FormatName:` [ *형식 이름을* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|레이블|`Label:` [ *레이블* ]|`Label:` TheLabel|  
  
 레이블 구문을 사용 하는 경우는 <xref:System.Messaging.MessageQueue.Path%2A> 메시지를 보낼 때 속성에는 예외가 발생 하는 경우는 <xref:System.Messaging.MessageQueue.Label%2A> 고유 하지 않습니다.  
  
 오프 라인으로 작업 하는 첫 번째 테이블의 이름 구문이 아니라, 형식 이름 구문을 사용 해야 합니다. 그렇지 않은 경우 (Active Directory 상주 하는) 주 도메인 컨트롤러를 형식 이름으로 경로 확인할 수 없기 때문에 예외가 throw 됩니다.  
  
 새 경로 설정 합니다. 메시지 큐를 닫고 모든 핸들을 해제 합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
> [!NOTE]
>  작업 그룹 모드에서에 개인 큐를 사용할 수 있습니다. 개인 큐 구문을 사용 하 여 경로 지정할 `MachineName` \\ `Private$` \\ `QueueName`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 <xref:System.Messaging.MessageQueue> 다양 한 경로 이름을 구문 형식을 사용 하 여 개체입니다. 각각의 경우에서 경로가 생성자에 정의 된 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">경로가 잘못되었습니다(예: 구문이 잘못된 경우)</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>큐에 있는 첫 번째 메시지의 복사본을 반환하지만 큐에서 메시지를 제거하지는 않습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 반환하지만 제거(피킹)하지는 않습니다. <see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있을 때까지 현재 스레드를 차단시킵니다.</summary>
        <returns>큐에 있는 첫 번째 메시지를 나타내는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지가 큐에 있는 될 때까지 대기 또는 큐를 피킹할이 오버 로드를 사용 합니다.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 첫 번째 메시지를 큐에서 제거 되지 않습니다. 따라서 반복 호출을 <xref:System.Messaging.MessageQueue.Peek%2A> 우선 순위가 높은 메시지 큐에 도착 하지 않는 한 동일한 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.Receive%2A> 모두 메서드, 다른 한편으로 읽고 큐에서 첫 번째 메시지를 제거 합니다. 에 대 한 호출을 반복 <xref:System.Messaging.MessageQueue.Receive%2A>, 따라서 서로 다른 메시지를 반환 합니다.  
  
 메시지 큐는 우선 순위 및 도착 시간에 따라 큐에 메시지를 정렬합니다. 최신 메시지의 우선 순위가 높은 경우에 이전 앞에 배치 됩니다.  
  
 큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다. 이 오버 로드 제한 시간을 지정 하지 않으므로, 애플리케이션이 무기한 대기 합니다. 대기하지 않고 애플리케이션 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다. 오버 로드를 사용 하 여 큐에 도착 하는 메시지에 대 한 제한 시간을 지정할 수도 있습니다 <xref:System.Messaging.MessageQueue.Peek%2A> 제한 시간을 지정 하는 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 예에서는 <xref:System.Messaging.MessageQueue.Peek%2A> 큐 메서드.  
  
 첫 번째 예제에서는 애플리케이션 메시지를 큐에서 사용할 수 있을 때까지 기다립니다. 첫 번째 예제; 도착 하는 메시지 액세스 하지 않음을 참고 단순히 메시지가 도착할 때까지 처리 일시 중지 합니다. 경우 메시지가 큐에 이미 있는 즉시 반환 됩니다.  
  
 두 번째 예제에서는 애플리케이션 정의 포함 하는 메시지 `Order` 클래스 큐에 전송 되 고 큐에서 피킹 합니다.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">큐가 메시지를 포함하도록 대기하는 최대 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 반환하지만 제거(피킹)하지는 않습니다. <see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있거나 지정된 시간이 초과될 때까지 현재 실행 스레드를 차단시킵니다.</summary>
        <returns>큐에 있는 첫 번째 메시지를 나타내는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 큐를 피킹할 또는 큐에 있는 지정된 된 메시지가 될 때 까지의 시간 동안 대기 합니다. 메시지가 큐에 이미 있는 경우 메서드가 즉시 반환 합니다.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 첫 번째 메시지를 큐에서 제거 되지 않습니다. 따라서 반복 호출을 <xref:System.Messaging.MessageQueue.Peek%2A> 우선 순위가 높은 메시지 큐에 도착 하지 않는 한 동일한 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.Receive%2A> 모두 메서드, 다른 한편으로 읽고 큐에서 첫 번째 메시지를 제거 합니다. 에 대 한 호출을 반복 <xref:System.Messaging.MessageQueue.Receive%2A>, 따라서 서로 다른 메시지를 반환 합니다.  
  
 메시지 큐는 우선 순위 및 도착 시간에 따라 큐에 메시지를 정렬합니다. 최신 메시지의 우선 순위가 높은 경우에 이전 앞에 배치 됩니다.  
  
 큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다. 시간에 또는 무기한으로 지정 된 기간까지 스레드가 차단 됩니다 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout>합니다. 대기하지 않고 애플리케이션 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Peek%2A> 제한 시간이 큐가 비어 있는지 여부를 확인 하려면 0 사용 하 여 메서드.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">큐가 메시지를 포함하도록 대기하는 최대 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="action"><see cref="T:System.Messaging.PeekAction" /> 값 중 하나입니다. 이 값은 큐의 현재 메시지를 피킹할지 또는 다음 메시지를 피킹할지 여부를 나타냅니다.</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 또는 다음 메시지를 제거하지 않고 반환(피킹)합니다. <see cref="M:System.Messaging.MessageQueue.Peek" /> 메서드는 동기적이므로 메시지를 사용할 수 있거나 지정된 시간이 초과될 때까지 현재 실행 스레드를 차단시킵니다.</summary>
        <returns>큐에 있는 메시지를 나타내는 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 큐를 피킹할 또는 큐에 있는 지정된 된 메시지가 될 때 까지의 시간 동안 대기 합니다. 메시지가 큐에 이미 있는 경우 메서드가 즉시 반환 합니다.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드 읽지만 큐에서 메시지를 제거 하지 않습니다. <xref:System.Messaging.MessageQueue.Receive%2A> 모두 메서드, 다른 한편으로 읽고 큐에서 메시지를 제거 합니다.  
  
 큐에 메시지가 도착할 때까지 대기하는 동안 현재 스레드를 차단하는 것이 허용되는 경우에만 <xref:System.Messaging.MessageQueue.Peek%2A>를 사용합니다. 시간에 또는 무기한으로 지정 된 기간까지 스레드가 차단 되 지정한 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout>합니다. 대기하지 않고 애플리케이션 처리를 계속하려면 비동기 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 메서드를 사용합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" /> 매개 변수에 대해 <see langword="PeekAction.Current" /> 또는 <see langword="PeekAction.Next" /> 이외의 값을 지정했습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 피킹합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">피킹할 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 피킹합니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 참조 하는 큐에서 찾습니다를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수 예외가 throw 됩니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드는 큐의 메시지 피킹을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Peek%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 특히 긍정 승인을 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">피킹할 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 피킹하며, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 참조 하는 큐에서 찾습니다를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 일치 하는 메시지가 없으면 합니다 `correlationID` 매개 변수를 새 메시지 없이 지정 된 기간 내에서 큐에 도착할는 `timeout` 매개 변수 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하려면 새 메시지의는 `correlationId` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는 `correlationId` 매개 변수입니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드는 큐의 메시지 피킹을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Peek%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 메시지가 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 메시지 식별자가 포함된 메시지의 복사본을 반환하지만 큐에서 해당 메시지를 제거하지는 않습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">피킹할 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <summary>메시지 식별자가 <paramref name="id" /> 매개 변수와 일치하는 메시지를 피킹합니다.</summary>
        <returns><see cref="T:System.Messaging.Message" /> 속성이 <paramref name="id" /> 매개 변수와 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 큐에서 제거 하지 않고 읽기 알려진된 메시지 식별자를 가진 메시지입니다. 메시지의 식별자가 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다. 이 오버 로드 된 큐 메시지를 포함 하지 않는 경우 예외가 throw 됩니다.  
  
 두 개의 추가 메서드를 사용 하면 큐에서 피킹 메시지: <xref:System.Messaging.MessageQueue.Peek%2A> 고 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>입니다. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 큐에서 첫 번째 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 승인, 보고서, 또는 큐로 보낸 메시지의 결과로 생성 된 응용 프로그램에서 생성 한 응답 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지가 없습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">피킹할 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>메시지 식별자가 <paramref name="id" /> 매개 변수와 일치하는 메시지를 피킹합니다. 큐에 메시지가 표시되거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns><see cref="T:System.Messaging.Message" /> 속성이 <paramref name="id" /> 매개 변수와 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 큐에서 제거 하지 않고 읽기 알려진된 메시지 식별자를 가진 메시지입니다. 메시지의 식별자가 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다. 이 오버 로드는 큐 메시지를 포함 하지 않는 경우 시간 제한이 발생 하기 전에 새 메시지가 도착 하지 않으면 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하려면 새 메시지의는 `id` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.Id%2A> 일치 하는 `id` 매개 변수입니다.  
  
 두 개의 추가 메서드를 사용 하면 큐에서 피킹 메시지: <xref:System.Messaging.MessageQueue.Peek%2A> 고 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>입니다. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 큐에서 첫 번째 메시지를 반환 합니다. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 승인, 보고서, 또는 큐로 보낸 메시지의 결과로 생성 된 응용 프로그램에서 생성 한 응답 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />가 들어 있는 메시지가 큐에 없고 <paramref name="timeout" /> 매개 변수가 지정한 기간이 만료되기 전에 메시지가 도착하지 않았습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐의 특정 메시지를 피킹합니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">피킹할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 비트랜잭션 큐에서 지정된 조회 식별자를 갖는 메시지를 피킹합니다.</summary>
        <returns>전달된 <paramref name="lookupId" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.LookupId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐에서 제거 하지 않고 알려진된 조회 식별자를 갖는 메시지를 읽으려면이 메서드를 사용 합니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다.  
  
 합니다 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 메시지 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 지정 된 `lookupId` 매개 변수입니다.  
  
 지정한 lookup 식별자와 메시지를 읽고 큐에서 제거를 사용 하 여를 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 메서드.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다. 다음 중 하나를 지정합니다. 
 <see langword="MessageLookupAction.Current" />: <paramref name="lookupId" />로 지정된 메시지를 피킹합니다.  
  
 <see langword="MessageLookupAction.Next" />: <paramref name="lookupId" />로 지정된 메시지의 뒤에 있는 메시지를 피킹합니다.  
  
 <see langword="MessageLookupAction.Previous" />: <paramref name="lookupId" />로 지정된 메시지의 앞에 있는 메시지를 피킹합니다.  
  
 <see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 피킹합니다. <paramref name="lookupId" /> 매개 변수는 0으로 설정되어야 합니다.  
  
 <see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 피킹합니다. <paramref name="lookupId" /> 매개 변수는 0으로 설정되어야 합니다.</param>
        <param name="lookupId">0에서 피킹할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다. 0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐의 특정 메시지를 피킹합니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
        <returns>전달된 <paramref name="action" /> 및 <paramref name="lookupId" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐에서 제거 하지 않고 알려진된 조회 식별자를 갖는 메시지를 읽으려면이 메서드를 사용 합니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다.  
  
 합니다 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 메시지 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 지정 된 `lookupId` 매개 변수입니다.  
  
 지정한 식별자를 가진 메시지를 읽고 큐에서 제거를 사용 하 여를 <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> 메서드.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 메시지를 제거하지 않고 메시지를 읽는 경우에 발생합니다. 이는 비동기 작업인 <see cref="M:System.Messaging.MessageQueue.BeginPeek" />의 결과입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 비동기 처리에 발생 하는 데 사용 되는 <xref:System.Messaging.MessageQueue.PeekCompleted> 메시지 큐에서 사용할 수 있는 경우.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> 호출 하 여 시작 작업을 완료 하는 데 사용 됩니다 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 고 메시지를 피킹할 때는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 합니다.  
  
 <xref:System.Messaging.PeekCompletedEventHandler> 대리자를 만들 때, 이벤트를 처리할 메서드를 식별합니다. 이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다. 대리자를 제거하지 않는 경우 이벤트가 발생할 때마다 이벤트 처리기가 호출됩니다. 이벤트 처리기 대리자에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 이벤트 처리기를 만듭니다 `MyPeekCompleted`에 연결 합니다 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트 처리기 대리자를 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 경로에 있는 큐에 비동기 작업을 시작 하려면 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.PeekCompleted> 이벤트가 발생 하 고 예제는 메시지를 피킹합니다 화면으로 해당 본문을 작성 합니다. 이 예제에서는 호출 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 다시 새 비동기 작업을 시작 하려면  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>큐에 포함된 모든 메시지를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐를 비우면 메시지 큐에 영향을 주는 큐 수정 플래그를 설정 하 여 <xref:System.Messaging.MessageQueue.LastModifyTime%2A> 속성입니다. 큐에서 제거 되는 메시지는 손실 됩니다. 배달 못 한 편지 큐 또는 저널 큐에 전송 되지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Purge%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐를 식별하는 이름을 가져오거나 설정합니다.</summary>
        <value>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐를 식별하는 이름입니다. 이 값은 <see langword="null" />일 수 없습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결합할 수 있습니다 합니다 <xref:System.Messaging.MessageQueue.QueueName%2A> 사용 하 여는 <xref:System.Messaging.MessageQueue.MachineName%2A> 친숙 한 만들려면 <xref:System.Messaging.MessageQueue.Path%2A> 큐의 이름입니다. 이름 변형에 대 한 구문을 <xref:System.Messaging.MessageQueue.Path%2A> 속성 표에 표시 된 것과 같이 큐의 유형에 따라 다릅니다.  
  
|큐 유형|구문|  
|----------------|------------|  
|공개 큐|`MachineName`\\`QueueName`|  
|개인 큐|`MachineName`\\`Private$`\\`QueueName`|  
|저널 큐|`MachineName`\\`QueueName`\\`Journal$`|  
  
 사용 하 여 "."를 로컬 컴퓨터를 나타내는입니다.  
  
 변경 된 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성에 영향을 줍니다는 <xref:System.Messaging.MessageQueue.Path%2A> 속성입니다. 설정 하는 경우는 <xref:System.Messaging.MessageQueue.QueueName%2A> 설정 하지 않고는 <xref:System.Messaging.MessageQueue.MachineName%2A> 속성을 <xref:System.Messaging.MessageQueue.Path%2A> 속성이 됩니다.\\ `QueueName`. 그렇지 않으면 합니다 <xref:System.Messaging.MessageQueue.Path%2A> 됩니다 `MachineName` \\ `QueueName`합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|예|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.QueueName%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">큐 이름이 <see langword="null" />입니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에서 메시지를 읽는 데 사용되는 기본 핸들을 가져옵니다.</summary>
        <value>큐에서 메시지를 피킹하거나 받는 데 사용하는 네이티브 큐 개체에 대한 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> 큐에서 메시지를 주고받는 보기에 사용 되는 메시지 큐 개체에 대 한 네이티브 Windows 핸들을 제공 합니다. 큐의 경로 변경 하면 핸들이 닫히고 새 값으로.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <summary>큐에 있는 첫 번째 메시지를 받고, 큐에서 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 큐에서 메시지를 받거나 큐에 메시지가 있을 때까지 기다립니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 새로운, 또는 큐에서 우선 순위가 높은 메시지를 수행 하는 메시지를 반환 합니다.  
  
 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 이 오버 로드는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 무기한 시간 제한을 지정, 애플리케이션이 무기한 대기 합니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 메시지를 수신 및 화면에 해당 메시지에 대 한 정보를 출력 합니다.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐 로부터 메시지를 수신 하는 `transaction` 매개 변수 또는 큐에 메시지가 있을 때까지 기다립니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 나오는 메시지를 반환 합니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다에 대 한 호출으로 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>입니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 이 오버 로드는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 무기한 시간 제한을 지정, 애플리케이션이 무기한 대기 합니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 로컬 컴퓨터의 트랜잭션 큐에 연결 하 고 큐에 메시지를 보냅니다. 그런 다음 주문을 포함 하는 메시지를 받습니다. 비트랜잭션 큐를 발견할 경우 throw 됩니다 예외 및 트랜잭션 롤백하고 있습니다.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
또는 
비트랜잭션 큐입니다.</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 메시지를 사용할 수 있을 때까지 현재 실행 스레드를 중단합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의한 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하는 `transactionType` 매개 변수 또는 큐에 메시지가 있을 때까지 기다립니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 나오는 메시지를 반환 합니다.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다에 대 한 호출으로 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>입니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 이 오버 로드는 <xref:System.Messaging.MessageQueue.Receive%2A> 메서드는 무기한 시간 제한을 지정, 애플리케이션이 무기한 대기 합니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐의 첫 번째 메시지를 받고, 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버로드를 사용하여 메시지를 받고, 큐에 메시지가 없는 경우에는 지정된 시간 내에 반환합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 동기적으로 메시지를 읽고 메서드를 사용 하면 큐에서 제거 합니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 새로운, 또는 큐에서 우선 순위가 높은 메시지를 수행 하는 메시지를 반환 합니다.  
  
 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 스레드가 지정 된 기간의 시간 또는 무기한으로 차단 됩니다의 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 메시지를 수신 및 화면에 해당 메시지에 대 한 정보를 출력 합니다. 이 예제에서는 메시지가 큐에 도착할 때까지 기다리는 동안 최대 5 초 동안 실행이 일시 중지 합니다.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다. 사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우 
이 오버로드를 사용하여 메시지를 받고, 큐에 메시지가 없는 경우에는 지정된 시간 내에 반환합니다.</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐의 첫 번째 메시지를 받으며, 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐 로부터 메시지를 수신 하는 `transaction` 매개 변수, 및는 지정 된 기간 내 큐에 메시지가 없는 경우 반환 합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 나오는 메시지를 반환 합니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다에 대 한 호출으로 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>입니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 스레드가 지정 된 기간의 시간 또는 무기한으로 차단 됩니다의 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는이 메서드를 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
또는 
비트랜잭션 큐입니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에서 사용할 수 있는 첫 번째 메시지를 받습니다. 이 호출은 동기적이므로 큐에 메시지를 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>큐에서 사용할 수 있는 첫 번째 메시지를 참조하는 <see cref="T:System.Messaging.Message" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의한 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하는 `transactionType` 매개 변수 및 지정 된 기간 동안 큐에 메시지가 없는 경우 시간을 반환 합니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 나오는 메시지를 반환 합니다.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 큐의 첫 번째 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. <xref:System.Messaging.MessageQueue.Peek%2A> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다에 대 한 호출으로 롤백할 수 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>입니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 스레드가 지정 된 기간의 시간 또는 무기한으로 차단 됩니다의 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는이 메서드를 사용 하는 방법을 보여 줍니다.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다. 사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</summary>
        <returns>큐에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 트랜잭션 큐 로부터 메시지를 수신 하는 `transaction` 매개 변수, 및는 지정 된 기간 내 큐에 메시지가 없는 경우 반환 합니다.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 나오는 메시지를 반환 합니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 트랜잭션이 중단 되 면 수신 되는 메시지 큐로 반환 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 큐의 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다, 호출 하 여 롤백하지 즉 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 스레드는 지정 된 기간의 시간 또는 무기한으로 차단 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우  
  
또는 
<paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
또는 
비트랜잭션 큐입니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="cursor">메시지 큐에서 특정 위치를 유지하는 <see cref="T:System.Messaging.Cursor" />입니다.</param>
        <param name="transactionType">메시지와 연결할 트랜잭션 컨텍스트 형식을 설명하는 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나입니다.</param>
        <summary>지정된 커서를 사용하여 큐에 있는 현재 메시지를 받습니다. 사용할 수 있는 메시지가 없는 경우 이 메서드는 메시지를 사용할 수 있거나 시간 제한이 만료될 때까지 대기합니다.</summary>
        <returns>큐에 있는 메시지를 참조하는 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 정의한 트랜잭션 컨텍스트를 사용 하 여 큐에서 메시지를 수신 하는 `transactionType` 매개 변수 및 지정 된 기간 동안 큐에 메시지가 없는 경우 시간을 반환 합니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 제거 하므로 동기적으로 메시지를 읽고 메서드를 사용 하면 됩니다. 에 대 한 후속 호출 <xref:System.Messaging.MessageQueue.Receive%2A> 큐에서 나오는 메시지를 반환 합니다.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 트랜잭션이 중단 되 면 수신 되는 메시지 큐로 반환 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 큐의 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.Peek%2A> 메서드. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.Peek%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.Peek%2A> 큐에 메시지를 제거 하지 않습니다, 호출 하 여 롤백하지 즉 <xref:System.Messaging.MessageQueueTransaction.Abort%2A>합니다.  
  
 호출 하 여 <xref:System.Messaging.MessageQueue.Receive%2A> 것이 허용 되는 현재 스레드를 메시지가 큐에 도착할 때까지 대기 하는 동안 차단 합니다. 스레드는 지정 된 기간의 시간 또는 무기한으로 차단 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수입니다. 애플리케이션 처리 메시지를 기다리지 않고 계속 해야 하는 경우 비동기 메서드를 사용 하 여 고려해 야 <xref:System.Messaging.MessageQueue.BeginReceive%2A>합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="cursor" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우 <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 큐에 메시지가 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <threadsafe>메서드는 스레드로부터 안전 하지 않습니다.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 받습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받습니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 존재하지 않는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 참조 하는 비트랜잭션 큐에서 찾습니다를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수 예외가 throw 됩니다. 이 고, 그렇지 메시지 큐에서 제거 되 고 애플리케이션에 반환 됩니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 합니다.  
  
 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 큐에서 주문을 포함 하는 메시지를 송수신 설정 합니다. 원본 메시지가 도달 하거나이 특히 긍정 승인을 요청 큐에서 검색 합니다.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 트랜잭션 큐로부터 받습니다. 지정된 상관 관계 식별자가 포함된 메시지가 큐에 현재 존재하지 않는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 참조 하는 트랜잭션 큐에서 검색를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수 예외가 throw 됩니다. 메시지 큐에서 제거 되 고 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 애플리케이션에 반환 되는 고, 그렇지는 `transaction` 매개 변수입니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우  
  
또는 
<paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">비트랜잭션 큐입니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 받습니다. 지정된 상관 관계 식별자가 들어 있는 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 참조 하는 큐에서 찾습니다를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 메시지가 발견 되지 일치 하는 경우는 `correlationID` 매개 변수 예외가 throw 됩니다. 메시지 큐에서 제거 되 고 정의한 트랜잭션 컨텍스트를 사용 하 여 애플리케이션에 반환 되는 고, 그렇지는 `transactionType` 매개 변수입니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 참조 하는 비트랜잭션 큐에서 찾습니다를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 상관 관계 식별자를 사용 하 여 메시지에서 지정 하는 경우이 메서드가 즉시 반환 된 `correlationId` 매개 변수는 큐에 있습니다. 이 고, 그렇지 메서드는 새 메시지가 도착에 대 한 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하려면 새 메시지의는 `correlationId` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는 `correlationId` 매개 변수입니다.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 트랜잭션 큐로부터 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 참조 하는 트랜잭션 큐에서 검색를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 상관 관계 식별자를 사용 하 여 메시지에서 지정 하는 경우이 메서드가 즉시 반환 합니다 `correlationId` 매개 변수는 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transaction` 매개 변수입니다. 이 고, 그렇지 메서드는 새 메시지가 도착에 대 한 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하려면 새 메시지의는 `correlationId` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는 `correlationId` 매개 변수입니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우  
  
또는 
<paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.  
  
또는 
비트랜잭션 큐입니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">받을 메시지의 <see cref="P:System.Messaging.Message.CorrelationId" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 상관 관계 식별자를 갖는 메시지를 받고, 지정된 상관 관계 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="correlationId" /> 매개 변수와 <see cref="T:System.Messaging.Message" />가 일치하는 <see cref="P:System.Messaging.Message.CorrelationId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 참조 하는 큐에서 찾습니다를 <xref:System.Messaging.MessageQueue> 메시지에 대 한 해당 <xref:System.Messaging.Message.CorrelationId%2A> 지정 된 일치 `correlationId` 매개 변수입니다. 상관 관계 식별자를 사용 하 여 메시지에서 지정 하는 경우이 메서드가 즉시 반환 합니다 `correlationId` 매개 변수는 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transactionType` 매개 변수입니다. 이 고, 그렇지 메서드는 새 메시지가 도착에 대 한 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는지 확인 하려면 새 메시지의는 `correlationId` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.CorrelationId%2A> 일치 하는 `correlationId` 매개 변수입니다. 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> 속성 관련된 응답, 보고서 또는 승인 메시지를 큐로 보낸 메시지를 연결 하는 데 사용 됩니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 메서드 고유 식별자를 지정 하 여 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 상관 관계 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="correlationId" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="correlationId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">지정된 <paramref name="correlationId" />가 들어 있는 메시지가 큐에 없고 제한 시간이 만료되기 전에 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>주어진 식별자를 갖는 메시지를 받고, 큐에서 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받습니다. 지정된 식별자가 들어 있는 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 사용 하 여 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다.  
  
 합니다 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드는 승인, 보고서 또는 큐로 보낸 메시지의 결과로 생성 된 애플리케이션에서 생성 한 응답 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 식별자를 갖는 메시지를 트랜잭션 큐로부터 받습니다. 지정된 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 사용 하 여 메시지를 읽고 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 된 `transaction` 매개 변수입니다. 이 메서드는 즉시 예외를 throw 하면 메시지가 큐에 없는 경우  
  
 합니다 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드는 승인, 보고서 또는 큐로 보낸 메시지의 결과로 생성 된 애플리케이션에서 생성 한 응답 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우  
  
또는 
<paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">비트랜잭션 큐입니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 받습니다. 지정된 식별자가 포함된 메시지가 큐에 현재 없는 경우에는 바로 예외가 발생합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 사용 하 여 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다. 메시지 큐에서 제거 되 고 정의한 트랜잭션 컨텍스트를 사용 하 여 애플리케이션에 반환 되는 고, 그렇지는 `transactionType` 매개 변수입니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 합니다 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다. 지정한 식별자를 가진 메시지는 큐와 연결 된 것과 다른 경우 <xref:System.Messaging.MessageQueue> 인스턴스 메시지를 찾을 수 없습니다.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드는 승인, 보고서 또는 큐로 보낸 메시지의 결과로 생성 된 애플리케이션에서 생성 한 응답 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="id" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 비트랜잭션 큐로부터 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 사용 하 여 메시지를 읽고 큐에서 제거 합니다. 식별자를 사용 하 여 메시지에서 지정 하는 경우이 메서드가 즉시 반환 된 `id` 매개 변수는 큐에 있습니다. 이 고, 그렇지 메서드는 새 메시지가 도착에 대 한 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하려면 새 메시지의는 `id` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.Id%2A> 일치 하는 `id` 매개 변수입니다.  
  
 합니다 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다.  
  
 이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에서 큐에 도착 하는 데 계속으로 허용 되는 `timeout` 매개 변수입니다. 스레드가 차단 됩니다에 대 한 최소 시간의 또는 무기한으로 지정된 된 기간 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한 합니다 `timeout` 매개 변수를 새 메시지에 지정한 제한 시간 내에서 큐에 도착 하는 데 계속 또는 `timeout` 매개 변수입니다.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드는 승인, 보고서 또는 큐로 보낸 메시지의 결과로 생성 된 애플리케이션에서 생성 한 응답 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>주어진 식별자를 갖는 메시지를 트랜잭션 큐로부터 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 사용 하 여 메시지를 읽고 정의한 내부 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 된 `transaction` 매개 변수입니다. 식별자를 사용 하 여 메시지에서 지정 하는 경우이 메서드가 즉시 반환 된 `id` 매개 변수는 큐에 있습니다. 이 고, 그렇지 메서드는 새 메시지가 도착에 대 한 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하려면 새 메시지의는 `id` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.Id%2A> 일치 하는 `id` 매개 변수입니다.  
  
 합니다 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다.  
  
 이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에서 큐에 도착 하는 데 계속으로 허용 되는 `timeout` 매개 변수입니다. 스레드가 차단 됩니다에 대 한 최소 시간의 또는 무기한으로 지정된 된 기간 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한는 `timeout` 매개 변수를 지정 된 시간 제한 기간 내에서 큐에 도착 하는 데 계속 새 메시지 또는 `timeout` 매개 변수입니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드는 승인, 보고서 또는 큐로 보낸 메시지의 결과로 생성 된 애플리케이션에서 생성 한 응답 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 된 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않는 한 메서드에 대 한 후속 호출에 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우  
  
또는 
<paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.  
  
또는 
비트랜잭션 큐입니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">받을 메시지의 <see cref="P:System.Messaging.Message.Id" />입니다.</param>
        <param name="timeout">새 메시지를 검사할 수 있을 때까지 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>주어진 식별자를 갖는 메시지를 받고, 지정된 식별자가 포함된 메시지를 큐에서 사용할 수 있거나 제한 시간이 만료될 때까지 대기합니다.</summary>
        <returns>전달된 <paramref name="id" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.Id" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 식별자를 사용 하 여 메시지를 읽고 큐에서 제거 합니다. 식별자를 사용 하 여 메시지에서 지정 하는 경우이 메서드가 즉시 반환 합니다 `id` 매개 변수는 여 정의 된 트랜잭션 컨텍스트를 사용 하 여 큐에는 `transactionType` 매개 변수입니다. 이 고, 그렇지 메서드는 새 메시지가 도착에 대 한 지정 된 기간을 대기 합니다. 제한 시간이 만료 되기 전에 새 메시지가 도착 하지 않으면, 예외가 throw 됩니다.  
  
 `timeout` 매개 변수는 총 실행이 메서드에 대 한 시간을 지정 하지 않습니다. 새 메시지가 큐에 도착할 때까지 기다리는 시간을 지정 합니다. 때마다 새 메시지가 도착 하면이 메서드를 검사 합니다 <xref:System.Messaging.Message.Id%2A> 일치 하는지 확인 하려면 새 메시지의는 `id` 매개 변수입니다. 그렇지 않은 경우이 메서드를 통해 제한 시간을 시작 하 고 다른 새 메시지가 도착할 때까지 기다립니다. 따라서 새 메시지 시간 제한 기간 내에 도착 하는 데 계속 것 없이 새 메시지 도착 한 시간 제한 기간이 만료 될 때까지 또는 해당 메시지가 도착할 때까지 무기한으로 실행을 계속 하려면이 메서드에 대 한 가능한 <xref:System.Messaging.Message.Id%2A> 일치 하는 `id` 매개 변수입니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 합니다 <xref:System.Messaging.Message.Id%2A> 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에서 메시지의 속성은 메시지 큐 엔터프라이즈 전체에서 고유 합니다 지정 `id` 매개 변수입니다. 지정한 식별자를 가진 메시지는 큐와 연결 된 것과 다른 경우 <xref:System.Messaging.MessageQueue> 인스턴스 메시지를 찾을 수 없습니다.  
  
 이 오버 로드를 사용 하 여 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> 것이 현재 스레드를 차단 하 여 새 메시지에 지정한 제한 시간 내에서 큐에 도착 하는 데 계속으로 허용 되는 `timeout` 매개 변수입니다. 스레드가 차단 됩니다에 대 한 최소 시간의 또는 무기한으로 지정된 된 기간 값을 지정 하는 경우 <xref:System.Messaging.MessageQueue.InfiniteTimeout> 에 대 한 합니다 `timeout` 매개 변수를 새 메시지에 지정한 제한 시간 내에서 큐에 도착 하는 데 계속 또는 `timeout` 매개 변수입니다.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 다른 두 메서드를 사용 하면 큐에서 메시지를 받을 수 있습니다. 합니다 <xref:System.Messaging.MessageQueue.Receive%2A> 큐의 첫 번째 메시지를 반환 하는 메서드 및 <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> 메서드는 승인, 보고서 또는 큐로 보낸 메시지의 결과로 생성 된 애플리케이션에서 생성 한 응답 메시지를 검색 하는 합니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 메서드는 항상 반환 첫 번째 메시지 큐에서 우선 순위가 높은 메시지 큐에 도착 하지 않으면 후속 메서드 호출이 동일한 메시지를 반환 합니다. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="timeout" /> 매개 변수에 지정된 값이 잘못된 경우. <paramref name="timeout" />이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />보다 클 수 있습니다.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">제한 시간이 만료되기 전에 <paramref name="id" />가 지정된 메시지가 큐에 도착하지 않았습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>MSMQ 3.0에서 도입되었습니다. 큐에서 특정 메시지를 받습니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">받을 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 비트랜잭션 큐에서 지정된 조회 식별자를 갖는 메시지를 받습니다.</summary>
        <returns>전달된 <paramref name="lookupId" /> 매개 변수와 <see cref="T:System.Messaging.Message" /> 속성이 일치하는 <see cref="P:System.Messaging.Message.LookupId" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지를 읽고 큐에서 제거 합니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다.  
  
 합니다 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 메시지 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 지정 된 `lookupId` 매개 변수입니다.  
  
 지정한 lookup 식별자와 메시지 큐에서 제거 하지 않고 읽기를 사용 하 여를 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다. 다음 중 하나를 지정합니다. 
 <see langword="MessageLookupAction.Current" />: <paramref name="lookupId" />로 지정된 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Next" />: <paramref name="lookupId" />로 지정된 메시지의 뒤에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Previous" />: <paramref name="lookupId" />로 지정된 메시지의 앞에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 받고 큐에서 제거합니다. <paramref name="lookupId" /> 매개 변수는 0으로 설정되어야 합니다.  
  
 <see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 받고 큐에서 제거합니다. <paramref name="lookupId" /> 매개 변수는 0으로 설정되어야 합니다.</param>
        <param name="lookupId">0을 수신할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다. 0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 트랜잭션 큐에서 특정 메시지를 받습니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
        <returns>전달된 <paramref name="lookupId" /> 및 <paramref name="action" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지를 읽고 정의한 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 된 `transaction` 매개 변수입니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다.  
  
 합니다 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 메시지 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 지정 된 `lookupId` 매개 변수입니다.  
  
 트랜잭션 큐에이 메서드는, 때문에 수신 된 메시지 반환 됩니다 큐에 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에서 메시지를 제거 하지 않습니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우  
  
또는 
비트랜잭션 큐입니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">큐에서 메시지를 읽는 방법을 지정하는 <see cref="T:System.Messaging.MessageLookupAction" /> 값 중 하나입니다. 다음 중 하나를 지정합니다. 
 <see langword="MessageLookupAction.Current" />: <paramref name="lookupId" />로 지정된 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Next" />: <paramref name="lookupId" />로 지정된 메시지의 뒤에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.Previous" />: <paramref name="lookupId" />로 지정된 메시지의 앞에 있는 메시지를 받고 큐에서 제거합니다.  
  
 <see langword="MessageLookupAction.First" />: 큐에 있는 첫 번째 메시지를 받고 큐에서 제거합니다. <paramref name="lookupId" /> 매개 변수는 0으로 설정되어야 합니다.  
  
 <see langword="MessageLookupAction.Last" />: 큐에 있는 마지막 메시지를 받고 큐에서 제거합니다. <paramref name="lookupId" /> 매개 변수는 0으로 설정되어야 합니다.</param>
        <param name="lookupId">0을 수신할 메시지의 <see cref="P:System.Messaging.Message.LookupId" />입니다. 0은 큐에 있는 첫 번째 또는 마지막 메시지에 액세스할 때 사용됩니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>MSMQ 3.0에서 도입되었습니다. 지정된 트랜잭션 컨텍스트를 사용하여 큐에서 특정 메시지를 받습니다. 메시지는 조회 식별자로 지정하거나 큐의 앞이나 뒤와 같은 위치로 지정할 수 있습니다.</summary>
        <returns>전달된 <paramref name="action" /> 및 <paramref name="lookupId" /> 매개 변수로 지정된 <see cref="T:System.Messaging.Message" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 알려진된 조회 식별자를 갖는 메시지를 읽고 정의한 트랜잭션 컨텍스트를 사용 하 여 큐에서 제거 된 `transactionType` 매개 변수입니다. 이 메서드는 메시지 큐에 없는 경우 즉시 예외를 throw 합니다.  
  
 합니다 <xref:System.Messaging.Message.LookupId%2A> 메시지의 속성은 큐에 고유한 메시지 있는 될 수 있도록 최대 하나의 메시지와 일치 하는 큐에는 지정 된 `lookupId` 매개 변수입니다.  
  
 큐에서 제거 하지 않고 지정 된 식별자를 사용 하 여 메시지를 읽으려면, 사용 된 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 메서드. 호출 하 여 반환 된 메시지와 연결 된 트랜잭션 컨텍스트가 없는 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>합니다. 때문에 <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 트랜잭션이 중단 된 경우에 다시 롤포워드할 수, 큐에서 메시지를 제거 하지 않습니다.  
  
 지정할 `Automatic` 에 대 한는 `transactionType` 매개 변수가 이미 있는 경우 외부 트랜잭션 컨텍스트를 사용 하 여 메시지를 수신 하려는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 수신 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 컨텍스트 외부에서 트랜잭션 큐 로부터 메시지를 수신 하려는 경우.  
  
 를 트랜잭션 큐 로부터 메시지를 받으려면이 메서드를 호출 하면 수신 된 메시지에 반환 됩니다 큐 트랜잭션이 중단 됩니다. 메시지가 제거 되지 않습니다 영구적으로 큐에서 트랜잭션이 커밋될 때까지.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0이 설치되어 있지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">지정된 <paramref name="lookupId" />의 메시지를 찾을 수 없는 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 매개 변수가 <see cref="T:System.Messaging.MessageLookupAction" /> 멤버 중 하나가 아닌 경우  
  
또는 
<paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐에서 메시지가 제거된 경우에 발생합니다. 이 이벤트는 비동기 작업인 <see cref="M:System.Messaging.MessageQueue.BeginReceive" />에 의해 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 비동기 처리에 발생 하는 데 사용 되는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 메시지 큐에서 사용할 수 있는 경우.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> 호출 하 여 시작 작업을 완료 하는 데 사용 됩니다 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 고 메시지를 피킹할 때는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 합니다.  
  
 <xref:System.Messaging.ReceiveCompletedEventHandler> 대리자를 만들 때, 이벤트를 처리할 메서드를 식별합니다. 이벤트를 이벤트 처리기와 연결하려면 대리자의 인스턴스를 해당 이벤트에 추가합니다. 대리자를 제거하지 않는 경우 이벤트가 발생할 때마다 이벤트 처리기가 호출됩니다. 이벤트 처리기 대리자에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 이벤트 처리기를 만듭니다 `MyReceiveCompleted`에 연결 합니다 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트 처리기 대리자를 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 시작 하는 비동기 수신 작업 경로에 있는 큐에 ". \myQueue"입니다. 경우는 <xref:System.Messaging.MessageQueue.ReceiveCompleted> 이벤트가 발생 하면이 예제에서는 메시지를 받고 해당 본문을 화면에 씁니다. 이 예제에서는 호출 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 새 시작을 다시 비동기 수신 작업입니다.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Messaging.MessageQueue" />가 제공하는 속성을 새로 고쳐 리소스의 현재 상태를 반영합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> 속성의 동기화를 <xref:System.Messaging.MessageQueue> 연결된 메시지 큐 서버 리소스를 사용 하 여 합니다. 경우 모든 속성을 같은 <xref:System.Messaging.MessageQueue.Label%2A> 또는 <xref:System.Messaging.MessageQueue.Category%2A>, 이후에 서버에서 변경 된를 <xref:System.Messaging.MessageQueue> 만들어진 <xref:System.Messaging.MessageQueue.Refresh%2A> 업데이트를 <xref:System.Messaging.MessageQueue> 새 정보로.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Refresh%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>사용 권한 목록을 운영 체제의 기본값으로 다시 설정합니다. 기본 목록에 추가한 큐 권한을 모두 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, 사용 권한 목록에서 기본값으로 돌아갑니다. 일반적으로이 큐 작성자 모든 사용 권한을 부여 하 고 Everyone 그룹에 게 다음 권한이 있습니다.  
  
-   큐의 속성을 가져옵니다.  
  
-   큐 권한을 얻습니다.  
  
-   큐에 작성 합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.ResetPermissions%2A>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>큐에 개체를 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 비트랜잭션 큐에 개체를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보내려고 합니다 `obj` 매개 변수를 참조 하는 큐는 <xref:System.Messaging.MessageQueue>. 큐에 보내는 개체 수를 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 전송 하는 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 이 오버 로드를 사용 하 여 트랜잭션 큐로 메시지를 보낼 경우 메시지 배달 못 한 편지 큐로 보내집니다. 받아들이는 오버 로드를 사용 하 여 다른 메시지를 포함 하는 트랜잭션의 일부가 되도록 메시지를 하려는 경우는 <xref:System.Messaging.MessageQueueTransaction> 또는 <xref:System.Messaging.MessageQueueTransactionType> 매개 변수로 합니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 포맷터가 기본값으로 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성 이외의 다른 모든 개체에 적용 되는 <xref:System.Messaging.Message>합니다. 를 지정 하면 예를 들어, 레이블 또는 사용 하 여 우선 순위를 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 형식이 아닌 개체를 포함 하는 모든 메시지에 적용 <xref:System.Messaging.Message> 경우 애플리케이션 큐로 보냅니다는 합니다. 보낼 때를 <xref:System.Messaging.Message>에 대 한 속성 값을 설정 합니다 <xref:System.Messaging.Message> 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐에 연결 하 고 큐에 메시지를 보냅니다.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 다음 코드 예제에서는 애플리케이션 정의 보냅니다 `Order` 큐에 클래스 및 해당 큐에서 메시지를 받습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에 개체를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼 합니다 `obj` 매개 변수를 참조 하는 트랜잭션 큐를 <xref:System.Messaging.MessageQueue>, 정의한 내부 트랜잭션 컨텍스트를 사용 하는 `transaction` 매개 변수. 큐에 보내는 개체 수를 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 전송 하는 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 이 오버 로드를 사용 하 여 비트랜잭션 큐에 메시지를 보낼 경우 예외를 throw 하지 않고 배달 못 한 편지 큐로 메시지를 보낼 수 있습니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 포맷터가 기본값으로 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성 이외의 다른 모든 개체에 적용 되는 <xref:System.Messaging.Message>합니다. 를 지정 하면 예를 들어, 레이블 또는 사용 하 여 우선 순위를 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 형식이 아닌 개체를 포함 하는 모든 메시지에 적용 <xref:System.Messaging.Message> 경우 애플리케이션 큐로 보냅니다는 합니다. 보낼 때를 <xref:System.Messaging.Message>에 대 한 속성 값을 설정 합니다 <xref:System.Messaging.Message> 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 <xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 하며 따라서 아파트 상태가 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다. 에 주 스레드의 상태를 설정 하는 Visual Basic `STA`이므로 적용 해야 합니다는 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴입니다. 그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다. 적용 된 <xref:System.MTAThreadAttribute> 다음 조각을 사용 하 여 합니다.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 문자열은 트랜잭션 큐로 보내고 큐에서 메시지를 받습니다.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
또는 
메시지 큐 애플리케이션에서 트랜잭션을 잘못 사용했음을 나타냈습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에 개체를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼 합니다 `obj` 매개 변수를 참조 하는 큐를 <xref:System.Messaging.MessageQueue>, 정의한 트랜잭션 컨텍스트를 사용 하는 `transactionType` 매개 변수. 지정할 `Automatic` 에 대 한는 `transactionType` 외부 트랜잭션 컨텍스트를 이미 있으면 매개 변수를 사용 하는 메시지를 보내는 원하는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 전송 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 메시지가 비트랜잭션 스레드로 전송 하려는 경우.  
  
 큐에 보내는 개체 수를 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 전송 하는 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 포맷터가 기본값으로 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성 이외의 다른 모든 개체에 적용 되는 <xref:System.Messaging.Message>합니다. 를 지정 하면 예를 들어, 레이블 또는 사용 하 여 우선 순위를 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 형식이 아닌 개체를 포함 하는 모든 메시지에 적용 <xref:System.Messaging.Message> 경우 애플리케이션 큐로 보냅니다는 합니다. 보낼 때를 <xref:System.Messaging.Message>에 대 한 속성 값을 설정 합니다 <xref:System.Messaging.Message> 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="label">메시지의 레이블입니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 비트랜잭션 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보내려고 합니다 `obj` 매개 변수를 참조 하는 큐는 <xref:System.Messaging.MessageQueue>. 이 오버 로드를 사용 하 여 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다. 큐에 보내는 개체 수를 <xref:System.Messaging.Message>, 구조, 데이터 개체 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 전송 하는 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 메시지 레이블에 메시지 큐 레이블을 다릅니다 되지만 둘 다 애플리케이션 종속 되어 상속 메시지 큐에 의미가 없습니다.  
  
 이 오버 로드를 사용 하 여 트랜잭션 큐로 메시지를 보낼 경우 메시지 배달 못 한 편지 큐로 보내집니다. 받아들이는 오버 로드를 사용 하 여 다른 메시지를 포함 하는 트랜잭션의 일부가 되도록 메시지를 하려는 경우는 <xref:System.Messaging.MessageQueueTransaction> 또는 <xref:System.Messaging.MessageQueueTransactionType> 매개 변수로 합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.Path%2A> 속성을이 <xref:System.Messaging.MessageQueue> 메시지를 보내기 전에 인스턴스를 지정 해야 합니다. 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 포맷터가 기본값으로 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성 이외의 다른 모든 개체에 적용 되는 <xref:System.Messaging.Message>합니다. 를 지정 하면 예를 들어, 레이블 또는 사용 하 여 우선 순위를 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 형식이 아닌 개체를 포함 하는 모든 메시지에 적용 <xref:System.Messaging.Message> 경우 애플리케이션 큐로 보냅니다는 합니다. 보낼 때를 <xref:System.Messaging.Message>에 대 한 속성 값을 설정 합니다 <xref:System.Messaging.Message> 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="label">메시지의 레이블입니다.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> 개체</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 트랜잭션 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼 합니다 `obj` 매개 변수를 참조 하는 트랜잭션 큐를 <xref:System.Messaging.MessageQueue>, 정의한 내부 트랜잭션 컨텍스트를 사용 하는 `transaction` 매개 변수. 이 오버 로드를 사용 하 여 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다. 큐에 보내는 개체 수를 <xref:System.Messaging.Message>, 구조, 데이터 개체 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 전송 하는 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다.  
  
 메시지 레이블에 메시지 큐 레이블을 다릅니다 되지만 둘 다 애플리케이션 종속 되어 상속 메시지 큐에 의미가 없습니다.  
  
 이 오버 로드를 사용 하 여 비트랜잭션 큐에 메시지를 보낼 경우 예외를 throw 하지 않고 배달 못 한 편지 큐로 메시지를 보낼 수 있습니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 포맷터가 기본값으로 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성 이외의 다른 모든 개체에 적용 되는 <xref:System.Messaging.Message>합니다. 를 지정 하면 예를 들어, 레이블 또는 사용 하 여 우선 순위를 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 형식이 아닌 개체를 포함 하는 모든 메시지에 적용 <xref:System.Messaging.Message> 경우 애플리케이션 큐로 보냅니다는 합니다. 보내면를 <xref:System.Messaging.Message>에 대 한 속성 값을 설정 합니다 <xref:System.Messaging.Message> 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성  
  
 <xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 하며 따라서 아파트 상태가 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다. 에 주 스레드의 상태를 설정 하는 Visual Basic `STA`이므로 적용 해야 합니다는 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴입니다. 그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다. 적용 된 <xref:System.MTAThreadAttribute> 다음 조각을 사용 하 여 합니다.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우  
  
또는 
<paramref name="transaction" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
또는 
메시지 큐 애플리케이션에서 트랜잭션을 잘못 사용했음을 나타냈습니다.  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">큐에 보낼 개체입니다.</param>
        <param name="label">메시지의 레이블입니다.</param>
        <param name="transactionType"><see cref="T:System.Messaging.MessageQueueTransactionType" /> 값 중 하나로, 메시지와 연결할 트랜잭션 컨텍스트 형식을 설명합니다.</param>
        <summary>이 <see cref="T:System.Messaging.MessageQueue" />가 참조하는 큐에 개체를 보내고 메시지에 레이블을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 포함 된 메시지를 보낼 합니다 `obj` 매개 변수를 참조 하는 큐를 <xref:System.Messaging.MessageQueue>, 정의한 트랜잭션 컨텍스트를 사용 하는 `transactionType` 매개 변수. 지정할 `Automatic` 에 대 한는 `transactionType` 외부 트랜잭션 컨텍스트를 이미 있으면 매개 변수를 사용 하는 메시지를 보내는 원하는 스레드에 연결 합니다. 지정 `Single` 내부 단일 트랜잭션으로 메시지를 전송 하려는 경우. 지정할 수 있습니다 `None` 트랜잭션 메시지가 비트랜잭션 스레드로 전송 하려는 경우.  
  
 큐에 보내는 개체 수를 <xref:System.Messaging.Message> 또는 관리 되는 개체입니다. 이외의 다른 모든 개체를 전송 하는 경우는 <xref:System.Messaging.Message>, 개체를 직렬화 하 고 메시지의 본문에 삽입 합니다. 이 오버 로드를 사용 하 여 메시지를 식별 하는 문자열 레이블을 지정할 수 있습니다.  
  
 메시지 레이블에 메시지 큐 레이블을 다릅니다 되지만 둘 다 애플리케이션 종속 되어 상속 메시지 큐에 의미가 없습니다.  
  
 설정 하지 않은 경우는 <xref:System.Messaging.MessageQueue.Formatter%2A> 호출 하기 전에 속성 <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, 포맷터가 기본값으로 <xref:System.Messaging.XmlMessageFormatter>합니다.  
  
 합니다 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 속성 이외의 다른 모든 개체에 적용 되는 <xref:System.Messaging.Message>합니다. 를 지정 하면 예를 들어, 레이블 또는 사용 하 여 우선 순위를 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 멤버를이 값은 형식이 아닌 개체를 포함 하는 모든 메시지에 적용 <xref:System.Messaging.Message> 경우 애플리케이션 큐로 보냅니다는 합니다. 보낼 때를 <xref:System.Messaging.Message>에 대 한 속성 값을 설정 합니다 <xref:System.Messaging.Message> 보다 우선적으로 적용 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, 및 메시지의 <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> 속성 우선 순위가 큐의 <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> 속성입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="label" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">메시지 큐 애플리케이션에서 트랜잭션을 잘못 사용했음을 나타냈습니다.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="transactionType" /> 매개 변수가 <see cref="T:System.Messaging.MessageQueueTransactionType" /> 멤버 중 하나가 아닌 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> 속성이 설정되어 있지 않은 경우  
  
또는 
메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 집합에 사용 권한을 추가합니다. 큐 속성 및 큐에 있는 메시지에 대해 액세스 권한이 있는 사용자를 제어합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">부여할 사용 권한 및 트러스티를 지정하는 액세스 제어 항목이 하나 이상 포함된 <see cref="T:System.Messaging.AccessControlList" />입니다.</param>
        <summary>액세스 제어 목록의 내용을 기준으로 큐에 액세스 권한을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 트러스티 및 사용 권한 정보를 지정 하려면 액세스 제어 항목의 컬렉션을 사용 하 여 권한을 취소. 이 사용 됩니다, 예를 들어, 한 번에 여러 사용자에 게 권한을 부여 하려면.  
  
 트러스티를 생성할 때 지정 하는 `ace` 매개 변수는 개별 사용자, 사용자, 그룹 또는 컴퓨터 일 수 있습니다. 트러스티가 개별, 형식을 사용 하 여 `DOMAIN` \\ `user`합니다. 지정할 수 있습니다 "." 트러스티 로컬 컴퓨터에 대 한 합니다.  
  
 사용 권한을 통해 할당 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자가 전체 컨트롤 및 도메인 그룹 모든 권한이 큐 속성을 가져오고 사용 권한 가져오기, 큐에 작성 하 합니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보를 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스가 거부 되었습니다 <xref:System.Messaging.AccessControlEntry> 스레드의 액세스 토큰에 나열 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티를 명시적으로 스레드 액세스 토큰에 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로, 경우에 암시적으로 액세스할 수 있습니다.  
  
 생성 하는 경우는 `dacl` 매개 변수를 추가한 <xref:System.Messaging.AccessControlEntry> 인스턴스를 프로그램 <xref:System.Messaging.AccessControlList> 컬렉션입니다. 각 액세스 제어 항목을 생성 하는 경우에 제네릭 또는 표준 액세스 권한을 지정할 수 있습니다. 큐에 대 한 권한을 다음의 조합일 수 있습니다.  
  
-   삭제  
  
-   보안 읽기  
  
-   보안 쓰기  
  
-   동기화  
  
-   소유자 수정  
  
-   읽기  
  
-   Write  
  
-   실행  
  
-   필수  
  
-   모두  
  
-   없음  
  
 이러한 권리는 비트 OR 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합입니다.  
  
-   모든 권한  
  
-   메시지 삭제  
  
-   메시지를 수신 합니다.  
  
-   메시지 보기  
  
-   저널 메시지 받기  
  
-   큐 속성 가져오기  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권  
  
-   메시지 작성  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>의 사용법을 보여줍니다.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">사용자, 액세스 형식 및 사용 권한 형식을 지정하는 <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />입니다.</param>
        <summary>액세스 제어 항목의 내용을 기준으로 큐에 액세스 권한을 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 부여, 거부 또는 트러스티와 권한 정보를 지정 하는 액세스 제어 항목을 사용 하 여 권한을 취소 합니다.  
  
 트러스티를 생성할 때 지정 하는 `ace` 매개 변수는 개별 사용자, 사용자, 그룹 또는 컴퓨터 일 수 있습니다. 트러스티가 개별, 형식을 사용 하 여 `DOMAIN` \\ `user`합니다. 지정할 수 있습니다 "." 트러스티 로컬 컴퓨터에 대 한 합니다.  
  
 사용 권한을 통해 할당 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자가 전체 컨트롤 및 도메인 그룹 모든 권한이 큐 속성을 가져오고 사용 권한 가져오기, 큐에 작성 하 합니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보를 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스가 거부 되었습니다 <xref:System.Messaging.AccessControlEntry> 스레드의 액세스 토큰에 나열 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티를 명시적으로 스레드 액세스 토큰에 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로, 경우에 암시적으로 액세스할 수 있습니다.  
  
 지정 하는 큐에 대 한 권한을 `rights` 매개 변수를 생성할 때에 <xref:System.Messaging.MessageQueueAccessControlEntry>, 다음의 조합일 수 있습니다.  
  
-   모든 권한  
  
-   메시지 삭제  
  
-   메시지를 수신 합니다.  
  
-   메시지 보기  
  
-   저널 메시지 받기  
  
-   큐 속성 가져오기  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권  
  
-   메시지 작성  
  
 합니다 `rights` 에 대 한 생성자에서 지정 하는 매개 변수를 `ace` 매개 변수는 플래그를 <xref:System.Messaging.MessageQueueAccessRights> 열거형입니다. 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합을 나타냅니다 작성 하는 경우 또는 `rights` 매개 변수입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">큐에 대한 추가 권한을 가져오는 개인, 그룹 또는 컴퓨터입니다.</param>
        <param name="rights">전달된 <paramref name="user" />에 메시지 큐 서비스가 할당하는 큐에 대한 권한 집합을 나타내는 <see cref="T:System.Messaging.MessageQueueAccessRights" />입니다.</param>
        <summary>지정된 액세스 권한을 컴퓨터, 그룹, 또는 사용자에게 부여합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 개별 사용자 지정된 권한 부여. 사용자는 개별 사용자, 사용자, 그룹 또는 컴퓨터를 포함 하는 모든 유효한 트러스티를 수 있습니다. 사용자가 개인 형식을 사용 하 여 `DOMAIN` \\ `user` 에 대 한는 `user` 매개 변수입니다. 지정할 수 있습니다 "."에 대 한는 `user` 매개 변수를 로컬 컴퓨터를 나타냅니다.  
  
 사용 권한을 통해 할당 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자가 전체 컨트롤 및 도메인 그룹 모든 권한이 큐 속성을 가져오고 사용 권한 가져오기, 큐에 작성 하 합니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보를 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스가 거부 되었습니다 <xref:System.Messaging.AccessControlEntry> 스레드의 액세스 토큰에 나열 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티를 명시적으로 스레드 액세스 토큰에 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로, 경우에 암시적으로 액세스할 수 있습니다.  
  
 에 지정 된 큐에 대 한 권한을 `rights` 매개 변수를 다음의 조합일 수 있습니다.  
  
-   모든 권한  
  
-   메시지 삭제  
  
-   메시지를 수신 합니다.  
  
-   메시지 보기  
  
-   저널 메시지 받기  
  
-   큐 속성 가져오기  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권  
  
-   메시지 작성  
  
 합니다 <xref:System.Messaging.MessageQueueAccessRights> 열거형은 빌드 또는 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합을 나타냅니다.는 `rights` 매개 변수입니다.  
  
 이 오버 로드를 사용 하 여만 권한을 부여할 수 있습니다. 취소 하거나 거부할 수 없습니다. 다른 오버 로드를 사용 하 여 명시적으로 부여 <xref:System.Messaging.AccessControlEntryType> 이외의 `Allow`합니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="user" />이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">큐에 대한 추가 권한을 가져오는 개인, 그룹 또는 컴퓨터입니다.</param>
        <param name="rights">전달된 <paramref name="user" />에 메시지 큐 서비스가 할당하는 큐에 대한 권한 집합을 나타내는 <see cref="T:System.Messaging.MessageQueueAccessRights" />입니다.</param>
        <param name="entryType"><paramref name="rights" /> 매개 변수로 지정된 사용 권한을 부여할지 거부할지 또는 해지할지를 지정하는 <see cref="T:System.Messaging.AccessControlEntryType" />입니다.</param>
        <summary>지정된 액세스 제어 형식(예: 허용, 거부, 해지, 또는 설정)을 포함하여, 지정된 액세스 권한을 컴퓨터, 그룹 또는 사용자에게 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 사용 하 여 권한을 부여, 거부 또는 개별 사용자에 대 한 지정 된 권한을 취소. 사용자는 개별 사용자, 사용자, 그룹 또는 컴퓨터를 포함 하는 모든 유효한 트러스티를 수 있습니다. 사용자가 개인 형식을 사용 하 여 `DOMAIN` \\ `user` 에 대 한는 `user` 매개 변수입니다. 지정할 수 있습니다 "."에 대 한는 `user` 매개 변수를 로컬 컴퓨터를 나타냅니다.  
  
 사용 권한을 통해 할당 <xref:System.Messaging.MessageQueue.SetPermissions%2A> 기존 목록에 대 한 권한을 추가 합니다. 기본적으로 공용 또는 개인 큐의 작성자가 전체 컨트롤 및 도메인 그룹 모든 권한이 큐 속성을 가져오고 사용 권한 가져오기, 큐에 작성 하 합니다. 호출 하는 경우 <xref:System.Messaging.MessageQueue.SetPermissions%2A>, 사용자 및 권한 정보를 기존 목록 맨 아래에 추가 됩니다.  
  
 각 시스템 검사 <xref:System.Messaging.AccessControlEntry> 다음 이벤트 중 하나가 발생할 때까지 시퀀스에서:  
  
-   액세스가 거부 되었습니다 <xref:System.Messaging.AccessControlEntry> 스레드의 액세스 토큰에 나열 된 트러스티 중 하나에 요청 된 액세스 권한을 명시적으로 거부 합니다.  
  
-   하나 이상의 액세스가 허용 된 <xref:System.Messaging.AccessControlEntry> 트러스티를 명시적으로 스레드 액세스 토큰에 나열 된 모든 요청 된 액세스 권한 부여에 대 한 항목입니다.  
  
-   모든 <xref:System.Messaging.AccessControlEntry> 가 항목을 체크 이며 여전히 하나 이상의 요청 된 액세스 권한이 허용 되지 않은 명시적으로, 경우에 암시적으로 액세스할 수 있습니다.  
  
 에 지정 된 큐에 대 한 권한을 `rights` 매개 변수를 다음의 조합일 수 있습니다.  
  
-   모든 권한  
  
-   메시지 삭제  
  
-   메시지를 수신 합니다.  
  
-   메시지 보기  
  
-   저널 메시지 받기  
  
-   큐 속성 가져오기  
  
-   큐 속성 설정  
  
-   사용 권한 가져오기  
  
-   사용 권한 설정  
  
-   큐 소유권  
  
-   메시지 작성  
  
 합니다 <xref:System.Messaging.MessageQueueAccessRights> 열거형은 빌드 또는 비트 연산자를 사용 하 여 결합할 수 있는 비트 플래그 집합을 나타냅니다.는 `rights` 매개 변수입니다.  
  
 다음 표에서이 메서드는 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>의 사용법을 보여줍니다.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 또는 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> 이벤트의 결과로 생성된 이벤트 처리기의 호출을 마샬링하는 개체를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> 또는 <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> 이벤트의 결과로 생성된 이벤트 처리기의 호출을 마샬링하는 개체를 나타내는 <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> 또는 <xref:System.Messaging.MessageQueue.PeekCompleted> 에서 이벤트가 발생 한 <xref:System.Messaging.MessageQueue.BeginReceive%2A> 또는 <xref:System.Messaging.MessageQueue.BeginPeek%2A> 각각 특정 스레드에 요청 합니다. 일반적으로 <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> 해당 구성 요소는 특정 스레드에 바인딩되어 있기 때문에 관련된 구성 요소 컨트롤 또는 폼에 배치 된 경우 설정 됩니다.  
  
 일반적으로 동기화 개체를 단일 스레드 메서드 호출을 마샬링합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>큐가 트랜잭션만 허용하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>큐가 트랜잭션의 일부로서 전달된 메시지만 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 트랜잭션 메시징 단일 트랜잭션으로 여러 관련된 메시지의 결합을 가리킵니다. 트랜잭션의 일부는 메시지를 순서 대로 배달 되도록 하는 대로 메시지를 보내는 한 번만 배달 되 고 대상 큐에서 검색 했습니다.  
  
 트랜잭션 큐 인 경우에 트랜잭션의 일부로 전송 되는 메시지에만 허용 합니다. 그러나 비트랜잭션 메시지를 보내거나 수 명시적 트랜잭션를 사용 하지 않고 로컬 트랜잭션 큐에서 받은 <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, 및 <xref:System.Messaging.MessageQueueTransaction.Abort%2A> 구문입니다. 비트랜잭션 메시지를 트랜잭션 큐로 보낼 경우이 구성 요소는 단일 메시지 트랜잭션을 만듭니다를 제외 하 고 직접 형식 이름을 사용 하 여 원격 컴퓨터에 있는 큐를 참조 하는 경우. 이 경우 메시지를 보낼 때 트랜잭션 컨텍스트를 지정 하지 않으면 하나를 만들어지지 않습니다 및 메시지를 배달 못 한 편지 큐로 보내집니다.  
  
 에 트랜잭션 큐로 비트랜잭션 메시지를 보내려면 메시지 예외가 발생할 경우 롤백할 수 없습니다.  
  
 <xref:System.Messaging.MessageQueueTransaction> 스레딩 아파트를 인식 하며 따라서 아파트 상태가 `STA`, 트랜잭션이 여러 스레드를 사용할 수 없습니다. 에 주 스레드의 상태를 설정 하는 Visual Basic `STA`이므로 적용 해야 합니다는 <xref:System.MTAThreadAttribute> 에 `Main` 서브루틴입니다. 그렇지 않으면 다른 스레드를 사용하여 트랜잭션 메시지를 전달할 때 <xref:System.Messaging.MessageQueueException> 예외가 throw됩니다. 적용 된 <xref:System.MTAThreadAttribute> 다음 조각을 사용 하 여 합니다.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제에서는 메시지 큐의 값을 표시 <xref:System.Messaging.MessageQueue.Transactional%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>받은 메시지가 업무 일지 큐로 복사되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>큐에서 받은 메시지가 해당 업무 일지 큐로 복사되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 큐 애플리케이션에서 새 애플리케이션 큐를 동일한 위치에 자동으로 관련 된 업무 일지 큐를 만듭니다. 업무 일지 큐는 큐에서 제거 된 메시지를 추적에 사용 됩니다. 메시지 큐를 수정이 속성을 설정 합니다. 따라서 다른 <xref:System.Messaging.MessageQueue> 인스턴스는 변경 내용의 영향입니다.  
  
 업무 일지 큐가 받을 시간 타이머가 만료 나 (Information Store 또는 Active Directory)를 메시지 큐 디렉터리 서비스를 사용 하 여 큐에서 제거 된 메시지 추적 하기 때문에 큐에서 제거 된 메시지를 추적 하지 않습니다.  
  
 애플리케이션; 업무 일지 큐에 메시지를 보낼 수 없습니다. 이러한 큐의 읽기 전용 액세스로 제한 됩니다. 또한 메시지 큐는 저널 큐에서 메시지를 제거 하지 않습니다. 받은 후 또는 큐를 제거 하 여 큐를 사용 하 여 애플리케이션에서 이러한 메시지를 해제 해야 합니다.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|아니요|  
  
   
  
## Examples  
 다음 코드 예제를 가져오고 메시지 큐의 값을 설정 <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> 속성입니다.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐 메서드에 액세스하는 동안 오류가 발생한 경우</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메시지 큐에 메시지를 보내는 데 사용되는 기본 핸들을 가져옵니다.</summary>
        <value>큐에 메시지를 보내는 데 사용하는 네이티브 큐 개체에 대한 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> 큐에 메시지를 보내는 데 사용 되는 메시지 큐 개체에 대 한 네이티브 Windows 핸들을 제공 합니다. 큐의 경로 변경 하면 핸들이 닫히고 새 값으로.  
  
 다음 표에서이 속성은 다양 한 작업 그룹 모드에서 사용할 수 있는지 여부를 보여 줍니다.  
  
|작업 그룹 모드|사용 가능|  
|--------------------|---------------|  
|로컬 컴퓨터|예|  
|로컬 컴퓨터와 직접 형식 이름|예|  
|원격 컴퓨터|아니요|  
|원격 컴퓨터와 직접 형식 이름|예|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">메시지 큐를 쓰기 작업에 사용할 수 없습니다.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>