<Type Name="HttpClientHandler" FullName="System.Net.Http.HttpClientHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba3ed49c9a90efc55711df6801abd12d767b3a33" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53291602" /></Metadata><TypeSignature Language="C#" Value="public class HttpClientHandler : System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpClientHandler extends System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpClientHandler&#xA;Inherits HttpMessageHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpClientHandler : System::Net::Http::HttpMessageHandler" />
  <TypeSignature Language="F#" Value="type HttpClientHandler = class&#xA;    inherit HttpMessageHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpMessageHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="99dc8-101"><see cref="T:System.Net.Http.HttpClient" />에서 사용되는 기본 메시지 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-101">The default message handler used by <see cref="T:System.Net.Http.HttpClient" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-102"><xref:System.Net.Http.HttpClientHandler> 클래스와 형식에서 파생 된 클래스를 통해 개발자는 구성 옵션에서 프록시 인증에 이르기까지 다양 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-102">The <xref:System.Net.Http.HttpClientHandler> class and classes derived from it enable developers to configure a variety of options ranging from proxies to authentication.</span></span>  
  
### <a name="httpclienthandler-in-net-core"></a><span data-ttu-id="99dc8-103">.NET Core에서 HttpClientHandler</span><span class="sxs-lookup"><span data-stu-id="99dc8-103">HttpClientHandler in .NET Core</span></span>

<span data-ttu-id="99dc8-104">.NET Core 2.1을 사용 하 여 시작 합니다 <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> 클래스 대신 `HttpClientHandler` 더 높은 수준의 HTTP 네트워킹 Api에서 사용 하는 구현을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-104">Starting with .NET Core 2.1, the <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> class instead of `HttpClientHandler` provides the implementation used by higher-level HTTP networking APIs.</span></span> <span data-ttu-id="99dc8-105">사용 하도록 애플리케이션을 구성할 수 있습니다 `HttpClientHandler` 대신 호출 하 여 <xref:System.AppContext.SetSwitch%2A> 같이 메서드:</span><span class="sxs-lookup"><span data-stu-id="99dc8-105">You can configure your application to use `HttpClientHandler` instead by calling the <xref:System.AppContext.SetSwitch%2A> method as follows:</span></span>

```csharp
AppContext.SetSwitch("System.Net.Http.useSocketsHttpHandler", false);
```
```vb
AppContext.SetSwitch("System.Net.Http.useSocketsHttpHandler", False)
``` 
  
## Examples  
 [!code-csharp[System.Net.Http.HttpClientHandler#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.http.httpclienthandler/cs/source.cs#1)]  
  
 <span data-ttu-id="99dc8-106">앞의 코드 예제를 사용 하는 `async Task Main()` 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-106">The preceding code example uses an `async Task Main()` entry point.</span></span> <span data-ttu-id="99dc8-107">해당 기능은 C# 7.1 이상 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-107">That feature requires C# 7.1 or later.</span></span>
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=245696"><span data-ttu-id="99dc8-108">웹 서비스에 연결</span><span class="sxs-lookup"><span data-stu-id="99dc8-108">Connecting to a web service</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245697"><span data-ttu-id="99dc8-109">빠른 시작: HttpClient를 사용 하 여 연결</span><span class="sxs-lookup"><span data-stu-id="99dc8-109">Quickstart: Connecting using HttpClient</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245699"><span data-ttu-id="99dc8-110">HttpClient 처리기를 사용 하는 방법</span><span class="sxs-lookup"><span data-stu-id="99dc8-110">How to use HttpClient handlers</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245698"><span data-ttu-id="99dc8-111">HttpClient 연결을 보호 하는 방법</span><span class="sxs-lookup"><span data-stu-id="99dc8-111">How to secure HttpClient connections</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=242550"><span data-ttu-id="99dc8-112">HttpClient 샘플</span><span class="sxs-lookup"><span data-stu-id="99dc8-112">HttpClient Sample</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpClientHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClientHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpClientHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="99dc8-113"><see cref="T:System.Net.Http.HttpClientHandler" /> 클래스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-113">Creates an instance of a <see cref="T:System.Net.Http.HttpClientHandler" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.Http.HttpClientHandler.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-114">처리기가 리디렉션 응답을 따르는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-114">Gets or sets a value that indicates whether the handler should follow redirection responses.</span></span></summary>
        <value><span data-ttu-id="99dc8-115"><see langword="true" /> 처리기가 리디렉션 응답; 따르는지 하는 경우 그렇지 않으면 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-115"><see langword="true" /> if the handler should follow redirection responses; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-116">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-116">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-117">설정할 <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> 에 `true` 리소스의 새 위치로 HTTP 리디렉션 헤더를 자동으로 수행 하는 처리기를 하려는 경우.</span><span class="sxs-lookup"><span data-stu-id="99dc8-117">Set <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> to `true` if you want the handler to automatically follow HTTP redirection headers to the new location of the resource.</span></span> <span data-ttu-id="99dc8-118">최대 리디렉션 수는 설정한는 <xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-118">The maximum number of redirections to follow is set by the <xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A> property.</span></span>  
  
 <span data-ttu-id="99dc8-119">하는 경우 <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> 로 설정 된 `false`, 모든 HTTP 응답 HTTP 상태 코드를 사용 하 여 300에서 399에 애플리케이션에 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-119">If <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> is set to `false`, all HTTP responses with an HTTP status code from 300 to 399 are  returned to the application.</span></span>  
  
 <span data-ttu-id="99dc8-120">권한 부여 헤더를 자동 리디렉션 시 지우고 처리기는 자동으로 다시 리디렉션된 위치에 인증 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-120">The Authorization header is cleared on auto-redirects and the handler automatically tries to re-authenticate to the redirected location.</span></span> <span data-ttu-id="99dc8-121">즉 실제로에서 리디렉션이 발생할 수 있으면 애플리케이션 권한 부여 헤더에 사용자 지정 인증 정보를 넣을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-121">In practice, this means that an application can't put custom authentication information into the Authorization header if it is possible to encounter redirection.</span></span> <span data-ttu-id="99dc8-122">대신, 애플리케이션을 구현 하 고 사용자 지정 인증 모듈을 등록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-122">Instead, the application must implement and register a custom authentication module.</span></span>  

> [!NOTE]
>  <span data-ttu-id="99dc8-123">사용 하 여 <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> 로 `true`, HTTPS URI에서 HTTP URI로 리디렉션되는 경우에.NET Framework 리디렉션을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-123">With <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> set to `true`, the .NET Framework will follow redirections even when being redirected to an HTTP URI from an HTTPS URI.</span></span>
<span data-ttu-id="99dc8-124">.NET core 버전 1.0, 1.1 및 2.0 따르지 않습니다 리디렉션을 HTTPS에서 HTTP도가 <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> 로 설정 된 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-124">.NET Core versions 1.0, 1.1 and 2.0 will not follow a redirection from HTTPS to HTTP even if <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> is set to `true`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.Http.HttpClientHandler.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-125">HTTP 콘텐츠 응답의 자동 압축 풀기를 위해 처리기가 사용하는 압축 풀기 메서드 형식을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-125">Gets or sets the type of decompression method used by the handler for automatic decompression of the HTTP content response.</span></span></summary>
        <value><span data-ttu-id="99dc8-126">처리기에서 사용되는 자동 압축 풀기 해제 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-126">The automatic decompression method used by the handler.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
<span data-ttu-id="99dc8-127">.NET framework 4.x `System.Net.Http` 전역 어셈블리 캐시 (GAC)에으로 이진 기본값은 <xref:System.Net.DecompressionMethods.None>합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-127">For the .NET Framework 4.x `System.Net.Http` binary in the Global Assembly Cache (GAC), the default value is <xref:System.Net.DecompressionMethods.None>.</span></span>

<span data-ttu-id="99dc8-128">경우는 [ `System.Net.Http` NuGet 패키지](https://www.nuget.org/packages/System.Net.Http/) v4.1.0 v4.3.2 하 되, 기본값은 <xref:System.Net.DecompressionMethods.GZip> 고 <xref:System.Net.DecompressionMethods.Deflate>입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-128">When the [`System.Net.Http` NuGet package](https://www.nuget.org/packages/System.Net.Http/) v4.1.0 to v4.3.2 is used, the default is <xref:System.Net.DecompressionMethods.GZip> and <xref:System.Net.DecompressionMethods.Deflate>.</span></span>

<span data-ttu-id="99dc8-129">NuGet 패키지 v4.3.2, 기본값인 후 <xref:System.Net.DecompressionMethods.None> 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-129">After NuGet package v4.3.2, the default value of <xref:System.Net.DecompressionMethods.None> is used.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.Http.HttpClientHandler.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-130">인증 기관의 해지 목록을 기준으로 인증서를 검사하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-130">Gets or sets a value that indicates whether the certificate is checked against the certificate authority revocation list.</span></span></summary>
        <value><span data-ttu-id="99dc8-131">인증서 해지 목록을 검사하면 <see langword="true" />이고, 검사하지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-131"><see langword="true" /> if the certificate revocation list is checked; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="99dc8-132">.NET Framework 4.7.1만 해당: 이 속성이 구현되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-132">.NET Framework 4.7.1 only: This property is not implemented.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateOptions">
      <MemberSignature Language="C#" Value="public System.Net.Http.ClientCertificateOption ClientCertificateOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Http.ClientCertificateOption ClientCertificateOptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.ClientCertificateOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificateOptions As ClientCertificateOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::ClientCertificateOption ClientCertificateOptions { System::Net::Http::ClientCertificateOption get(); void set(System::Net::Http::ClientCertificateOption value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificateOptions : System.Net.Http.ClientCertificateOption with get, set" Usage="System.Net.Http.HttpClientHandler.ClientCertificateOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.ClientCertificateOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-133">인증서가 인증서 저장소에서 자동으로 선택되는지 또는 호출자가 특정 클라이언트 인증서에 전달하도록 허용되는지를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-133">Gets or sets a value that indicates if the certificate is automatically picked from the certificate store or if the caller is allowed to pass in a specific client certificate.</span></span></summary>
        <value><span data-ttu-id="99dc8-134">이 처리기와 연결된 보안 인증서의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-134">The collection of security certificates associated with this handler.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.HttpClientHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-135">서버에 대한 요청과 연결된 보안 인증서의 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-135">Gets the collection of security certificates that are associated requests to the server.</span></span></summary>
        <value><span data-ttu-id="99dc8-136">X509CertificateCollection 인증서를 수행할 때 서버에 표시 되는 클라이언트 인증을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-136">The X509CertificateCollection that is presented to the server when performing certificate based client authentication.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.Http.HttpClientHandler.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-137">처리기에서 서버 쿠키를 저장하는 데 사용되는 쿠키 컨테이너를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-137">Gets or sets the cookie container used to store server cookies by the handler.</span></span></summary>
        <value><span data-ttu-id="99dc8-138">처리기에서 서버 쿠키를 저장하는 데 사용되는 쿠키 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-138">The cookie container used to store server cookies by the handler.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-139">합니다 <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> 속성의 인스턴스를 제공 합니다 <xref:System.Net.CookieContainer> 이 처리기와 연관 된 쿠키를 포함 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-139">The <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> property provides an instance of the <xref:System.Net.CookieContainer> class that contains the cookies associated with this handler.</span></span>  
  
 <span data-ttu-id="99dc8-140">경우는 <xref:System.Net.Http.HttpClientHandler.UseCookies%2A> 속성은 `true`는 <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> 속성 서버 쿠키를 저장 하는 데 사용 되는 쿠키 컨테이너를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-140">If the <xref:System.Net.Http.HttpClientHandler.UseCookies%2A> property is `true`, the <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> property represents the cookie container used to store the server cookies.</span></span> <span data-ttu-id="99dc8-141">사용자는이 속성을 사용 하 여 요청을 보내기 전에 사용자 지정 쿠키를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-141">The user can set custom cookies before sending requests using this property.</span></span> <span data-ttu-id="99dc8-142">경우는 <xref:System.Net.Http.HttpClientHandler.UseCookies%2A> 속성이 false이 고 사용자가 쿠키를 추가 <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>, 쿠키는 무시 하 고 서버에 전송 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-142">If the  <xref:System.Net.Http.HttpClientHandler.UseCookies%2A> property is false and the user adds cookies to <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>, cookies are ignored and not sent to the server.</span></span> <span data-ttu-id="99dc8-143">설정 된 <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> 에 `null` 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-143">Setting the <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> to `null` will throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.HttpClientHandler.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-144">이 처리기에서 사용하는 인증 정보를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-144">Gets or sets authentication information used by this handler.</span></span></summary>
        <value><span data-ttu-id="99dc8-145">처리기와 연결된 인증 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-145">The authentication credentials associated with the handler.</span></span> <span data-ttu-id="99dc8-146">기본값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-146">The default is <see langword="null" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousAcceptAnyServerCertificateValidator">
      <MemberSignature Language="C#" Value="public static Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,bool&gt; DangerousAcceptAnyServerCertificateValidator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Func`5&lt;class System.Net.Http.HttpRequestMessage, class System.Security.Cryptography.X509Certificates.X509Certificate2, class System.Security.Cryptography.X509Certificates.X509Chain, valuetype System.Net.Security.SslPolicyErrors, bool&gt; DangerousAcceptAnyServerCertificateValidator" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DangerousAcceptAnyServerCertificateValidator As Func(Of HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ DangerousAcceptAnyServerCertificateValidator { Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DangerousAcceptAnyServerCertificateValidator : Func&lt;System.Net.Http.HttpRequestMessage, System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors, bool&gt;" Usage="System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-147">항상 <see langword="true" />를 반환하는 캐시된 대리자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-147">Gets a cached delegate that always returns <see langword="true" />.</span></span></summary>
        <value><span data-ttu-id="99dc8-148">항상 <see langword="true" />를 반환하는 캐시된 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-148">A cached delegate that always returns <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-149">테스트 시나리오에서 특히 일반적인 패턴을 사용 하 여 <xref:System.Net.Http.HttpClient> 않아야 유효성을 검사할 수, 예: 자체 서명 된 인증서는 인증서를 사용 하 여 서버에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-149">Particularly in test scenarios, a common pattern use <xref:System.Net.Http.HttpClient> to connect to a server with a certificate that shouldn't be validated, such as a self-signed certificate.</span></span> <span data-ttu-id="99dc8-150">사용 하 여 일반적으로 이렇게 <xref:System.Net.Http.HttpClientHandler> 설정 하 여는 <xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A> 속성을 항상 반환 하는 대리자 `True`; 인증서가 유효성 검사를 통과 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-150">You commonly do this with <xref:System.Net.Http.HttpClientHandler> by setting the <xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A> property to a delegate that always returns `True`; this indicates that the certificate has passed validation.</span></span> <span data-ttu-id="99dc8-151">그러나 일부 구현에서이 콜백은 지원 및 일부 throw <xref:System.PlatformNotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-151">However, not all implementations support this callback, and some throw <xref:System.PlatformNotSupportedException>.</span></span>  
  
 <span data-ttu-id="99dc8-152"><xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> 속성이이 제한을 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-152">The <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> property addresses this limitation.</span></span> <span data-ttu-id="99dc8-153">반환 하는 대리자를 <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> 속성에 할당할 수는 <xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A> 속성을 다음 예제와 같이 않습니다:</span><span class="sxs-lookup"><span data-stu-id="99dc8-153">The delegate returned by the <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> property can be assigned to the <xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A> property, as the following example does:</span></span>  
  
```cs
handler.ServerCertificateCustomValidationCallback = httpClientHandler.DangerousAcceptAnyServerCertificateValidator;
```

 <span data-ttu-id="99dc8-154">이렇게 하면 <xref:System.Net.Http.HttpClientHandler> 구현 개발자의 의도 표현 하는 알려진된 개체 참조 id를 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-154">This gives <xref:System.Net.Http.HttpClientHandler> implementations a known object reference identity that expresses the developer's intention.</span></span> <span data-ttu-id="99dc8-155">개체에 저장 하는 경우는 <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> 속성이 참조과 동일한 <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>, 런타임에서 완전히 그렇지 않은 경우 throw 하는 플랫폼에서 유효성 검사를 사용 하지 않도록 설정할 수는 <xref:System.PlatformNotSupportedException>합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-155">If the object stored in the <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> property is reference equals to <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>, the runtime is able to entirely disable validation on a platform that would otherwise throw a <xref:System.PlatformNotSupportedException>.</span></span>  
  
 <span data-ttu-id="99dc8-156">쪽 혜택으로 개발자가 쉽게 안전 하지 않은 애플리케이션을 전달 하지 않으려면 개발자를 위한 인증서 유효성 검사를 사용 하지 않도록 설정 위험 플래그를 도구용 쉽게 수행할 수 있도록이 속성을 사용 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-156">As a side benefit, developers can use this property to make it easier for tools to flag the danger of disabling certificate validation, which makes it easier for developers to avoid shipping insecure applications.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultProxyCredentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials DefaultProxyCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials DefaultProxyCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.DefaultProxyCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultProxyCredentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ DefaultProxyCredentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultProxyCredentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.HttpClientHandler.DefaultProxyCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-157">기본(시스템) 프록시를 사용하는 경우 인증을 위해 기본 프록시 서버에 제출하기 위해 자격 증명을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-157">When the default (system) proxy is being used, gets or sets the credentials to submit to the default proxy server for authentication.</span></span> <span data-ttu-id="99dc8-158">기본 프록시는 <see cref="P:System.Net.Http.HttpClientHandler.UseProxy" />가 <see langword="true" />로 설정되고 <see cref="P:System.Net.Http.HttpClientHandler.Proxy" />가 <see langword="null" />로 설정된 경우에만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-158">The default proxy is used only when <see cref="P:System.Net.Http.HttpClientHandler.UseProxy" /> is set to <see langword="true" /> and <see cref="P:System.Net.Http.HttpClientHandler.Proxy" /> is set to <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="99dc8-159">기본 프록시 서버에 요청을 인증 하는 데 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-159">The credentials needed to authenticate a request to the default proxy server.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClientHandler.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="httpClientHandler.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="99dc8-160">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />, 관리되지 않는 리소스만 해제하려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-160"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="99dc8-161"><see cref="T:System.Net.Http.HttpClientHandler" />에서 사용하는 관리되지 않는 리소스를 해제하고 관리되는 리소스를 선택적으로 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-161">Releases the unmanaged resources used by the <see cref="T:System.Net.Http.HttpClientHandler" /> and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-162">이 메서드는 공용 `Dispose()` 메서드 및 <xref:System.Object.Finalize%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="99dc8-162">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="99dc8-163">`Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드를 `disposing` 매개 변수 설정 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-163">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="99dc8-164"><xref:System.Object.Finalize%2A> 호출 `Dispose` 사용 하 여 `disposing` 로 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-164"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="99dc8-165">`disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Net.Http.HttpClientHandler>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-165">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Http.HttpClientHandler> references.</span></span> <span data-ttu-id="99dc8-166">이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-166">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaxAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxAutomaticRedirections : int with get, set" Usage="System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-167">처리기가 따르는 최대 리디렉션 수를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-167">Gets or sets the maximum number of redirects that the handler follows.</span></span></summary>
        <value><span data-ttu-id="99dc8-168">처리기가 따르는 최대 리디렉션 응답 수입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-168">The maximum number of redirection responses that the handler follows.</span></span> <span data-ttu-id="99dc8-169">기본값은 50입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-169">The default value is 50.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-170"><xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A> 되는 경우 따라야 하는 요청에 대 한 리디렉션의 최대 수를 설정 하는 속성을 <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> 속성은 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-170">The <xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A> property sets the maximum number of redirections for the request to follow if the <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> property is `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConnectionsPerServer">
      <MemberSignature Language="C#" Value="public int MaxConnectionsPerServer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxConnectionsPerServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxConnectionsPerServer" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxConnectionsPerServer As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxConnectionsPerServer { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxConnectionsPerServer : int with get, set" Usage="System.Net.Http.HttpClientHandler.MaxConnectionsPerServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-171"><see cref="T:System.Net.Http.HttpClient" /> 개체를 사용하여 요청을 수행하는 경우 허용되는 동시 연결의 최대 수(서버 엔드포인트당)를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-171">Gets or sets the maximum number of concurrent connections (per server endpoint) allowed when making requests using an <see cref="T:System.Net.Http.HttpClient" /> object.</span></span> <span data-ttu-id="99dc8-172">서버 엔드포인트를 기준으로 제한되므로 예를 들어, 256이라는 값은 http://www.adatum.com/에 256개의 동시 연결을 허용하고 http://www.adventure-works.com/에 추가로 256개의 동시 연결을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-172">Note that the limit is per server endpoint, so for example a value of 256 would permit 256 concurrent connections to http://www.adatum.com/ and another 256 to http://www.adventure-works.com/.</span></span></summary>
        <value><span data-ttu-id="99dc8-173">최대 동시 연결 (서버 끝점당)에서 허용 되는 <see cref="T:System.Net.Http.HttpClient" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-173">The maximum number of concurrent connections (per server endpoint) allowed by an <see cref="T:System.Net.Http.HttpClient" /> object.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxRequestContentBufferSize">
      <MemberSignature Language="C#" Value="public long MaxRequestContentBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxRequestContentBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRequestContentBufferSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxRequestContentBufferSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRequestContentBufferSize : int64 with get, set" Usage="System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-174">처리기에서 사용되는 최대 요청 콘텐츠 버퍼 크기를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-174">Gets or sets the maximum request content buffer size used by the handler.</span></span></summary>
        <value><span data-ttu-id="99dc8-175">최대 요청 콘텐츠 버퍼 크기(바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-175">The maximum request content buffer size in bytes.</span></span> <span data-ttu-id="99dc8-176">기본값은 2GB입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-176">The default value is 2 gigabytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-177">앱을 설정할 수는 <xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> 요청 버퍼의 크기를 제한 하려면 낮은 값으로 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-177">An app can set the <xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> property to a lower value to limit the size of the request buffer.</span></span> <span data-ttu-id="99dc8-178">요청 콘텐츠의 크기 보다 크면는 <xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> 속성인 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-178">If the size of the request content is greater than the <xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> property, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.HttpClientHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-179">응답 헤더의 킬로바이트(1024바이트) 단위로 최대 길이를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-179">Gets or sets the maximum length, in kilobytes (1024 bytes), of the response headers.</span></span> <span data-ttu-id="99dc8-180">예를 들어 값이 64인 경우 최대 응답 헤더의 길이로 65536바이트가 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-180">For example, if the value is 64, then 65536 bytes are allowed for the maximum response headers' length.</span></span></summary>
        <value><span data-ttu-id="99dc8-181">최대 길이, 응답 헤더의 킬로바이트 (1024 바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-181">The maximum length, in kilobytes (1024 bytes), of the response headers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.Http.HttpClientHandler.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-182">처리기가 요청과 함께 인증 헤더를 보낼 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-182">Gets or sets a value that indicates whether the handler sends an Authorization header with the request.</span></span></summary>
        <value><span data-ttu-id="99dc8-183">처리기가 인증을 수행한 이후 요청과 함께 HTTP 권한 부여 헤더를 함께 보내도록 하려면 <see langword="true" />이고, 그렇게 하지 않으려면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-183"><see langword="true" /> for the handler to send an HTTP Authorization header with requests after authentication has taken place; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="99dc8-184">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-184">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-185">특정 클라이언트 요청 후 <xref:System.Uri> 가 성공적으로 인증 하는 경우는 <xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A> 속성은 `true` 및 자격 증명 제공 <xref:System.Net.Http.HttpClientHandler> 에 제공 된 자격 증명 목록에 대해 일치를 <xref:System.Net.Http.HttpClientHandler.Credentials%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-185">After a client request to a specific <xref:System.Uri> is successfully authenticated, if the <xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A> property is `true` and credentials are supplied, <xref:System.Net.Http.HttpClientHandler> matches against the credential list supplied in the  <xref:System.Net.Http.HttpClientHandler.Credentials%2A> property.</span></span> <span data-ttu-id="99dc8-186">권한 부여 헤더에 각 요청과 함께 전송 되 <xref:System.Uri> 일치 하는 특정 <xref:System.Uri> 마지막 슬래시까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-186">The Authorization header is sent with each request to any <xref:System.Uri> that matches the specific <xref:System.Uri> up to the last forward slash.</span></span>  
  
 <span data-ttu-id="99dc8-187">특정 클라이언트 요청 하는 경우 <xref:System.Uri> 는 표준 인증 프로시저를 사용 하 여 요청 되지 성공적으로 인증 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-187">If the client request to a specific <xref:System.Uri> is not successfully authenticated, the request uses standard authentication procedures.</span></span>  
  
 <span data-ttu-id="99dc8-188">첫 번째 요청을 제외 하 고는 <xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A> 속성은 이후 요청에 인증 정보를 보낼지 여부를 나타냅니다는 <xref:System.Uri> 일치 하는 특정 <xref:System.Uri> 하기 위해 대기 하지 않고 마지막 슬래시까지 서버에서 요구 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-188">With the exception of the first request, the <xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A> property indicates whether to send authentication information with subsequent requests to a <xref:System.Uri> that matches the specific <xref:System.Uri> up to the last forward slash without waiting to be challenged by the server.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Properties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Net.Http.HttpClientHandler.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-189"><see cref="T:System.Net.Http.HttpClient" /> 요청에 대해 사용자 지정 속성의 쓰기 가능한 사전(즉, 맵)을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-189">Gets a writable dictionary (that is, a map) of custom properties for the <see cref="T:System.Net.Http.HttpClient" /> requests.</span></span> <span data-ttu-id="99dc8-190">사전이 비어 있도록 초기화되었습니다. 사용자 지정 처리기 및 특수한 처리에 대한 키-값 쌍을 삽입하고 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-190">The dictionary is initialized empty; you can insert and query key-value pairs for your custom handlers and special processing.</span></span></summary>
        <value><span data-ttu-id="99dc8-191">사용자 지정 속성의 쓰기 가능한 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-191">a writable dictionary of custom properties.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.Http.HttpClientHandler.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-192">처리기에서 사용되는 프록시 정보를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-192">Gets or sets proxy information used by the handler.</span></span></summary>
        <value><span data-ttu-id="99dc8-193">처리기에서 사용되는 프록시 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-193">The proxy information used by the handler.</span></span> <span data-ttu-id="99dc8-194">기본값은 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-194">The default value is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-195">합니다 <xref:System.Net.Http.HttpClientHandler.Proxy%2A> 속성을 식별 합니다 <xref:System.Net.WebProxy> 인터넷 리소스에 대 한 요청을 처리 하는 데 사용할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-195">The <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property identifies the <xref:System.Net.WebProxy> object to use to process requests to Internet resources.</span></span> <span data-ttu-id="99dc8-196">없는 프록시를 사용 해야 함을 지정 하려면 설정 합니다 <xref:System.Net.Http.HttpClientHandler.Proxy%2A> 속성을 반환 하 여 프록시 인스턴스는 <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="99dc8-196">To specify that no proxy should be used, set the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property to the proxy instance returned by the <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A> method.</span></span>  
  
 <span data-ttu-id="99dc8-197">로컬 컴퓨터 또는 애플리케이션 구성 파일을 기본 프록시를 사용할 수 있는지 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-197">The local computer or application config file may specify that a default proxy be used.</span></span> <span data-ttu-id="99dc8-198">경우는 <xref:System.Net.Http.HttpClientHandler.Proxy%2A> 속성을 지정 하면에서 프록시 설정을 <xref:System.Net.Http.HttpClientHandler.Proxy%2A> 속성 재정의 로컬 컴퓨터 또는 애플리케이션 구성 파일 및 해당 처리기에는 지정 된 프록시 설정을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-198">If the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property is specified, then the proxy settings from the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property override the local computer or application config file and the handler will use the proxy settings specified.</span></span> <span data-ttu-id="99dc8-199">구성 파일에 없는 프록시를 지정 하는 경우 및 <xref:System.Net.Http.HttpClientHandler.Proxy%2A> 속성이 지정 되지 않은, 처리기는 로컬 컴퓨터의 Internet Explorer에서 상속 된 프록시 설정을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-199">If no proxy is specified in a config file and the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property is unspecified, the handler uses the proxy settings inherited from Internet Explorer on the local computer.</span></span> <span data-ttu-id="99dc8-200">Internet Explorer의 프록시 설정이 없는 경우 요청이 서버로 직접 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-200">If there are no proxy settings in Internet Explorer, the request is sent directly to the server.</span></span>  
  
 <span data-ttu-id="99dc8-201"><xref:System.Net.Http.HttpClientHandler> 클래스 구문 분석 하 여 와일드 카드 문자를 사용 하 여 프록시 무시 목록에서에서 상속 되며, Internet Explorer 동일한 바이패스 목록에는 Internet Explorer에서 직접 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-201">The <xref:System.Net.Http.HttpClientHandler> class parses a proxy bypass list with wildcard characters inherited from Internet Explorer the same as the bypass list is parsed directly by Internet Explorer.</span></span> <span data-ttu-id="99dc8-202">예를 들어 합니다 <xref:System.Net.Http.HttpClientHandler> 클래스의 정규식을 바이패스 목록이 "nt \*" Internet Explorer에서 분석 "nt.\*"입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-202">For example, the <xref:System.Net.Http.HttpClientHandler> class will parse a bypass list of "nt\*" from Internet Explorer as a regular expression of "nt.\*".</span></span> <span data-ttu-id="99dc8-203">따라서 URL " http://nt.com"을 사용 하 여 프록시를 무시 합니다 <xref:System.Net.Http.HttpClientHandler> 클래스 및 Internet Explorer를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-203">So a URL of " http://nt.com" would bypass the proxy using the <xref:System.Net.Http.HttpClientHandler> class and using Internet Explorer.</span></span>  
  
 <span data-ttu-id="99dc8-204"><xref:System.Net.Http.HttpClientHandler> 클래스는 로컬 프록시 바이패스를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-204">The <xref:System.Net.Http.HttpClientHandler> class supports local proxy bypass.</span></span> <span data-ttu-id="99dc8-205">클래스에는 다음 조건 중 하나가 충족 되는 경우에 로컬 대상을 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-205">The class considers a destination to be local if any of the following conditions are met:</span></span>  
  
1.  <span data-ttu-id="99dc8-206">대상 플랫 이름 (URL에 점 없음)를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-206">The destination contains a flat name (no dots in the URL).</span></span>  
  
2.  <span data-ttu-id="99dc8-207">루프백 주소를 포함 하는 대상 (<xref:System.Net.IPAddress.Loopback> 또는 <xref:System.Net.IPAddress.IPv6Loopback>) 하거나 대상 포함는 <xref:System.Net.IPAddress> 로컬 컴퓨터에 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-207">The destination contains a loopback address (<xref:System.Net.IPAddress.Loopback> or <xref:System.Net.IPAddress.IPv6Loopback>) or the destination contains an <xref:System.Net.IPAddress> assigned to the local computer.</span></span>  
  
3.  <span data-ttu-id="99dc8-208">로컬 컴퓨터의 도메인 접미사를 일치 대상의 도메인 접미사 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).</span><span class="sxs-lookup"><span data-stu-id="99dc8-208">The domain suffix of the destination matches the local computer's domain suffix (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="protected internal override System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClientHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClientHandler.SendAsync (request, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="99dc8-209">HTTP 요청 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-209">The HTTP request message.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="99dc8-210">작업을 취소할 취소 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-210">A cancellation token to cancel the operation.</span></span></param>
        <summary><span data-ttu-id="99dc8-211"><see cref="T:System.Net.Http.HttpRequestMessage" />에 제공된 정보를 기반으로 <see cref="T:System.Net.Http.HttpResponseMessage" />의 인스턴스를 차단되지 않을 작업으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-211">Creates an instance of  <see cref="T:System.Net.Http.HttpResponseMessage" /> based on the information provided in the <see cref="T:System.Net.Http.HttpRequestMessage" /> as an operation that will not block.</span></span></summary>
        <returns><span data-ttu-id="99dc8-212">비동기 작업(operation)을 나타내는 작업(task) 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-212">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-213">이 작업은 차단 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-213">This operation is does not block.</span></span> <span data-ttu-id="99dc8-214">인스턴스를 반환 <xref:System.Threading.Tasks.Task%601> 비동기 작업을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-214">It returns an instance of <xref:System.Threading.Tasks.Task%601> to represent the asynchronous operation.</span></span> <span data-ttu-id="99dc8-215">작업이 완료 되 면 <xref:System.Threading.Tasks.Task%601.Result%2A> 응답 메시지를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-215">When the operation completes, <xref:System.Threading.Tasks.Task%601.Result%2A> contains the response message.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="99dc8-216"><paramref name="request" />가 <see langword="null" />이었습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-216">The <paramref name="request" /> was <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateCustomValidationCallback">
      <MemberSignature Language="C#" Value="public Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,bool&gt; ServerCertificateCustomValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`5&lt;class System.Net.Http.HttpRequestMessage, class System.Security.Cryptography.X509Certificates.X509Certificate2, class System.Security.Cryptography.X509Certificates.X509Chain, valuetype System.Net.Security.SslPolicyErrors, bool&gt; ServerCertificateCustomValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateCustomValidationCallback As Func(Of HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ ServerCertificateCustomValidationCallback { Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ get(); void set(Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateCustomValidationCallback : Func&lt;System.Net.Http.HttpRequestMessage, System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors, bool&gt; with get, set" Usage="System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-217">서버 인증서의 유효성을 검사할 콜백 메서드를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-217">Gets or sets a callback method to validate the server certificate.</span></span></summary>
        <value><span data-ttu-id="99dc8-218">서버 인증서의 유효성을 검사할 콜백 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-218">A callback method to validate the server certificate.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocols">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.SslProtocols SslProtocols { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SslProtocols" />
      <MemberSignature Language="VB.NET" Value="Public Property SslProtocols As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::SslProtocols SslProtocols { System::Security::Authentication::SslProtocols get(); void set(System::Security::Authentication::SslProtocols value); };" />
      <MemberSignature Language="F#" Value="member this.SslProtocols : System.Security.Authentication.SslProtocols with get, set" Usage="System.Net.Http.HttpClientHandler.SslProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-219">HttpClientHandler 개체에 의해 관리되는 <see cref="T:System.Net.Http.HttpClient" /> 개체에서 사용하는 TLS/SSL 프로토콜을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-219">Gets or sets the TLS/SSL protocol used by the <see cref="T:System.Net.Http.HttpClient" /> objects managed by the HttpClientHandler object.</span></span></summary>
        <value><span data-ttu-id="99dc8-220"><see cref="T:System.Security.Authentication.SslProtocols" /> 열거형에 정의된 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-220">One of the values defined in the <see cref="T:System.Security.Authentication.SslProtocols" /> enumeration.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="99dc8-221">.NET Framework 4.7.1만 해당: 이 속성이 구현되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-221">.NET Framework 4.7.1 only: This property is not implemented.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SupportsAutomaticDecompression">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAutomaticDecompression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SupportsAutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAutomaticDecompression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAutomaticDecompression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAutomaticDecompression : bool" Usage="System.Net.Http.HttpClientHandler.SupportsAutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-222">처리기가 자동 응답 콘텐츠 압축 풀기를 지원하는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-222">Gets a value that indicates whether the handler supports automatic response content decompression.</span></span></summary>
        <value><span data-ttu-id="99dc8-223">처리기가 자동 응답 콘텐츠 압축 풀기를 지원하면 <see langword="true" />이고, 지원하지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-223"><see langword="true" /> if the if the handler supports automatic response content decompression; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-224">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-224">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsProxy">
      <MemberSignature Language="C#" Value="public virtual bool SupportsProxy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsProxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SupportsProxy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsProxy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsProxy : bool" Usage="System.Net.Http.HttpClientHandler.SupportsProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-225">처리기가 프록시 설정을 지원하는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-225">Gets a value that indicates whether the handler supports proxy settings.</span></span></summary>
        <value><span data-ttu-id="99dc8-226">처리기가 프록시 설정을 지원하면 <see langword="true" />이고, 지원하지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-226"><see langword="true" /> if the if the handler supports proxy settings; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-227">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-227">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsRedirectConfiguration">
      <MemberSignature Language="C#" Value="public virtual bool SupportsRedirectConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsRedirectConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SupportsRedirectConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsRedirectConfiguration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsRedirectConfiguration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsRedirectConfiguration : bool" Usage="System.Net.Http.HttpClientHandler.SupportsRedirectConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-228">처리기에서 <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> 및 <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> 속성에 대한 구성 설정을 지원하는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-228">Gets a value that indicates whether the handler supports configuration settings for the <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> and <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> properties.</span></span></summary>
        <value><span data-ttu-id="99dc8-229">처리기에서 <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> 및 <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> 속성에 대한 구성 설정을 지원하면 <see langword="true" />이고, 지원하지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-229"><see langword="true" /> if the if the handler supports configuration settings for the <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> and <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> properties; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-230">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-230">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCookies">
      <MemberSignature Language="C#" Value="public bool UseCookies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.UseCookies" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCookies As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCookies { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCookies : bool with get, set" Usage="System.Net.Http.HttpClientHandler.UseCookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-231">처리기에서 <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> 속성을 사용하여 서버 쿠키를 저장하고 요청을 보낼 때 이러한 쿠키를 사용할지 여부를 나타내는 값을 가져오거나 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-231">Gets or sets a value that indicates whether the handler uses the  <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> property  to store server cookies and uses these cookies when sending requests.</span></span></summary>
        <value><span data-ttu-id="99dc8-232">처리기에서 <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> 속성을 사용하여 서버 쿠키를 저장하고 요청을 보낼 때 이러한 쿠키를 사용하는 경우 <see langword="true" />, 사용하지 않는 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-232"><see langword="true" /> if the if the handler supports uses the  <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> property  to store server cookies and uses these cookies when sending requests; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-233">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-233">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.Http.HttpClientHandler.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-234">처리기에서 기본 자격 증명을 요청과 함께 전송하는지 여부를 제어하는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-234">Gets or sets a value that controls whether default credentials are sent with requests by the handler.</span></span></summary>
        <value><span data-ttu-id="99dc8-235">기본 자격 증명이 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-235"><see langword="true" /> if the default credentials are used; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-236">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-236">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99dc8-237">이 속성을 설정 `true` 에서 요청을 수행 하는 경우는 <xref:System.Net.Http.HttpClientHandler> 개체, 서버에서 요청 하는 경우 인증 해야 현재 로그온된 한 사용자의 자격 증명을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-237">Set this property to `true` when requests made by the <xref:System.Net.Http.HttpClientHandler> object should, if requested by the server, be authenticated using the credentials of the currently logged on user.</span></span> <span data-ttu-id="99dc8-238">클라이언트 애플리케이션에 대 한 대부분의 시나리오에 필요한 동작은 이것이입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-238">For client applications, this is the desired behavior in most scenarios.</span></span> <span data-ttu-id="99dc8-239">이 속성을 사용 하는 대신 ASP.NET 애플리케이션과 같은 중간 계층 애플리케이션에 대 한 일반적으로 설정 된 <xref:System.Net.Http.HttpClientHandler.Credentials%2A> 속성 대신 요청 클라이언트의 자격 증명을 합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-239">For middle-tier applications, such as ASP.NET applications, instead of using this property, you would typically set the <xref:System.Net.Http.HttpClientHandler.Credentials%2A> property to the credentials of the client on whose behalf the request is made.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseProxy">
      <MemberSignature Language="C#" Value="public bool UseProxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseProxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.UseProxy" />
      <MemberSignature Language="VB.NET" Value="Public Property UseProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseProxy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseProxy : bool with get, set" Usage="System.Net.Http.HttpClientHandler.UseProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99dc8-240">처리기가 요청에 대해 프록시를 사용하는지 여부를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-240">Gets or sets a value that indicates whether the handler uses a proxy for requests.</span></span></summary>
        <value><span data-ttu-id="99dc8-241">처리기가 요청에 대해 프록시를 사용해야 하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-241"><see langword="true" /> if the handler should use a proxy for requests; otherwise <see langword="false" />.</span></span> <span data-ttu-id="99dc8-242">기본값은 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="99dc8-242">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>