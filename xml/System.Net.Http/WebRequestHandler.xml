<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="78e1210b4a91957a00054abc0eda2dfca311b629" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55323309" /></Metadata><TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <TypeSignature Language="F#" Value="type WebRequestHandler = class&#xA;    inherit HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Windows 스토어 응용 프로그램 또는 다른 환경에서 사용할 수 없는 데스크톱 고유의 기능을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스를 사용 하 여 전송 처리기 구현 <xref:System.Net.HttpWebRequest> 인스턴스를 서버에 HTTP 요청을 보냅니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Http.WebRequestHandler" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowPipelining : bool with get, set" Usage="System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청을 인터넷 리소스에 파이프라인할 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Boolean" />를 반환합니다.  
  
 요청을 파이프라인해야 하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 애플리케이션이 사용 하 여 <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> 파이프라인된 연결에 대 한 기본 설정을 나타내는 속성을 합니다. 때 <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> 는 `true`, 애플리케이션에서 지 원하는 서버에 연결할 파이프라인.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationLevel : System.Net.Security.AuthenticationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청에 사용되는 인증 및 가장 수준을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Security.AuthenticationLevel" /> 값의 비트 조합입니다. 기본값은 <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상호 인증에서는 클라이언트와 서버가 모두 자격 증명을 제공해야 ID를 구성할 수 있습니다. <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> 및 <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> 값은 Kerberos 인증과 관련이 있습니다. Kerberos 인증은 직접 지원될 수도 있고, 보안 협상 프로토콜을 사용하여 실제 보안 프로토콜을 선택하는 경우에 사용할 수도 있습니다. 인증 프로토콜에 대 한 자세한 내용은 참조 하세요. [인터넷 인증](~/docs/framework/network-programming/internet-authentication.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청에 대한 캐시 정책을 가져오거나 설정합니다.</summary>
        <value>캐시 정책을 정의하는 <see cref="T:System.Net.Cache.RequestCachePolicy" /> 개체입니다. 기본값은 <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 캐시 정책 및 캐시에 요청된 된 리소스의 현재 상태 응답을 캐시에서 검색할 수 있는지 여부를 결정 합니다. 일반적으로 캐시 된 응답을 사용 하 여 애플리케이션 성능이 향상 됩니다. 하지만 캐시에서 응답 서버의 응답에 맞지 않습니다 위험이 있습니다.  
  
 기본 캐시 정책을 설정 하 여 또는 Machine.config 구성 파일에서 지정할 수 있습니다는 <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> 속성입니다.  
  
 응답 스트림에 리소스를 검색 하 고 스트림의 끝까지 읽는 경우에 리소스의 복사본이 캐시에 추가 됩니다. 이므로 동일한 리소스에 대 한 다른 요청에는이 요청에 대 한 캐시 정책 수준에 따라 캐시 된 복사본을 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청과 관련된 보안 인증서의 컬렉션을 가져오거나 설정합니다.</summary>
        <value>이 요청과 연결된 보안 인증서의 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 데이터를 언로드하기 전에 서버에서 100-continue를 기다리는 시간(밀리초)을 가져오거나 설정합니다.</summary>
        <value>애플리케이션이 데이터를 업로드하기 전에 서버에서 100-continue를 기다리는 시간(밀리초)입니다. 기본값은 350 밀리초입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 요청에 대한 가장 수준을 가져오거나 설정합니다.</summary>
        <value>요청의 가장 수준입니다. 기본값은 <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가장 수준을 서버에서 클라이언트의 자격 증명을 사용 하는 방법을 결정 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답 헤더의 허용되는 최대 길이를 가져오거나 설정합니다.</summary>
        <value>응답 헤더의 킬로바이트(1024바이트) 단위 길이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응답 헤더 길이 응답 상태 줄 및 HTTP 프로토콜의 일부로 받은 추가 제어 문자를 포함 합니다. 값이-1 이면 응답 헤더;에 제한 되지 않습니다 0 이면 모든 요청이 실패 하는 값입니다.  
  
 경우는 <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> 속성이 명시적으로 설정 되지 않은의 값을 기본적으로 <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> 속성입니다.  
  
 받은 응답 헤더 길이 값을 초과할 경우는 <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> 속성을 응답에 액세스할 때 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버에 요청을 쓰거나 서버에서 요청을 읽을 때의 제한 시간을 밀리초 단위로 가져오거나 설정합니다.</summary>
        <value>쓰기 또는 읽기가 가능한 제한 시간(밀리초)입니다. 기본값은 300,000밀리초(5분)입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 인증서의 유효성을 검사할 콜백 메서드를 가져오거나 설정합니다.</summary>
        <value>서버 인증서의 유효성을 검사할 콜백 메서드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> 는 `null`, 서버 인증서는 표준 잘 알려진 인증 기관을 사용 하 여 검사할 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>고속 NTLM 인증 연결 공유가 허용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Boolean" />를 반환합니다.  
  
 인증된 연결을 열어 두려면 <see langword="true" />이고, 열어 두지 않으려면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 기본값은 `false`, 요청이 완료 된 후에 닫을 수에 대 한 현재 연결에 이르게 합니다. 새 요청을 발급 될 때마다 애플리케이션에 인증 시퀀스 거쳐야 합니다. 이 속성 설정 된 경우 `true`, 응답을 검색 하는 데 사용 하는 연결 인증을 수행한 후에 계속 열려 있습니다. 이 경우에이 속성이 설정 요청 다른 `true` 다시 인증 하지 않고 연결을 사용할 수 있습니다. 즉, 사용자 A에 대 한 연결을 인증 된 경우 사용자 B 다시 사용할 수 있습니다 A의 연결 1. 사용자의 자격 증명에 따라 사용자 B의 요청이 처리 된  
  
> [!CAUTION]
>  수 있는지 관리 문제가 시스템의 경우이 속성을 설정 해야 하는 애플리케이션을 인증 하지 않고 연결을 사용 하도록 이기 때문에 `true`입니다. 애플리케이션에서 여러 사용자에 대 한 요청을 전송 하는 경우 (여러 사용자 계정을 가장 합니다.) 하며 리소스를 보호 하는 인증,이 속성 설정 하지 않으면이 `true` 아래 설명 된 대로 연결 그룹을 사용 하지 않는 한 합니다.  
  
 하는 경우이 메커니즘을 사용 하도록 설정 하려는 경우에 성능 문제가 발생 하는 애플리케이션 통합된 Windows 인증을 사용 하 여 웹 서버에서 실행 되 고 있습니다.  
  
 이 설정을 사용 하면 시스템 보안 위험을 엽니다. 설정한 경우에 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> 속성을 `true` 다음 예방 조치를 수행 해야 합니다.  
  
-   연결이 악용을 방지 하려면 보호 된 환경에서 애플리케이션을 실행 합니다.  
  
 백 엔드 서버를 제어 하는 경우는 대 안으로 좋습니다 인증 지 속성을 해제 합니다. 어느 정도 성능이 향상 되지만 것이 더 안전 합니다. 자세한 내용은 MSDN library에서 AuthPersistence 검색 [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>