<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="771bc63ed8e74a35e152dfca4c416071c5963605" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57962604" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley 소켓 인터페이스를 구현합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 클래스는 네트워크 통신을 위한 다양 한 메서드 및 속성을 제공 합니다. <xref:System.Net.Sockets.Socket> 클래스 수행할 수 있도록 둘 다 동기 및 통신 프로토콜 중 하나를 사용 하 여 비동기 데이터 전송에 나열 된 <xref:System.Net.Sockets.ProtocolType> 열거형입니다.  
  
 <xref:System.Net.Sockets.Socket> 클래스는 비동기 메서드에 대 한.NET Framework 명명 패턴을 따릅니다. 예를 들어 동기 <xref:System.Net.Sockets.Socket.Receive%2A> 는 비동기 메서드는 해당 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 고 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드.  
  
 응용 프로그램 실행 중 하나의 스레드만, 필요한 경우에 동기 작업 모드를 위해 설계 된 다음 메서드를 사용 합니다.  
  
-   서버 수를 사용 하 여 연결을 수신 TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Listen%2A> 메서드. <xref:System.Net.Sockets.Socket.Accept%2A> 들어오는 모든 연결 요청 및 반환 방법 프로세스는 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 통신에 사용할 수 있습니다. 반환이 사용 하 여 <xref:System.Net.Sockets.Socket> 를 호출 하 여 <xref:System.Net.Sockets.Socket.Send%2A> 또는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드. 호출 된 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.Listen%2A> 메서드 로컬 IP 주소 및 포트 번호를 지정 하려는 경우. 사용 가능한 포트를 할당 하려면 기본 서비스 공급자를 하려는 경우 0의 포트 번호를 사용 합니다. 수신 호스트에 연결 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 데이터에 전달 하기 위해 호출 된 <xref:System.Net.Sockets.Socket.Send%2A> 또는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.  
  
-   UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 연결을 전혀 수신 필요가 없습니다. 호출 된 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 들어오는 데이터 그램을 수락 하는 방법입니다. 사용 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램을 원격 호스트에 보내는 방법.  
  
 실행 하는 동안 별도 스레드를 사용 하 여 통신을 처리 하려면 비동기 작업 모드를 위해 설계 된 다음 메서드를 사용 합니다.  
  
-   TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 및 <xref:System.Net.Sockets.Socket.EndConnect%2A> 수신 호스트와 연결 하는 방법입니다. 사용 하 여는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 하 고 <xref:System.Net.Sockets.Socket.EndSend%2A> 또는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 및 <xref:System.Net.Sockets.Socket.EndReceive%2A> 데이터를 비동기적으로 통신 하는 방법입니다. 사용 하 여 들어오는 연결 요청을 처리할 수 있습니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 고 <xref:System.Net.Sockets.Socket.EndAccept%2A>입니다.  
  
-   UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 하 고 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 데이터 그램, 및 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 및 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 데이터 그램을 합니다.  
  
 소켓에서 여러 비동기 작업을 수행 하는 경우 완료 되지 않은 반드시 시작 되는 순서에서입니다.  
  
 사용 하 여 데이터를 받는 경우는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 사용 하지 않도록 설정 하는 방법의 <xref:System.Net.Sockets.Socket>합니다. 호출한 후 <xref:System.Net.Sockets.Socket.Shutdown%2A>, 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 관련 된 모든 리소스를 해제 하는 메서드에 <xref:System.Net.Sockets.Socket>.  
  
 합니다 <xref:System.Net.Sockets.Socket> 클래스를 사용 하면 구성할 수 있습니다 하 <xref:System.Net.Sockets.Socket> 사용 하 여를 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드. 이러한 설정을 사용 하 여 검색 된 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.  
  
> [!NOTE]
>  상대적으로 간단한 응용 프로그램을 작성 하는 최대 성능이 필요 하지 않은 경우 사용을 고려 <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, 및 <xref:System.Net.Sockets.UdpClient>합니다. 이러한 클래스를 간단 하 고 보다 편리한 사용자 인터페이스를 제공 합니다. <xref:System.Net.Sockets.Socket> 통신 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 방법을 <xref:System.Net.Sockets.Socket> HTTP 서버에 데이터를 보내고 응답을 수신 하는 클래스를 사용할 수 있습니다. 이 예제에서는 전체 페이지를 받을 때까지 차단 합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">나가는 연결을 설정 하거나 들어오는 요청을 수락 합니다.</permission>
    <threadsafe>이 클래스의 인스턴스는 스레드로부터 안전 합니다.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">.NET Framework의 네트워크 프로그래밍</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">System.Net 클래스에 대한 모범 사례</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">네트워크 애플리케이션에 대한 캐시 관리</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">인터넷 프로토콜 버전 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">네트워크 프로그래밍 샘플</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">.NET Framework의 네트워크 추적</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">네트워크 프로그래밍의 보안</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">버전 3.5의 소켓 성능 향상</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />에서 반환된 소켓 정보입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" />에서 반환된 특정 값을 사용하여 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우는 <xref:System.Net.Sockets.Socket.%23ctor%2A> 여러 번 사용 하 여 각 호출에 대 한 인수로 동일한 바이트 배열 생성자를 만들려는 관리 되는 여러 <xref:System.Net.Sockets.Socket>s 동일한 기본 소켓을 사용 합니다. 이 방법은 좋습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</param>
        <summary>지정된 소켓 종류 및 프로토콜을 사용하여 <see cref="T:System.Net.Sockets.Socket" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `socketType` 매개 변수 유형을 지정 합니다 <xref:System.Net.Sockets.Socket> 클래스 및 `protocolType` 매개 변수에서 사용 하는 프로토콜을 지정 합니다. <xref:System.Net.Sockets.Socket>합니다. 두 매개 변수가 독립적인있지 않습니다. 종종는 <xref:System.Net.Sockets.Socket> 형식 프로토콜에서 암시적입니다. 경우 조합을 <xref:System.Net.Sockets.Socket> 형식 및 프로토콜에서 잘못 된 결과 형식 <xref:System.Net.Sockets.Socket>,이 생성자는 <xref:System.Net.Sockets.SocketException>합니다.  
  
> [!NOTE]
>  이 생성자는 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" />과 <paramref name="protocolType" />을 조합했을 때 소켓이 잘못된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 값 중 하나입니다.</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</param>
        <summary>지정된 주소 패밀리, 소켓 종류 및 프로토콜을 사용하여 <see cref="T:System.Net.Sockets.Socket" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily` 매개 변수를 지정 하는 주소 지정 체계를 <xref:System.Net.Sockets.Socket> 클래스 사용을 `socketType` 매개 변수 유형을 지정 합니다 <xref:System.Net.Sockets.Socket> 클래스 및 `protocolType` 매개 변수에서 사용 하는 프로토콜을 지정 합니다. <xref:System.Net.Sockets.Socket>. 세 개의 매개 변수가 독립적인있지 않습니다. 일부 주소 패밀리 제한으로, 그리고 자주 프로토콜을 사용할 수는 <xref:System.Net.Sockets.Socket> 형식 프로토콜에서 암시적입니다. 경우 주소 패밀리, 조합 <xref:System.Net.Sockets.Socket> 형식 및 프로토콜에서 잘못 된 형식 <xref:System.Net.Sockets.Socket>,이 생성자는 <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  이 생성자는 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 인스턴스를 만드는 방법을 보여 줍니다는 <xref:System.Net.Sockets.Socket> 클래스입니다.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />, <paramref name="socketType" /> 및 <paramref name="protocolType" />을 조합했을 때 소켓이 잘못된 경우</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>새로 만든 연결에 대한 새 <see cref="T:System.Net.Sockets.Socket" />을 만듭니다.</summary>
        <returns>새로 만든 연결에 대한 <see cref="T:System.Net.Sockets.Socket" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 동기적으로 수신 소켓의 연결 요청 큐에서 첫 번째 보류 중인 연결 요청을 추출 하 고 다음 만들고 반환 새 <xref:System.Net.Sockets.Socket>합니다. 반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다. 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 메서드의 반환된 된 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 확인할 수 있습니다.  
  
 블로킹 모드에서 <xref:System.Net.Sockets.Socket.Accept%2A> 들어오는 연결 시도 큐에 대기 될 때까지 차단 합니다. 연결을 수락 되 면 원래 <xref:System.Net.Sockets.Socket> 큐 들어오는 연결 요청 될 때까지 닫기 계속 합니다.  
  
 비블로킹을 사용 하 여이 메서드를 호출 하는 경우 <xref:System.Net.Sockets.Socket>, 고 요청 큐에 대기 하는 연결 되지 않았습니다 <xref:System.Net.Sockets.Socket.Accept%2A> throw를 <xref:System.Net.Sockets.SocketException>입니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  호출 하기 전에 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드를 먼저 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 간단한 허용 <xref:System.Net.Sockets.Socket> 연결 합니다.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.InvalidOperationException">받아들이는 소켓이 연결을 수신하지 않는 경우. <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.Accept" />을 호출해야 합니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>들어오는 연결 시도를 받아들이는 비동기 작업을 시작합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다. 비동기적으로 연결을 허용 하면 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다. 호출 하기 전에 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.  
  
 콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 개체는 필요:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 기존를 선택적으로 지정할 수 <xref:System.Net.Sockets.Socket> 지정 하 여 들어오는 연결을 사용 하는 <xref:System.Net.Sockets.Socket> 사용 하는 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 속성입니다.  
  
 경우는 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 속성이 null이 새 <xref:System.Net.Sockets.Socket> 같은 생성 된 <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, 및 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 현재 <xref:System.Net.Sockets.Socket> 으로 설정 하 고는 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 속성입니다.  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 필요에 따라 초기 데이터 블록의 후 소켓을 수신 하는 버퍼를 제공할 수 있습니다는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 성공 합니다. 이 경우에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 받을 데이터를 포함 하는 버퍼를 설정 해야 하는 속성 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성 버퍼에서 수신 하도록 데이터의 바이트의 최대 수로 설정 해야 합니다. 사용 하 여 이러한 속성을 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> 메서드. 전달 된 버퍼의 파트에서 사용 하는 내부적으로 사용에 대 한 기본 Winsock AcceptEx 호출 합니다. 즉, 반환 되는 데이터 양을 값 보다 작을 수 항상은 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성에는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 제공 되는 인스턴스. 내부적으로 사용 되는 버퍼의 크기는 소켓의 주소 패밀리에 따라 달라 집니다. 필요한 최소 버퍼 크기는 288 바이트입니다. 큰 버퍼 크기를 지정 하는 경우 해당 <xref:System.Net.Sockets.Socket> Winsock AcceptEx 호출에서 받은 주소 데이터가 아닌 일부 추가 데이터는 것을 예상 하 고이 추가 데이터를 수신할 때까지 기다립니다. 시간 초과가 발생 하는 경우 연결이 다시 설정 됩니다. 따라서 추가 데이터는 특정 크기, 예상 되는 경우 버퍼 크기는 최소 버퍼 크기와이 크기를 설정 해야 합니다.  
  
 완료 콜백 메서드를 검사 해야 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 여부를 확인 하는 속성을 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 작업이 성공적으로 합니다.  
  
 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트 발생 및 연결 없음에 동의 하는 경우 일부 경우에 발생할 수는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 속성을 설정할 <xref:System.Net.Sockets.SocketError.ConnectionReset>합니다. 반 열린 SYN 형식 검사를 사용 하 여 포트 검색의 결과로 발생할 수 있습니다 (SYN SYN-ACK-> RST 시퀀스->). 사용 하 여 응용 프로그램을 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 메서드는이 조건을 처리할 준비가 되어 있어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">인수가 잘못된 경우. 제공된 버퍼의 크기가 너무 작으면 이 예외가 발생합니다. 버퍼의 크기는 최소한 2 * (sizeof(SOCKADDR_STORAGE + 16)바이트 이상이어야 합니다.  
  
버퍼를 여러 개 지정하고 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 null이 아닌 경우에도 이 예외가 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">인수가 범위를 벗어난 경우. <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />가 0보다 작으면 이 예외가 발생합니다.</exception>
        <exception cref="T:System.InvalidOperationException">잘못된 작업이 요청된 경우. 받아들이는 <see cref="T:System.Net.Sockets.Socket" />이 연결을 수신 대기하지 않거나 받아들인 소켓이 바인딩되어 있으면 이 예외가 발생합니다.  
  
<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 메서드를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 메서드를 호출해야 합니다.  
  
소켓이 이미 연결되어 있거나 지정된 <paramref name="e" /> 매개 변수를 사용하여 소켓 작업이 이미 진행 중인 경우에도 이 예외가 발생합니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 주소 패밀리를 가져옵니다.</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> 주소 지정 체계를 지정 인스턴스의 <xref:System.Net.Sockets.Socket> 클래스를 사용할 수 있습니다. 이 속성은 읽기 전용 및 경우 설정 됩니다는 <xref:System.Net.Sockets.Socket> 만들어집니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, 및 <xref:System.Net.Sockets.ProtocolType> 콘솔.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>네트워크에서 받아서 읽을 수 있는 데이터의 양을 가져옵니다.</summary>
        <value>네트워크에서 받아서 읽을 수 있는 데이터의 바이트 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비블로킹을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> 가 호출 하기 전에 읽기에 대 한 데이터가 대기 될 수 있는지 여부를 결정 하는 좋은 방법은 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. 사용 가능한 데이터 읽기에 대 한 네트워크 버퍼에 대기 하는 데이터의 총 크기입니다. 네트워크 버퍼에서 대기 중인 데이터가 없을 경우 <xref:System.Net.Sockets.Socket.Available%2A> 0을 반환 합니다.  
  
 원격 호스트 종료 되거나 연결이 닫히면 <xref:System.Net.Sockets.Socket.Available%2A> throw 할 수는 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 IOControl FIONREAD 및 사용 가능한 속성을 사용 하 여 결과 비교 합니다.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>들어오는 연결 시도를 받아들이는 비동기 작업을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>들어오는 연결 시도를 받아들이는 비동기 작업을 시작합니다.</summary>
        <returns>비동기 <see cref="T:System.IAsyncResult" /> 생성을 참조하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다. 비동기적으로 연결을 허용 하면 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다. 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.  
  
 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. 수신 대기 전달 해야이를 위해서는, 최소한 <xref:System.Net.Sockets.Socket> 개체를 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해를 `state` 매개 변수입니다. 콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 시스템에서 일반적으로 지정 된 콜백 메서드를 실행 하는 별도 스레드를 사용 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndAccept%2A> 보류 중인 연결 검색 될 때까지 합니다. <xref:System.Net.Sockets.Socket.EndAccept%2A> 새 돌아갑니다 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 받고 보내는 데 사용할 수 있는 개체입니다. 반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다. Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.  
  
 시스템 콜백 메서드를 호출 하는 호출 스레드를 사용할 수도 있습니다. 이 경우에 <xref:System.IAsyncResult.CompletedSynchronously%2A> 속성에서 반환 된 <xref:System.IAsyncResult> 나타내는로 설정 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 동기적으로 완료 합니다.  
  
 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다. 경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
> [!NOTE]
>  사용할 수는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 반환 된 속성 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 확인할 수 있습니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기적으로 들어오는 연결을 수신 하려고 시도 합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <exception cref="T:System.InvalidOperationException">받아들이는 소켓이 연결을 수신하지 않는 경우. <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />을 호출해야 합니다.  
  
또는 
받아들여진 소켓이 바인딩된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="receiveSize">송신자로부터 받아들일 바이트 수입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>들어오는 연결 시도를 받아들이는 비동기 작업을 시작하고 클라이언트 응용 프로그램에서 보낸 데이터의 첫 번째 블록을 받습니다.</summary>
        <returns>비동기 <see cref="T:System.IAsyncResult" /> 생성을 참조하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다. 연결을 비동기적으로 수락 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다. 이 오버 로드를 사용 하면 초기 전송에 동의 하는 바이트 수를 지정할 수 있습니다는 `receiveSize` 매개 변수입니다.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.  
  
 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. 수신 대기 전달 해야이를 위해서는, 최소한 <xref:System.Net.Sockets.Socket> 개체를 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해를 `state` 매개 변수입니다. 콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 시스템에서 일반적으로 지정 된 콜백 메서드를 실행 하는 별도 스레드를 사용 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndAccept%2A> 보류 중인 연결 검색 될 때까지 합니다.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 받고 보내는 데 사용할 수 있습니다. 반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다. Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.  
  
 시스템 콜백 메서드를 호출 하는 호출 스레드를 사용할 수도 있습니다. 이 경우에 <xref:System.IAsyncResult.CompletedSynchronously%2A> 속성에서 반환 된 <xref:System.IAsyncResult> 나타내는로 설정 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 동기적으로 완료 합니다.  
  
 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다.  경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
> [!NOTE]
>  사용 하 여 호출할 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 반환 된 속성 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 식별 하는 개체입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 소켓을 열어 및 비동기 연결을 허용 합니다. 이 예제에서는 소켓 초기 10 바이트의 데이터를 허용합니다. 받은 바이트 수와 데이터는 콜백 대리자에 의해 콘솔에 표시 됩니다. 참조 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 에 대 한 설명은 나머지 데이터는 어떻게 받을 수 있습니다.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <exception cref="T:System.InvalidOperationException">받아들이는 소켓이 연결을 수신하지 않는 경우. <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />을 호출해야 합니다.  
  
또는 
받아들여진 소켓이 바인딩된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">허용되는 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다. 이 값은 <see langword="null" />일 수 있습니다.</param>
        <param name="receiveSize">받을 최대 바이트 수입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>지정된 소켓에서 들어오는 연결 시도를 받아들이는 비동기 작업을 시작하고 클라이언트 응용 프로그램에서 보낸 데이터의 첫 번째 블록을 받습니다.</summary>
        <returns>비동기 <see cref="T:System.IAsyncResult" /> 개체 생성을 참조하는 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜에서 사용할 수는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 들어오는 연결을 비동기적으로 처리를 시도 합니다. 비동기적으로 연결을 허용 하면 별도 실행 스레드 내에서 데이터를 주고받을 수 있습니다. 이 오버 로드를 사용 하면에 수락한 소켓을 지정할 수 있습니다는 `acceptSocket` 매개 변수입니다. 이 매개 변수가 `null`, 받아들여진된 소켓이 만들어집니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. 초기 전송에 동의 하는 바이트 수를 지정할 수는 `receiveSize` 매개 변수입니다.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Listen%2A> 수신 대기 하 고 들어오는 연결 요청을 큐에 대 한 방법입니다.  
  
 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. 수신 대기 전달 해야이를 위해서는, 최소한 <xref:System.Net.Sockets.Socket> 개체를 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해를 `state` 매개 변수입니다. 콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 시스템에서 일반적으로 지정 된 콜백 메서드를 실행 하는 별도 스레드를 사용 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndAccept%2A> 보류 중인 연결 검색 될 때까지 합니다.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트를 사용 하 여 데이터를 받고 보내는 데 사용할 수 있는 개체입니다. 반환이 사용할 수 없습니다 <xref:System.Net.Sockets.Socket> 연결 큐에서 모든 추가 연결을 허용 하도록 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다. Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우.  
  
 시스템 콜백 메서드를 호출 하는 호출 스레드를 사용할 수도 있습니다. 이 경우에 <xref:System.IAsyncResult.CompletedSynchronously%2A> 속성에서 반환 된 <xref:System.IAsyncResult> 나타내는로 설정 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 동기적으로 완료 합니다.  
  
 콜백 메서드를 작성에 대 한 자세한 내용은 참조 하세요. [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다. 경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
> [!NOTE]
>  사용할 수는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 반환 된 속성 <xref:System.Net.Sockets.Socket> 원격 호스트의 네트워크 주소 및 포트 번호를 식별 하는 개체입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 소켓을 열어 및 비동기 연결을 허용 합니다. 이 예제에서는 소켓 수락 초기 10 바이트의 데이터 및 `acceptSocket` 매개 변수는 `null`는 강제로 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 받아들여진된 소켓이 만드는 방법. 받은 바이트 수와 데이터는 콜백 대리자에 의해 콘솔에 표시 됩니다. 참조 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 에 대 한 설명은 나머지 데이터는 어떻게 받을 수 있습니다.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <exception cref="T:System.InvalidOperationException">받아들이는 소켓이 연결을 수신하지 않는 경우. <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />를 호출하기 전에 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 및 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />을 호출해야 합니다.  
  
또는 
받아들여진 소켓이 바인딩된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">원격 호스트를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="end_point">원격 호스트를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다.</summary>
        <returns>비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 에 대 한 연결에 대 한 비동기 요청을 시작 하는 메서드는 `remoteEP` 매개 변수입니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 합니다. 기본 원격 호스트를 비동기적으로 설정 하거나 연결을 별도 실행 스레드 내에서 데이터 전송 및 수신 하는 기능을 제공 합니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드. 최소한를 전달 해야 합니다는 <xref:System.Net.Sockets.Socket> 하 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 통해를 `state` 매개 변수입니다. 콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket>, 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginConnect%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 때까지 <xref:System.Net.Sockets.Socket> 성공적으로 연결 하거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A>입니다. Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 고 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 원격 호스트와 통신할 수 있습니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 브로드캐스트 설정 하 고 `true`입니다. 그렇게 할 수 없으면 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.  
  
 연결 지향 프로토콜을 사용 하 고 호출 하지 마세요 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다. 호출 하기 전에 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 연결 없는 프로토콜을 사용 하는 경우 할당 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 또는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. 기본 원격 호스트를 변경 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 원하는 끝점을 사용 합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다. 경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다. 기본 공급자의 제한 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 연결 시도 시작합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="address">원격 호스트의 <see cref="T:System.Net.IPAddress" />입니다.</param>
        <param name="port">원격 호스트의 포트 번호입니다.</param>
        <param name="requestCallback">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="callback">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">연결 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <paramref name="requestCallback" /> 대리자에게 전달됩니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다. 호스트는 <see cref="T:System.Net.IPAddress" />와 포트 번호로 지정됩니다.</summary>
        <returns>비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드. 메서드는 일반적으로 `requestCallback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 오버 로드 또는 <xref:System.Net.Sockets.Socket.EndConnect%2A>합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다. 경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다. 기본 공급자의 제한 됩니다. 또한는 <xref:System.Net.EndPoint> 즉 사용 되는 달라 야 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 연결 시도 시작합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" />이 소켓 패밀리에 없는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">포트 번호가 잘못된 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" />의 길이가 0입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">원격 호스트를 지정하는 하나 이상의 <see cref="T:System.Net.IPAddress" />입니다.</param>
        <param name="port">원격 호스트의 포트 번호입니다.</param>
        <param name="requestCallback">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="callback">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">연결 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <paramref name="requestCallback" /> 대리자에게 전달됩니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다. 호스트는 <see cref="T:System.Net.IPAddress" /> 배열과 포트 번호로 지정됩니다.</summary>
        <returns>비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드. 메서드는 일반적으로 `requestCallback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 오버 로드 합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다. 경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다. 기본 공급자의 제한 됩니다. 또한는 <xref:System.Net.EndPoint> 즉 사용 되는 달라 야 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 연결 시도 시작합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />를 사용하는 소켓에 유효합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">포트 번호가 잘못된 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" />의 길이가 0입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="host">원격 호스트의 이름입니다.</param>
        <param name="port">원격 호스트의 포트 번호입니다.</param>
        <param name="requestCallback">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="callback">연결 작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">연결 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <paramref name="requestCallback" /> 대리자에게 전달됩니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다. 호스트는 호스트 이름과 포트 번호로 지정됩니다.</summary>
        <returns>비동기 연결을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드. 메서드는 일반적으로 `requestCallback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 오버 로드 합니다.  
  
 보류 중인 호출을 취소 하는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 닫기는 <xref:System.Net.Sockets.Socket>합니다. 경우는 <xref:System.Net.Sockets.Socket.Close%2A> 메서드가 비동기 작업이 진행에서 되는 동안 호출에 제공 된 콜백은 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드가 호출 됩니다.  이후에 호출 하는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드를 throw 합니다는 <xref:System.ObjectDisposedException> 나타내려면 작업이 취소 되었습니다.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  이 소켓의 이전 연결이 끊어지면 다음 경우 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 작업이 완료 될 때까지 종료 되지 않는 스레드에서 호출 해야 합니다. 기본 공급자의 제한 됩니다. 또한는 <xref:System.Net.EndPoint> 즉 사용 되는 달라 야 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 연결 시도 시작합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">포트 번호가 잘못된 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었거나 비동기 작업이 이미 진행 중입니다.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">연결을 닫은 다음 이 소켓을 다시 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>원격 엔드포인트와의 연결을 끊는 비동기 요청을 시작합니다.</summary>
        <returns>비동기 작업을 참조하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜을 사용 하는 경우 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 원격 끝점 으로부터의 연결을 끊도록을 요청 하는 방법입니다. 하는 경우 `reuseSocket` 는 `true`, 소켓을 다시 사용할 수 있습니다.  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 메서드 별도 스레드를 사용 하 여 지정된 된 콜백 메서드를 호출 합니다. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 완료 보류 중 연결 해제 될 때까지 메서드가 차단 됩니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 하세요. [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
> [!NOTE]
>  표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 통신을 위한 소켓을 만들고 원격 호스트에 일부 데이터를 보냅니다. 데이터를 보낼 때 <xref:System.Net.Sockets.Socket.Shutdown%2A> 송신을 중지 하 고 작업을 수신 하기 위해 호출 됩니다. 그런 다음 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 연결 끊기 요청을 시작 하기 위해 호출 됩니다. 요청이 완료 되 면는 <xref:System.Net.Sockets.Socket.Connected%2A> 속성 소켓 연결이 있는지 여부를 테스트 하기 위해 쿼리 됩니다.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="callback">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</summary>
        <returns>비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드. 메서드는 일반적으로 `callback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <param name="callback">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</summary>
        <returns>비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드. 메서드는 일반적으로 `callback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">받은 데이터를 저장하기 위한 <paramref name="buffer" /> 매개 변수의 위치(0부터 시작)입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="callback">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</summary>
        <returns>비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드. 메서드는 일반적으로 `callback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 연결 된 데이터를 비동기적으로 받으려면 시작 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">받을 데이터를 저장할 <paramref name="buffer" /> 내의 위치입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <param name="error">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <param name="callback">작업이 완료되었을 때 호출할 메서드를 참조하는 <see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">수신 작업에 대한 정보가 들어 있는 사용자 정의 개체입니다. 이 개체는 작업이 완료되면 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 대리자에게 전달됩니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 비동기적으로 받기 시작합니다.</summary>
        <returns>비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 를 호출 하 여 작업을 완료 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드. 메서드는 일반적으로 `callback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단, 중 하나를 사용 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 오버 로드 합니다.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫힌 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">데이터를 저장하기 위한 <paramref name="buffer" /> 매개 변수의 위치(0부터 시작)입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">데이터의 소스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="remote_end">데이터의 소스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>지정된 네트워크 장치에서 비동기적으로 데이터를 받기 시작합니다.</summary>
        <returns>비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드 비동기적으로 원격 호스트에서 연결 없는 데이터 그램을 읽기 시작 합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 받을 수 있습니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드. 최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다. 콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>시스템 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는, 및에서 차단 됩니다 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 때까지 <xref:System.Net.Sockets.Socket> 데이터를 읽거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드를 사용 하 여 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>입니다. 원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 하세요. [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
> [!NOTE]
>  호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 또는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>.  
  
 이 메서드는 데이터를 읽습니다는 `buffer` 매개 변수를 캡처를 원격 데이터를 전송 하는 끝점을 호스트 합니다. 이 끝점을 검색 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>합니다. 이 메서드는 비동기적으로 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 가장 유용 합니다. 이러한 경우 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>. 신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다. 신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.  
  
 항상 반환 되는 원격 호스트 끝점에는 응용 프로그램을 명시적으로 바인딩해야 하는 데는 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 및 호출 합니다 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드를 `optionLevel` 매개변수설정<xref:System.Net.Sockets.SocketOptionLevel.IP>또는 <xref:System.Net.Sockets.SocketOptionLevel.IPv6> 적절 하 게 합니다 `optionName` 매개 변수 설정 <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, 및 `optionValue` 호출 하기 전에이 옵션을 사용 하도록 설정 하려면 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드. 그렇지 않을 경우 반환 되지 않을 때 보낸 데이터 그램의 수를 수신기가 호출 되기 전에 원격 호스트 끝점에 대 한 가능한는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.  
  
 하지만 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다. 작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드를 호출 하 여 들어오는 연결 요청을 수락 하거나 합니다 <xref:System.Net.Sockets.Socket.Accept%2A> 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 을 설정 하거나 연결을 허용 하기 전에 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드. 이러한 경우 중를 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.  
  
 연결 지향 소켓 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 을 사용 하 여 지정 된 바이트 수 만큼 데이터를 읽습니다는 `size` 매개 변수입니다.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 호스트에서 연결 없는 데이터 그램을 비동기적으로 받습니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">데이터를 저장하기 위한 <paramref name="buffer" /> 매개 변수의 위치(0부터 시작)입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">데이터의 소스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>비동기적으로 지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼의 특정 위치로 지정된 바이트 수의 데이터를 받고 엔드포인트 및 패킷 정보를 저장하기 시작합니다.</summary>
        <returns>비동기 읽기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 비동기 수신 작업을 호출 하 여 완료 해야 합니다는 <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> 메서드. 메서드는 일반적으로 `asyncCallback` 위임 합니다.  
  
 이 메서드는 작업이 완료 될 때까지 차단 하지 않습니다. 작업이 완료 될 때까지 차단 합니다 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
 비동기 프로그래밍 모델을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 이 메서드는 데이터를 읽습니다는 `buffer` 받은 패킷에 대 한 정보 뿐만 아니라 매개 변수를 캡처를 원격 호스트, 데이터 전송 되는 끝점입니다. 이 끝점을 검색 하는 방법에 대 한 자세한 내용은 참조 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>합니다. 이 메서드는 비동기적으로 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 가장 유용 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</summary>
        <returns>비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드. 최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다. 작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드. 원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다. 사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />가 비어 있는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</summary>
        <returns>비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드. 최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다. 작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드. Set 메서드를 호출을 <xref:System.Threading.ManualResetEvent> 콜백 메서드에서 원래 스레드가 계속 실행 하려는 경우. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다. 사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />가 비어 있는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">데이터 보내기를 시작하기 위한 <paramref name="buffer" /> 매개 변수의 위치(0부터 시작)입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</summary>
        <returns>비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드. 최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다. 작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드. 원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다. 사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" />이 <paramref name="buffer" />의 길이보다 작은 경우  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">데이터 보내기를 시작하기 위한 <paramref name="buffer" /> 매개 변수의 위치(0부터 시작)입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 비동기적으로 보냅니다.</summary>
        <returns>비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>하십시오 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드. 최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다. 작은 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSend%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSend%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드. 원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSend%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다. 사용 해도 되는지 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 연결 없는 프로토콜 사용도 해야 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.BeginSend%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  `state` 사용자 정의 클래스의 인스턴스화가입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 비동기적으로 원격 호스트에 데이터를 보내기 시작 합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" />이 <paramref name="buffer" />의 길이보다 작은 경우  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">비동기 클라이언트 소켓 예제</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">비동기 서버 소켓 예제</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파일을 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">보낼 파일의 경로 및 이름이 들어 있는 문자열입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 플래그를 사용하여 <paramref name="fileName" /> 파일을 연결된 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 개체에 보냅니다.</summary>
        <returns>비동기 보내기를 나타내는 <see cref="T:System.IAsyncResult" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 된 파일을 보냅니다 `fileName` 연결 된 소켓입니다. 경우 `fileName` 는 로컬 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다. 와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다. 파일이 없는 경우, 예외 <xref:System.IO.FileNotFoundException> throw 됩니다.  
  
 이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을. 에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 참조 합니다 [Windows 소켓](/windows/desktop/WinSock/) 설명서.  
  
 합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 하지 않으면 예외를 throw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 메서드를 사용 하면 별도 실행 스레드 내에서 파일을 보낼 수 있습니다.  
  
 작업을 완료 하 여 호출 되는 콜백 메서드를 만들 수 있습니다는 <xref:System.AsyncCallback> 대리자 매개 변수입니다. 최소한,이 작업을 수행 하는 `state` 매개 변수를 포함 해야 합니다는 <xref:System.Net.Sockets.Socket> 통신에 사용 되는 개체입니다. 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 사용자 지정 개체의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, 시스템을 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 때까지 <xref:System.Net.Sockets.Socket> 전체 파일을 전송 하거나 예외를 throw 합니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜을 사용 하 여 파일의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 해야 합니다. 이 경우 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.  
  
> [!NOTE]
>  표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제를 만들고 비동기 통신을 위한 소켓을 연결 합니다. 먼저 "text.txt" 파일은 원격 호스트에 비동기적으로 전송 됩니다. 콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전송을 완료 합니다.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.NotSupportedException">소켓이 원격 호스트에 연결되지 않은 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="fileName" /> 파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">보낼 파일의 경로 및 이름이 들어 있는 문자열입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="preBuffer">파일이 전송되기 전에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="postBuffer">파일이 전송된 후에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 값의 비트 조합입니다.</param>
        <param name="callback">이 작업이 완료되면 호출될 <see cref="T:System.AsyncCallback" /> 대리자입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="state">이 요청에 대한 상태 정보가 들어 있는 사용자 정의 개체입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <summary>파일 및 데이터 버퍼를 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.IAsyncResult" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드의 비트 조합 보낼 파일의 이름이 필요한 <xref:System.Net.Sockets.TransmitFileOptions> 값입니다. `preBuffer` 매개 변수를 파일 앞에 데이터를 포함 합니다. `postBuffer` 파일을 따라 하려는 데이터가 포함 됩니다. 경우 `fileName` 는 로컬 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다. 와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다. 파일이 없는 경우, 예외 <xref:System.IO.FileNotFoundException> throw 됩니다.  
  
 `flags` 매개 변수는 파일 전송에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다. 이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.TransmitFileOptions>합니다.  
  
 이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을. 에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 참조 합니다 [Windows 소켓](/windows/desktop/WinSock/) 설명서.  
  
 합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Connect%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 하지 않으면 예외를 throw <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>합니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 방법을 사용 하면 별도 실행 스레드 내에서 파일을 보낼 수 있습니다.  
  
 작업을 완료 하 여 호출 되는 콜백 메서드를 만들 수 있습니다는 <xref:System.AsyncCallback> 대리자 매개 변수입니다. 최소한,이 작업을 수행 하는 `state` 매개 변수를 포함 해야 합니다는 <xref:System.Net.Sockets.Socket> 통신에 사용 되는 개체입니다. 클래스 또는 구조체를 저장할 콜백이 정보가 더 필요한 경우 만들 수 있습니다는 <xref:System.Net.Sockets.Socket> 및 기타 필요한 정보입니다. 이 사용자 지정 개체의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다는 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, 시스템을 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하 고에서 차단 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 때까지 <xref:System.Net.Sockets.Socket> 전체 파일을 전송 하거나 예외를 throw 합니다. 콜백 메서드를 작성에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 연결 지향 프로토콜에서 사용 되지만 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 먼저 호출 된 연결 없는 프로토콜에 대해서도 작동 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜 사용도 해야 파일의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다. 이 경우 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.  
  
> [!NOTE]
>  표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 통신에 대 한 소켓 연결 및 보내기 시작 파일 "text.txt" 비동기적으로 원격 호스트에 만듭니다. 이 예는 `preBuffer` 및 `postBuffer` 데이터 파일 및 기본값을 사용 하 여 보낼 생성 <xref:System.Net.Sockets.TransmitFileOptions> 값이 사용 됩니다. 콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전송을 완료 합니다.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
        <exception cref="T:System.NotSupportedException">운영 체제가 Windows NT 이상이 아닌 경우  
  
또는 
소켓이 원격 호스트에 연결되지 않은 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="fileName" /> 파일을 찾을 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">보낼 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">데이터 보내기를 시작할 <paramref name="buffer" />의 위치(0부터 시작)입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">원격 디바이스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="remote_end">원격 디바이스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 정보를 포함하는 개체입니다.</param>
        <summary>특정 원격 호스트에 데이터를 비동기적으로 보냅니다.</summary>
        <returns>비동기 보내기를 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 에 지정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드는 `remoteEP` 매개 변수입니다. 호출 된 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다. 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 프로토콜과 연결 지향 프로토콜 모두 작동 합니다.  
  
 구현 하는 콜백 메서드를 만들 수 있습니다 합니다 <xref:System.AsyncCallback> 위임 하 고 해당 이름을 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드. 최소한,이 작업을 수행 하 여 `state` 매개 변수는 연결을 포함 해야 합니다 또는 기본 <xref:System.Net.Sockets.Socket> 통신에 사용 되 합니다. 콜백이 정보가 더 필요한 경우에 포함 된 작은 클래스를 만들 수 있습니다는 <xref:System.Net.Sockets.Socket>, 및 기타 필요한 정보입니다. 이 클래스의 인스턴스를 전달 합니다 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 를 통해 메서드를 `state` 매개 변수입니다.  
  
 콜백 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 메서드. 응용 프로그램을 호출할 때 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>는 별도 스레드를 사용 하 여 지정 된 콜백 메서드를 실행 하는 시스템과의 차단 됩니다 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 때까지 <xref:System.Net.Sockets.Socket> 요청 된 바이트의 번호를 전송 하거나 예외를 throw 합니다. 원래 스레드를 호출한 후 차단 하려는 경우는 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드를 사용 하 여는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 메서드. 원래 스레드를 계속 실행 하려는 경우 콜백 메서드에서 받으며에서 Set 메서드를 호출 합니다. 콜백 메서드를 작성 하는 방법에 대 한 자세한 내용은 참조 [콜백 메서드로 대리자 마샬링](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)합니다.  
  
 먼저 호출 해야 합니다는 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드를 또는 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 무시 합니다는 `remoteEP` 매개 변수 및 송신 데이터를를 <xref:System.Net.EndPoint> 에 설정 된 합니다 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.  
  
 연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 나 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다. 호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다. 또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 이 경우 기본 서비스 공급자는 가장 적절 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다. 기본 서비스 공급자가 사용 가능한 포트를 선택 하려는 경우 0의 포트 번호를 사용 합니다. 할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 메서드가 성공적으로 완료 합니다.  
  
 먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다. -버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  비동기에 대 한 캐시 된 실행 컨텍스트 (보안 컨텍스트를 가장된 된 사용자 및 호출 컨텍스트에) <xref:System.Net.Sockets.Socket> 메서드. 특정 컨텍스트 처음 사용한 후 (특정 비동기 <xref:System.Net.Sockets.Socket> 메서드를 특정 <xref:System.Net.Sockets.Socket> 인스턴스와 특정 콜백을), 이후 해당 컨텍스트에서 사용 하면 성능이 향상 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 원격 호스트에 데이터를 비동기적으로 보냅니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">콜백 메서드로 대리자 마샬링</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.EndPoint" />과 연결된 로컬 <see cref="T:System.Net.Sockets.Socket" />입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" />을 로컬 엔드포인트와 연결합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 특정 로컬 끝점을 사용 하는 경우. 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Listen%2A> 메서드. 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 사용 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 특정 로컬 끝점을 사용 하는 제외 합니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Bind%2A> 프로토콜과 연결 지향 프로토콜 모두에서 메서드.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.Bind%2A>, 로컬을 먼저 만들어야 <xref:System.Net.IPEndPoint> 에서 데이터를 전달 하려는입니다. 할당 되는 로컬 주소는 중요 하지 않은 경우 만들 수 있습니다는 <xref:System.Net.IPEndPoint> 를 사용 하 여 <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> 주소 매개 변수 및 기본 서비스 공급자 가장 적합 한 네트워크 주소를 할당 합니다. 이렇게 하면 여러 네트워크 인터페이스가 있는 경우 응용 프로그램을 간소화 하는 데 도움이 될 수 있습니다. 사용 되는 로컬 포트는 중요 하지 않은 경우 만들 수 있습니다는 <xref:System.Net.IPEndPoint> 포트 번호 0을 사용 합니다. 이 경우 서비스 공급자에는 1024-5000 사이의 사용 가능한 포트 번호를 할당 합니다.  
  
 호출 하 여 할당 된 로컬 네트워크 주소 및 포트 번호를 검색할 수 있습니다, 위의 접근 방식을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>합니다. 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 에 대 한 호출을 수행한 후 될 때까지 할당 된 로컬 네트워크 주소를 반환 하지 것입니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 완료 송신 또는 수신 될 때까지이 정보에 액세스할을 수 없습니다 됩니다.  
  
 UDP 소켓을 받은 패킷에 대 한 인터페이스 정보를 수신 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 로 설정 하는 소켓 옵션을 사용 하 여 메서드를 명시적으로 호출 해야 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 호출한 후 즉시는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드.  
  
> [!NOTE]
>  호출 해야 멀티 캐스트 데이터 그램을 수신 하려는 경우는 <xref:System.Net.Sockets.Socket.Bind%2A> 멀티 캐스트 포트 번호를 사용 하 여 메서드.  
  
> [!NOTE]
>  호출 해야 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 사용 하 여 연결 없는 데이터 그램을 수신 하려는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException> 호출할 때 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예에서는 바인드를 <xref:System.Net.Sockets.Socket> 지정된 된 로컬 끝점을 사용 하 여 합니다.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">정의한 호스트에서 연결을 수락 하기 위해 <paramref name="localEP" />합니다. 연결 된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />이 블로킹 모드인지 여부를 나타내는 값을 설정하거나 가져옵니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />이 차단되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 나타냅니다 여부를 <xref:System.Net.Sockets.Socket> 블로킹 모드 인지 합니다.  
  
 블로킹 모드에 있으며 메서드를 호출 하는 즉시 완료 되지 않은 경우에 응용 프로그램 요청 된 작업이 완료 될 때까지 실행에 차단 됩니다. 요청 된 작업이 완료 하는 경우에 계속 변경, 실행 하려는 경우는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false`입니다. <xref:System.Net.Sockets.Socket.Blocking%2A> 속성이 비동기 메서드에 적용 되지 않습니다. 전송 및 데이터를 비동기적으로 받는 실행을 차단 하려면를 사용 하 여는 <xref:System.Threading.ManualResetEvent> 클래스입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 메서드 중 하나를 호출하여 원격 호스트에 대한 연결을 요청하는 데 사용되는 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 개체입니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> 메서드는 원격 호스트 연결에 대 한 비동기 요청을 취소 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 매개 변수가 null일 수 없으며, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />도 null일 수 없습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 연결을 닫고 연결된 리소스를 모두 해제합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 연결을 닫고 연결된 리소스를 모두 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드는 원격 호스트 연결을 닫고 관리 되는 모든 릴리스와 연관 된 리소스를 관리 되지 않는 <xref:System.Net.Sockets.Socket>합니다. 를 닫으면 합니다 <xref:System.Net.Sockets.Socket.Connected%2A> 속성이 `false`합니다.  
  
 연결 지향 프로토콜에 대 한 것이 좋습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Close%2A> 메서드. 이렇게 하면 모든 데이터가 전송 및 연결이 닫히기 전에 연결된 된 소켓에서 수신 합니다.  
  
 호출 해야 하는 경우 <xref:System.Net.Sockets.Socket.Close%2A> 첫 번째 호출 하지 않고 <xref:System.Net.Sockets.Socket.Shutdown%2A>, 대기 중인 데이터를 설정 하 여 전송 나가는 전송 되도록 할 수 있습니다 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> 옵션을 `false` 고 0이 아닌 제한 시간 간격을 지정 합니다. <xref:System.Net.Sockets.Socket.Close%2A> 그런 다음,는이 데이터를 보낼 때까지 또는 지정된 된 제한 시간이 만료 될 때까지 차단 합니다. 설정 하는 경우 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 하 `false` 0 시간 제한 간격을 지정 하 고 <xref:System.Net.Sockets.Socket.Close%2A> 연결을 해제 하 고 나가는 큐에 대기 중인된 데이터를 자동으로 삭제 합니다.  
  
> [!NOTE]
>  설정 하는 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 `false`, 만들기를 <xref:System.Net.Sockets.LingerOption>, 설정 된 속성을 설정 `true`, 설정 및는 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성을 원하는 시간 초과 기간. 이 사용 하 여 <xref:System.Net.Sockets.LingerOption> 와 함께 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 호출 합니다 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 닫습니다는 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">나머지 데이터가 전송될 때까지 <paramref name="timeout" />초까지 기다린 후 소켓을 닫습니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 연결을 닫고 지정된 시간 제한의 모든 관련 리소스를 해제하여 대기 중인 데이터가 전송될 수 있도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드는 원격 호스트 연결을 닫고 관리 되는 모든 릴리스와 연관 된 리소스를 관리 되지 않는 <xref:System.Net.Sockets.Socket>합니다. 를 닫으면 합니다 <xref:System.Net.Sockets.Socket.Connected%2A> 속성이 `false`합니다.  
  
 연결 지향 프로토콜에 대 한 것이 좋습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Close%2A>입니다. 이렇게 하면 모든 데이터가 전송 및 연결이 닫히기 전에 연결된 된 소켓에서 수신 합니다.  
  
 호출 해야 하는 경우 <xref:System.Net.Sockets.Socket.Close%2A> 첫 번째 호출 하지 않고 <xref:System.Net.Sockets.Socket.Shutdown%2A>, 대기 중인 데이터를 설정 하 여 전송 나가는 전송 되도록 할 수 있습니다 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 옵션을 `false` 고 0이 아닌 제한 시간 간격을 지정 합니다. <xref:System.Net.Sockets.Socket.Close%2A> 그런 다음,는이 데이터를 보낼 때까지 또는 지정된 된 제한 시간이 만료 될 때까지 차단 합니다. 설정 하는 경우 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 하 `false` 0 시간 제한 간격을 지정 하 고 <xref:System.Net.Sockets.Socket.Close%2A> 연결을 해제 하 고 나가는 큐에 대기 중인된 데이터를 자동으로 삭제 합니다.  
  
> [!NOTE]
>  설정 하는 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 `false`, 만들기를 <xref:System.Net.Sockets.LingerOption>, 설정 된 속성을 설정 `true`, 설정 및는 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성을 원하는 시간 제한 기간. 이 사용 하 여 <xref:System.Net.Sockets.LingerOption> 와 함께 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 소켓 옵션을 호출 합니다 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 종결 하는 방법을 보여 줍니다는 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>원격 호스트에 대한 연결을 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">원격 디바이스를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>원격 호스트에 대한 연결을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 끝점입니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다. 호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A>를 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다. TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다. 연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다. 사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다. 연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다. 사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.  
  
> [!NOTE]
>  연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다. 연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다. 기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.  
  
> [!NOTE]
>  소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다. 비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다. 기본 공급자의 제한 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</exception>
        <permission cref="T:System.Net.SocketPermission">원격 호스트에 연결 합니다. 연결 된 열거형: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">원격 호스트의 IP 주소입니다.</param>
        <param name="port">원격 호스트의 포트 번호입니다.</param>
        <summary>원격 호스트에 대한 연결을 설정합니다. 호스트는 IP 주소와 포트 번호로 지정됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 끝점입니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다. 호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A> 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다. TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다. 연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다. 사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다. 연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다. 사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.  
  
> [!NOTE]
>  연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다. 연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다. 기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.  
  
> [!NOTE]
>  소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다. 비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다. 기본 공급자의 제한 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">포트 번호가 잘못된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" />의 길이가 0입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">원격 호스트의 IP 주소입니다.</param>
        <param name="port">원격 호스트의 포트 번호입니다.</param>
        <summary>원격 호스트에 대한 연결을 설정합니다. 호스트는 IP 주소의 배열과 포트 번호로 지정됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출한 후 즉시 일반적으로 <xref:System.Net.Dns.GetHostAddresses%2A>, 단일 호스트에 대 한 여러 IP 주소를 반환할 수 있는 합니다. TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 끝점입니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다. 호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A> 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다. TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다. 연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다. 사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다. 연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다. 사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.  
  
> [!NOTE]
>  연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다. 연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다. 기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.  
  
> [!NOTE]
>  소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다. 비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다. 기본 공급자의 제한 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">포트 번호가 잘못된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" />의 길이가 0입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="host">원격 호스트의 이름입니다.</param>
        <param name="port">원격 호스트의 포트 번호입니다.</param>
        <summary>원격 호스트에 대한 연결을 설정합니다. 호스트는 호스트 이름과 포트 번호로 지정됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP와 같은 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드는 동기적으로 간에 네트워크 연결을 설정 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 및 지정된 된 원격 호스트 합니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 기본 원격 호스트를 설정 합니다. 호출한 후 <xref:System.Net.Sockets.Socket.Connect%2A> 사용 하 여 원격 장치에 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드를 사용 하 여 원격 장치에서 데이터를 수신 하거나는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.Connect%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 원격 호스트를 사용 하 여 동기적으로 통신 합니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, 또는 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>입니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 설정 하지 않으면 메서드가 차단 되는 <xref:System.Net.Sockets.Socket.Blocking%2A> 속성을 `false` 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>입니다. TCP 비활성화 차단 같은 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException> 연결을 만드는 데 시간이 필요 합니다. 연결 없는 프로토콜 기본 원격 호스트를 설정 하기만 하므로 예외를 throw 하지 않습니다. 사용할 수 있습니다 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오려고 합니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다. 연결 지향 하 여 원격 호스트 연결이 시작 오류 WSAEWOULDBLOCK 반환 되 면 <xref:System.Net.Sockets.Socket>, 있지만 아직 완료 되지 않은 성공적으로 합니다. 사용 하 여를 <xref:System.Net.Sockets.Socket.Poll%2A> 시기를 결정 하는 방법의 <xref:System.Net.Sockets.Socket> 가 완료 된 연결 합니다.  
  
 IPv6을 사용 하는 경우 및 <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> 메서드는 모두 IPv6로 확인 되는 호스트에 연결할 및 IPv4 주소, IPv6 주소에 대 한 연결 IPv4 주소 앞의 첫 번째 시도 합니다. 호스트의 IPv6 주소에서 수신 하지 않는 경우 연결을 설정 하는 시간을 지연이 있을 수 있습니다.  
  
> [!NOTE]
>  연결 지향 프로토콜을 사용 하 고 호출 하지 않았습니다 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Connect%2A>, 기본 서비스 공급자가 로컬 네트워크 주소 및 포트 번호를 할당 합니다. 연결 없는 프로토콜을 사용 하는 경우 완료를 송신 하거나 수신 작업 때까지 서비스 공급자 로컬 네트워크 주소 및 포트 번호를 할당 하지 않습니다. 기본 원격 호스트를 변경 하려는 경우 호출 <xref:System.Net.Sockets.Socket.Connect%2A> 원하는 끝점을 사용 합니다.  
  
> [!NOTE]
>  소켓 이전에 연결 하는 경우 연결을 복원 하려면이 방법을 사용할 수 없습니다. 비동기 작업 중 하나를 사용 하 여 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 다시 연결 하는 방법입니다. 기본 공급자의 제한 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 끝점에 연결 하 고 연결을 확인 합니다.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">포트 번호가 잘못된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 제품군의 소켓에 유효합니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />을 호출하여 수신 상태에 배치되었습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 원격 호스트에 대 한 연결에 대 한 비동기 요청을 시작 합니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 기본 원격 호스트를 설정 합니다.  
  
 콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.  
  
 호출자에 게 설정 해야 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 연결할 원격 호스트의 합니다.  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 원격 호스트와 통신할 수 있습니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 기본 원격 호스트를 변경 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 원하는 끝점을 사용 합니다.  
  
 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 브로드캐스트 설정 하 고 `true`입니다. 이렇게 하지 않으면 경우는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 개체는 필요:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 필요에 따라 버퍼 제공 될 수 있습니다는 원자 단위로 전송 후 소켓을 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 성공 합니다. 이 경우에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 보낼 데이터를 포함 하는 버퍼를 설정 해야 하는 속성 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성 버퍼에서 보내는 데이터의 바이트 수로 설정 해야 합니다. 연결이 설정 되 면이 버퍼의 데이터 전송 됩니다.  
  
 연결 지향 프로토콜을 사용 하 고 호출 하지 마세요 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다.  
  
 호출 하기 전에 서비스 공급자가 로컬 네트워크 IP 주소 및 포트 번호를 연결 없는 프로토콜을 사용 하는 경우 할당 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 또는 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 throw <xref:System.NotSupportedException> 경우의 주소 패밀리를 <xref:System.Net.Sockets.Socket> 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 같은 주소 패밀리를 하지 않습니다.  
  
> [!NOTE]
>  표시 되 면를 <xref:System.Net.Sockets.SocketException> 사용 하 여이 메서드를 호출 하는 경우는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">인수가 잘못된 경우. 버퍼를 여러 개 지정하고 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 null이 아니면 이 예외가 발생합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 매개 변수가 null일 수 없으며, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />도 null일 수 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 수신 대기 중이거나 <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우. 로컬 엔드포인트와 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 같은 주소 패밀리에 포함되지 않은 경우에도 이 예외가 발생합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</param>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>원격 호스트 연결에 대한 비동기 요청을 시작합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 메서드에 대 한 비동기 요청을 시작 하는 연결 지향 프로토콜을 사용 하는 경우는 원격 호스트에 연결 합니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 으로 지정 된 기본 원격 호스트를 설정 합니다 `socketType` 및 `protocolType` 매개 변수입니다.  
  
 콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.  
  
 호출자에 게 설정 해야 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 연결할 원격 호스트의 합니다.  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 UDP와 같은 연결 없는 프로토콜을 사용 하는 경우 호출할 필요가 없습니다 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 데이터 보내기 및 받기 전에 합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 고 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 원격 호스트와 통신할 수 있습니다. 호출 하는 경우 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 지정 된 기본값이 아닌 주소에서 도착 하는 모든 데이터 그램 무시 됩니다. 기본 원격 호스트를 변경 하려는 경우 호출 된 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 원하는 끝점을 사용 합니다.  
  
 먼저 호출 해야 기본 원격 호스트 브로드캐스트 주소를 설정 하려는 경우 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 브로드캐스트 설정 하 고 `true`입니다. 이렇게 하지 않으면 경우는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 개체는 필요:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 필요에 따라 버퍼 제공 될 수 있습니다는 원자 단위로 전송 후 소켓을 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 성공 합니다. 이 경우에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 보낼 데이터를 포함 하는 버퍼를 설정 해야 하는 속성 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 속성 버퍼에서 보내는 데이터의 바이트 수로 설정 해야 합니다. 연결이 설정 되 면이 버퍼의 데이터 전송 됩니다.  
  
 연결 지향 프로토콜을 사용 하 고 호출 하지 마세요 <xref:System.Net.Sockets.Socket.Bind%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 합니다.  
  
 호출 하기 전에 서비스 공급자가 로컬 네트워크 IP 주소 및 포트 번호를 연결 없는 프로토콜을 사용 하는 경우 할당 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 또는 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드.  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드가 throw <xref:System.NotSupportedException> 경우의 주소 패밀리를 <xref:System.Net.Sockets.Socket> 및 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 같은 주소 패밀리를 하지 않습니다.  
  
> [!NOTE]
>  표시 되 면를 <xref:System.Net.Sockets.SocketException> 사용 하 여이 메서드를 호출 하는 경우는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">인수가 잘못된 경우. 버퍼를 여러 개 지정하고 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 null이 아니면 이 예외가 발생합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 매개 변수가 null일 수 없으며, <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />도 null일 수 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" />이 수신 대기 중이거나 <paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우. 로컬 엔드포인트와 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 같은 주소 패밀리에 포함되지 않은 경우에도 이 예외가 발생합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자에게 요청된 작업을 수행할 권한이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />이 마지막으로 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 또는 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 작업을 수행할 때 원격 호스트에 연결되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>가장 최근 작업에서 <see cref="T:System.Net.Sockets.Socket" />이 원격 리소스에 연결되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Connected` 속성의 연결 상태를 가져옵니다는 <xref:System.Net.Sockets.Socket> 마지막 I/O 작업을 기준으로 합니다. 반환 될 때 `false`, <xref:System.Net.Sockets.Socket> 가 연결 된 적 또는 연결 되어 있지 않습니다.  
  
 값을 <xref:System.Net.Sockets.Socket.Connected%2A> 속성은 가장 최근 작업 연결의 상태를 반영 합니다. 연결의 현재 상태를 확인 해야 할 경우 비차단, 0 바이트 송신 호출을 확인 합니다. 호출이 성공적으로 반환 또는 WAEWOULDBLOCK 오류 코드 (10035)를 throw 하는 경우 소켓 아직 연결 되어 있습니다. 그렇지 않으면 소켓 연결 되어 있지 않습니다.  
  
 호출 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 는 사용자 데이터 그램 프로토콜 (UDP) socket 클래스에는 <xref:System.Net.Sockets.Socket.Connected%2A> 속성은 항상 반환 `true`하지만이 동작은 UDP의 고유한 연결 없는 특성을 변경 하지 않습니다.  
  
   
  
## Examples  
 원격 끝점을 확인 하려면 다음 코드 예제에서는 연결 된 <xref:System.Net.Sockets.Socket.Connected%2A> 속성인 연결의 현재 상태를 확인 합니다.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">현재 연결을 닫은 다음 이 소켓을 다시 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>소켓 연결을 닫고 소켓을 다시 사용할 수 있도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜을 사용 하는 경우에 소켓을 닫으려면이 메서드를 사용할 수 있습니다. 이 메서드 종료 집합과 연결 된 <xref:System.Net.Sockets.Socket.Connected%2A> 속성을 `false`입니다. 그러나 경우 `reuseSocket` 는 `true`, 소켓을 다시 사용할 수 있습니다.  
  
 호출 해야 모든 데이터가 전송 및 소켓 닫히기 전에 수신 되도록 <xref:System.Net.Sockets.Socket.Shutdown%2A> 호출 하기 전에 <xref:System.Net.Sockets.Socket.Disconnect%2A> 메서드.  
  
 호출 해야 하는 경우 <xref:System.Net.Sockets.Socket.Disconnect%2A> 첫 번째 호출 하지 않고 <xref:System.Net.Sockets.Socket.Shutdown%2A>를 설정할 수 있습니다 합니다 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> 옵션을 `false` 보내도록 위해 대기 중인 데이터를 확인 하는 0이 아닌 제한 시간 간격을 지정 합니다. <xref:System.Net.Sockets.Socket.Disconnect%2A> 그런 다음 데이터를 보낼 때까지 또는 지정된 된 제한 시간이 만료 될 때까지 차단 합니다. 설정 하는 경우 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 하 `false` 0 시간 제한 간격을 지정 하 고 <xref:System.Net.Sockets.Socket.Close%2A> 연결을 해제 하 고 나가는 큐에 대기 중인된 데이터를 자동으로 삭제 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동기 통신을 위한 소켓을 만들고 원격 호스트에 일부 데이터를 보냅니다. 그런 다음 호출 <xref:System.Net.Sockets.Socket.Shutdown%2A>송신을 중지 하 고 작업을 수신 하려면, 및 <xref:System.Net.Sockets.Socket.Disconnect%2A>, 소켓 연결을 닫습니다.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">이 메서드는 Windows 2000 이전 버전에서 사용해야 합니다. 그렇지 않으면 예외가 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>원격 엔드포인트와의 연결을 끊는 비동기 요청을 시작합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜을 사용 하는 경우 호출 된 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> 메서드 원격 끝점 으로부터의 연결을 끊도록을 요청 합니다. 설정 하는 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> 하 `true` 에 `e` 매개 변수를 소켓을 다시 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 매개 변수가 null인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 사용을 마치면 <xref:System.Net.Sockets.Socket>를 호출합니다. `Dispose` 메서드를 사용하면 <xref:System.Net.Sockets.Socket>를 사용할 수 없게 됩니다. 호출한 후 `Dispose`에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Net.Sockets.Socket> 가비지 수집기에서 메모리를 회수할 수 있도록 하는 <xref:System.Net.Sockets.Socket> 차지한 합니다.  
  
 자세한 내용은 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 하 고 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
> [!NOTE]
>  `Dispose`에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.Net.Sockets.Socket>를 호출하십시오. 이렇게 하지 않으면 가비지 컬렉션이 <xref:System.Net.Sockets.Socket> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />, 관리되지 않는 리소스만 해제하려면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 삭제할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 `Dispose()` 메서드 및 <xref:System.Object.Finalize%2A> 메서드. `Dispose()` 보호 된 호출 `Dispose(Boolean)` 메서드를 `disposing` 매개 변수 설정 `true`합니다. <xref:System.Object.Finalize%2A> 호출 `Dispose` 사용 하 여 `disposing` 로 `false`합니다.  
  
 `disposing` 매개 변수가 `true`인 경우 이 메서드는 이 <xref:System.Net.Sockets.Socket>에서 참조하는 관리 개체가 보유하고 있는 리소스를 모두 해제합니다. 이 메서드는 참조되는 각 개체의 `Dispose()` 메서드를 호출합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />는 다른 개체에서 여러 번 호출할 수 있습니다. <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />를 재정의할 때 이전 <see langword="Dispose" /> 호출에서 삭제된 개체를 참조하지 않도록 주의하십시오. 구현 하는 방법에 대 한 자세한 내용은 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />를 참조 하세요 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
에 대 한 자세한 내용은 <see langword="Dispose" /> 및 <see cref="M:System.Object.Finalize" />를 참조 하십시오 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 및 [Finalize 메서드 재정의](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" />에서 IP(인터넷 프로토콜) 데이터그램의 조각화를 허용하는지 여부를 나타내는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />에서 데이터그램 조각화를 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데이터 그램 크기는 최대 전송 단위 (MTU) 전송 매체의 초과 하는 경우 조각화가 필요 합니다. 송신 호스트 (모든 인터넷 프로토콜 버전) 또는 중간 라우터 (인터넷 프로토콜 버전 4만) 하 여 데이터 그램을 조각화 될 수 있습니다. 데이터 그램을 조각화 수 해야 하는 경우 및 <xref:System.Net.Sockets.Socket.DontFragment%2A> 옵션 설정, 데이터 그램 무시 되 고 데이터 그램의 보낸 사람에 게 제어 메시지 ICMP (Internet Protocol) 오류 메시지가 보내집니다.  
  
 프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.DontFragment%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 패밀리의 소켓이 아닌 소켓에 대해 이 속성을 설정한 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />이 IPv4 및 IPv6 둘 다에 사용되는 이중 모드 소켓인지 여부를 지정하는 <see cref="T:System.Boolean" /> 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />이 이중 모드 소켓이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">소켓 참조의 복제본을 만드는 대상 프로세스의 ID입니다.</param>
        <summary>대상 프로세스에 대한 소켓 참조를 복제하고 이 프로세스의 소켓을 닫습니다.</summary>
        <returns>대상 프로세스에 전달될 소켓 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대상 프로세스를 사용할지 <xref:System.Net.Sockets.Socket.%23ctor%2A> 중복 소켓 인스턴스를 만들려고 합니다.  
  
 호출 하는 경우는 <xref:System.Net.Sockets.Socket.%23ctor%2A> 여러 번 사용 하 여 각 호출에 대 한 인수로 동일한 바이트 배열 생성자를 만들려는 관리 되는 여러 <xref:System.Net.Sockets.Socket> 인스턴스가 동일한 기본 소켓을 사용 합니다. 이 방법은 좋습니다.  
  
 소켓을 생성 하는 프로세스는 비동기 메서드를 사용 하는 경우 (<xref:System.Net.Sockets.Socket.BeginReceive%2A> 또는 <xref:System.Net.Sockets.Socket.BeginSend%2A>), 먼저 설정 해야 하는 프로세스는 <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> 속성을 소켓을 않을만들기프로세스의완료포트에바인딩된고,그렇지않으면true<xref:System.ArgumentNullException> 대상 프로세스에 대해 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" />가 잘못된 프로세스 ID인 경우 
또는 
소켓 참조를 복제하지 못한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" />이 브로드캐스트 패킷을 보내거나 받을 수 있는지 여부를 나타내는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />이 브로드캐스트 패킷을 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 브로드캐스트 특정 서브넷으로 제한 되며 사용자 데이터 그램 프로토콜 (UDP.)를 사용 해야 합니다. 인터넷 프로토콜 버전 4 브로드캐스트할 수 있습니다 로컬 서브넷에 패킷을 255.255.255.255;로 전송 하 여 또는 네트워크의 호스트 부분에 설정 된 모든 비트를 사용 하 여 IP (인터넷 프로토콜) 주소 부분은 지정 된 브로드캐스트 주소로 사용할 수 있습니다. 예를 들어 IP 주소는 192.168.1.40 클래스 C 주소를 네트워크 마스크 255.255.255.0-을 사용 하 여 네트워크 부분은 처음 세 옥텟과 호스트 부분은 마지막 8 진수에 리디렉션된 브로드캐스트 주소 192.168.1.255 됩니다.  
  
 프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">데이터그램 소켓이 아닌 소켓에 이 옵션을 설정한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>들어오는 연결 시도를 비동기적으로 받아들입니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송된 바이트가 들어 있는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보와 모든 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</param>
        <summary>들어오는 연결 시도를 비동기적으로 받아들이고 원격 호스트 통신을 처리할 새 <see cref="T:System.Net.Sockets.Socket" /> 개체를 만듭니다. 이 메서드는 전송된 초기 데이터가 들어 있는 버퍼를 반환합니다.</summary>
        <returns>원격 호스트와의 통신을 처리할 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginAccept%2A>합니다. 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A>에서 호출 되는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드를 별도 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 반환 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 `asyncResult` 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 성공적으로 연결 시도 완료 하는 방법입니다. `buffer` 호출에서 받은 데이터가이 오버 로드의 매개 변수 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 및 `bytesTransferred` 매개 변수는 호출에서 전송 된 바이트 수를 포함 합니다.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드 연결이 보류 중이면 때까지 차단 들어오는 연결 큐에 있습니다. 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드는 들어오는 연결을 허용 하 고 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트에서 데이터를 받고 데이터를 보내는 데 사용할 수 있습니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 연결 소켓을 만들고 초기 10 바이트의 데이터를 수락 합니다. 콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndAccept%2A> 비동기 요청을 끝냅니다. 데이터 및 전송 된 바이트 수가 반환 됩니다 합니다 `buffer` 및 `bytesTransferred` 이 메서드의 매개 변수를 콘솔에 표시 됩니다.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 비어 있는 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />를 호출했지만 <paramref name="asyncResult" />가 만들어지지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 메서드가 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" />에 액세스하려고 시도하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">모든 사용자 정의 데이터뿐만 아니라 이 비동기 작업에 대한 상태 정보도 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="result">모든 사용자 정의 데이터뿐만 아니라 이 비동기 작업에 대한 상태 정보도 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <summary>들어오는 연결 시도를 비동기적으로 받아들이고 원격 호스트 통신을 처리할 새로운 <see cref="T:System.Net.Sockets.Socket" />을 만듭니다.</summary>
        <returns>원격 호스트와의 통신을 처리할 <see cref="T:System.Net.Sockets.Socket" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginAccept%2A>합니다. 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드를 별도 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 반환 합니다. 사용할 수 있어야 합니다 `asyncResult` 매개 변수에서 반환 된는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 `asyncResult` 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 성공적으로 연결 시도 완료 하는 방법입니다.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드 연결이 보류 중이면 때까지 차단 들어오는 연결 큐에 있습니다. 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드는 들어오는 연결을 허용 하 고 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트에서 데이터를 받고 데이터를 보내는 데 사용할 수 있습니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 요청을 종료 하 고 새 <xref:System.Net.Sockets.Socket> 들어오는 연결 요청을 수락 하도록 합니다. 소켓을 사용 하 여 비동기 통신을 보여 주는 전체 예제를 참조 하세요 [소켓 코드 예제에서는](~/docs/framework/network-programming/socket-code-examples.md)합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />를 호출했지만 <paramref name="asyncResult" />가 만들어지지 않은 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 자세한 내용은 설명 부분을 참조하세요.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 메서드가 이미 호출된 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송된 바이트가 들어 있는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="bytesTransferred">전송된 바이트 수 입니다.</param>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보와 모든 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</param>
        <summary>들어오는 연결 시도를 비동기적으로 받아들이고 원격 호스트 통신을 처리할 새 <see cref="T:System.Net.Sockets.Socket" /> 개체를 만듭니다. 이 메서드는 전송된 초기 데이터와 바이트 수가 들어 있는 버퍼를 반환합니다.</summary>
        <returns>원격 호스트와의 통신을 처리할 <see cref="T:System.Net.Sockets.Socket" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginAccept%2A>합니다. 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginAccept%2A>에서 호출 되는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드를 별도 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드 반환 합니다. 사용할 수 있어야 합니다 `asyncResult` 매개 변수에서 반환 된는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 메서드.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 `asyncResult` 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndAccept%2A> 성공적으로 연결 시도 완료 하는 방법입니다. `buffer` 호출에서 받은 데이터가이 오버 로드의 매개 변수 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 및 `bytesTransferred` 매개 변수는 호출에서 전송 된 바이트 수를 포함 합니다.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드 연결이 보류 중이면 때까지 차단 들어오는 연결 큐에 있습니다. 합니다 <xref:System.Net.Sockets.Socket.EndAccept%2A> 메서드는 들어오는 연결을 허용 하 고 반환 된 새 <xref:System.Net.Sockets.Socket> 원격 호스트에서 데이터를 받고 데이터를 보내는 데 사용할 수 있습니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 연결 소켓을 만들고 초기 10 바이트의 데이터를 수락 합니다. 콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndAccept%2A> 비동기 요청을 끝냅니다. 데이터 및 전송 된 바이트 수가 반환 됩니다 합니다 `buffer` 및 `bytesTransferred` 이 메서드의 매개 변수를 콘솔에 표시 됩니다.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 비어 있는 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />를 호출했지만 <paramref name="asyncResult" />가 만들어지지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 메서드가 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" />에 액세스하려고 시도하는 동안 오류가 발생한 경우.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="result">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <summary>보류 중인 비동기 연결 요청을 끝냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 시작 하는 비동기 원격 호스트 연결 요청을 완료 하는 차단 메서드를 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult> 가져오려면 매개 변수를 <xref:System.Net.Sockets.Socket> 에서 연결 시도가 수행 되는. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndConnect%2A> 성공적으로 연결 시도 완료 하는 방법입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 연결 시도 종료합니다. 소켓을 사용 하 여 비동기 통신을 보여 주는 전체 예제를 참조 하세요 [소켓 코드 예제에서는](~/docs/framework/network-programming/socket-code-examples.md)합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />가 비동기 연결을 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보와 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</param>
        <summary>보류 중인 비동기 연결 끊기 요청을 끝냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 호출을 완료 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>합니다. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 메서드는 연결 끊기 완료 될 때까지 차단 합니다. 비동기 작업에 대 한 자세한 내용은 MSDN 라이브러리의 비동기 프로그래밍 개요 항목을 참조 하세요.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 통신을 위한 소켓을 만들고 원격 호스트에 일부 데이터를 보냅니다. 데이터를 보낼 때 <xref:System.Net.Sockets.Socket.Shutdown%2A> 송신을 중지 하 고 작업을 수신 하기 위해 호출 됩니다. 그런 다음 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 연결 끊기 요청을 시작 하기 위해 호출 됩니다. 콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 비동기 요청을 끝냅니다. 요청이 완료 되 면는 <xref:System.Net.Sockets.Socket.Connected%2A> 속성 소켓 연결이 있는지 여부를 테스트 하기 위해 쿼리 됩니다.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />가 비동기 연결을 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.Net.WebException">연결 끊기 요청 시간이 초과된 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>보류 중인 비동기 읽기를 끝냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="result">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <summary>보류 중인 비동기 읽기를 끝냅니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 에서 시작한 비동기 읽기 작업을 완료 하는 메서드를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 에 전달 된 상태 개체를 가져오는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드. 수신 추출 <xref:System.Net.Sockets.Socket> 에서이 상태 개체입니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 읽기 작업을 완료 하 고 읽은 바이트 수를 반환 하는 메서드.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndReceive%2A> 는 들어오는 네트워크 버퍼에 사용 가능한 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는에 지정 된 바이트 수를 최대 수 만큼의 데이터를 읽을 합니다 `size` 의 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 받은 데이터를 가져오려면 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult>, 결과 상태 개체에 포함 된 버퍼를 추출 합니다.  
  
 취소 하는 보류 중인 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 호출 합니다 <xref:System.Net.Sockets.Socket.Close%2A> 메서드.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 보류 중인 비동기 읽기를 끝냅니다. 소켓을 사용 하 여 비동기 통신을 보여 주는 전체 예제를 참조 하세요 [소켓 코드 예제에서는](~/docs/framework/network-programming/socket-code-examples.md)합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />가 비동기 읽기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <summary>보류 중인 비동기 읽기를 끝냅니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.EndReceive%2A> 에서 시작한 비동기 읽기 작업을 완료 하는 메서드를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceive%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 에 전달 된 상태 개체를 가져오는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드. 수신 추출 <xref:System.Net.Sockets.Socket> 에서이 상태 개체입니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 읽기 작업을 완료 하 고 읽은 바이트 수를 반환 하는 메서드.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndReceive%2A> 는 들어오는 네트워크 버퍼에 사용 가능한 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드는에 지정 된 바이트 수를 최대 수 만큼의 데이터를 읽을 합니다 `size` 의 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 메서드. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.EndReceive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 받은 데이터를 가져오려면 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult>, 결과 상태 개체에 포함 된 버퍼를 추출 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />가 비동기 읽기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="result">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="endPoint">소스 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="end_point">소스 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>특정 엔드포인트에서 보류 중인 비동기 읽기를 끝냅니다.</summary>
        <returns>성공할 경우 받은 바이트 수입니다. 실패하면 0을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 에서 시작한 비동기 읽기 작업을 완료 하는 메서드를 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 에 전달 된 상태 개체를 가져오는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드. 수신 추출 <xref:System.Net.Sockets.Socket> 에서이 상태 개체입니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 읽기 작업을 완료 하 고 읽은 바이트 수를 반환 하는 메서드.  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 는 들어오는 네트워크 버퍼에 사용 가능한 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드는에 지정 된 바이트 수를 최대 수 만큼의 데이터를 읽을 합니다 `size` 의 매개 변수는 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 메서드. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다. 받은 데이터를 가져오려면 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드의 <xref:System.IAsyncResult> 개체를 결과 상태 개체에 포함 된 버퍼를 추출 합니다. 원래 호스트를 식별 하려면 추출 합니다 <xref:System.Net.EndPoint> 로 캐스팅 하 고는 <xref:System.Net.IPEndPoint>합니다. 사용 된 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> IP 주소를 획득 하는 방법 및 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 포트 번호를 가져올 방법.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 특정에서 보류 중인 비동기 읽기를 끝냅니다 <xref:System.Net.EndPoint>합니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />가 비동기 읽기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="socketFlags">받은 패킷에 대한 <see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="endPoint">소스 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="ipPacketInformation">받은 패킷의 <see cref="T:System.Net.IPAddress" /> 및 인터페이스입니다.</param>
        <summary>특정 엔드포인트에서 보류 중인 비동기 읽기를 끝냅니다. 또한 이 메서드는 패킷에 대해 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />이 제공하는 것보다 많은 정보를 제공합니다.</summary>
        <returns>성공할 경우 받은 바이트 수입니다. 실패하면 0을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작업이 완료 되지 않은 경우이 메서드는 완료 될 때까지 차단 됩니다.  
  
 이 작업을 동기적으로 수행 하려면 사용 된 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드.  
  
 검사 `ipPacketInformation` 경우 알아야 할 유니캐스트, 멀티 캐스트 또는 브로드캐스트 주소를 사용 하 여 데이터 그램을 보냈습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="endPoint" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />가 비동기 읽기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>보류 중인 비동기 보내기를 끝냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="result">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <summary>보류 중인 비동기 보내기를 끝냅니다.</summary>
        <returns>성공적이면 <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수이고, 그렇지 않으면 잘못된 <see cref="T:System.Net.Sockets.Socket" /> 오류입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSend%2A>합니다.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSend%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSend%2A> 성공적으로 송신 작업을 완료 하 고 전송 된 바이트 수를 반환 하는 메서드.  
  
 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 보낸 버퍼의 일부 때까지 차단 됩니다. 반환 된 값 <xref:System.Net.Sockets.Socket.EndSend%2A> 버퍼 없음을 나타냅니다 호출 완전히 전송 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드가 다시 보내지 않은 데이터를 저장할 버퍼를 수정 합니다.  
  
 보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 보류 중인 비동기 보내기를 끝냅니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />가 비동기 보내기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <summary>보류 중인 비동기 보내기를 끝냅니다.</summary>
        <returns>성공적이면 <see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수이고, 그렇지 않으면 잘못된 <see cref="T:System.Net.Sockets.Socket" /> 오류입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSend%2A>합니다.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSend%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSend%2A> 성공적으로 송신 작업을 완료 하 고 전송 된 바이트 수를 반환 하는 메서드.  
  
 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSend%2A> 보낸 버퍼의 일부 때까지 차단 됩니다. 반환 된 값 <xref:System.Net.Sockets.Socket.EndSend%2A> 버퍼 없음을 나타냅니다 호출 완전히 전송 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드가 다시 보내지 않은 데이터를 저장할 버퍼를 수정 합니다.  
  
 보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSend%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  지정 된 스레드에 의해 시작 되는 모든 I/O는 종료 되 면 취소 됩니다. 스레드가 종료 된 작업이 완료 되기 전에 보류 중인 비동기 작업이 실패할 수 있습니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />가 비동기 보내기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보를 저장하는 <see cref="T:System.IAsyncResult" /> 개체입니다.</param>
        <summary>보류 중인 비동기 파일 보내기를 끝냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>합니다.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 반환 합니다. 콜백 메서드를 <xref:System.IAsyncResult> 에서 반환 된 개체는 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 보내기 작업을 완료 하는 방법입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 데이터 그램 전송 될 때까지 차단 합니다. 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전체 파일이 전송 될 때까지 차단 합니다. 보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 비동기 통신에 대 한 소켓 연결 및 보내기 시작 파일 "text.txt" 비동기적으로 원격 호스트에 만듭니다. 콜백 대리자 호출 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 전송을 완료 합니다.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows NT가 필요합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 비어 있는 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />이 비동기 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />을 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <param name="result">이 비동기 작업에 대한 상태 정보 및 사용자 정의 데이터를 저장하는 <see cref="T:System.IAsyncResult" />입니다.</param>
        <summary>특정 위치로의 보류 중인 비동기 보내기를 끝냅니다.</summary>
        <returns>성공적이면 보낸 바이트 수이고, 그렇지 않으면 잘못된 <see cref="T:System.Net.Sockets.Socket" /> 오류입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 시작 하는 비동기 송신 작업을 완료 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>합니다.  
  
 호출 하기 전에 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>를 구현 하는 콜백 메서드를 만들어야 합니다 <xref:System.AsyncCallback> 위임 합니다. 이 콜백 메서드는 별도의 스레드에서 실행 하 고 후 시스템에 의해 호출 됩니다 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 반환 합니다. 콜백 메서드를 사용 해야 합니다 <xref:System.IAsyncResult> 반환한를 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드에 매개 변수로 합니다.  
  
 콜백 메서드 내에서 호출 합니다 <xref:System.IAsyncResult.AsyncState%2A> 메서드를 <xref:System.IAsyncResult> 보내는 가져오려면 매개 변수 <xref:System.Net.Sockets.Socket>합니다. 구한 후 합니다 <xref:System.Net.Sockets.Socket>를 호출할 수 있습니다는 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 성공적으로 송신 작업을 완료 하 고 전송 된 바이트 수를 반환 하는 메서드.  
  
 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 바이트 수가 요청 된 전송 될 때까지 차단 됩니다. 보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 특정 위치에는 비동기 보내기를 끝냅니다.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 메서드를 호출했지만 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />가 비동기 보내기를 위해 이미 호출된 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" />이 하나의 포트에 하나의 프로세스만 바인딩하는 것을 허용하는지 여부를 지정하는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />이 특정 포트에 하나의 소켓만 바인딩하는 것을 허용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" /> Windows Server 2003 및 Windows XP 서비스 팩 2 및 <see langword="false" /> 다른 모든 버전.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 됩니다 `false`, 여러 소켓을 사용할 수는 <xref:System.Net.Sockets.Socket.Bind%2A> 특정 포트에 바인딩할 메서드; 있지만 하나의 소켓의 포트에 전송 되는 네트워크 트래픽에서 작업을 수행할 수 있습니다. 둘 이상의 소켓을 사용 하려고 하는 경우는 <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 구체적인 IP 주소를 사용 하 여 하나를 해당 포트로 전송 되는 네트워크 트래픽을 처리한 다음 특정 포트에 바인딩할 메서드.  
  
 경우 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 됩니다 `true`를 처음 사용 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> IP (인터넷 프로토콜) 주소에 관계 없이 특정 포트에 바인딩하지 하려고 하는 메서드가 성공;의 모든 후속 사용를 <xref:System.Net.Sockets.Socket.Bind%2A> 해당 포트에 바인딩하지 하려고 하는 방법에는 원래 바인딩된 소켓 소멸 될 때까지 실패 합니다.  
  
 이 속성 전에 설정 해야 <xref:System.Net.Sockets.Socket.Bind%2A> 이 고 그렇지 않으면 호출을 <xref:System.InvalidOperationException> throw 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />가 이 <see cref="T:System.Net.Sockets.Socket" />에 대해 호출된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 클래스에서 사용한 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 종료 자가 호출 클래스를 <xref:System.Net.Sockets.Socket.Close%2A> 닫는 메서드를를 <xref:System.Net.Sockets.Socket> 와 연결 된 리소스를 해제 하 고는 <xref:System.Net.Sockets.Socket>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 인스턴스에 대한 해시 값을 반환합니다.</summary>
        <returns>정수 해시 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode 메서드는이 인스턴스의 해시 코드를 반환합니다. 이 값은 해시 테이블에서 키로 사용할 수 있습니다.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 옵션의 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <summary>개체로 나타내는 지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션 값을 반환합니다.</summary>
        <returns>옵션 값을 나타내는 개체입니다. <paramref name="optionName" /> 매개 변수가 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />로 설정되면 반환 값은 <see cref="T:System.Net.Sockets.LingerOption" /> 클래스의 인스턴스입니다. <paramref name="optionName" />이 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" />이나 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />으로 설정되면 반환 값은 <see cref="T:System.Net.Sockets.MulticastOption" /> 클래스의 인스턴스입니다. <paramref name="optionName" />이 다른 값이면 반환 값은 정수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다. 이 오버 로드를 사용 하 여 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, 및 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> 옵션입니다. 에 대 한 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger> 옵션을 사용 하 여 <xref:System.Net.Sockets.Socket> 에 대 한는 `optionLevel` 매개 변수입니다. 에 대 한 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 하 고 <xref:System.Net.Sockets.SocketOptionName.DropMembership>를 사용 하 여 <xref:System.Net.Sockets.SocketOptionLevel.IP>입니다. 위에 나열 된 옵션의 값을 설정, 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 검색 된 <xref:System.Net.Sockets.LingerOption> 및 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값을 콘솔에 표시 합니다.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.  
  
또는 
 <paramref name="optionName" />이 지원되지 않는 값인 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />로 설정된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <param name="optionValue">해당 옵션 설정을 받을 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <summary>바이트 배열로 나타내는 지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션 설정을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다. 이 메서드가 성공적으로 완료 되는 배열에서 지정 된 `optionValue` 매개 변수는 지정 된 값이 포함 <xref:System.Net.Sockets.Socket> 옵션.  
  
 때의 길이 `optionValue` 배열이 지정된 된 값을 저장 하는 데 필요한 바이트의 수보다 작은 <xref:System.Net.Sockets.Socket> 옵션을 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다. 정수 또는 부울 값으로 표현 되는 모든 소켓에 대 한이 오버 로드를 사용 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 검색 된 <xref:System.Net.Sockets.LingerOption> 및 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값을 콘솔에 표시 합니다.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.  
  
또는 
.NET Compact Framework 응용 프로그램에서 Windows CE 기본 버퍼 공간을 32768바이트로 설정한 경우. <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />을 호출하여 소켓당 버퍼 공간을 변경할 수 있습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <param name="optionLength">예상되는 반환 값의 길이(바이트)입니다.</param>
        <summary>배열의 지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션 값을 반환합니다.</summary>
        <returns>소켓 옵션의 값을 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` 매개 변수는 반환 된 바이트 배열의 최대 크기를 설정 합니다. 옵션 값을 바이트에 필요한 경우 배열이 포함 됩니다 바이트 수입니다. 옵션 값을 더 많은 바이트를 요구 하는 경우 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 정수 또는 부울 값으로 표현 되는 모든 소켓에 대 한이 오버 로드를 사용 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 검색 된 <xref:System.Net.Sockets.LingerOption> 및 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값을 콘솔에 표시 합니다.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.  
  
또는 
.NET Compact Framework 응용 프로그램에서 Windows CE 기본 버퍼 공간을 32768바이트로 설정한 경우. <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />을 호출하여 소켓당 버퍼 공간을 변경할 수 있습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />에 대한 운영 체제 핸들을 가져옵니다.</summary>
        <value><see cref="T:System.IntPtr" />에 대한 운영 체제 핸들을 나타내는 <see cref="T:System.Net.Sockets.Socket" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 하위 수준 운영 모드를 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">수행할 작업의 컨트롤 코드를 지정하는 <see cref="T:System.Int32" /> 값입니다.</param>
        <param name="optionInValue">작업에 필요한 입력 데이터가 들어 있는 <see cref="T:System.Byte" /> 배열입니다.</param>
        <param name="optionOutValue">작업에서 반환된 출력 데이터가 들어 있는 <see cref="T:System.Byte" /> 배열입니다.</param>
        <summary>숫자 컨트롤 코드를 사용하여 <see cref="T:System.Net.Sockets.Socket" />의 하위 수준 운영 모드를 설정합니다.</summary>
        <returns><paramref name="optionOutValue" /> 매개 변수의 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.IOControl%2A> 메서드는 운영 체제에 대 한 하위 수준 액세스를 제공 <xref:System.Net.Sockets.Socket> 의 현재 인스턴스의 내부는 <xref:System.Net.Sockets.Socket> 클래스입니다. 자세한 내용은 참조는 [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) 설명서.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 FIONREAD 및 사용할 수 있는 속성의 결과 비교 합니다.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> 속성을 사용하지 않고 블로킹 모드를 변경하려고 한 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">수행할 작업의 컨트롤 코드를 지정하는 <see cref="T:System.Net.Sockets.IOControlCode" /> 값입니다.</param>
        <param name="optionInValue">해당 작업에 필요한 입력 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="optionOutValue">해당 작업에서 반환된 출력 데이터를 포함하는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 열거형으로 컨트롤 코드를 지정하여 <see cref="T:System.Net.Sockets.IOControlCode" />의 하위 수준 운영 모드를 설정합니다.</summary>
        <returns><paramref name="optionOutValue" /> 매개 변수의 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 운영 체제에 대 한 하위 수준 액세스를 제공 <xref:System.Net.Sockets.Socket> 의 현재 인스턴스의 내부는 <xref:System.Net.Sockets.Socket> 클래스입니다. 자세한 내용은 참조는 [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) 설명서.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출의 결과 비교 <xref:System.Net.Sockets.Socket.IOControl%2A> 사용 하 여 <xref:System.Net.Sockets.IOControlCode.DataToRead> 하며 <xref:System.Net.Sockets.Socket.Available%2A> 속성입니다.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> 속성을 사용하지 않고 블로킹 모드를 변경하려고 한 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />이 특정 로컬 포트에 바인딩되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />이 로컬 포트에 바인딩되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 명시적으로 바인딩되어 있는 경우 소켓 로컬 포트에 바인딩된 것으로 간주 되는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 같은 멤버를 호출 하 여 암시적으로 바인딩된 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, 또는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, 임시 로컬 포트 (무료 보다 큰 포트를 사용 하는 1024, 운영 체제에서 선택 합니다.) 서버 사용을 <xref:System.Net.Sockets.Socket.Bind%2A> 클라이언트에 연결할 수 있도록 잘 알려진 포트에 바인딩해야 하는 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.IsBound%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>보류 중인 데이터를 모두 보내려고 할 때 <see cref="T:System.Net.Sockets.Socket" />에서 소켓 닫기를 지연할지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>소켓을 닫는 동안 링거하는 방법을 지정하는 <see cref="T:System.Net.Sockets.LingerOption" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성이 변경 되는 방법은 <xref:System.Net.Sockets.Socket.Close%2A> 메서드 동작 합니다. 집합 Winsock에서 연결을 다시 설정할는 조건을 수정 하는 경우이 속성입니다. 연결 다시 설정은 IP 프로토콜 동작에 따라 발생할 수 있습니다.  
  
 이 속성을 호출한 후에 연결 지향 연결이 열린 채로 시간의 길이 제어 <xref:System.Net.Sockets.Socket.Close%2A> 데이터 전송 대기 상태인 경우입니다.  
  
 피어에 데이터를 보내는 메서드를 호출 하면이 데이터는 나가는 네트워크 버퍼에 배치 됩니다. 이 데이터는 하기 전에 원격 호스트에 전송 되도록 하려면이 속성을 사용할 수는 <xref:System.Net.Sockets.TcpClient.Close%2A> 메서드가 연결을 삭제 합니다.  
  
 활성화 하려면 만들기를 <xref:System.Net.Sockets.LingerOption> 원하는 값이 포함 된 인스턴스 및 설정의 <xref:System.Net.Sockets.Socket.LingerState%2A> 이 인스턴스에 대 한 속성입니다.  
  
 동작을 설명 하는 다음 표에서 <xref:System.Net.Sockets.Socket.Close%2A> 의 가능한 값에 대 한 메서드를 <xref:System.Net.Sockets.LingerOption.Enabled%2A> 속성 및 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성에 저장 됩니다는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성입니다.  
  
|LingerState.Enabled|LingerState.LingerTime|동작|  
|-------------------------|----------------------------|--------------|  
|`false` (사용 안 함), 기본값|제한 시간이 적용 되지 않습니다 (기본값).|기본 IP 프로토콜 제한 시간이 만료 될 때까지 보류 중인 데이터 보내려고 시도 합니다.|  
|`true` (사용)|0이 아닌 제한 시간|지정된 된 제한 시간이 만료 되 면 시도가 실패 하면 다음 Winsock 연결을 다시 설정 될 때까지 보류 중인 데이터 보내려고 시도 합니다.|  
|`true` (사용)|0 시간 제한입니다.|보류 중인 데이터를 삭제합니다. Winsock 소켓 연결 지향 (예: TCP)에 대 한 연결을 다시 설정 합니다.|  
  
 IP 스택이 연결의 왕복 시간을 기준으로 사용 하려면 기본 IP 프로토콜 제한 시간을 계산 합니다. 대부분의 경우에서 시간 제한이 스택에 의해 계산 응용 프로그램에 의해 정의 된 보다 상대적입니다. 소켓에 대 한 기본 동작은이 때는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성이 설정 되지 않았습니다.  
  
 경우는 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 속성에 저장 됩니다는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성의 기본 IP 프로토콜 제한 보다 큰, 기본 IP 프로토콜 제한 시간이 적용 되 고 재정의 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.LingerState%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">보류 중인 연결 큐의 최대 길이입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" />을 수신 상태로 둡니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 연결 지향 하면 <xref:System.Net.Sockets.Socket> 들어오는 연결 시도를 수신 대기 하도록 합니다. `backlog` 매개 변수는 들어오는 연결 수락 대기할 수 있는 횟수를 지정 합니다. 지정할 수 있습니다 하는 연결의 최대 수를 확인 하려면 검색을 <xref:System.Net.Sockets.SocketOptionName.MaxConnections> 값입니다. <xref:System.Net.Sockets.Socket.Listen%2A> 차단 하지 않습니다.  
  
 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다. 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 또는 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 큐에서 연결을 허용 하도록 합니다.  
  
> [!NOTE]
>  호출 해야 합니다는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.Listen%2A>, 또는 <xref:System.Net.Sockets.Socket.Listen%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  백로그 매개 변수는 운영 체제에 따라 다른 값으로 제한 됩니다. 더 높은 값을 지정할 수 있지만 백로그 제한 됩니다 운영 체제에 따라 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket> 들어오는 연결을 수신 대기 합니다.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로컬 엔드포인트를 가져옵니다.</summary>
        <value><see cref="T:System.Net.EndPoint" />이 통신하는 데 사용하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 속성을 가져옵니다는 <xref:System.Net.EndPoint> 로컬 IP 주소 및 포트 번호를 포함 하는 프로그램 <xref:System.Net.Sockets.Socket> 바인딩됩니다. 이 캐스팅 해야 <xref:System.Net.EndPoint> 에 <xref:System.Net.IPEndPoint> 모든 정보를 검색 하기 전에 합니다. 호출할 수 있습니다 합니다 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 로컬 검색 하는 방법 <xref:System.Net.IPAddress>, 및 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 로컬 포트 번호를 검색 하는 방법입니다.  
  
 합니다 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 에 대 한 호출을 수행한 후에 일반적으로 속성을 설정 합니다 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 시스템에서 소켓의 로컬 IP 주소 및 포트 번호 할당을 허용 하는 경우는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 속성이 첫 번째 I/O 작업 후 설정 됩니다. 연결 지향 프로토콜에 대 한 첫 번째 I/O 작업에 대 한 호출 수를 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜에 대 한 첫 번째 I/O 작업은 송신 중 하나일 또는 호출을 수신 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제를 검색 하 고 로컬과 원격 끝점을 표시 합니다.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>나가는 멀티캐스트 패킷을 보내는 응용 프로그램에 전달할지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />이 나가는 멀티캐스트 패킷을 받으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 멀티 캐스트는 인터넷에서 다 대 다 통신을 위한 확장 가능한 메서드입니다. 멀티 캐스트 주소로; 프로세스 구독 그런 다음 구독된 프로세스에서 보낸 모든 패킷이 멀티 캐스트 주소를 구독 하는 다른 모든 프로세스에서 수신 됩니다.  
  
 프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> 스트림에서 Nagle 알고리즘을 사용하는지 여부를 나타내는 <see cref="T:System.Net.Sockets.Socket" /> 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />에서 Nagle 알고리즘을 사용하면 <see langword="false" />이고, 그렇지 않으면 <see langword="true" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 알고리즘은 작은 패킷 버퍼 및 다음 결합 하 고 상황에 따라 하나의 패킷으로 보낼은 소켓에서 네트워크 트래픽을 줄이기 위해 설계 되었습니다. TCP 패킷 헤더와 전송 되는 데이터의 40 바이트로 이루어져 있습니다. TCP를 사용 하 여 작은 데이터 패킷을 전송 될 때 TCP 헤더에서 발생 하는 오버 헤드는 네트워크 트래픽의 주요 부분이 될 수 있습니다. 과도 하 게 로드 네트워크에서이 오버 헤드로 정체 인해 과도 하 게 전파 시간 뿐만 아니라 데이터 그램 손실된 하 고, 재전송 될 수 있습니다. Nagle 알고리즘은 보내는 새 TCP segmentswhen 새 연결에서 이전 데이터가 남아 승인 되지 않은 경우 사용자 로부터 도착 나가는 데이터입니다.  
  
 대부분의 네트워크 응용 프로그램에서 Nagle 알고리즘을 사용 해야 합니다.  
  
 사용자 데이터 그램 프로토콜 (UDP) 소켓에서이 속성을 설정 하는 아무런 효과가 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.NoDelay%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" />에 액세스하려고 시도하는 동안 오류가 발생한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내부 운영 체제 및 네트워크 어댑터에서 IPv4(인터넷 프로토콜 버전 4)를 지원하는지 여부를 나타냅니다.</summary>
        <value>운영 체제 및 네트워크 어댑터에서 IPv4 프로토콜을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>내부 운영 체제 및 네트워크 어댑터에서 IPv6(인터넷 프로토콜 버전 6)을 지원하는지 여부를 나타냅니다.</summary>
        <value>운영 체제 및 네트워크 어댑터에서 IPv6 프로토콜을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="microSeconds">응답을 기다릴 시간(마이크로초)입니다.</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 상태를 결정합니다.</summary>
        <returns><paramref name="mode" /> 매개 변수에 전달된 폴링 모드 값에 따른 <see cref="T:System.Net.Sockets.Socket" />의 상태입니다.  
  
 <list type="table"><listheader><term> 모드 
 </term><description> 반환 값 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />이 호출되었고 연결이 보류 중이면 <see langword="true" />를 반환합니다. 
또는 
 데이터를 읽을 수 있으면 <see langword="true" />를 반환합니다. 
또는 
 연결을 닫았거나, 다시 설정하였거나, 종료하였으면 <see langword="true" />를 반환합니다. 
그렇지 않으면 <see langword="false" />를 반환합니다.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />가 처리 중이고 연결에 성공했으면 <see langword="true" />를 반환합니다. 
또는 
 데이터를 보낼 수 있으면 <see langword="true" />를 반환합니다. 
그렇지 않으면 <see langword="false" />를 반환합니다.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>차단되지 않는 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />가 처리 중이고 연결에 실패했으면 <see langword="true" />를 반환합니다. 
또는 
 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" />이 설정되어 있지 않고 out-of-band 데이터를 사용할 수 있으면 <see langword="true" />를 반환합니다. 
그렇지 않으면 <see langword="false" />를 반환합니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.Poll%2A> 메서드는 상태를 확인 합니다 <xref:System.Net.Sockets.Socket>합니다. 지정 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> 에 대 한는 `selectMode` 매개 변수에 지정 된 경우는 <xref:System.Net.Sockets.Socket> 읽을 수 있습니다. 지정 <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> 여부를 확인 하는 <xref:System.Net.Sockets.Socket> 쓸 수 있습니다. 사용 하 여 <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> 오류 조건을 검색 합니다. <xref:System.Net.Sockets.Socket.Poll%2A> 단위의 지정한 시간 기간이 경과할 때까지 실행이 차단 됩니다 `microseconds`, 경과 합니다. 설정 된 `microSeconds` 매개 변수를 음의 정수로 응답을 무기한 대기 하려는 경우. 여러 소켓의 상태를 확인 하려는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.Select%2A> 메서드.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  이 메서드는 특정 유형의 끊어진된 네트워크 케이블을 같은 연결 문제를 검색할 수 없습니다 또는 원격 호스트를 비정상적으로 종료 되었습니다. 이러한 종류의 오류를 검색 하는 데이터 전송 및 수신 하려고 해야 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 서버에 연결 하 고 사용 하 여 소켓을 만듭니다 <xref:System.Net.Sockets.Socket.Poll%2A> 소켓의 상태를 확인 합니다.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> 매개 변수가 <see cref="T:System.Net.Sockets.SelectMode" /> 값이 아닌 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래 설명 부분을 참조하세요.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 프로토콜 종류를 가져옵니다.</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 속성을 설정 하는 경우는 <xref:System.Net.Sockets.Socket> 생성 되 고 사용 하는 프로토콜을 지정 <xref:System.Net.Sockets.Socket>합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, 및 <xref:System.Net.Sockets.ProtocolType> 콘솔.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>바인딩된 <see cref="T:System.Net.Sockets.Socket" />에서 데이터를 받습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <summary>수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.Socket" />의 데이터를 받습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다. 호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.  
  
 이 오버 로드 하기만 수신 버퍼를 제공할 수 있습니다. 버퍼 크기에 대 한 기본값으로 버퍼 매개 변수의 길이 0으로 오프셋 및 <xref:System.Net.Sockets.SocketFlags> 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 연결에서 데이터를 받습니다 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">받은 데이터를 포함하는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</param>
        <summary>바인딩된 <see cref="T:System.Net.Sockets.Socket" />의 데이터를 받아 수신 버퍼 목록에 넣습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 데이터 버퍼 매개 변수를 읽고 성공적으로 읽은 바이트 수를 반환 합니다. 모두 연결 지향 프로토콜과 소켓에서 호출할 수 있습니다.  
  
 이 오버 로드를 제공 해야 하거나 이상의 버퍼를 수신 합니다.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 원격 호스트에 연결 되어에서 도착 하는 데이터만 읽습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 큐에 넣은 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffers` 매개 변수를 `buffers` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
 **참고** 이 멤버는 응용 프로그램에서 네트워크 추적을 사용 하도록 설정 하면 추적 정보를 출력 합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하려고 시도하는 동안 오류가 발생한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다. 호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.  
  
 이 오버 로드만 제공 해야 수신 버퍼 및 필요한 <xref:System.Net.Sockets.SocketFlags>합니다. 버퍼를 0으로 오프셋 이며 크기 기본값 바이트 매개 변수의 길이입니다.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 비차단 모드에 있고 프로토콜 스택 버퍼에 사용할 수 있는 데이터가 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 0이 아닌, 다시 시도 수신 작업입니다.  
  
 연결 지향 사용 중인 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 크기 버퍼의 최대 수 만큼의 데이터를 읽이 됩니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 큐에 넣은 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 데이터 버퍼를 지정 하 고 <xref:System.Net.Sockets.SocketFlags> 에 연결 된 데이터를 받기 위해 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">받은 데이터를 포함하는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받아 수신 버퍼 목록에 넣습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 데이터를 읽습니다는 `buffers` 매개 변수 및 성공적으로 읽은 바이트 수를 반환 합니다. 모두 연결 지향 프로토콜과 소켓에서 호출할 수 있습니다.  
  
 이 오버 로드를 제공 해야 하거나 이상의 버퍼를 수신 합니다. 합니다 <xref:System.Net.Sockets.SocketFlags> 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 원격 호스트에 연결 되어에서 도착 하는 데이터만 읽습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> throw 호출을 <xref:System.Net.Sockets.SocketException>입니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 큐에 넣은 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffers` 매개 변수를 `buffers` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 연결 된 데이터를 수신 하는 방법에 설명 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="buffers" /> 수가 0인 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하려고 시도하는 동안 오류가 발생한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />에서 원하는 바이트 수의 데이터를 받습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수 및 성공적으로 읽은 바이트 수를 반환 합니다. 호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.  
  
 이 오버 로드 하기만 하면 수신 버퍼, 바이트를 수신 하려는 및 필요한 수가 <xref:System.Net.Sockets.SocketFlags>합니다.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 0이 아닌, 다시 시도 수신 작업입니다.  
  
 연결 지향 사용 중인 경우 <xref:System.Net.Sockets.Socket>는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 지정 된 바이트 수까지 사용 가능한 데이터 읽습니다는 `size` 매개 변수입니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 데이터를 수신 `buffer`를 지정 하 고 <xref:System.Net.Sockets.SocketFlags.None> 에 대 한 <xref:System.Net.Sockets.SocketFlags>합니다.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" />가 <paramref name="buffer" />의 크기를 초과한 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">받은 데이터를 포함하는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받아 수신 버퍼 목록에 넣습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 데이터를 읽습니다는 `buffers` 매개 변수 및 성공적으로 읽은 바이트 수를 반환 합니다. 모두 연결 지향 프로토콜과 소켓에서 호출할 수 있습니다.  
  
 이 오버 로드를 제공 해야 하거나 이상의 버퍼를 수신 합니다. 합니다 <xref:System.Net.Sockets.SocketFlags> 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 원격 호스트에 연결 되어에서 도착 하는 데이터만 읽습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> throw 호출을 <xref:System.Net.Sockets.SocketException>입니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼의 크기까지 가능한 한 많은 데이터를 읽습니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffers` 매개 변수를 `buffers` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="buffers" /> 수가 0인 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하려고 시도하는 동안 오류가 발생한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">수신된 데이터의 스토리지 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="offset">받을 데이터를 저장할 <paramref name="buffer" /> 내의 위치입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼의 특정 오프셋 위치에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 원하는 바이트 수를 받습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다. 호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 소켓에 액세스하는 동안 오류가 발생했습니다. 아래 설명을 참조 하세요. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는의 size 매개 변수에 의해 지정 된 바이트 수까지 사용 가능한 많은 데이터를 읽습니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 연결된 된 데이터를 받기 전에 데이터 버퍼, 오프셋, 크기 및 소켓 플래그를 지정 하는 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않은 경우  
  
또는 
<see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="offset">수신된 데이터를 저장할 <paramref name="buffer" /> 매개 변수의 위치입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 수신 버퍼에 바인딩된 <see cref="T:System.Net.Sockets.SocketFlags" />의 데이터를 받습니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드 버퍼 매개 변수로 데이터를 읽고 성공적으로 읽은 바이트 수를 반환 합니다. 호출할 수 있습니다 <xref:System.Net.Sockets.Socket.Receive%2A> 모두 연결 지향 프로토콜과 소켓에서.  
  
 호출 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정할 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 호출 하기 전에 들어오는 연결을 받아들일 <xref:System.Net.Sockets.Socket.Receive%2A>합니다. <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 설정 된 원격 호스트에서 도착 하는 읽기만 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 연결 없는 프로토콜을 사용 하는 경우 사용할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 하면 모든 호스트에서 데이터를 받을 수 있습니다.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.Receive%2A> 를 사용 하 여 시간 제한 값을 설정 하지 않으면 데이터를 사용할 수 있을 때까지 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>입니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 소켓에 액세스하는 동안 오류가 발생했습니다. 아래 설명을 참조 하세요. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 사용할 경우 연결 지향 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는의 size 매개 변수에 의해 지정 된 바이트 수까지 사용 가능한 많은 데이터를 읽습니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> 에서 지정 하는 대상 주소에서 첫 번째 대기 중인된 데이터 그램을 읽게 됩니다.는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드. 받게 데이터 그램의 크기 보다 큰 경우 합니다 `buffer` 매개 변수를 `buffer` 작성 메시지의 첫 번째 파트를 사용 하 여 과도 한 데이터 손실은 및 <xref:System.Net.Sockets.SocketException> throw 됩니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되어 있지 않은 경우  
  
또는 
<see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에서 데이터를 받기 위해 비동기 요청을 시작합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드 사용에 소켓 또는 바인딩된 연결 소켓을 연결 하 고 들어오는 데이터를 읽는 데 사용 됩니다. 소켓의 로컬 주소를 알 수 있어야 합니다.  
  
 바인딩된 연결 없는 소켓에 대 한이 함수는 받은 메시지를 수락할 주소를 제한 합니다. 함수는만 연결에서 지정 된 원격 주소에서 메시지를 반환 합니다. 다른 주소에서 메시지를 자동으로 삭제 됩니다.  
  
 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 읽기 요청에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다. 이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>합니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 또는 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 바이트 스트림 스타일 소켓, 들어오는 데이터 버퍼가 채워집니다, 연결을 닫거나 내부적으로 버퍼링 된 데이터를 모두 사용 될 때까지 버퍼에 배치 됩니다.  
  
 메시지 지향 소켓, 들어오는 메시지와 연결 된 버퍼의 총 크기까지 버퍼에 배치 됩니다는 `e` 매개 변수입니다. 메시지 버퍼 보다 큰 경우에 메시지의 첫 번째 부분을 사용 하 여 버퍼가 채워집니다.  
  
 연결 지향 소켓을 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 메서드는 바이트 스트림 또는 메시지 지향 소켓 인지에 따라 두 가지 방식 중 하나를 사용 하 여 가상 회로의 정상 종료를 나타낼 수 있습니다. 바이트 스트림의 경우 0 바이트를 읽은 것 정상 종료 및 더 이상 바이트를 읽게 됩니다 그 어느 때를 나타냅니다. 메시지 지향 소켓, 여기서 0 바이트 메시지를 허용 되는 <xref:System.Net.Sockets.SocketException> 사용 하 여는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 네이티브 WSAEDISCON Winsock 오류 코드 (10101)로 설정 정상 종료를 나타내는 데 사용 됩니다. 어떤 경우에 <xref:System.Net.Sockets.SocketException> 사용 하 여는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 기본 Winsock WSAECONNRESET로 오류 코드 (10054)를 중단 한 닫기를 발생 했음을 나타냅니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">인수가 잘못된 경우. <paramref name="e" /> 매개 변수의 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 또는 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 올바른 버퍼를 참조하지 않는 경우. 이러한 속성 중 하나를 설정할 수 있지만 두 속성을 동시에 설정할 수는 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 수신 버퍼 크기를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>수신 버퍼의 크기(바이트)가 들어 있는 <see cref="T:System.Int32" />입니다. 기본값은 8192입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 더 큰 버퍼 크기를 잠재적으로 빈 승인 (데이터 부분이 없는 TCP 패킷) 수가 줄어들지만 연결 문제를 인식 하는 데 오래 걸릴 수 있습니다. 큰 파일을 전송 하는 경우 높은 대역폭, 대기 시간이 긴 연결 (예: 위성 광대역 공급자입니다.)를 사용 하는 버퍼 크기를 늘리는 것이 좋습니다  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">set 작업에 지정된 값이 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>데이터그램을 받고 소스 엔드포인트를 저장합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">수신된 데이터의 스토리지 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="remoteEP">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>데이터 버퍼에 데이터그램을 받고 엔드포인트를 저장합니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다. 이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.  
  
 이 오버 로드만 제공 해야 수신 `buffer`, 및 <xref:System.Net.EndPoint> 원격 호스트를 나타내는입니다. 버퍼 오프셋 기본값은 0입니다. 크기의 길이 기본값으로 합니다 `buffer` 매개 변수 및 `socketFlags` 기본값은 <xref:System.Net.Sockets.SocketFlags.None>합니다.  
  
> [!NOTE]
>  호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.  
  
 연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>. 신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다. 신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다. 작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. 이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.  
  
 연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 크기의 최대 수 만큼의 데이터를 읽기는 `buffer`합니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">받는 데이터에 대한 저장소 위치인 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼에 데이터그램을 받고 엔드포인트를 저장합니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다. 이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.  
  
 이 오버 로드 하기만 하면 필요한 수신 버퍼를 제공 <xref:System.Net.Sockets.SocketFlags>, 및 <xref:System.Net.EndPoint> 원격 호스트를 나타내는입니다. 오프셋된 기본값 0 및 버퍼 매개 변수의 길이 크기 기본값은입니다.  
  
> [!NOTE]
>  호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다.  
  
 연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>. 신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다. 신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다. 작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. 이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.  
  
 연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 크기의 최대 수 만큼의 데이터를 읽기는 `buffer`합니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다. <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">수신된 데이터의 스토리지 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼에 원하는 바이트 수를 받고 엔드포인트를 저장합니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다. 이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.  
  
 이 오버 로드만 제공 해야 수신 버퍼를 받으려면를 필요한 바이트 수가 <xref:System.Net.Sockets.SocketFlags>, 및 <xref:System.Net.EndPoint> 원격 호스트를 나타내는입니다. 버퍼 오프셋 기본값은 0입니다.  
  
 연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>. 신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다. 신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다. 작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. 이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.  
  
 연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 을 사용 하 여 지정 된 바이트 수 만큼 데이터를 읽습니다는 `size` 매개 변수입니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
> [!NOTE]
>  호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다. 버퍼 크기와 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" /> 이 <paramref name="buffer" />의 길이보다 큽니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않은 경우  
  
또는 
<see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">수신된 데이터의 스토리지 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="offset">수신된 데이터를 저장할 <paramref name="buffer" /> 매개 변수의 위치입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼의 지정된 위치에 지정된 바이트 수의 데이터를 수신하고 엔드포인트를 저장합니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 데이터를 보낸 원격 호스트 끝점을 캡처합니다. 이 메서드는 알 수 없는 호스트 또는 여러 호스트에서 연결 없는 데이터 그램을 수신 하려는 경우에 유용 합니다.  
  
 연결 없는 프로토콜을 사용 하 여 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 는 로컬 네트워크 버퍼에 받은 첫 번째 큐에 넣은 데이터 그램을 읽습니다. 받게 데이터 그램의 크기 보다 큰 경우 `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 채울 `buffer` 으로 가능한 한 throw 되는 메시지의 대부분을 <xref:System.Net.Sockets.SocketException>. 신뢰할 수 없는 프로토콜을 사용 하는 경우 과도 한 데이터 손실 됩니다. 신뢰할 수 있는 프로토콜을 사용 하는, 과도 한 데이터는 서비스 공급자가 유지 되 고 호출 하 여 검색할 수 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 충분히 큰 버퍼를 사용 하 여 메서드.  
  
 읽을 수 있는 데이터가 없는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 데이터가 있을 때까지 차단 됩니다. 비차단 모드에서는 및에서 사용할 수 있는 데이터가 없는 경우는 프로토콜 스택 버퍼에서를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 즉시 완료 되 고 throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용할 수는 <xref:System.Net.Sockets.Socket.Available%2A> 속성을 읽을 수 있는 데이터 인지 확인 합니다. 때 <xref:System.Net.Sockets.Socket.Available%2A> 는 0이 아닌 수신 작업을 다시 시도 합니다.  
  
 하지만 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 것 연결 없는 프로토콜에 대 한 연결 지향 프로토콜도 사용할 수 있습니다. 작업을 수행 하려는 경우 먼저 하거나 설정 해야 원격 호스트 연결을 호출 하 여는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 하거나 들어오는 원격 호출 하 여 호스트 연결을 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 호출 하기 전에 연결을 허용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드를 받을 수는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드. 이러한 경우 중를 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드는 무시를 `remoteEP` 매개 변수 및 데이터로 연결된 된 또는 기본 원격 호스트에만 수신 합니다.  
  
 연결 지향 소켓 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 을 사용 하 여 지정 된 바이트 크기의 데이터 읽습니다는 `size` 매개 변수입니다. 원격 호스트를 종료 하는 경우는 <xref:System.Net.Sockets.Socket> 연결과 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용할 수 있는 모든 데이터가 수신 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드가 즉시 완료 되 고 0 바이트를 반환 합니다.  
  
> [!NOTE]
>  호출 하기 전에 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>를 명시적으로 바인딩해야 합니다 <xref:System.Net.Sockets.Socket> 사용 하 여 로컬 끝점을 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 없는 경우 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 원격 호스트에서 연결이 끊긴 데이터 그램을 받습니다. 오프셋, 버퍼 크기와 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 메서드.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 오프셋 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.  
  
또는 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않은 경우  
  
또는 
소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>지정된 네트워크 장치에서 비동기적으로 데이터를 받기 시작합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 메서드는 연결 없는 소켓에서 데이터를 수신 하는 데 주로 사용 됩니다. 소켓의 로컬 주소를 알 수 있어야 합니다.  
  
 호출자에 게 설정 해야 합니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 받을 수는 데이터를 원격 호스트의 합니다.  
  
 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 읽기 요청에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다. 이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>합니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 메시지 지향 소켓, 들어오는 메시지 버퍼의 총 크기까지 버퍼에 배치 됩니다. 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 고 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 속성 버퍼의 데이터를 배치할 위치와 데이터의 양을 결정 합니다.  
  
 바이트 스트림 스타일 소켓, 들어오는 데이터 버퍼가 채워집니다, 연결을 닫거나 내부적으로 버퍼링 된 데이터를 모두 사용 될 때까지 버퍼에 배치 됩니다. 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 고 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 속성 버퍼의 데이터를 배치할 위치와 데이터의 양을 결정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 null인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">수신된 데이터의 스토리지 위치에 해당하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="offset">수신된 데이터를 저장할 <paramref name="buffer" /> 매개 변수의 위치입니다.</param>
        <param name="size">수신 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">원격 서버를 나타내며 참조에 의해 전달되는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.Sockets.IPPacketInformation" /> 보유 주소 및 인터페이스 정보입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 데이터 버퍼의 지정된 위치에 지정된 바이트 수의 데이터를 수신하고 엔드포인트 및 패킷 정보를 저장합니다.</summary>
        <returns>받은 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드 데이터를 읽고는 `buffer` 매개 변수를 성공적으로 읽은 바이트 수를 반환 하 고 받은 패킷에 대 한 정보 뿐만 아니라 데이터를 전송 하는 원격 호스트 끝점을 캡처합니다.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드는 연결 없는 소켓에서 메시지 데이터를 수신 하는 데 주로 사용 됩니다. 소켓의 로컬 주소를 알 수 있어야 합니다. 이 메서드가 데이터 그램 및 원시 소켓을 사용 하 여 사용할 수 있습니다. 소켓이 소켓 유형 설정으로 초기화 되어야 합니다 <xref:System.Net.Sockets.SocketType.Dgram> 또는 <xref:System.Net.Sockets.SocketType.Raw> 이 메서드를 호출 하기 전에 합니다. 소켓을 사용 하 여 생성할 때이 수행할 수 있습니다 <xref:System.Net.Sockets.Socket.%23ctor%2A>합니다.  
  
 메시지 지향 소켓에 대 한 들어오는 메시지에 놓입니다 합니다 `buffer` 매개 변수에서 지정한 총 크기는 최대를 `size` 매개 변수입니다. 합니다 `offset` 위치를 결정 하는 매개 변수는 `buffer` 데이터 배치 됩니다. 데이터의 실제 량에 배치 합니다 `buffer` 에서 반환 되는 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드를 자동으로 메서드 설정 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을 `true` 처음 호출 될를 지정 된 <xref:System.Net.Sockets.Socket>합니다. 그러나 반환 된 <xref:System.Net.Sockets.IPPacketInformation> 개체 소켓 옵션을 설정한 후에 로컬 컴퓨터에 도착 하는 패킷에 적용 됩니다. 로컬 끝점에 바인딩될 때 소켓 사이 패킷을 보내면 (의해 명시적으로 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 또는 중 하나에 의해 암시적으로 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, 또는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드) 및 첫 번째 호출을 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드를 호출 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 메서드는 잘못 된 반환 <xref:System.Net.Sockets.IPPacketInformation> 이러한 패킷에 대 한 개체입니다.  
  
 되도록 모든 <xref:System.Net.Sockets.IPPacketInformation> 개체는 유효, 응용 프로그램 설정 해야 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을 `true` 사용 하 여 로컬 끝점에 연결 되기 전에 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 메서드.  
  
 응용 프로그램을 검사할 수는 `ipPacketInformation` 유니캐스트, 멀티 캐스트 또는 브로드캐스트 주소를 사용 하 여 데이터 그램을 보냈는지를 알고 있어야 하는 경우 매개 변수입니다.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 와 일치 해야 합니다 <xref:System.Net.Sockets.AddressFamily> 의 <xref:System.Net.EndPoint> 에 사용 되는 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
\- 또는- 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 오프셋 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닙니다.  
  
또는 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 속성이 설정되지 않은 경우  
  
또는 
.NET Framework가 AMD 64비트 프로세서에서 실행 중인 경우  
  
또는 
소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에는 Windows XP가 필요한데 운영 체제가 Windows 2000 또는 그 이전 버전인 경우</exception>
        <permission cref="T:System.Net.SocketPermission">네트워크에서 연결을 허용 합니다. 연관된 열거형: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>지정된 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />를 사용하여 원하는 바이트 수의 데이터를 데이터 버퍼의 특정 위치로 받는 비동기 작업을 시작하고 엔드포인트 및 패킷 정보를 저장합니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드는 연결 없는 소켓에서 메시지 데이터를 수신 하는 데 주로 사용 됩니다. 소켓의 로컬 주소를 알 수 있어야 합니다. 이 메서드가 데이터 그램 및 원시 소켓을 사용 하 여 사용할 수 있습니다. 소켓이 소켓 유형 설정으로 초기화 되어야 합니다 <xref:System.Net.Sockets.SocketType.Dgram> 또는 <xref:System.Net.Sockets.SocketType.Raw> 이 메서드를 호출 하기 전에 합니다. 소켓을 사용 하 여 생성할 때이 수행할 수 있습니다 <xref:System.Net.Sockets.Socket.%23ctor%2A>합니다.  
  
 호출자에 게 설정 해야 합니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성을는 <xref:System.Net.IPEndPoint> 받을 수는 데이터를 원격 호스트의 합니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 메시지 지향 소켓, 들어오는 메시지 버퍼의 총 크기까지 버퍼에 배치 됩니다. 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 고 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 속성 버퍼의 데이터를 배치할 위치와 데이터의 양을 결정 합니다.  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드를 자동으로 설정 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을 `true` 처음 호출 될는 지정 된 <xref:System.Net.Sockets.Socket>합니다. 그러나는 <xref:System.Net.Sockets.IPPacketInformation> 개체 소켓 옵션을 설정한 후에 로컬 컴퓨터에 도착 하는 패킷에 적용 됩니다. 소켓 로컬 끝점에 바인딩될 때 소켓 사이 패킷을 보내면 (의해 명시적으로 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드 또는 중 하나에 의해 암시적으로 <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, 또는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드)를 처음으로 호출 하는 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>메서드를 호출 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 메서드를 잘못에서 하면 <xref:System.Net.Sockets.IPPacketInformation> 이러한 패킷에 대 한 개체입니다.  
  
 되도록 모든 <xref:System.Net.Sockets.IPPacketInformation> 개체는 유효, 응용 프로그램 설정 해야 합니다 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 소켓 옵션을`true` 사용 하 여 로컬 끝점에 연결 되기 전에 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 메서드.  
  
 응용 프로그램에서 결과 검사할 수 <xref:System.Net.Sockets.IPPacketInformation> 유니캐스트, 멀티 캐스트 또는 브로드캐스트 주소를 사용 하 여 데이터 그램을 보냈는지 확인 해야 하는 경우 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 null인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동기 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 호출이 완료되어야 하는 제한 시간을 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>제한 시간 값(밀리초)입니다. 기본값은 0으로, 시간 제한이 없음을 나타냅니다. - 1을 지정해도 시간 제한이 없음을 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 옵션은 동기 <xref:System.Net.Sockets.Socket.Receive%2A> 만 호출 합니다. 제한 시간이 초과 되 면 합니다 <xref:System.Net.Sockets.Socket.Receive%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">set 작업에 지정된 값이 -1보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>원격 엔드포인트를 가져옵니다.</summary>
        <value><see cref="T:System.Net.EndPoint" />이 통신에 사용하는 <see cref="T:System.Net.Sockets.Socket" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 속성을 가져옵니다는 <xref:System.Net.EndPoint> 원격 IP 주소 및 포트 번호를 포함 하는 <xref:System.Net.Sockets.Socket> 연결 합니다. 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 기본 원격 IP 주소 및 포트 번호를 포함 합니다 <xref:System.Net.Sockets.Socket> 통신 합니다. 이 캐스팅 해야 <xref:System.Net.EndPoint> 에 <xref:System.Net.IPEndPoint> 모든 정보를 검색 하기 전에 합니다. 호출할 수 있습니다 합니다 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 원격을 검색 하는 방법 <xref:System.Net.IPAddress>, 및 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 원격 포트 번호를 검색 하는 방법입니다.  
  
 합니다 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 중 하나를 호출한 후 설정할지 <xref:System.Net.Sockets.Socket.Accept%2A> 또는 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 이전에이 속성에 액세스 하려고 하면 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제를 검색 하 고 로컬과 원격 끝점을 표시 합니다.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="checkRead">가독성을 확인할 <see cref="T:System.Net.Sockets.Socket" /> 인스턴스의 <see cref="T:System.Collections.IList" />입니다.</param>
        <param name="checkWrite">쓰기 가능성을 확인할 <see cref="T:System.Net.Sockets.Socket" /> 인스턴스의 <see cref="T:System.Collections.IList" />입니다.</param>
        <param name="checkError">오류를 확인할 <see cref="T:System.Net.Sockets.Socket" /> 인스턴스의 <see cref="T:System.Collections.IList" />입니다.</param>
        <param name="microSeconds">시간 제한 값(마이크로초)입니다. 값 -1은 시간 제한이 없음을 나타냅니다.</param>
        <summary>하나 이상의 소켓 상태를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 하나 이상의 상태를 확인 하는 정적 메서드는 <xref:System.Net.Sockets.Socket> 인스턴스. 하나 이상의 소켓에 배치 해야 합니다는 <xref:System.Collections.IList> 사용 하기 전에 <xref:System.Net.Sockets.Socket.Select%2A> 메서드. 호출 하 여 가독성을 위해 확인할 <xref:System.Net.Sockets.Socket.Select%2A> 사용 하 여 합니다 <xref:System.Collections.IList> 으로 `checkRead` 매개 변수입니다. 쓰기 가능성에 대 한 소켓을 확인 하려면 사용 된 `checkWrite` 매개 변수입니다. 오류 조건을 검색을 사용 하 여 `checkError`입니다. 호출한 후 <xref:System.Net.Sockets.Socket.Select%2A>, <xref:System.Collections.IList> 조건을 만족 하는 소켓에만 채워집니다.  
  
 가독성에 대 한 호출을 수신 대기 상태에 있는 경우 즉 <xref:System.Net.Sockets.Socket.Accept%2A> 차단 하지 않아도 됩니다. 연결이 이미 수락 된 경우 가독성 데이터를 읽을 수 있음을 의미 합니다. 이러한 경우에 모든 수신 작업을 차단 하지 않고 성공 합니다. 가독성을 나타낼 수도 있습니다 있는지 여부를 원격 <xref:System.Net.Sockets.Socket> 가 종료 경우, 연결에 대 한 호출 <xref:System.Net.Sockets.Socket.Receive%2A> 0 바이트가 반환을 즉시 반환 됩니다.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 반환 될 때 관심 소켓의 하나 이상 (의 소켓을 `checkRead`, `checkWrite`, 및 `checkError` 나열) 지정 된 조건에 맞는 또는 `microSeconds` 매개 변수를 초과 하는 먼저 도달 하 합니다. 설정 `microSeconds` -1로 무기한 시간 제한을 지정 합니다.  
  
 비블로킹 한다면 <xref:System.Net.Sockets.Socket.Connect%2A>를 성공적으로 연결 하는 것이 방식입니다. 설정 되는 연결에 이미 있는 경우 모든 작업을 차단 하지 않고 성공 송신 쓰기 가능성 의미 합니다.  
  
 비 중단 호출을 수행한 <xref:System.Net.Sockets.Socket.Connect%2A>, `checkerror` 소켓 성공적으로 연결 하지 않은 매개 변수를 식별 합니다.  
  
> [!NOTE]
>  사용 된 <xref:System.Net.Sockets.Socket.Poll%2A> 메서드는 단일 상태를 확인 하려는 경우 <xref:System.Net.Sockets.Socket>합니다.  
  
> [!NOTE]
>  이 메서드는 특정 유형의 끊어진된 네트워크 케이블을 같은 연결 문제를 검색할 수 없습니다 또는 원격 호스트를 비정상적으로 종료 되었습니다. 이러한 종류의 오류를 검색 하는 데이터 전송 및 수신 하려고 해야 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.Select%2A> 수신 소켓 연결 요청을 확인할 수 있습니다.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> 매개 변수가 <see langword="null" />이거나 비어 있는 경우  
  
및 
<paramref name="checkWrite" /> 매개 변수가 <see langword="null" />이거나 비어 있는 경우 
및 
<paramref name="checkError" /> 매개 변수가 <see langword="null" />이거나 비어 있는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 데이터를 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 에 지정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다. <xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.  
  
 이 오버 로드에 보낼 데이터가 들어 있는 버퍼에 필요 합니다. <xref:System.Net.Sockets.SocketFlags> 0 값은 기본적으로, 버퍼 오프셋 기본값은 0이 고 기본값은 버퍼의 크기를 보낼 바이트 수입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 연결 된 데이터를 보내는 방법을 보여 줍니다 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">보낼 데이터가 들어 있는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</param>
        <summary>목록에 있는 버퍼 집합을 연결된 <see cref="T:System.Net.Sockets.Socket" />으로 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.  
  
 이 오버 로드에 전송 하려는 데이터가 포함 된 하나 이상의 버퍼에 필요 합니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />가 비어 있는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. 아래의 설명 부분을 참조하십시오.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 데이터를 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />에 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 에 설정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다. <xref:System.Net.Sockets.Socket.Send%2A> 모두 연결 지향 프로토콜과 프로토콜에 대 한 메서드를 사용할 수 있습니다.  
  
 이 오버 로드 해야 전송 하려는 데이터를 포함 하는 버퍼의 비트 조합 <xref:System.Net.Sockets.SocketFlags>합니다. 버퍼 오프셋에 0이 고 기본값은 버퍼의 크기를 보낼 바이트 수입니다. 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수 값, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  버퍼의 크기 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 해야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 연결 된 데이터를 보내는 방법을 보여 줍니다 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">보낼 데이터가 들어 있는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 목록에 있는 버퍼 집합을 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />으로 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드에 전송 하려는 데이터가 포함 된 하나 이상의 버퍼에 필요 합니다. <xref:System.Net.Sockets.SocketFlags> 기본값은 0입니다. 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketFlags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비 중단 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />가 비어 있는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 원하는 바이트 수의 데이터를 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />에 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 에 설정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다. <xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.  
  
 이 오버 로드를 보낼 바이트 수 및의 비트 조합을 전송 하려는 데이터가 포함 된 버퍼 필요 <xref:System.Net.Sockets.SocketFlags>합니다. 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출할 때마다 하기 전에 <xref:System.Net.Sockets.Socket.Send%2A> 메서드. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 연결 지향 프로토콜로 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 보내는 요청 된 바이트 수보다 작을 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  크기가 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 해야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다. 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 버퍼에 있는 데이터를 보내고 지정 <xref:System.Net.Sockets.SocketFlags.None> 에 대 한 <xref:System.Net.Sockets.SocketFlags>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" />가 0보다 작거나 버퍼 크기를 초과하는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
소켓에 액세스하는 동안 운영 체제 오류가 발생한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">보낼 데이터가 들어 있는 <see cref="T:System.ArraySegment`1" /> 형식의 <see cref="T:System.Byte" /> 목록입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 목록에 있는 버퍼 집합을 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />으로 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드에 전송 하려는 데이터가 포함 된 하나 이상의 버퍼에 필요 합니다. <xref:System.Net.Sockets.SocketFlags> 기본값은 0입니다. 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketFlags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 사용 하지 않는 경우는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용할 수 있습니다 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 모든 버퍼의 바이트를 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비 중단 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 버퍼의 바이트 수보다 적은 데이터를 보내는 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 버퍼의 바이트를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" />가 비어 있는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="offset">데이터 보내기를 시작할 데이터 버퍼의 위치입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 오프셋에서 시작하고 지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 지정된 바이트 수의 데이터를 연결된 <see cref="T:System.Net.Sockets.Socket" />으로 전송합니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 에 지정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다. <xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.  
  
 이 오버 로드를 지정 하는 경우에 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다. 사용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A>를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용 해도 되는지 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 보내는 요청 된 바이트 수보다 작을 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 데이터 버퍼, 오프셋, 크기를 지정 하 고 <xref:System.Net.Sockets.SocketFlags> 는 연결 된 데이터를 보내기 위해 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
<see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="offset">데이터 보내기를 시작할 데이터 버퍼의 위치입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="errorCode">소켓 오류를 저장하는 <see cref="T:System.Net.Sockets.SocketError" /> 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" />를 사용하여 지정된 오프셋부터 원하는 바이트 수의 데이터를 연결된 <see cref="T:System.Net.Sockets.SocketFlags" />에 보냅니다.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />에 보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 에 지정 된 원격 호스트에 데이터를 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드와 성공적으로 보낸 바이트 수를 반환 합니다. <xref:System.Net.Sockets.Socket.Send%2A> 연결 지향 및 연결 없는 프로토콜에 대해 사용할 수 있습니다.  
  
 이 오버 로드를 지정 하는 경우에 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 또는 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 없는 프로토콜 및 계획을 사용 하 여 여러 다른 호스트에 데이터를 보내도록는, 하는 경우 사용 해야 <xref:System.Net.Sockets.Socket.SendTo%2A>합니다. 사용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A>를 호출 해야 <xref:System.Net.Sockets.Socket.Connect%2A> 호출 하기 전에 매번 <xref:System.Net.Sockets.Socket.Send%2A>합니다. 사용 해도 되는지 <xref:System.Net.Sockets.Socket.SendTo%2A> 사용 하 여 기본 원격 호스트를 설정한 후에 <xref:System.Net.Sockets.Socket.Connect%2A>합니다. 호출 하기 전에 기본 원격 호스트를 변경할 수도 있습니다 <xref:System.Net.Sockets.Socket.Send%2A> 다른 호출 하 여 <xref:System.Net.Sockets.Socket.Connect%2A>입니다.  
  
 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.Send%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Send%2A> 를 사용 하 여 제한 시간을 설정 하지 않으면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>합니다. 시간 제한 값이 초과 되는 <xref:System.Net.Sockets.Socket.Send%2A> 되는 <xref:System.Net.Sockets.SocketException>합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.Send%2A> 보내는 요청 된 바이트 수보다 작을 경우에 성공적으로 완료 될 수 있습니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.Send%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  송신 완료가 데이터를 성공적으로 배달 된 나타내지 않습니다. 버퍼 공간이 전송할 데이터를 보유 하도록 전송 시스템 내에서 사용 가능한 경우 소켓이 비블로킹 모드로 배치 된 경우 전송이 차단 됩니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 데이터 버퍼, 오프셋, 크기를 지정 하 고 <xref:System.Net.Sockets.SocketFlags> 는 연결 된 데이터를 보내기 위해 <xref:System.Net.Sockets.Socket>합니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
<see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>데이터를 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드 연결 지향 소켓에서 하나 이상의 버퍼에서 나가는 데이터를 쓰는 데 사용 됩니다. 이 메서드 데도 사용할 수 있습니다, 있지만 연결 없는 소켓 connect 작업에서 원격 호스트를 지정 합니다.  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> 에 설정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 또는 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 경우 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 설정  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 합니다 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드가 먼저 호출 하지 않으면 예외가 throw 됩니다 <xref:System.Net.Sockets.Socket.Accept%2A>를 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>합니다.  
  
 호출 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다.  
  
 메시지 지향 소켓에 대 한 기본 Windows sockets 서비스 공급자의 최대 메시지 크기를 초과 하지 않습니다. 데이터가 전송 되는 데이터가 너무 길어 기본 서비스 공급자를 통해 원자 단위로 전달 하는 경우 및 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드가 throw를 <xref:System.Net.Sockets.SocketException> 사용 하 여는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 네이티브 WSAEMSGSIZE Winsock 오류 코드 (10040)로 설정 합니다.  
  
 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드 데이터를 성공적으로 배달 된 나타내지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> 매개 변수의 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 또는 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 속성이 올바른 버퍼를 참조하지 않는 경우. 이러한 속성 중 하나를 설정할 수 있지만 두 속성을 동시에 설정할 수는 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" />이 아직 연결되지 않았거나 <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 또는 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 메서드를 통해 소켓을 가져오지 못한 경우</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 송신 버퍼 크기를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>송신 버퍼의 크기(바이트)가 들어 있는 <see cref="T:System.Int32" />입니다. 기본값은 8192입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큰 버퍼 크기는 연결 문제를 인식을 지연 될 수 있습니다. 큰 파일을 전송 하는 경우 높은 대역폭, 대기 시간이 긴 연결 (예: 위성 광대역 공급자입니다.)를 사용 하는 버퍼 크기를 늘리는 것이 좋습니다  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.SendBufferSize%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">set 작업에 지정된 값이 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결된 <see cref="T:System.Net.Sockets.Socket" />에 파일 및 선택적 데이터를 동기적으로 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">전송할 파일의 경로 및 이름을 포함하는 <see cref="T:System.String" />입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 전송 플래그를 사용하여 <paramref name="fileName" /> 파일을 연결된 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 개체에 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 된 파일을 보냅니다 `fileName` 연결 된 소켓입니다. 합니다 `flags` 매개 변수의 기본값은 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) 및 `preBuffer` 하 고 `postBuffer` 매개 변수의 기본값은 `null`합니다. 경우 `fileName` 는 로컬 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다. 와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다. 파일이 없는 경우, 예외 <xref:System.IO.FileNotFoundException> throw 됩니다.  
  
 이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을. 에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 참조 합니다 [Windows 소켓](/windows/desktop/WinSock/) 설명서.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 에 지정 된 원격 호스트에 파일을 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. <xref:System.Net.Sockets.Socket.SendFile%2A> 연결 없는 프로토콜 및 연결 지향 둘 다에 대해 사용할 수 있습니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 그렇지 않은 경우이 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendFile%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트에 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendFile%2A> 파일 전송 될 때까지 차단 합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.SendFile%2A> 전체 파일이 전송 되기 전에 성공적으로 완료 될 수 있습니다. 보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendFile%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만듭니다 소켓 연결 및 원격 호스트에 파일을 보냅니다. "Test.txt" 파일을 로컬 컴퓨터의 루트 디렉터리에 있습니다.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">소켓이 원격 호스트에 연결되지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 차단 모드가 아니며 이 동기 호출을 수락할 수 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="fileName" /> 파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">전송할 파일의 경로 및 이름을 포함하는 <see cref="T:System.String" />입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="preBuffer">파일이 전송되기 전에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="postBuffer">파일이 전송된 후에 전송할 데이터를 포함하는 <see cref="T:System.Byte" /> 배열입니다. 이 매개 변수는 <see langword="null" />일 수 있습니다.</param>
        <param name="flags">하나 이상의 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 값입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 값을 사용하여 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 파일 <paramref name="fileName" /> 및 데이터 버퍼를 전송합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드의 비트 조합 보낼 파일의 이름이 필요한 <xref:System.Net.Sockets.TransmitFileOptions> 값입니다. `preBuffer` 매개 변수를 파일 앞에 데이터를 포함 합니다. `postBuffer` 파일을 따라 하려는 데이터가 포함 됩니다. 경우 `fileName` 는 현재 작업 디렉터리에서 식별 된 파일의 이름만 사용 하 여, 그렇지 않으면 전체 경로 및 파일의 이름을 지정 해야 합니다. 와일드 카드 ("... \\\myfile.txt ") 및 UNC 공유 이름 ("\\\\\\\shared 디렉터리\\\myfile.txt ")는 지원 합니다.  
  
 `flags` 매개 변수는 파일 전송에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다. 이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.TransmitFileOptions>합니다.  
  
 이 메서드는 사용 된 `TransmitFile` Windows Sockets 2 api에서 함수를 찾을. 에 대 한 자세한 내용은 `TransmitFile` 함수와 해당 플래그를 참조 합니다 [Windows 소켓](/windows/desktop/WinSock/) 설명서.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 에 지정 된 원격 호스트에 파일을 동기식으로 전송 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. <xref:System.Net.Sockets.Socket.SendFile%2A> 연결 없는 프로토콜 및 연결 지향 둘 다에 대해 사용할 수 있습니다.  
  
 연결 없는 프로토콜을 사용 하는 경우 호출 해야 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 이 메서드를 호출 하기 전에 고, 그렇지 <xref:System.Net.Sockets.Socket.SendFile%2A> throw를 <xref:System.Net.Sockets.SocketException>입니다. 사용 해야 하는 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Connect%2A> 원격 호스트 연결을 설정 하거나 사용 하 여 <xref:System.Net.Sockets.Socket.Accept%2A> 는 들어오는 연결을 허용 하도록 합니다.  
  
 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendFile%2A> 전체 파일이 전송 될 때까지 차단 합니다. 비블로킹 모드로 <xref:System.Net.Sockets.Socket.SendFile%2A> 전체 파일이 전송 되기 전에 성공적으로 완료 될 수 있습니다. 보장이 없습니다 보내는 데이터를 네트워크에 즉시 표시 됩니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendFile%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 만들고 소켓을 연결 합니다. "Test.txt" 파일을 로컬 컴퓨터의 루트 디렉터리에 있습니다. 이 예제에서는 버퍼 및 데이터의 만들고 파일을 사용 하 여 원격 호스트에 전송 합니다. 기본 <xref:System.Net.Sockets.TransmitFileOptions> 사용 됩니다.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">운영 체제가 Windows NT 이상이 아닌 경우  
  
또는 
소켓이 원격 호스트에 연결되지 않은 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 차단 모드가 아니며 이 동기 호출을 수락할 수 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="fileName" /> 파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>파일 컬렉션 또는 메모리 내 데이터 버퍼를 연결된 <see cref="T:System.Net.Sockets.Socket" /> 개체에 비동기적으로 보냅니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드는 원격 호스트에 메모리 또는 파일의 컬렉션 데이터 버퍼를 보내는 데 있습니다. <xref:System.Net.Sockets.Socket> 원격 호스트에 이미 연결 되어 있어야 합니다.  
  
 경우는 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> 작업 디렉터리에서 파일 참조를 파일의 이름만 사용 하 여 식별;이 고, 그렇지 전체 경로 및 파일의 이름을 지정 해야 합니다. UNC 공유 이름과 와일드 카드가 지원 됩니다. 파일이 없으면 <xref:System.IO.FileNotFoundException> throw 됩니다.  
  
 콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.  
  
 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 파일 전송에 대 한 추가 정보를 사용 하 여 창 소켓 서비스 공급자를 제공 합니다. 이 매개 변수를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Net.Sockets.TransmitFileOptions>합니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 이 메서드는 Windows 소켓 2 API에 TransmitPackets 함수를 사용 합니다. TransmitPackets 함수와 해당 플래그에 대 한 자세한 내용은 참조는 [Windows 소켓](/windows/desktop/WinSock/) 설명서.  
  
 연결 지향 프로토콜에서 사용 되지만 합니다 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드 역시 연결 없는 프로토콜에 먼저 호출 된 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 기본 원격 호스트를 설정 하는 방법입니다. 연결 없는 프로토콜 사용도 해야 파일의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 합니다. 이 경우 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throw를 <xref:System.Net.Sockets.SocketException> 예외입니다.  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드는 사용 되는 운영 체제에 따라 최적화 됩니다. Windows server 버전에는 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 메서드는 높은 성능을 위해 최적화 됩니다.  
  
 Windows 클라이언트 버전에는 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 최소 메모리 및 리소스 사용률에 대 한 메서드는 최적화 합니다.  
  
 사용 합니다 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> 플래그를 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 속성에는 `e` 매개 변수는 상당한 성능 이점을 제공할 수 있습니다. 하는 경우 시작 하는 스레드가 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 계산이 많은 작업에 대 한 메서드 호출을 되, 것이 가능 하지만 드문 시작 Apc를 방지할 수 있습니다. 사용자 모드 및 커널 Apc 간의 차이 참고 합니다. 커널 Apc 스레드가 대기 상태일 때 시작 합니다. 사용자 모드 Apc 스레드 경고 대기 상태가 되 면 시작  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 속성에 지정된 파일을 찾을 수 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우. <see cref="T:System.Net.Sockets.Socket" />이 원격 호스트에 연결되어 있지 않은 경우에도 이 예외가 발생합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">연결 없는 <see cref="T:System.Net.Sockets.Socket" />이 사용되고 있고 보내는 파일이 내부 전송의 최대 패킷 크기를 초과하는 경우</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동기 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 호출이 완료되어야 하는 제한 시간을 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>제한 시간 값(밀리초)입니다. 1부터 499 사이의 값으로 속성을 설정하면 값이 500으로 변경됩니다. 기본값은 0으로, 시간 제한이 없음을 나타냅니다. - 1을 지정해도 시간 제한이 없음을 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 옵션은 동기 <xref:System.Net.Sockets.Socket.Send%2A> 만 호출 합니다. 제한 시간이 초과 되 면 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드는 throw를 <xref:System.Net.Sockets.SocketException>입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.SendTimeout%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">set 작업에 지정된 값이 -1보다 작습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>특정 엔드포인트에 데이터를 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="remoteEP">데이터의 대상을 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>지정된 엔드포인트에 데이터를 보냅니다.</summary>
        <returns>보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 버퍼 오프셋의 크기를 기본값 보낼 바이트 수는 0을 `buffer` 매개 변수 및 <xref:System.Net.Sockets.SocketFlags> 기본값은 0입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다. 호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다. 또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다. 할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.  
  
 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다. 원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.  
  
 소켓을 차단 하면 버퍼의 바이트 모든 전송 될 때까지 차단 됩니다. 있으므로 비차단 <xref:System.Net.Sockets.Socket> 완료 즉시 보낼 수 있습니다 하지 모든 바이트를 `buffer`. 응용 프로그램의 책임 보낸 바이트 수를 추적 하는 응용 프로그램에서 모든 바이트를 보낼 때 까지는 작업을 다시 시도 하는 것은 `buffer`합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 양의 아웃 바운드 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
 블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다. 보낸 바이트 수 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">해당 데이터의 대상 위치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 특정 엔드포인트에 데이터를 보냅니다.</summary>
        <returns>보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 버퍼 오프셋 0이 고 기본값의 크기를 보낼 바이트 수를 `buffer`입니다. 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다. 호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다. 또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다. 할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.  
  
 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다. 원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.  
  
 소켓 차단 됩니다 될 때까지 차단 요청한 모든 바이트를 `buffer` 전송 됩니다. 있으므로 비차단 <xref:System.Net.Sockets.Socket> 완료 즉시 보낼 수 있습니다 하지 모든 바이트를 `buffer`. 응용 프로그램의 책임 보낸 바이트 수를 추적 하는 응용 프로그램에서 모든 바이트를 보낼 때 까지는 작업을 다시 시도 하는 것은 `buffer`합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 나가는 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
 블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다. 보낸 바이트 수 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다. <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">해당 데이터의 대상 위치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.SocketFlags" />를 사용하여 특정 엔드포인트에 원하는 바이트 수의 데이터를 보냅니다.</summary>
        <returns>보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 버퍼에는 기본값 0으로 오프셋입니다. 지정 하는 경우는 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다. 호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다. 또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다. 할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.  
  
 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다. 원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.  
  
 소켓을 차단 하면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다. 하므로 비차단 <xref:System.Net.Sockets.Socket> 완료를 즉시 보낼 수 있습니다 하지의 모든 단일 작업에서 요청 된 바이트입니다. 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 나가는 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
 블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다. 보낸 바이트 수 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다. 크기와 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">지정된 <paramref name="size" />가 <paramref name="buffer" />의 크기를 초과한 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">전송할 데이터를 포함하는 형식 <see cref="T:System.Byte" />의 배열입니다.</param>
        <param name="offset">데이터 보내기를 시작할 데이터 버퍼의 위치입니다.</param>
        <param name="size">보낼 바이트 수입니다.</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 값의 비트 조합입니다.</param>
        <param name="remoteEP">해당 데이터의 대상 위치를 나타내는 <see cref="T:System.Net.EndPoint" />입니다.</param>
        <summary>버퍼의 지정된 위치에서 시작하여 특정 <see cref="T:System.Net.Sockets.SocketFlags" />를 통해 원하는 바이트 수의 데이터를 지정된 엔드포인트로 보냅니다.</summary>
        <returns>보낸 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 지정 하는 경우에 <xref:System.Net.Sockets.SocketFlags.DontRoute> 으로 플래그를 `socketflags` 매개 변수, 라우팅되지 것입니다 보내는 데이터입니다.  
  
 연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>입니다. 호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.Send%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드를 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendTo%2A>는 `remoteEP` 작업만 송신 하는 매개 변수에서 지정 된 기본 원격 호스트를 덮어씁니다. 또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드를 기본 서비스 공급자가 가장 적합 한 로컬 네트워크 주소 및 포트 번호를 할당 하기 때문에 합니다. 할당 된 로컬 네트워크 주소 및 포트 번호를 확인 해야 하는 경우 사용할 수 있습니다는 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드가 성공적으로 완료 합니다.  
  
 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendTo%2A> 연결 지향 프로토콜과 함께 사용할 수도 있습니다. 원격 호스트 연결을 호출 하 여 먼저 설정 해야 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Connect%2A> 메서드 사용 하 여 들어오는 연결 요청을 수락 또는 <xref:System.Net.Sockets.Socket.Accept%2A> 메서드. 설정 하거나 원격 호스트 연결을 허용 하지 않는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 호출 하기 전에 연결 없는 프로토콜에 대 한 기본 원격 호스트를 설정할 수도 있습니다는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드. 이러한 경우 중 <xref:System.Net.Sockets.Socket.SendTo%2A> 는 무시 합니다 `remoteEP` 매개 변수와 연결 된 송신 데이터 또는 기본 원격 호스트 합니다.  
  
 소켓을 차단 하면 바이트 수가 요청 된 전송 될 때까지 차단 됩니다. 비블로킹 이후 <xref:System.Net.Sockets.Socket> 완료를 즉시 보낼 수 있습니다 하지의 모든 단일 작업에서 요청 된 바이트입니다. 이 응용 프로그램은 전송 된 바이트 수를 추적 하 고 응용 프로그램에서 요청 된 바이트 수를 보낼 때 까지는 작업을 다시 시도를 합니다. 보내는 데이터를 네트워크에 즉시 표시 되는 보장 되지 않습니다 이기도 합니다. 네트워크 효율성을 높입니다 상당한 나가는 데이터를 수집할 때까지 기본 시스템 전송을 지연 될 수 있습니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드 내부 시스템을 네트워크에 대 한 데이터 전송 버퍼 공간이 했습니다는 의미입니다.  
  
 블로킹 모드에서 연결 없는 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.SendTo%2A> 데이터 그램 전송 될 때까지 차단 됩니다. 먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션을 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>입니다. 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendTo%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정된 된 원격 호스트에 연결 없는 데이터 그램을 보냅니다. 오프셋, 크기 및 <xref:System.Net.Sockets.SocketFlags> 에 전달 되는 <xref:System.Net.Sockets.Socket.SendTo%2A> 메서드.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="remoteEP" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="offset" /> 이 <paramref name="buffer" />의 길이보다 큽니다.  
  
또는 
 <paramref name="size" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 <paramref name="buffer" />의 길이에서 <paramref name="offset" /> 매개 변수 값을 뺀 크기보다 큰 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" />가 값의 유효한 조합이 아닌 경우  
  
또는 
<see cref="T:System.Net.Sockets.Socket" />에 액세스하는 동안 운영 체제 오류가 발생한 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택에 있는 호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">이 비동기 소켓 작업에 사용할 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체입니다.</param>
        <summary>특정 원격 호스트에 데이터를 비동기적으로 보냅니다.</summary>
        <returns>I/O 작업이 보류 중인 경우 <see langword="true" />입니다. 작업이 완료되면 <paramref name="e" /> 매개 변수에 대한 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생합니다.  
  
 I/O 작업이 동기적으로 완료된 경우 <see langword="false" />입니다. 이 경우에는 <paramref name="e" /> 매개 변수에서 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 이벤트가 발생하지 않으며, 메서드 호출이 반환된 직후 매개 변수로 전달된 <paramref name="e" /> 개체를 검사하여 작업 결과를 검색할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 에 지정 된 원격 호스트에 비동기 송신 작업을 시작 하는 메서드를 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 의 속성을 `e` 매개 변수입니다. 호출 된 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 방법을 사용 하면 별도 실행 스레드 내에서 데이터를 보낼 수 있습니다. 이 메서드는 연결 없는 프로토콜을 위한 것일 지라도 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 프로토콜과 연결 지향 프로토콜 모두 작동 합니다.  
  
 콜백 메서드를 이벤트 처리기를 구현 하는 완료 알림을 수를 만들어야\<SocketAsyncEventArgs > 대리자를 연결 하는 콜백에 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트입니다.  
  
 다음 속성 및 이벤트는 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 성공적으로이 메서드를 호출 하는 데 필요한 개체:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 호출자에 게 설정할 수 있습니다는 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 속성을 호출 하기 전에 필요한 모든 사용자 상태 개체는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드 정보를 콜백 메서드에서 검색할 수 있도록 합니다. 콜백 단일 개체 보다 더 많은 정보가 필요한 경우 멤버로 다른 필요한 상태 정보를 보관할 작은 클래스를 만들 수 있습니다.  
  
 먼저 호출 해야 합니다는 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>를 <xref:System.Net.Sockets.Socket.BeginAccept%2A>를 <xref:System.Net.Sockets.Socket.BeginConnect%2A>를 <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드. 그렇지 않으면 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 연결 지향 프로토콜을 사용 하는 경우는 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드는 무시 합니다 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 속성 및 송신 데이터를를 <xref:System.Net.EndPoint?displayProperty=nameWithType> 에 설정 된를 <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>를 <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드.  
  
 연결 없는 프로토콜을 사용 하는 경우에 기본 원격 호스트를 설정할 필요가 없습니다 합니다 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendToAsync%2A>입니다. 호출 하려는 경우이 작업을 수행 해야 합니다 <xref:System.Net.Sockets.Socket.BeginSend%2A> 또는 <xref:System.Net.Sockets.Socket.SendAsync%2A> 메서드. 호출 하는 경우는 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, 또는 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 메서드 호출 하기 전에 <xref:System.Net.Sockets.Socket.SendToAsync%2A>는 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 작업만 송신 하는 속성에서 지정 된 기본 원격 호스트를 덮어씁니다. 또한 필요는 없습니다를 호출 하는 <xref:System.Net.Sockets.Socket.Bind%2A> 메서드. 이 경우 기본 서비스 공급자는 가장 적절 한 로컬 네트워크 IP 주소 및 포트 번호를 할당 합니다. 기본 서비스 공급자가 사용 가능한 포트를 선택 하려는 경우 0의 포트 번호를 사용 합니다. 할당 된 로컬 네트워크 IP 주소와 포트 번호를 식별 해야 하는 경우 사용할 수 있습니다 합니다 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 후에는 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 이벤트가 신호를 받 및 연결 된 대리자가 호출 됩니다.  
  
 먼저 호출 해야 데이터 브로드캐스트 주소를 전송 하려는 경우는 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 메서드와 집합 소켓 옵션 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> true로 합니다. 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하지 않도록 수도 있어야 합니다. 이 경우 데이터 그램 전송 되지 것입니다 하 고 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 시킵니다를 <xref:System.Net.Sockets.SocketException>합니다.  
  
 DontRoute 플래그를 지정 하는 경우는 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 속성, 데이터 전송 라우팅되지 것입니다.  
  
 메시지 지향 소켓에 대 한 기본 전송의 최대 메시지 크기를 초과 필요가 주의 기울여 해야 합니다. 버퍼의 크기는 기본 서비스 공급자의 최대 패킷 크기를 초과 하면 데이터 그램 전송 되지 않습니다 하 고 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 시킵니다는 <xref:System.Net.Sockets.SocketException>합니다. 성공적으로 완료 된 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 메서드 데이터를 성공적으로 배달 된 나타내지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />가 null인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> 매개 변수에 지정된 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 개체를 사용하여 소켓 작업이 이미 진행 중인 경우</exception>
        <exception cref="T:System.NotSupportedException">이 메서드에 Windows XP 이상이 필요한 경우.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">연결 지향 프로토콜이 지정되었는데 <see cref="T:System.Net.Sockets.Socket" />이 아직 연결되지 않은 경우</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="level">이 소켓에 설정할 IP 보호 수준입니다.</param>
        <summary>소켓에 IP 보호 수준을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 제한 메서드를 사용 하면는 IPv6 또는 IP 소켓 주소와 같은 링크 로컬 또는 사이트 로컬 접두사가 같은 지정된 된 범위에서 수신 대기 하도록 합니다. 이 소켓 옵션에는 응용 프로그램을으로 IPv6 또는 IP 소켓에 액세스 제한을 적용할 수 있습니다. 이러한 제한을 사용하면 사설 LAN에서 실행되는 응용 프로그램을 간단하고 강력하게 외부 공격으로부터 보호할 수 있습니다. 이 소켓 옵션을 사용 하 여 액세스 제한을 제거 하는 경우에 수를 `level` 매개 변수는 설정 <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>합니다. 이 소켓 옵션을 통해 적절한 경우 공용 및 개인 사용자의 무제한 액세스를 허용하거나 필요에 따라 같은 사이트로만 액세스를 제한하여 수신 소켓의 범위를 넓히거나 좁힐 수 있습니다.  
  
 이 소켓 옵션은 <xref:System.Net.Sockets.IPProtectionLevel> 열거형에 지정된 보호 수준을 정의합니다.  
  
 합니다 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 메서드를 사용 하도록 설정 하거나 통과 NAT (Network Address)에 대 한 사용 하지 않도록를 사용 하는 <xref:System.Net.Sockets.Socket> 인스턴스. Teredo, 6to4 또는 ISATAP 터널을 사용 하 여 NAT 통과 제공할 수 있습니다.  
  
 경우는 `level` 매개 변수는 설정 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, 또는 <xref:System.Net.Sockets.IPProtectionLevel.Restricted>,이 명시적으로 사용 하지 않도록 설정에 대 한 NAT 통과 <xref:System.Net.Sockets.Socket> 인스턴스.  
  
 경우는 `level` 매개 변수는 설정 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>,이 수에 대 한 NAT 통과 <xref:System.Net.Sockets.Socket> 시스템에서 방화벽 규칙에 따라 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> 매개 변수는 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />일 수 없습니다. IP 보호 수준은 미지정으로 설정할 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">소켓의 설정은 <see cref="T:System.Net.Sockets.AddressFamily" />는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />여야 합니다.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 옵션을 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <param name="optionValue"><see cref="T:System.Boolean" />으로 나타낸 옵션 값입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 지정된 <see cref="T:System.Boolean" /> 값으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다. 설정 `optionValue` 하 `true` 옵션을 사용할 수 있도록 또는 `false` 옵션을 사용 하지 않도록 설정 합니다.  
  
 <xref:System.Net.Sockets.Socket> 옵션은 프로토콜 지원 수준에 따라 그룹화 됩니다.  
  
 다음은 다양 한 <xref:System.Net.Sockets.Socket> 이 오버 로드를 사용 하 여 설정할 수 있습니다. 이러한 옵션은 적절 한 별로 그룹화 됩니다 <xref:System.Net.Sockets.SocketOptionLevel> 값입니다. 이러한 옵션 중 하나를 설정 하려는 경우 사용 해야 적절 한 <xref:System.Net.Sockets.SocketOptionLevel> 에 대 한 값을 `optionLevel` 매개 변수입니다. 설정 하려는 옵션을 지정 해야 합니다 `optionName` 매개 변수입니다. 나열 된 옵션의 현재 값을 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 이러한 옵션에 대 한 자세한 내용은 참조는 <xref:System.Net.Sockets.SocketOptionName> 열거형입니다.  
  
> [!NOTE]
>  표시 되 면을 <xref:System.Net.Sockets.SocketException> 예외를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 소켓을 열고 사용 하도록 설정 합니다 `DontLinger` 하며 `OutOfBandInline` 소켓 옵션입니다.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 개체가 닫힌 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <param name="optionValue">해당 옵션 값을 나타내는 <see cref="T:System.Byte" /> 형식의 배열입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 바이트 배열로 나타내는 특정 값으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다. 이 오버 로드를 사용 하 여 설정 된 <xref:System.Net.Sockets.Socket> 옵션 값으로 바이트 배열을 필요로 하는 옵션입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Net.Sockets.LingerOption> 고 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값입니다.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <param name="optionValue">해당 옵션의 값입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 원하는 정수 값으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다. 옵션을 사용 하 여를 <xref:System.Boolean> 데이터 형식에 옵션을 사용 하도록 설정 하려면 0이 아닌 값 및 옵션을 사용 하지 않으려면 0을 지정 합니다. 정수 데이터 형식이 있는 옵션에 대 한 적절 한 값을 지정 합니다. <xref:System.Net.Sockets.Socket> 옵션은 프로토콜 지원 수준에 따라 그룹화 됩니다.  
  
 다음은 다양 한 <xref:System.Net.Sockets.Socket> 이 오버 로드를 사용 하 여 설정할 수 있습니다. 이러한 옵션은 적절 한 별로 그룹화 됩니다 <xref:System.Net.Sockets.SocketOptionLevel>합니다. 이러한 옵션 중 하나를 설정 하려는 경우 사용 해야 적절 한 <xref:System.Net.Sockets.SocketOptionLevel> 에 대 한는 `optionLevel` 매개 변수입니다. 설정 하려는 옵션을 지정 해야 합니다 `optionName` 매개 변수입니다. 나열 된 옵션의 현재 값을 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 이 오버 로드를 사용 하 여 설정할 수 있는 옵션입니다.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 이러한 옵션에 대 한 자세한 내용은 참조는 <xref:System.Net.Sockets.SocketOptionName> 열거형입니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Net.Sockets.LingerOption> 고 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값입니다.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 값 중 하나입니다.</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 값 중 하나입니다.</param>
        <param name="optionValue">해당 옵션의 값이 들어 있는 <see cref="T:System.Net.Sockets.LingerOption" /> 또는 <see cref="T:System.Net.Sockets.MulticastOption" />입니다.</param>
        <summary>지정된 <see cref="T:System.Net.Sockets.Socket" /> 옵션을 개체로 나타내는 특정 값으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 현재 동작을 결정 하는 옵션 <xref:System.Net.Sockets.Socket>합니다. 이 오버 로드를 사용 하 여 설정 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, 및 <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> 옵션입니다. 에 대 한 합니다 <xref:System.Net.Sockets.SocketOptionName.Linger> 옵션을 사용 하 여 <xref:System.Net.Sockets.Socket> 에 대 한는 `optionLevel` 매개 변수입니다. 에 대 한 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 하 고 <xref:System.Net.Sockets.SocketOptionName.DropMembership>를 사용 하 여 <xref:System.Net.Sockets.SocketOptionLevel.IP>입니다. 위에 나열 된 옵션의 현재 값을 사용 하려는 경우는 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 메서드.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Net.Sockets.LingerOption> 고 <xref:System.Net.Sockets.Socket.Send%2A> 제한 시간 값입니다.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">더 이상 허용하지 않을 작업을 지정하는 <see cref="T:System.Net.Sockets.SocketShutdown" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Net.Sockets.Socket" />에서 보내기 및 받기를 사용할 수 없도록 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결 지향를 사용 하는 경우 <xref:System.Net.Sockets.Socket>를 항상 호출 합니다 <xref:System.Net.Sockets.Socket.Shutdown%2A> 닫기 전에 메서드를 <xref:System.Net.Sockets.Socket>입니다. 이렇게 하면 모든 데이터가 전송 및 연결이 닫히기 전에 연결된 된 소켓에서 수신 합니다.  
  
 호출 된 <xref:System.Net.Sockets.Socket.Close%2A> 메서드를 사용 가능한 관리 및 연관 된 리소스를 관리 되지 않는 <xref:System.Net.Sockets.Socket>. 다시 사용 하지 마십시오는 <xref:System.Net.Sockets.Socket> 닫으면 합니다.  
  
 다음 표는 합니다 <xref:System.Net.Sockets.SocketShutdown> 에 대 한 유효한 열거형 값의 `how` 매개 변수입니다.  
  
|값|설명|  
|-----------|-----------------|  
|보내기|이 비활성화 <xref:System.Net.Sockets.Socket>합니다.|  
|받기|수신이를 사용 하지 않도록 설정 <xref:System.Net.Sockets.Socket>합니다.|  
|Both|보내기 및 받기에 모두 사용 하지 않도록 설정 <xref:System.Net.Sockets.Socket>합니다.|  
  
 설정 `how` 하 <xref:System.Net.Sockets.SocketShutdown.Send> 다음에 대 한 호출 <xref:System.Net.Sockets.Socket.Send%2A> 허용 되지 않습니다. 연결을 사용 하는 경우 <xref:System.Net.Sockets.Socket>지정, <xref:System.Net.Sockets.SocketShutdown.Send> 영향을 주지 것입니다.  
  
 설정 `how` 하 <xref:System.Net.Sockets.SocketShutdown.Receive> 다음에 대 한 호출 <xref:System.Net.Sockets.Socket.Receive%2A> 허용 되지 않습니다. 하위 프로토콜 계층에서 효과가 없습니다. 다음 조건 중 하나를 호출한 후 존재 하는 경우 연결이 종료 되며 연결 지향 프로토콜을 사용 하는 경우 <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   데이터는 수신 대기 중인 들어오는 네트워크 버퍼입니다.  
  
-   더 많은 데이터가 전송 되었습니다.  
  
 연결 없는 프로토콜을 사용 중인 데이터 그램 허용 되며 큐에 대기 됩니다. 그러나 버퍼 공간이 추가로 들어오는 데이터 그램에 대 한 사용 가능한 경우 이러한 삭제 되 고 보낸 사람에 게 오류가 반환 됩니다. 사용 하 여 <xref:System.Net.Sockets.Socket.Shutdown%2A> 연결에 <xref:System.Net.Sockets.Socket> 권장 되지 않습니다.  
  
 설정 `how` 에 <xref:System.Net.Sockets.SocketShutdown.Both> 모두 보냅니다를 사용 하지 않도록 설정 하 고 위에서 설명한 것 처럼 수신 합니다.  
  
> [!NOTE]
>  수신 되 면를 <xref:System.Net.Sockets.SocketException> 호출할 때 합니다 <xref:System.Net.Sockets.Socket.Shutdown%2A> 메서드를 사용 하 여는 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 특정 오류 코드를 가져오는 속성입니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.Shutdown%2A> 사용 하지 않도록 설정 하 여 <xref:System.Net.Sockets.Socket>입니다.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />의 형식을 가져옵니다.</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 읽기 전용 이며 경우 설정 됩니다는 <xref:System.Net.Sockets.Socket> 만들어집니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, 및 <xref:System.Net.Sockets.ProtocolType> 콘솔.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IPv4 지원이 사용 가능하며 현재 호스트에서 사용하도록 설정되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 호스트에서 IPv4 프로토콜을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Framework에서 더 이상 사용되지 않는 특정 <see cref="T:System.Net.Dns" /> 멤버에 대해 IPv6을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>Framework에서 더 이상 사용되지 않는 특정 <see cref="T:System.Net.Dns" /> 메서드에 대해 IPv6을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 운영 체제는 IPv4 및 IPv6 프로토콜을 지원할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
완료 했으면 IDisposable.Dispose 호출를 사용 하 여는 <xref:System.Net.Sockets.Socket>합니다. IDisposable.Dispose 메서드는 <xref:System.Net.Sockets.Socket> 불안정 한 상태가 됩니다. IDisposable.Dispose를 호출한 후에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Net.Sockets.Socket> 가비지 수집기에서 메모리를 회수할 수 있도록 하는 <xref:System.Net.Sockets.Socket> 차지한 합니다. 자세한 내용은 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 하 고 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.

> [!NOTE] 
> 에 대 한 마지막 참조를 해제 하기 전에 항상 IDisposable.Dispose를 호출 합니다 <xref:System.Net.Sockets.Socket>합니다. 이렇게 하지 않으면 가비지 컬렉션이 <xref:System.Net.Sockets.Socket> 개체의 `Finalize` 메서드를 호출할 때까지 사용 중인 리소스가 해제되지 않습니다.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" />에서 보낸 IP(인터넷 프로토콜) 패킷의 TTL(Time-To-Live) 값을 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>TTL 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 값은 라우터 라우터 패킷 및는 제어 메시지 ICMP (Internet Protocol) "TTL 초과"를 삭제 하기 전에 패킷이 이동할 수의 최대 수를 나타내는 오류 메시지가 보낸 사람에 게 반환 됩니다.  
  
 TTL 값은 0 ~ 255 값으로 설정할 수 있습니다. 이 속성은 설정 되지 않은 경우에 소켓에 대 한 기본 TTL 값은 32입니다.  
  
 프로토콜 TCP (Transmission Control) 소켓에서이 속성을 설정할 연결에 성공 하면 소켓을 사용 하 여 설정 된 경우 TCP/IP 스택을 무시 됩니다.  
  
 수신 되 면를 <xref:System.Net.Sockets.SocketException>를 사용 하 여를 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 속성을 특정 오류 코드를 가져옵니다. 이 코드를 가져온 후에 참조를 [Windows 소켓 버전 2 API 오류 코드](/windows/desktop/winsock/windows-sockets-error-codes-2) 오류의 자세한 설명에 대 한 설명서입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.Sockets.Socket.Ttl%2A> 속성입니다.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 값은 음수로 설정할 수 있습니다.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 또는 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 패밀리의 소켓이 아닌 소켓에 대해 이 속성을 설정한 경우</exception>
        <exception cref="T:System.Net.Sockets.SocketException">소켓에 액세스하는 동안 오류가 발생했습니다. TTL을 255보다 큰 값으로 설정하고자 할 때에도 이 오류가 반환됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />이 닫혔습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>소켓에서 중첩된 I/O 모드만 사용해야 하는지 여부를 지정합니다.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" />에서 중첩된 I/O 모드만 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 에 대 한는 <xref:System.Net.Sockets.Socket> 호출 하려는 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>합니다. 프레임 워크는 사용을 금지 하는 소켓 완료 포트를 할당할 수 있습니다이 고, 그렇지 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">소켓이 완료 포트에 바인딩된 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>