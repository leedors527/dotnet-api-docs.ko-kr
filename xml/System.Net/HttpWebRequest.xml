<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6513eb09c9c682954c909cdc6924cf4c2c9f593" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58690259" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Net.WebRequest" /> 클래스의 HTTP 관련 구현을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  사용 하는 것이 바람직하지 `HttpWebRequest` 새로운 개발에 대 한 합니다. 대신는 <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> 클래스입니다.

 합니다 <xref:System.Net.HttpWebRequest> 에 정의 된 메서드 및 클래스 속성에 대 한 지원을 제공 <xref:System.Net.WebRequest> 및 추가 속성 및 HTTP를 사용 하 여 서버와 직접 상호 작용할 수 있도록 하는 방법에 대 한 합니다.  
  
 사용 하지 마십시오는 <xref:System.Net.HttpWebRequest.%23ctor%2A> 생성자입니다. 사용 된 <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> 새로운 초기화 하는 방법 <xref:System.Net.HttpWebRequest> 개체입니다. 경우에 리소스 URI (Uniform Identifier) 체계 `http://` 또는 `https://`를 <xref:System.Net.WebRequest.Create%2A> 반환는 <xref:System.Net.HttpWebRequest> 개체입니다.  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> 에 지정 된 리소스 요청 동기 메서드를 <xref:System.Net.HttpWebRequest.RequestUri%2A> 속성과 반환을 <xref:System.Net.HttpWebResponse> 응답 개체를 포함 하는 합니다. 반환한 스트림을 사용 하 여 응답 데이터를 받을 수 <xref:System.Net.HttpWebResponse.GetResponseStream%2A>입니다. 응답 개체 또는 응답 스트림이 닫혀 있는 경우 데이터를 나머지 몰수 됩니다. 나머지 데이터를 배출할 수는 있으며 다음 조건을 포함 하는 경우 응답 개체 또는 스트림을 닫을 때 소켓 후속 요청에 다시 사용 됩니다: keep-alive 또는 파이프라인 요청, 적은 양의 데이터를 받을 수 해야 하는 경우 또는 남은 데이터는 짧은 시간에 수신 됩니다. 보관에서 언급 한 조건이 하나도 없는 경우 드레이닝 시간이 초과 하는 소켓을 닫습니다. Keep-alive 또는 파이프라인 연결에 대 한 EOF 될 때까지 응용 프로그램의 스트림을 읽습니다 하는 것이 좋습니다. 이렇게 하면 소켓 성능 향상에 덜 사용 되는 리소스를 생성 하는 후속 요청에 대해 다시 사용 됩니다.  
  
 리소스에 데이터를 전송 하려는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드가 반환 되는 <xref:System.IO.Stream> 개체를 사용 하 여 데이터를 보냅니다. 합니다 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 고 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드는 송신 데이터 스트림에 대 한 비동기 액세스를 제공 합니다.  
  
 클라이언트 인증에 <xref:System.Net.HttpWebRequest>, 클라이언트 인증서를 설치 해야 합니다는 현재 사용자의 개인 인증서 저장소입니다.  
  
 합니다 <xref:System.Net.HttpWebRequest> throw 클래스는 <xref:System.Net.WebException> 리소스에 액세스 하는 동안 오류가 발생 한 경우. 합니다 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> 속성에 포함을 <xref:System.Net.WebExceptionStatus> 오류의 출처를 나타내는 값입니다. 때 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> 은 <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>의 <xref:System.Net.WebException.Response%2A> 속성을 포함 합니다 <xref:System.Net.HttpWebResponse> 리소스에서 받은 합니다.  
  
 <xref:System.Net.HttpWebRequest> 메서드를 설정 하거나 시스템을 설정한 속성으로 인터넷 리소스에 전송 일반 HTTP 헤더 값을 표시 합니다. 다음 표에서 전체 목록을 보여 줍니다. 다른 헤더를 설정할 수 있습니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 이름/값 쌍으로 합니다. 참고 서버 및 캐시가 변경 될 수 있습니다 하거나 요청 하는 동안 헤더를 추가 합니다.  
  
 다음 표에서 속성, 메서드 또는 시스템에 의해 설정 된 HTTP 헤더를 나열 합니다.  
  
|Header|설정한|  
|------------|------------|  
|허용|설정한는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성입니다.|  
|연결|으로 설정 합니다 <xref:System.Net.HttpWebRequest.Connection%2A> 속성인 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성입니다.|  
|Content-Length|설정한는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성입니다.|  
|콘텐츠 형식|설정한는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성입니다.|  
|예상|설정한는 <xref:System.Net.HttpWebRequest.Expect%2A> 속성입니다.|  
|날짜|현재 날짜를 시스템으로 설정 합니다.|  
|호스트|현재 호스트 정보를 시스템으로 설정 합니다.|  
|If-수정-이후|설정한는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다.|  
|범위|설정한는 <xref:System.Net.HttpWebRequest.AddRange%2A> 메서드.|  
|참조 자|설정한는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성입니다.|  
|전송 인코딩|으로 설정 합니다 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성 (합니다 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성 이어야 합니다 `true`).|  
|사용자 에이전트|설정한는 <xref:System.Net.HttpWebRequest.UserAgent%2A> 속성입니다.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> 자동으로 등록 됩니다. 호출할 필요가 없습니다 합니다 <xref:System.Net.WebRequest.RegisterPrefix%2A> 등록 하는 방법 <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> Uri를 사용 하기 전에 부터는 `http://` 또는 `https://`합니다.  
  
 로컬 컴퓨터 또는 응용 프로그램 구성 파일을 기본 프록시를 사용할 수 있는지 지정할 수 있습니다. 경우는 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성을 지정 하면에서 프록시 설정을 <xref:System.Net.HttpWebRequest.Proxy%2A> 로컬 컴퓨터 또는 응용 프로그램 구성 파일을 재정의 하는 속성 및 <xref:System.Net.HttpWebRequest> 인스턴스는 지정 된 프록시 설정을 사용 합니다. 구성 파일에 없는 프록시를 지정 하는 경우 및 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성이 지정 되어 있지는 <xref:System.Net.HttpWebRequest> 클래스에서에서 상속 되며, Internet Explorer 로컬 컴퓨터의 프록시 설정을 사용 합니다. Internet Explorer의 프록시 설정이 없는 경우 요청이 서버로 직접 전송 됩니다.  
  
 <xref:System.Net.HttpWebRequest> 클래스에서에서 상속 되며, Internet Explorer 다르게 바이패스 목록에는 Internet Explorer에서 직접 구문 분석 하는 보다 와일드 카드 문자를 사용 하 여 프록시 바이패스 목록이 구문 분석 합니다. 예를 들어를 <xref:System.Net.HttpWebRequest> 클래스는 정규식으로 구문 분석 바이패스 목록이 "nt *" Internet Explorer에서 "nt. $"입니다. 이 Internet Explorer의 기본 동작에서 서로 다릅니다. 따라서 URL "`http://intxxxxx`"을 사용 하 여 프록시를 무시는 <xref:System.Net.HttpWebRequest> 클래스 하지만 Internet Explorer를 사용 하 여 프록시를 바이패스는 합니다.  
  
> [!NOTE]
>  프레임 워크를 만들 때 SSL 세션을 캐시 하 고 가능한 경우 새 요청에 대 한 캐시 된 세션을 사용 하려고 합니다. SSL 세션을 다시 사용 하려고 시도할 때, 프레임 워크의 첫 번째 요소를 사용 하는 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (있는 경우 하나) 하는 경우에 익명 세션을 다시 사용 하려고 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> 비어 있습니다.  
  
> [!NOTE]
>  쿠키는 보안상의 이유로 기본적으로 비활성화 됩니다. 사용 하 여 쿠키를 사용 하려는 경우는 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 쿠키를 사용 하도록 설정 하려면 속성입니다.  
  
 .NET Framework 4.6에는 안전 하지 않은 암호화 및 해시 알고리즘에 대 한 연결을 차단 하는 새로운 보안 기능이 포함 됩니다. 응용 프로그램 및 HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream 등 Api 통해 TLS/SSL을 사용 하 여.NET Framework 4.6을 대상으로 하는 기본적으로는 더 안전한 동작을 가져옵니다.  
  
 개발자는 RC4 서비스를 지 원하는 기존 SSL3 서비스 또는 TLS와의 상호 운용성을 유지 하기 위해이 동작을 옵트아웃 하려면 원할 수 있습니다. [이 문서에서는](https://support.microsoft.com/kb/3069494) 새 동작 사용 되지 않도록 코드를 수정 하는 방법에 설명 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Net.HttpWebRequest> uri http://www.contoso.com/합니다.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">요청된 된 URI 또는 URI에 요청을 리디렉션할에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">버전 3.5 SP1에서에서 HTTPWebRequest에 대 한 NTLM 인증 변경 내용</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.HttpWebRequest" /> 클래스의 새 인스턴스를 초기화합니다. 이 생성자는 사용되지 않습니다. 자세한 내용은 설명 섹션을 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

둘 다 <xref:System.Net.HttpWebRequest> 생성자는 사용 되지 않으며 사용 하지 않아야 합니다. 호출을 <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> 새로운 초기화 방법 <xref:System.Net.HttpWebRequest> 개체입니다.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.HttpWebRequest" /> 클래스의 새 인스턴스를 초기화합니다. 이 생성자는 사용되지 않습니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">새 <see cref="T:System.Net.HttpWebRequest" /> 개체를 serialize하는 데 필요한 정보가 들어 있는 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체입니다.</param>
        <param name="streamingContext">새 <see cref="T:System.Net.HttpWebRequest" /> 개체와 관련되어 있는 serialize된 스트림의 소스 및 대상이 들어 있는 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 개체입니다.</param>
        <summary><see cref="T:System.Net.HttpWebRequest" />와 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 클래스에 지정된 인스턴스에서 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 클래스의 새 인스턴스를 초기화합니다. 이 생성자는 사용되지 않습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialization을 사용 하는 경우 응용 프로그램은 완전 신뢰 모드로 실행 해야 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">네트워크 리소스에 무제한 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 및 SOAP Serialization</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>인터넷 리소스에 대한 요청을 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> 메서드 리소스 요청을 취소 합니다. 요청을 취소 된 후 호출을 <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, 또는 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드를 사용 하면을 <xref:System.Net.WebException> 사용 하 여를 <xref:System.Net.WebException.Status%2A> 속성이로 설정 <xref:System.Net.WebExceptionStatus.RequestCanceled>합니다.  
  
 <xref:System.Net.HttpWebRequest.Abort%2A> 메서드를 지정 된 콜백이 동기적으로 실행 합니다 합니다 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 경우는 <xref:System.Net.HttpWebRequest.Abort%2A> 이러한 작업 중 하나는 처리 중인 호출 됩니다. 잠재적인 교착 상태 문제가 발생할 수 있습니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [네트워크 추적](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)합니다.  
  
   
  
## Examples  
 비동기 요청의 경우 것은 자체 제한 시간 메커니즘을 구현 하는 클라이언트 응용 프로그램의 책임입니다. 다음 코드 예제에서는이 작업을 수행 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Accept" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Accept" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 선택을 취소 합니다 `Accept` HTTP 헤더를 설정 합니다 <xref:System.Net.HttpWebRequest.Accept%2A> 속성을 `null`.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요청에 범위 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">범위의 시작점이나 끝점입니다.</param>
        <summary>요청된 데이터의 시작이나 끝에서 특정 범위에 대해 바이트 범위 헤더를 요청에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청 바이트 범위 헤더를 추가 합니다.  
  
 하는 경우 `range` 이 양수인 경우는 `range` 매개 변수 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야 합니다 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 하는 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에 HTTP 엔터티에서 데이터의 시작 부분에서 데이터를 보내기 시작 해야 합니다 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 예제 (99 바이트 위치로 시작)에서 처음 100 바이트가 전송 하도록 서버에는 다음 것을 요청 하는 HTTP 프로토콜 요청에 범위 헤더입니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 예를 들어를 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 요청에 범위 헤더를 추가합니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">범위의 시작점이나 끝점입니다.</param>
        <summary>요청된 데이터의 시작이나 끝에서 특정 범위에 대해 바이트 범위 헤더를 요청에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청 바이트 범위 헤더를 추가 합니다.  
  
 하는 경우 `range` 이 양수인 경우는 `range` 매개 변수 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야 합니다 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 하는 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에 HTTP 엔터티에서 데이터의 시작 부분에서 데이터를 보내기 시작 해야 합니다 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 예제 (99 바이트 위치로 시작)에서 처음 100 바이트가 전송 하도록 서버에는 다음 것을 요청 하는 HTTP 프로토콜 요청에 범위 헤더입니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 예를 들어를 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="from">데이터를 보내기 시작하는 위치입니다.</param>
        <param name="to">데이터 보내기를 중지하는 위치입니다.</param>
        <summary>지정된 범위에 대해 요청에 바이트 범위 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청 바이트 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 예를 들어 합니다 `from` 매개 변수는 0으로 지정 하며 `to` 매개 변수는 99로 지정 됩니다. 자동 범위 지정 자가이 메서드에서 "bytes"으로 설정 됩니다.  
  
 HTTP 서버 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 요청에 범위 헤더를 추가합니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />이 <paramref name="to" />보다 큰 경우  
  
또는 
 <paramref name="from" /> 또는 <paramref name="to" />가 0 미만입니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="from">데이터를 보내기 시작하는 위치입니다.</param>
        <param name="to">데이터 보내기를 중지하는 위치입니다.</param>
        <summary>지정된 범위에 대해 요청에 바이트 범위 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청 바이트 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 예를 들어 합니다 `from` 매개 변수는 0으로 지정 하며 `to` 매개 변수는 99로 지정 됩니다. 자동 범위 지정 자가이 메서드에서 "bytes"으로 설정 됩니다.  
  
 HTTP 서버 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />이 <paramref name="to" />보다 큰 경우  
  
또는 
 <paramref name="from" /> 또는 <paramref name="to" />가 0 미만입니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">범위에 대한 설명입니다.</param>
        <param name="range">범위의 시작점이나 끝점입니다.</param>
        <summary>요청된 데이터의 시작이나 끝에서 특정 범위에 대한 요청에 Range 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 하는 경우 `range` 이 양수인 경우는 `range` 매개 변수 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야 합니다 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 하는 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에 HTTP 엔터티에서 데이터의 시작 부분에서 데이터를 보내기 시작 해야 합니다 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로 지정 될 "bytes", 대부분의 HTTP 서버에서 인식 되는 유일한 범위 지정자 이기 때문입니다. 설정 된 `rangeSpecifier` 매개 변수를 다른 문자열을 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 사용자 지정 범위 지정자 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=-99\r\n\r\n`  
  
 예를 들어 합니다 `rangeSpecifier` 매개 변수는 "bytes"로 지정 됩니다 및 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 응답에서 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="range" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">범위에 대한 설명입니다.</param>
        <param name="range">범위의 시작점이나 끝점입니다.</param>
        <summary>요청된 데이터의 시작이나 끝에서 특정 범위에 대한 요청에 Range 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 하는 경우 `range` 이 양수인 경우는 `range` 매개 변수 범위의 시작 지점을 지정 합니다. 서버에서 데이터를 보내기 시작 해야 합니다 `range` HTTP 엔터티에서 데이터의 끝에 지정 된 매개 변수입니다.  
  
 하는 경우 `range` 가 음수 이면는 `range` 매개 변수는 끝점의 범위를 지정 합니다. 서버에 HTTP 엔터티에서 데이터의 시작 부분에서 데이터를 보내기 시작 해야 합니다 `range` 매개 변수를 지정 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로 지정 될 "bytes", 대부분의 HTTP 서버에서 인식 되는 유일한 범위 지정자 이기 때문입니다. 설정 된 `rangeSpecifier` 매개 변수를 다른 문자열을 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 사용자 지정 범위 지정자 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=-99\r\n\r\n`  
  
 예를 들어 합니다 `rangeSpecifier` 매개 변수는 "bytes"로 지정 됩니다 및 `range` 매개 변수-99 것입니다.  
  
 HTTP 서버 응답에서 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="from" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">범위에 대한 설명입니다.</param>
        <param name="from">데이터를 보내기 시작하는 위치입니다.</param>
        <param name="to">데이터 보내기를 중지하는 위치입니다.</param>
        <summary>지정된 범위에 대해 요청에 범위 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로 지정 될 "bytes", 대부분의 HTTP 서버에서 인식 되는 유일한 범위 지정자 이기 때문입니다. 설정 된 `rangeSpecifier` 매개 변수를 다른 문자열을 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 사용자 지정 범위 지정자 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 예를 들어 합니다 `rangeSpecifier` 매개 변수를 "bytes"으로 지정 됩니다 합니다 `from` 매개 변수를 0이 됩니다 및 `to` 매개 변수는 99 것입니다.  
  
 HTTP 서버 응답에서 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더에 지정 된 문자열은에 의해 지정 되는 범위 지정자는 `rangeSpecifier` 이 메서드에 대 한 매개 변수입니다.  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />이 <paramref name="to" />보다 큰 경우  
  
또는 
 <paramref name="from" /> 또는 <paramref name="to" />가 0 미만입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="from" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="to" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">범위에 대한 설명입니다.</param>
        <param name="from">데이터를 보내기 시작하는 위치입니다.</param>
        <param name="to">데이터 보내기를 중지하는 위치입니다.</param>
        <summary>지정된 범위에 대해 요청에 범위 헤더를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> 메서드 요청에 범위 헤더를 추가 합니다.  
  
 모든 HTTP 엔터티가 표시 되는 HTTP 메시지의 바이트 시퀀스로 바이트 범위 개념 이므로 모든 HTTP 엔터티에 대 한 의미 합니다. 그러나 일부 클라이언트 및 서버에서 바이트 범위 작업을 지원 해야 합니다.  
  
 요청에 범위 헤더 클라이언트가 요청 하려고 한다는 것만 HTTP 엔터티의 일부 지정 된 범위의 바이트를 수신 하는 데 사용 합니다. 서버 범위 헤더 요청을 지원할 필요가 없습니다.  
  
 `rangeSpecifier` 매개 변수는 일반적으로 지정 될 "bytes", 대부분의 HTTP 서버에서 인식 되는 유일한 범위 지정자 이기 때문입니다. 설정 된 `rangeSpecifier` 매개 변수를 다른 문자열을 바이트 (ietf RFC 2616에 정의 된 바이트 범위 지정자) 이외의 사용자 지정 범위 지정자 지원할 수 있게 합니다.  
  
 처음 100 바이트가 요청 될 HTTP 프로토콜 요청에 범위 헤더의 예는 다음과 같습니다.  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 예를 들어 합니다 `rangeSpecifier` 매개 변수를 "bytes"으로 지정 됩니다 합니다 `from` 매개 변수를 0이 됩니다 및 `to` 매개 변수는 99 것입니다.  
  
 HTTP 서버 응답에서 Accept-ranges 헤더를 사용 하 여 범위 헤더에 대 한 지원을 나타냅니다. 바이트 범위를 지 원하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 헤더에 지정 된 문자열은에 의해 지정 되는 범위 지정자는 `rangeSpecifier` 이 메서드에 대 한 매개 변수입니다.  
  
 Accept-ranges 헤더를 서버에서 응답의 헤더에 수신 되지 않으면, 다음 서버 범위 헤더를 지원 하지 않습니다. 범위를 지원 하지 않지만 Accept-ranges 헤더를 인식 하는 서버에서 Accept-ranges 헤더의 예제는 다음과 같을 수 됩니다.  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 전체 요청과 연관 된 HTTP 헤더만 구문 분석 되 고 속성을 통해 사용 가능 범위 요청에서 응답을 받을 때의 <xref:System.Net.HttpWebResponse> 클래스입니다. 각 범위와 연결 된 헤더는 응답에 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" />이 <paramref name="to" />보다 큰 경우  
  
또는 
 <paramref name="from" /> 또는 <paramref name="to" />가 0 미만입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" />이 잘못되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException">범위 헤더를 추가할 수 없습니다.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 실제로 응답하는 인터넷 리소스의 URI(Uniform Resource Identifier)를 가져옵니다.</summary>
        <value>요청에 실제로 응답하는 인터넷 리소스를 식별하는 <see cref="T:System.Uri" />입니다. 기본값은 요청을 초기화하기 위해 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 메서드가 사용한 URI입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> 속성을 요청 하는 동안 발생 하는 모든 리디렉션이 완료 된 후 URI로 설정 합니다.  
  
 원래 요청의 URI에 유지 되는 <xref:System.Net.HttpWebRequest.RequestUri%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 확인 하는 <xref:System.Net.HttpWebRequest> 개체 `req` 이 요청을 다른 위치로 리디렉션되고의 값을 설정 합니다 `hasChanged` 변수를 `true` 요청이 리디렉션된; 경우이 고 그렇지 `hasChanged`로 설정 된 `false`합니다.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청이 리디렉션 응답을 따르는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>요청이 인터넷 리소스의 리디렉션 응답을 자동으로 따르면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정할 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 에 `true` 리소스의 새 위치로 HTTP 리디렉션 헤더를 자동으로 수행 하려면 요청 하려는 경우. 최대 리디렉션 수는 설정한는 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> 속성입니다.  
  
 하는 경우 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 로 설정 된 `false`, 399 300의 HTTP 상태 코드를 사용 하 여 모든 응답은 응용 프로그램에 반환 됩니다.  
  
 자동 리디렉션 시 권한 부여 헤더의 선택을 취소 하 고 <xref:System.Net.HttpWebRequest> 자동으로 다시 리디렉션된 위치에 인증 하려고 합니다. 즉 실제로에서 리디렉션이 발생할 수 있으면 응용 프로그램 권한 부여 헤더에 사용자 지정 인증 정보를 넣을 수 없습니다. 대신, 응용 프로그램을 구현 하 고 사용자 지정 인증 모듈을 등록 해야 합니다. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> 관련된 클래스는 사용자 지정 인증 모듈을 구현 하는 데 사용 됩니다. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> 메서드는 사용자 지정 인증 모듈을 등록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 리디렉션 응답을 수행 하려면 요청을 허용 하는 속성입니다.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인터넷 리소스에서 받은 데이터를 버퍼링할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에서 받은 데이터를 버퍼링하려면 <see langword="true" />이고, 버퍼링하지 않으려면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인터넷 리소스에 보낸 데이터를 버퍼링할 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에 보낸 데이터를 버퍼링할 수 있게 하려면 <see langword="true" />이고, 버퍼링할 수 없게 하려면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> 는 `true`, 요청 리디렉션 또는 인증 시 다시 전송에 사용할 준비가 되도록 데이터를 메모리에 버퍼링 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> 속성 데이터 버퍼링을 사용 하지 않도록 설정 합니다.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>데이터 버퍼에서 사용 가능한 모든 메모리를 사용할 수 있기 때문에 큰 데이터 세트를 업로드 하는 경우 <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />을 <see langword="true" />로 설정하면 성능 문제가 발생할 수 있습니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>압축을 푸는 데 사용할 형식을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Net.DecompressionMethods" /> 사용 되는 압축 유형을 나타내는 개체입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">개체의 현재 상태는 이 속성을 설정하도록 허용하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자입니다.</param>
        <param name="state">이 요청에 대한 상태 개체입니다.</param>
        <summary>데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" /> 개체에 대한 비동기 요청을 시작합니다.</summary>
        <returns>비동기 요청을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 에 대 한 데이터를 보내는 데 스트림에 대 한 비동기 요청을 시작 하는 메서드는 <xref:System.Net.HttpWebRequest>합니다. 비동기 콜백 메서드를 사용 하 여 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 실제 스트림을 반환 하는 방법입니다.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드 전에이 메서드는 비동기 됩니다 (DNS 확인, 프록시 검색 및 예제에 대 한 TCP 소켓 연결)를 완료 하려면 몇 가지 동기 설치 작업에 필요 합니다. 결과적으로,이 메서드가 호출 되 면 안 사용자 인터페이스 (UI) 스레드에서 오류가 발생 한 예외가 전에 동기 방식으로 초기 설정 작업을 완료 하려면 네트워크 설정에 따라 몇 분) (최대 상당한 시간을 걸릴 수 있으므로 또는 메서드가 성공 합니다.  
  
 스레드 풀에 대 한 자세한 내용은 참조 하세요 [관리 되는 스레드 풀](~/docs/standard/threading/the-managed-thread-pool.md)합니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 를 사용 해야 메서드는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 응답을 검색 하는 방법.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 스트림 인스턴스에 대 한 비동기 요청을 확인 하는 방법입니다.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 속성이 GET 또는 HEAD인 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />가 <see langword="true" />이고, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />이 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 -1이고, <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.Method" />가 POST 또는 PUT인 경우</exception>
        <exception cref="T:System.InvalidOperationException">스트림이 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />에 대한 이전 호출에서 사용되고 있는 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />이 값으로 설정되었으며 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />입니다.  
  
또는 
스레드 풀에 스레드가 부족합니다.</exception>
        <exception cref="T:System.NotSupportedException">요청 캐시 유효성 검사기에서 이 요청에 대한 응답이 캐시에서 제공될 수 있지만 데이터를 쓰는 요청의 경우 캐시를 사용하지 않아야 함을 나타내는 경우. 이 예외는 제대로 구현되지 않은 사용자 지정 캐시 유효성 검사기를 사용하려는 경우에 발생할 수 있습니다.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">.NET Compact Framework 응용 프로그램에서 콘텐츠 길이가 0인 요청 스트림을 올바르게 가져오고 닫지 않은 경우. 콘텐츠 길이가 0인 요청을 처리하는 방법에 대한 자세한 내용은 [.NET Compact Framework의 네트워크 프로그래밍](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)을 참조하세요.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 대리자</param>
        <param name="state">이 요청에 대한 상태 개체입니다.</param>
        <summary>인터넷 리소스에 대한 비동기 요청을 시작합니다.</summary>
        <returns>응답에 대한 비동기 요청을 참조하는 <see cref="T:System.IAsyncResult" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 인터넷 리소스에서 응답에 대 한 비동기 요청을 시작 합니다. 비동기 콜백 메서드를 사용 하 여 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 실제 반환 하는 방법 <xref:System.Net.WebResponse>합니다.  
  
 A <xref:System.Net.ProtocolViolationException> 속성을 설정 하는 경우 여러 경우에 throw 되는 <xref:System.Net.HttpWebRequest> 충돌 하는 클래스입니다. 응용 프로그램을 설정 하는 경우이 예외가 발생 합니다 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 및 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true`, HTTP GET 요청을 보냅니다. 응용 프로그램이이 지원 되지 않습니다만 HTTP 1.0 프로토콜을 지 원하는 서버에 청크 분할 전송 하려고 하는 경우이 예외가 발생 합니다. 응용 프로그램에서 설정 하지 않고 데이터를 전송 하려고 하는 경우이 예외가 발생 합니다 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 또는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 됩니다 `false` keepalive 연결에 버퍼링 사용 하지 않도록 설정 하는 경우 및 (합니다 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`)`.`  
  
 경우는 <xref:System.Net.WebException> 는 throw를 사용 합니다 <xref:System.Net.WebException.Response%2A> 및 <xref:System.Net.WebException.Status%2A> 서버에서 응답을 확인 하려면 예외의 속성.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드 전에이 메서드는 비동기 됩니다 (DNS 확인, 프록시 검색 및 예제에 대 한 TCP 소켓 연결)를 완료 하려면 몇 가지 동기 설치 작업에 필요 합니다. 결과적으로,이 메서드가 호출 되 면 안 사용자 인터페이스 (UI) 스레드에서 오류가 발생 한 예외가 전에 동기 방식으로 초기 설정 작업을 완료 하려면 네트워크 설정에 따라 몇 분) (최대 상당한 시간을 걸릴 수 있으므로 또는 메서드가 성공 합니다.  
  
 스레드 풀에 대 한 자세한 내용은 참조 하세요 [관리 되는 스레드 풀](~/docs/standard/threading/the-managed-thread-pool.md)합니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 를 사용 해야 메서드는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 응답을 검색 하는 방법.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 인터넷 리소스에 대 한 비동기 요청을 수행 하는 방법입니다.  
  
> [!NOTE]
>  비동기 요청의 경우 것은 자체 제한 시간 메커니즘을 구현 하는 클라이언트 응용 프로그램의 책임입니다. 다음 코드 예제에는 작업을 수행 하는 방법을 보여 줍니다.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 스트림은 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />에 대한 이전 호출에서 이미 사용 중입니다.  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />이 값으로 설정되었으며 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />입니다.  
  
또는 
스레드 풀에 스레드가 부족합니다.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" />가 GET 또는 HEAD이고 <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 0보다 크거나 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="true" />입니다.  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />가 <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />이 <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />, 그리고 <see cref="P:System.Net.HttpWebRequest.Method" />가 POST 또는 PUT입니다.  
  
또는 
<see cref="T:System.Net.HttpWebRequest" />에 엔터티 본문이 있지만 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 메서드를 호출하지 않고 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 메서드가 호출되었습니다.  
  
또는 
<see cref="P:System.Net.HttpWebRequest.ContentLength" />가 0보다 크지만 애플리케이션에서 약속된 모든 데이터를 쓰지 않습니다.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청과 관련된 보안 인증서의 컬렉션을 가져오거나 설정합니다.</summary>
        <value>이 요청과 연결된 보안 인증서를 포함하는 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램을 컬렉션에 인증서를 추가할 수 있지만에 액세스 권한이 없을 수 있습니다. 컬렉션에 포함 된 인증서를 사용 하려면 응용 프로그램에 인증서를 발급 한 엔터티를 동일한 액세스 권한이 있어야 합니다.  
  
> [!NOTE]
>  프레임 워크를 만들 때 SSL 세션을 캐시 하 고 가능한 경우 새 요청에 대 한 캐시 된 세션을 사용 하려고 합니다. SSL 세션을 다시 사용 하려고 시도할 때, 프레임 워크의 첫 번째 요소를 사용 하는 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (있는 경우 하나) 하는 경우에 익명 세션을 다시 사용 하려고 <xref:System.Net.HttpWebRequest.ClientCertificates%2A> 비어 있습니다.  
  
> [!NOTE]
>  클라이언트 인증서를를 추가 하면 안 성능상의 이유로 <xref:System.Net.HttpWebRequest> 서버에 대 한 요청은 알 수 없는 경우.  
>   
>  클라이언트 인증서 저장소에 인증서를 열거 하는 방법을 보여 주는 코드 예제를 참조 하세요.를 <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Set 작업에 대해 지정된 값이 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Connection" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Connection" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요청을 보냅니다 합니다 <xref:System.Net.HttpWebRequest.Connection%2A> 속성으로 인터넷 리소스에는 `Connection` HTTP 헤더입니다. 경우의 값을 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`, "유지" 값의 끝에 추가 됩니다는 `Connection` 헤더입니다.  
  
 선택을 취소 합니다 `Connection` HTTP 헤더를 설정 합니다 <xref:System.Net.HttpWebRequest.Connection%2A> 속성을 `null`.  
  
 변경를 <xref:System.Net.HttpWebRequest.Connection%2A> 호출 하 여 요청이 시작 된 후 속성을 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Connection%2A> 연결 HTTP 헤더의 값을 설정 하는 속성입니다.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.Connection" />의 값이 Keep-alive 또는 Close로 설정되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 대한 연결 그룹의 이름을 가져오거나 설정합니다.</summary>
        <value>이 요청에 대한 연결 그룹의 이름입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> 속성을 사용 하면 연결 그룹을 사용 하 여 요청을 연결할 수 있습니다. 응용 프로그램 데이터베이스 서버에서 고객 정보를 검색 하는 웹 사이트 등의 다른 사용자에 대 한 대 이상의 서버에 요청에서 하는 경우에 유용 합니다.  
  
   
  
## Examples  
 사용자 정보를 사용 하 여 가정 하 고 연결 그룹을 형성 하는 방법을 다음 코드 예제에서는 변수 `username`, `password`, 및 `domain` 이 코드를 호출 하기 전에 응용 프로그램에 의해 설정 됩니다.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>각 연결 그룹을 서버에 대 한 추가 연결을 만듭니다. 설정한 연결 수가 초과 될 수 있습니다이 <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> 해당 서버에 대 한 속성입니다.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">연결 그룹화</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="Content-length" /> HTTP 헤더를 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에 보낼 데이터의 바이트 수입니다. 기본값은 -1로, 해당 속성이 설정되지 않았으며 보낼 요청 데이터가 없음을 나타냅니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성으로 보낼 값이 포함 된 `Content-length` 요청과 함께 HTTP 헤더입니다.  
  
 에-1이 아닌 모든 값을 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을 지정 하는 요청 데이터를 업로드 하는 데이터를 업로드 하는 방법만 설정할 수 있습니다는 <xref:System.Net.HttpWebRequest.Method%2A> 속성입니다.  
  
 후 합니다 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 값을 바이트 수 써야를 호출 하 여 반환 되는 요청 스트림에 합니다 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 중 하나 또는 둘 다를 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 및 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 게시 되는 문자열의 길이 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 또는 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 메서드를 호출하여 요청이 시작되었습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">새 <see cref="P:System.Net.HttpWebRequest.ContentLength" /> 값이 0보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Content-type" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Content-type" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성 요청의 미디어 형식을 포함 합니다. 에 할당 된 값을 <xref:System.Net.HttpWebRequest.ContentType%2A> 요청을 보내면 속성에 모든 기존 내용을 대체 합니다 `Content-type` HTTP 헤더입니다.  
  
 선택을 취소 합니다 `Content-type` HTTP 헤더를 설정 합니다 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성을 `null`.  
  
> [!NOTE]
>  이 속성의 값에 저장 됩니다 <xref:System.Net.WebHeaderCollection> 합니다. 경우 <xref:System.Net.WebHeaderCollection> 설정 속성 값이 손실 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인터넷 리소스에서 HTTP 100-continue 응답을 받을 때 호출된 대리자 메서드를 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에서 HTTP 계속 응답이 반환될 때 실행하는 콜백 메서드를 구현하는 대리자입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> 클라이언트가 100 수신 될 때 호출할 콜백 메서드를 지정 하는 속성-Continue 응답 합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> 속성을 설정 하면 클라이언트에 대리자를 호출 때마다 형식의 응답을 프로토콜 <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) 수신 합니다. 클라이언트를 인터넷 리소스에서 수신 중인 데이터의 상태를 표시 하려는 경우에 유용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버에서 100-Continue가 수신될 때까지 기다릴 제한 시간(밀리초)을 가져오거나 설정합니다.</summary>
        <value>100-Continue가 수신될 때까지 기다릴 제한 시간(밀리초)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 100-Continue 엔터티 본문을 보낼 수 제한 시간이 만료 되기 전에 응답을 받을입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청과 관련된 쿠키를 가져오거나 설정합니다.</summary>
        <value>이 요청과 관련된 쿠키가 들어 있는 A <see cref="T:System.Net.CookieContainer" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 속성의 인스턴스를 제공 합니다 <xref:System.Net.CookieContainer> 이 요청과 연관 된 쿠키를 포함 하는 클래스입니다.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> `null` 기본적으로 합니다. 할당 해야 합니다는 <xref:System.Net.CookieContainer> 개체 속성에서 반환 된 쿠키를를 <xref:System.Net.HttpWebResponse.Cookies%2A> 의 속성을 <xref:System.Net.HttpWebResponse> 반환한는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드.  
  
> [!NOTE]
>  쿠키는 보안상의 이유로 기본적으로 비활성화 됩니다. 사용 하 여 쿠키를 사용 하려는 경우는 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 쿠키를 사용 하도록 설정 하려면 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 URL로 요청을를 보내고 응답에서 반환 된 쿠키를 표시 합니다.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 대한 인증 정보를 가져오거나 설정합니다.</summary>
        <value>요청과 관련된 인증 자격 증명이 들어 있는 <see cref="T:System.Net.ICredentials" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> 속성 요청의 작성자를 식별 하는 인증 정보를 포함 합니다. <xref:System.Net.HttpWebRequest.Credentials%2A> 속성 일 수 있습니다를 <xref:System.Net.NetworkCredential>, 있는 경우 사용자, 암호 및 도메인 정보에 포함 된 합니다 <xref:System.Net.NetworkCredential> 요청을 인증에 개체를 사용 하거나 수를 <xref:System.Net.CredentialCache>있으며이 경우 Uniform Resource 요청의 식별자 (URI)는 요청을 인증 하는 데 사용자, 암호 및 도메인 정보를 확인 하려면 사용 됩니다.  
  
 대부분의 클라이언트 시나리오에서 사용 해야는 <xref:System.Net.CredentialCache.DefaultCredentials%2A> 현재 로그온된 한 사용자의 자격 증명을 포함 하는 속성입니다. 이 위해 설정 된 <xref:System.Net.WebClient.UseDefaultCredentials%2A> 속성을 `true` 이 속성을 설정 하는 대신 합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest> 클래스는 ASP.NET 응용 프로그램에서 자격 증명 같은 중간 계층 응용 프로그램에서 사용 되는 <xref:System.Net.CredentialCache.DefaultCredentials%2A> 속성 ASP 페이지 (서버 쪽 자격 증명)를 실행 하는 계정에 속해야 합니다. 일반적으로이 속성을 설정한 대신해 요청 클라이언트의 자격 증명입니다.  
  
> [!NOTE]
>  다른 사용자로 가장할 NTLM 인증 체계를 사용할 수 없습니다. Kerberos는 가장을 지원 하기 위해 특수 하 게 구성 되어야 합니다.  
  
 하나 이상의 인증 방법 HttpWebRequest를 제한 하려면를 <xref:System.Net.CredentialCache> 하나 이상의 인증 체계에 자격 증명를 바인딩하고 클래스  
  
 지원 되는 인증 체계는 다이제스트, 협상, Kerberos, NTLM 및 Basic에 포함 됩니다.  
  
 보안상의 이유로 리디렉션을 자동으로 수행할 때에서 리디렉션에 포함 하려는 자격 증명을 저장 한 <xref:System.Net.CredentialCache> 이 속성에 할당 합니다. 이 속성에 자동으로 설정할 `null` 제외 하 고 있으면 리디렉션 시는 <xref:System.Net.CredentialCache>합니다. 이 속성 값을 갖는 자동으로 설정할 `null` 해당 조건에서 자격 증명 의도 하지 않은 모든 대상에 전송 되지 않도록 합니다.
  
## Examples  
 다음 코드 예제는 요청에 대 한 자격 증명을 설정 합니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 요청에 사용할 <see langword="Date" /> HTTP 헤더 값을 가져오거나 설정합니다.</summary>
        <value>HTTP 요청의 Date 헤더 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Date 헤더 이면 `null`를 반환 값에 설정한 다음 <xref:System.DateTime.MinValue?displayProperty=nameWithType>합니다.  
  
 <xref:System.Net.HttpWebRequest.Date%2A> 속성은 표준 <xref:System.DateTime?displayProperty=nameWithType> 개체를 포함할 수 있습니다는 <xref:System.DateTimeKind?displayProperty=nameWithType> 필드 <xref:System.DateTimeKind.Local?displayProperty=nameWithType>를 <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, 또는 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>합니다. 사용 하는 경우 모든 종류의 시간을 설정할 수는 <xref:System.Net.HttpWebRequest.Date%2A> 속성입니다. 하는 경우 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> 를 설정 하거나 검색 합니다 <xref:System.Net.HttpWebRequest.Date%2A> 속성으로 간주 됩니다 <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (현지 시간).  
  
 클래스는 <xref:System.Net> 네임 스페이스 항상 코드를 작성 합니다 <xref:System.Net.HttpWebRequest.Date%2A> GMT (Utc) 형식을 사용 하 여 표준 형태로 전송 하는 동안 통신 중에는 속성입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Date%2A> 속성이 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 해당 `Date` HTTP 헤더에서 제거 됩니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Date%2A> 속성은 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 있음을 나타냅니다 합니다 `Date` HTTP 헤더에 포함 되지 않습니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Date%2A> 설정 되어 전송 하려고 시도 하 고는 <xref:System.Net.HttpWebRequest> 본문이 없는 <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> 의해 throw 됩니다.는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>를 <xref:System.Net.HttpWebRequest.GetResponse%2A>, 및 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청에 대한 기본 캐시 정책을 가져오거나 설정합니다.</summary>
        <value>다른 정책을 적용할 수 없을 때 이 요청에 대해 적용할 캐시 정책을 지정하는 <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP 및 HTTPS 체계를 지정 된 정책을 등록이 속성을 설정 합니다. 이 요청에 대해이 정책을 사용 하는 경우:  
  
 방법이 없는 <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> 이 요청에 대 한 지정 된 속성입니다.  
  
또는
  
 컴퓨터 및 응용 프로그램 구성 파일에를이 요청을 만드는 데 사용 하는 리소스 URI (Uniform Identifier) 적용 되는 캐시 정책을 지정 하지 않으면.  
  
 캐시 정책 리소스 호스트 컴퓨터에 요청을 전송 하는 대신 캐시에서 요청된 된 리소스를 사용할 수 있는지 여부를 결정 합니다.  
  
 응답 스트림에 리소스를 검색 하 고 스트림의 끝까지 읽는 경우에 리소스의 복사본이 캐시에 추가 됩니다. 이므로 동일한 리소스에 대 한 다른 요청에는이 요청에 대 한 캐시 정책 수준에 따라 캐시 된 복사본을 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">네트워크 리소스에 무제한 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 오류 응답의 기본 최대 길이를 가져오거나 설정합니다.</summary>
        <value>HTTP 오류 응답의 기본 최대 길이입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 0보다 작고 -1이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> 속성에 대한 기본값을 가져오거나 설정합니다.</summary>
        <value>받은 응답 헤더의 기본 최대 길이이며 킬로바이트(1024바이트) 단위입니다. 기본 구성 파일에서는 이 값을 64KB로 설정합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응답 헤더 길이 응답 상태 줄 및 HTTP 프로토콜의 일부로 받은 추가 제어 문자를 받았습니다. 값이-1 이면 수신;은 응답 헤더에 제한 되지 않습니다 0 이면 모든 요청이 실패 하는 값입니다.  
  
 또한 구성 파일에서이 값을 변경할 수 있습니다. 이 속성의 영향을 설정 하 여 재정의할 수 있습니다 합니다 <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> 인스턴스의 속성을 <xref:System.Net.HttpWebRequest> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 0보다 작고 -1이 아닌 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" /> 개체에 대한 비동기 요청을 끝냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">스트림에 대해 보류된 요청입니다.</param>
        <summary>데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" /> 개체에 대한 비동기 요청을 끝냅니다.</summary>
        <returns>요청 데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드에 의해 시작 된 스트림에 대 한 비동기 요청을 완료 합니다 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드. 후 합니다 <xref:System.IO.Stream> 반환 된 개체를 사용 하 여 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.HttpWebRequest> 사용 하 여를 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
> [!NOTE]
>  값을 설정 해야 합니다 <xref:System.Net.HttpWebRequest.ContentLength%2A> 스트림에 데이터를 쓰기 전에 속성입니다.  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 스트림을 닫습니다 재사용에 대 한 연결을 해제 하는 메서드. 스트림 닫기에 실패 하면 응용 프로그램을 연결에서 실행 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 스트림 인스턴스에 대 한 비동기 요청을 종료 하는 방법입니다.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.IOException">요청이 완료되지 않아서 스트림을 사용할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">현재 인스턴스에서 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />을 호출한 결과 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException">이 메서드가 <paramref name="asyncResult" />를 사용하여 이미 호출된 경우</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.  
  
또는 
이 요청을 처리하는 동안 오류가 발생했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">스트림에 대해 보류된 요청입니다.</param>
        <param name="context"><see cref="T:System.Net.TransportContext" />에 대한 <see cref="T:System.IO.Stream" />입니다.</param>
        <param name="transportContext"><see cref="T:System.Net.TransportContext" />에 대한 <see cref="T:System.IO.Stream" />입니다.</param>
        <summary>데이터를 쓰는 데 사용하는 <see cref="T:System.IO.Stream" /> 개체에 대한 비동기 요청을 종료하고 해당 스트림과 연결된 <see cref="T:System.Net.TransportContext" />를 출력합니다.</summary>
        <returns>요청 데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> 메서드에 의해 시작 된 스트림에 대 한 비동기 요청을 완료 합니다 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드 및 출력을 <xref:System.Net.TransportContext> 스트림과 연결 된. 후 합니다 <xref:System.IO.Stream> 반환 된 개체를 사용 하 여 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.HttpWebRequest> 사용 하 여를 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
 확장 된 보호를 사용 하 여 통합된 Windows 인증을 사용 하는 일부 응용 프로그램에서 사용 하는 전송 계층을 쿼리할 수 해야 <xref:System.Net.HttpWebRequest> 기본 TLS 채널에서의 CBT (채널 바인딩 토큰)를 검색 하기 위해. 합니다 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드는 요청 본문을 포함 하는 HTTP 메서드에 대해이 정보에 대 한 액세스를 제공 (`POST` 고 `PUT` 요청). 응용 프로그램에서 자체 인증을 구현 하는 CBT에 액세스 해야 하는 경우에 필요 합니다.  
  
> [!NOTE]
>  응용 프로그램의 값을 설정 해야 하는 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을이 스트림을 검색 하 고 데이터를 기록 하기 전에 수행 해야 합니다.  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 스트림을 닫습니다 재사용에 대 한 연결을 해제 하는 메서드. 스트림 닫기에 실패 하면 응용 프로그램을 연결에서 실행 합니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">현재 인스턴스에서 <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />을 호출한 결과 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 메서드가 <paramref name="asyncResult" />를 사용하여 이미 호출된 경우</exception>
        <exception cref="T:System.IO.IOException">요청이 완료되지 않아서 스트림을 사용할 수 없는 경우</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.  
  
또는 
이 요청을 처리하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">확장된 보호를 사용하는 Windows 통합 인증</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">응답에 대해 보류된 요청입니다.</param>
        <summary>인터넷 리소스에 대한 비동기 요청을 종료합니다.</summary>
        <returns>인터넷 리소스로부터의 응답이 들어 있는 <see cref="T:System.Net.WebResponse" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 메서드를 호출 하 여 시작 된 인터넷 리소스에 대 한 비동기 요청을 완료 합니다 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드.  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.Net.HttpWebResponse.Close%2A> 방법 스트림을 닫고 연결을 해제 합니다. 이렇게 하지 않으면 연결에서 실행 되도록 응용 프로그램에 발생할 수 있습니다.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 인터넷 리소스에 대 한 비동기 요청을 종료 하는 방법입니다.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 메서드가 <paramref name="asyncResult." />를 사용하여 이미 호출되었습니다.  
  
또는 
<see cref="P:System.Net.HttpWebRequest.ContentLength" /> 속성이 0보다 큰데 데이터를 요청 스트림에 쓰지 않은 경우</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.  
  
또는 
이 요청을 처리하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ArgumentException">현재 인스턴스에서 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />을 호출한 결과 <paramref name="asyncResult" />가 반환되지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Expect" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Expect" /> 헤더의 콘텐츠입니다. 기본값은 <see langword="null" />입니다.  
  
 <block subset="none" type="note"><para>  
 이 속성의 값은 <see cref="T:System.Net.WebHeaderCollection" />에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" />가 하위 문자열로 "100-continue"를 포함하는 문자열로 설정된 경우</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.WebRequest" /> 인스턴스에 대한 해시 값을 반환합니다.</summary>
        <returns>정수 해시 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode 메서드는 웹 요청의 해시 코드를 반환합니다. 이 값은 해시 테이블에서 키로 사용할 수 있습니다.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">데이터로 채울 <see cref="T:System.Runtime.Serialization.SerializationInfo" />입니다.</param>
        <param name="streamingContext">이 직렬화의 대상을 지정하는 <see cref="T:System.Runtime.Serialization.StreamingContext" />입니다.</param>
        <summary>대상 개체를 serialize하는 데 필요한 데이터로 <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 된 모든 개체는 <xref:System.Runtime.Serialization.SerializationInfo> 자동으로 추적 되 고 포맷터가 serialize 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요청 데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" /> 개체를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요청 데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" /> 개체를 가져옵니다.</summary>
        <returns>요청 데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 데이터를 전송 하는 데는 스트림을 반환 합니다 <xref:System.Net.HttpWebRequest>합니다. 후 합니다 <xref:System.IO.Stream> 반환 된 개체를 사용 하 여 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.HttpWebRequest> 사용 하 여를 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
 응용 프로그램의 값을 설정 해야 하는 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을이 스트림을 검색 하기 전에 수행 해야 합니다.  
  
 호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 스트림을 닫습니다 재사용에 대 한 연결을 해제 하는 메서드. 스트림 닫기에 실패 하면 응용 프로그램을 연결에서 실행 합니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 를 사용 해야 메서드는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 응답을 검색 하는 방법.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> stream 인스턴스를 반환 하는 방법입니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 속성이 GET 또는 HEAD인 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />가 <see langword="true" />이고, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />이 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 -1이고, <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.Method" />가 POST 또는 PUT인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 메서드가 두 번 이상 호출된 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />이 값으로 설정되었으며 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">요청 캐시 유효성 검사기에서 이 요청에 대한 응답이 캐시에서 제공될 수 있지만 데이터를 쓰는 요청의 경우 캐시를 사용하지 않아야 함을 나타내는 경우. 이 예외는 제대로 구현되지 않은 사용자 지정 캐시 유효성 검사기를 사용하려는 경우에 발생할 수 있습니다.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.  
  
또는 
요청의 제한 시간이 만료된 경우  
  
또는 
이 요청을 처리하는 동안 오류가 발생했습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">.NET Compact Framework 응용 프로그램에서 콘텐츠 길이가 0인 요청 스트림을 올바르게 가져오고 닫지 않은 경우. 콘텐츠 길이가 0인 요청을 처리하는 방법에 대한 자세한 내용은 [.NET Compact Framework의 네트워크 프로그래밍](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx)을 참조하세요.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Net.TransportContext" />에 대한 <see cref="T:System.IO.Stream" />입니다.</param>
        <summary>요청 데이터를 쓰는 데 사용하는 <see cref="T:System.IO.Stream" /> 개체를 가져오고 해당 스트림과 연결된 <see cref="T:System.Net.TransportContext" />를 출력합니다.</summary>
        <returns>요청 데이터를 쓰는 데 사용할 <see cref="T:System.IO.Stream" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드 데이터를 전송 하는 데는 스트림을 반환 합니다 <xref:System.Net.HttpWebRequest> 출력는 <xref:System.Net.TransportContext> 스트림과 연결 된입니다. 후 합니다 <xref:System.IO.Stream> 반환 된 개체를 사용 하 여 데이터를 보낼 수 있습니다 합니다 <xref:System.Net.HttpWebRequest> 사용 하 여를 <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> 메서드.  
  
 확장 된 보호를 사용 하 여 통합된 Windows 인증을 사용 하는 일부 응용 프로그램에서 사용 하는 전송 계층을 쿼리할 수 해야 <xref:System.Net.HttpWebRequest> 기본 TLS 채널에서의 CBT (채널 바인딩 토큰)를 검색 하기 위해. 합니다 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드는 요청 본문을 포함 하는 HTTP 메서드에 대해이 정보에 대 한 액세스를 제공 (`POST` 고 `PUT` 요청). 응용 프로그램에서 자체 인증을 구현 하는 CBT에 액세스 해야 하는 경우에 필요 합니다.  
  
 응용 프로그램의 값을 설정 해야 하는 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성을이 스트림을 검색 하기 전에 수행 해야 합니다.  
  
 호출 해야 합니다는 <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> 스트림을 닫습니다 재사용에 대 한 연결을 해제 하는 메서드. 스트림 닫기에 실패 하면 응용 프로그램을 연결에서 실행 합니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 를 사용 해야 메서드는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 응답을 검색 하는 방법.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 메서드는 <see cref="T:System.IO.Stream" />를 얻을 수 없었습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 메서드가 두 번 이상 호출된 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />이 값으로 설정되었으며 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">요청 캐시 유효성 검사기에서 이 요청에 대한 응답이 캐시에서 제공될 수 있지만 데이터를 쓰는 요청의 경우 캐시를 사용하지 않아야 함을 나타내는 경우. 이 예외는 제대로 구현되지 않은 사용자 지정 캐시 유효성 검사기를 사용하려는 경우에 발생할 수 있습니다.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" /> 속성이 GET 또는 HEAD인 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />가 <see langword="true" />이고, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />이 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 -1이고, <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.Method" />가 POST 또는 PUT인 경우</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.  
  
또는 
요청의 제한 시간이 만료된 경우  
  
또는 
이 요청을 처리하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">확장된 보호를 사용하는 Windows 통합 인증</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>인터넷 리소스에서의 응답을 반환합니다.</summary>
        <returns>인터넷 리소스로부터의 응답이 들어 있는 <see cref="T:System.Net.WebResponse" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드가 반환 되는 <xref:System.Net.WebResponse> 인터넷 리소스 로부터의 응답이 들어 있는 개체입니다. 반환 되는 실제 인스턴스는 <xref:System.Net.HttpWebResponse>, 및 HTTP 관련 속성 액세스 하려면 해당 클래스에 형식 캐스팅 될 수 있습니다.  
  
 A <xref:System.Net.ProtocolViolationException> 속성을 설정 하는 경우 여러 경우에 throw 되는 <xref:System.Net.HttpWebRequest> 충돌 하는 클래스입니다. 응용 프로그램을 설정 하는 경우이 예외가 발생 합니다 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 및 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true`, HTTP GET 요청을 보냅니다. 응용 프로그램이이 지원 되지 않습니다만 HTTP 1.0 프로토콜을 지 원하는 서버에 청크 분할 전송 하려고 하는 경우이 예외가 발생 합니다. 응용 프로그램에서 설정 하지 않고 데이터를 전송 하려고 하는 경우이 예외가 발생 합니다 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성 또는 <xref:System.Net.HttpWebRequest.SendChunked%2A> 됩니다 `false` keepalive 연결에 버퍼링 사용 하지 않도록 설정 하는 경우 및 (합니다 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`)`.`  
  
> [!CAUTION]
>  호출 해야 합니다는 <xref:System.Net.HttpWebResponse.Close%2A> 방법 스트림을 닫고 연결을 해제 합니다. 이렇게 하지 않으면 연결에서 실행 되도록 응용 프로그램에 발생할 수 있습니다.  
  
 POST 메서드를 사용 하면 여 요청 스트림을 가져오고, 게시 될 데이터를 작성 하며 스트림을 닫습니다. 게시할; 콘텐츠에 대 한 대기를 차단 하는이 메서드 시간 제한 집합이 있는 경우 해당 호출 스레드는 차단 무기한으로 콘텐츠를 제공 하지 않습니다.  
  
> [!NOTE]
>  여러 번 호출 <xref:System.Net.HttpWebRequest.GetResponse%2A> 동일한 응답 개체를 반환 합니다. 요청은 다시 발급 되지 않습니다.  
  
> [!NOTE]
>  응용 프로그램 특정 요청에 대 한 동기 및 비동기 메서드를 혼합할 수 없습니다. 호출 하는 경우는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 를 사용 해야 메서드는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 응답을 검색 하는 방법.  
  
> [!NOTE]
>  경우는 <xref:System.Net.WebException> 는 throw를 사용 합니다 <xref:System.Net.WebException.Response%2A> 및 <xref:System.Net.WebException.Status%2A> 서버에서 응답을 확인 하려면 예외의 속성.  
  
> [!NOTE]
>  응용 프로그램에 네트워크 추적을 사용하도록 설정하면 이 멤버에서 추적 정보를 출력합니다. 자세한 내용은 [.NET Framework의 네트워크 추적](~/docs/framework/network-programming/network-tracing.md)합니다.  
  
> [!NOTE]
>  쿠키는 보안상의 이유로 기본적으로 비활성화 됩니다. 사용 하 여 쿠키를 사용 하려는 경우는 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 쿠키를 사용 하도록 설정 하려면 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 요청에 대 한 응답을 가져옵니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">스트림이 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />에 대한 이전 호출에서 이미 사용되고 있는 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" />이 값으로 설정되었으며 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />입니다.</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.HttpWebRequest.Method" />가 GET 또는 HEAD이고, <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 0 이상이거나 <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="true" />인 경우  
  
또는 
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" />가 <see langword="true" />이고, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />이 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.ContentLength" />가 -1이고, <see cref="P:System.Net.HttpWebRequest.SendChunked" />가 <see langword="false" />이고, <see cref="P:System.Net.HttpWebRequest.Method" />가 POST 또는 PUT인 경우  
  
또는 
<see cref="T:System.Net.HttpWebRequest" />에 엔터티 본문이 있지만 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 메서드를 호출하지 않고 <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 메서드가 호출되었습니다.  
  
또는 
<see cref="P:System.Net.HttpWebRequest.ContentLength" />가 0보다 크지만 애플리케이션에서 약속된 모든 데이터를 쓰지 않습니다.</exception>
        <exception cref="T:System.NotSupportedException">요청 캐시 유효성 검사기에서 이 요청에 대한 응답이 캐시에서 제공될 수 있지만 이 요청에는 서버로 보낼 데이터가 포함되어 있음을 나타내는 경우. 데이터를 보내는 요청의 경우에는 캐시를 사용하지 말아야 합니다. 이 예외는 제대로 구현되지 않은 사용자 지정 캐시 유효성 검사기를 사용하려는 경우에 발생할 수 있습니다.</exception>
        <exception cref="T:System.Net.WebException"><see cref="M:System.Net.HttpWebRequest.Abort" />가 이전에 호출되었습니다.  
  
또는 
요청의 제한 시간이 만료된 경우  
  
또는 
이 요청을 처리하는 동안 오류가 발생했습니다.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인터넷 리소스로부터 응답을 받았는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>응답을 받았으면 <see langword="true" />이고, 받지 않았으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.HaveResponse%2A> 인터넷 리소스에서 응답을 받은 경우를 결정 하는 속성입니다.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 헤더를 구성하는 이름/값 쌍의 컬렉션을 지정합니다.</summary>
        <value>HTTP 요청의 헤더를 구성하는 이름/값 쌍이 들어 있는 <see cref="T:System.Net.WebHeaderCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> 요청과 연결 된 프로토콜 헤더를 포함 하는 컬렉션입니다. 다음 표에서에 저장 되지 않은 HTTP 헤더를 <xref:System.Net.HttpWebRequest.Headers%2A> 되지만 컬렉션 시스템에 의해 설정 또는 속성 또는 메서드.  
  
|Header|설정한|  
|------------|------------|  
|허용|설정한는 <xref:System.Net.HttpWebRequest.Accept%2A> 속성입니다.|  
|연결|으로 설정 합니다 <xref:System.Net.HttpWebRequest.Connection%2A> 속성 및 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성입니다.|  
|Content-Length|설정한는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성입니다.|  
|콘텐츠 형식|설정한는 <xref:System.Net.HttpWebRequest.ContentType%2A> 속성입니다.|  
|예상|설정한는 <xref:System.Net.HttpWebRequest.Expect%2A> 속성입니다.|  
|날짜|설정한는 <xref:System.Net.HttpWebRequest.Date%2A> 속성입니다.|  
|호스트|설정한는 <xref:System.Net.HttpWebRequest.Host%2A> 속성입니다.|  
|If-수정-이후|설정한는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다.|  
|범위|설정한는 <xref:System.Net.HttpWebRequest.AddRange%2A> 메서드.|  
|참조 자|설정한는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성입니다.|  
|전송 인코딩|으로 설정 합니다 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성 (의 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성이 true 여야 합니다).|  
|사용자 에이전트|설정한는 <xref:System.Net.HttpWebRequest.UserAgent%2A> 속성입니다.|  
  
 합니다 <xref:System.Net.WebHeaderCollection.Add%2A> 메서드가 throw는 <xref:System.ArgumentException> 보호 되는 이러한 헤더 중 하나를 설정 하려는 경우.  
  
 변경 합니다 <xref:System.Net.HttpWebRequest.Headers%2A> 를 호출 하 여 요청이 시작 된 후 속성 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다.  
  
 웹 서버 캐시 변경할 수도 있고 웹 요청에 헤더를 추가 하기 때문에 헤더 값을 변경 되지 가정 하지 않아야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성을 콘솔에 HTTP 헤더 이름/값 쌍을 인쇄 합니다.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 또는 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 메서드를 호출하여 요청이 시작되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청 URI와 독립적인 HTTP 요청에 사용할 Host 헤더 값을 가져오거나 설정합니다.</summary>
        <value>HTTP 요청의 Host 헤더 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> 호스트 헤더 값은 요청 URI와에서 독립적인 HTTP 요청에서 사용 하도록 설정 하려면 속성을 사용할 수 있습니다. <xref:System.Net.HttpWebRequest.Host%2A> 속성 호스트 이름 및 선택적 포트 번호를 구성할 수 있습니다. 포트 정보가 없는 호스트 헤더는 요청 된 서비스 (포트 80 HTTP URL에 대 한 예를 들어)에 대 한 기본 포트를 의미합니다.  
  
 호스트 및 포트를 지정 하는 형식을 IETF에서 게시 RFC2616의 14.23에서 규칙을 따라야 합니다. 이러한 요구 사항을 준수 하 고 8080 포트를 지정 하는 예를 들어 수에 대해 다음 값을 <xref:System.Net.HttpWebRequest.Host%2A> 속성:  
  
 `www.contoso.com:8080`  
  
 사용 하는 <xref:System.Net.HttpWebRequest.Host%2A> 속성을 명시적으로 사용자 지정 호스트 헤더 값을도 영향을 줍니다 캐싱 영역, 쿠키 및 인증 합니다. 특정 URI 접두사에 대 한 자격 증명을 제공 하는 응용 프로그램, 응용 프로그램에서 URI에 있는 대상 서버가 아닌 호스트 헤더의 값이 포함 된 URI를 사용 하도록 해야 합니다. 리소스를 캐시 하는 경우 사용 된 키에는 요청 URI 대신 호스트 헤더 값을 사용 합니다. 쿠키에 저장 되는 <xref:System.Net.CookieContainer> 서버 도메인 이름으로 논리적으로 그룹화 합니다. 응용 프로그램 호스트 헤더를 지정 하는 경우이 값이 도메인으로 사용 됩니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.Host%2A> 속성을 설정 하지 않으면 다음 HTTP 요청에 사용할 호스트 헤더 값은 요청 URI에 기반 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">호스트 헤더는 <see langword="null" />로 설정할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">호스트 헤더 잘못된 값으로 설정할 수 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.HttpWebRequest" />가 이미 전송되기 시작한 다음에는 호스트 헤더를 설정할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="If-Modified-Since" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value><see langword="If-Modified-Since" /> HTTP 헤더의 콘텐츠가 들어 있는 <see cref="T:System.DateTime" />입니다. 기본값이 현재 날짜와 시간입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성은 표준 <xref:System.DateTime?displayProperty=nameWithType> 개체를 포함할 수 있습니다는 <xref:System.DateTimeKind?displayProperty=nameWithType> 필드 <xref:System.DateTimeKind.Local?displayProperty=nameWithType>를 <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, 또는 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>합니다. 사용 하는 경우 모든 종류의 시간을 설정할 수는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다. 하는 경우 <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> 를 설정 하거나 검색 합니다 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성으로 간주 됩니다 <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (현지 시간).  
  
 클래스는 <xref:System.Net> 네임 스페이스 항상 코드를 작성 합니다 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> GMT (Utc) 형식을 사용 하 여 표준 형태로 전송 하는 동안 통신 중에는 속성입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성이 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 해당 `If-Modified-Since` HTTP 헤더에서 제거 됩니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성은 <xref:System.DateTime.MinValue?displayProperty=nameWithType>, 있음을 나타냅니다 합니다 `If-Modified-Since` HTTP 헤더에 포함 되지 않습니다는 <xref:System.Net.HttpWebRequest.Headers%2A> 속성 및 <xref:System.Net.WebHeaderCollection>합니다.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인터넷 리소스에 영구 연결을 할 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에 대한 요청의 <see langword="true" /> HTTP 헤더 값이 Keep-alive이면 <see langword="Connection" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 보낼는 `Connection` HTTP 헤더의 값을 유지 합니다. 응용 프로그램에 사용 하 여 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 영구 연결에 대 한 기본 설정을 나타냅니다. 경우는 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성은 `true`, 응용 프로그램은 지 원하는 서버에 대 한 영구 연결 합니다.  
  
> [!NOTE]
>  HTTP/1.1을 사용 하는 경우 Keep-alive 기본적으로 켜져 있습니다. 설정 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 하 `false` 전송 될 수 있습니다는 `Connection: Close` 서버로 헤더입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성을 `false` 인터넷 리소스를 사용 하 여 영구 연결을 설정 하지 않으려면입니다.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청이 따르는 최대 리디렉션 수를 가져오거나 설정합니다.</summary>
        <value>요청이 따르는 최대 리디렉션 응답 수입니다. 기본값은 50입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> 되는 경우 따라야 하는 요청에 대 한 리디렉션의 최대 수를 설정 하는 속성을 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 속성은 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성의 값을 설정 합니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">값이 0 이하로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답 헤더의 허용되는 최대 길이를 가져오거나 설정합니다.</summary>
        <value>응답 헤더의 킬로바이트(1024바이트) 단위 길이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응답 헤더 길이 응답 상태 줄 및 HTTP 프로토콜의 일부로 받은 추가 제어 문자를 포함 합니다. 값이-1 이면 응답 헤더;에 제한 되지 않습니다 0 이면 모든 요청이 실패 하는 값입니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> 속성이 명시적으로 설정 되지 않은의 값을 기본적으로 <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> 속성입니다.  
  
 받은 응답 헤더 길이 값을 초과할 경우는 <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> 속성을 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> 또는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드를 발생 시킵니다를 <xref:System.Net.WebException> 사용 하 여는 <xref:System.Net.WebException.Status%2A> 속성이로 설정 <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성의 값을 설정 합니다.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">요청이 제출된 후에 속성이 설정된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 0보다 작고 -1이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청의 미디어 형식을 가져오거나 설정합니다.</summary>
        <value>요청의 미디어 형식입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.Net.HttpWebRequest.MediaType%2A> 속성에 영향을 줍니다는 <xref:System.Net.HttpWebResponse.CharacterSet%2A> 속성입니다. 설정한 경우 합니다 <xref:System.Net.HttpWebRequest.MediaType%2A> 요청에서 해당 미디어 형식을 응답에 반환 하는 문자 집합의 목록에서 선택 됩니다 `Content-type` HTTP 헤더입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 대한 메서드를 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에 접속하는 데 사용할 요청 메서드입니다. 기본값은 GET입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> HTTP 1.1 프로토콜 동사 중 하나에 속성을 설정할 수 있습니다. GET, HEAD, POST, PUT, 추적 또는 옵션 삭제 합니다.  
  
 경우는 <xref:System.Net.HttpWebRequest.ContentLength%2A> 속성이-1 이외의 값으로 설정 되는 <xref:System.Net.HttpWebRequest.Method%2A> 데이터를 업로드 하는 프로토콜 속성에 속성을 설정 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Method%2A> 게시물에는 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">메서드를 지정하지 않은 경우  
  
또는 
메서드 문자열에 잘못된 문자가 들어 있는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청을 인터넷 리소스에 파이프라인할 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>요청을 파이프라인해야 하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램이 사용 하 여 <xref:System.Net.HttpWebRequest.Pipelined%2A> 파이프라인된 연결에 대 한 기본 설정을 나타내는 속성을 합니다. 때 <xref:System.Net.HttpWebRequest.Pipelined%2A> 는 `true`, 응용 프로그램에서 지 원하는 서버에 연결할 파이프라인.  
  
 파이프라인 연결 하는 경우에만 합니다 <xref:System.Net.HttpWebRequest.KeepAlive%2A> 속성도 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 값을 인쇄 합니다 <xref:System.Net.HttpWebRequest.Pipelined%2A> 콘솔에는 속성입니다.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청과 함께 인증 헤더를 보낼 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>인증을 수행한 이후 요청과 함께 HTTP 권한 부여 헤더를 함께 보내는 경우 <see langword="true" /> 이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특정 클라이언트 요청 후 <xref:System.Uri> 가 성공적으로 인증 하는 경우 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 됩니다 `true` 자격 증명이 제공, 권한 부여 헤더에 각 요청과 함께 전송 되 고 <xref:System.Uri> 일치 하는 특정 <xref:System.Uri>마지막 슬래시까지 합니다. 특정 클라이언트 요청이 성공적으로 인증 하면 <xref:System.Uri> 다음을 포함 하는:  
  
 `http://www.contoso.com/firstpath/`  
  
 사전 인증에 대 한 권한 부여 헤더는 다음 중 하나에 각 요청과 함께 전송 되는 다음 <xref:System.Uri> 인스턴스:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 그러나 권한 부여 헤더를 보내지 요청을 사용 하 여 다음 중 하나에 <xref:System.Uri> 인스턴스:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 특정 클라이언트 요청 하는 경우 <xref:System.Uri> 는 표준 인증 프로시저를 사용 하 여 요청 되지 성공적으로 인증 합니다.  
  
 첫 번째 요청을 제외 하 고는 <xref:System.Net.WebRequest.PreAuthenticate%2A> 속성은 이후 요청에 인증 정보를 보낼지 여부를 나타냅니다는 <xref:System.Uri> 일치 하는 특정 <xref:System.Uri> 하기 위해 대기 하지 않고 마지막 슬래시까지 서버에서 요구 됩니다.  
  
 클라이언트와 서버 간에 다음 대화 상자에서는이 속성의 효과를 보여 줍니다. 대화 상자는 기본 인증을 사용 하 여 가정 합니다.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `false`:  
  
 클라이언트 SomeUrl 가져오기  
  
 서버: 401 Www-authenticate Basic  
  
 클라이언트 권한 부여 헤더를 사용 하 여 가져오기  
  
 서버: 200 정상  
  
 클라이언트 SomeUrl 가져오기  
  
 서버: 401 Www-authenticate Basic  
  
 클라이언트 권한 부여 헤더를 사용 하 여 가져오기  
  
 서버: 200 정상  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> `true`:  
  
 클라이언트 SomeUrl 가져오기  
  
 서버: 401 Www-authenticate Basic  
  
 클라이언트 권한 부여 헤더를 사용 하 여 가져오기  
  
 서버: 200 정상  
  
 클라이언트 권한 부여 헤더를 사용 하 여 someUrl 가져오기  
  
 인증 체계를 사전 인증을 지원 하지 않는 경우이 속성의 값은 무시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 사용할 HTTP의 버전을 가져오거나 설정합니다.</summary>
        <value>요청에 사용할 HTTP 버전입니다. 기본값은 <see cref="F:System.Net.HttpVersion.Version11" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> 클래스는 버전 1.0 및 1.1 http를 지원 합니다. 설정 <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> 다른 버전으로 예외를 throw 합니다.  
  
> [!NOTE]
>  현재 요청의 HTTP 버전을 설정 하려면 사용 합니다 <xref:System.Net.HttpVersion.Version10> 및 <xref:System.Net.HttpVersion.Version11> 필드를 <xref:System.Net.HttpVersion> 클래스.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">HTTP 버전이 1.0이나 1.1 이외의 값으로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 대한 프록시 정보를 가져오거나 설정합니다.</summary>
        <value>요청을 프록시하는 데 사용할 <see cref="T:System.Net.IWebProxy" /> 개체입니다. 기본값은 <see cref="P:System.Net.GlobalProxySelection.Select" /> 속성을 호출함으로써 설정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성을 식별 합니다 <xref:System.Net.WebProxy> 인터넷 리소스에 대 한 요청을 처리 하는 데 사용할 개체입니다. 없는 프록시를 사용 해야 함을 지정 하려면 설정 합니다 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성을 반환 하 여 프록시 인스턴스는 <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> 메서드.  
  
 로컬 컴퓨터 또는 응용 프로그램 구성 파일을 기본 프록시를 사용할 수 있는지 지정할 수 있습니다. 경우는 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성을 지정 하면에서 프록시 설정을 <xref:System.Net.HttpWebRequest.Proxy%2A> 로컬 컴퓨터 또는 응용 프로그램 구성 파일을 재정의 하는 속성 및 <xref:System.Net.HttpWebRequest> 인스턴스는 지정 된 프록시 설정을 사용 합니다. 구성 파일에 없는 프록시를 지정 하는 경우 및 <xref:System.Net.HttpWebRequest.Proxy%2A> 속성이 지정 되어 있지는 <xref:System.Net.HttpWebRequest> 클래스에서에서 상속 되며, Internet Explorer 로컬 컴퓨터의 프록시 설정을 사용 합니다. Internet Explorer의 프록시 설정이 없는 경우 요청이 서버로 직접 전송 됩니다.  
  
 <xref:System.Net.HttpWebRequest> 클래스 구문 분석 하 여 와일드 카드 문자를 사용 하 여 프록시 무시 목록에서에서 상속 되며, Internet Explorer 동일한 바이패스 목록에는 Internet Explorer에서 직접 구문 분석 됩니다. 예를 들어 합니다 <xref:System.Net.HttpWebRequest> 클래스의 정규식을 바이패스 목록이 "nt *" Internet Explorer에서 분석 "nt.\*"입니다. 따라서 URL "`http://nt.com`"을 사용 하 여 프록시를 무시 합니다 <xref:System.Net.HttpWebRequest> 클래스 및 Internet Explorer를 사용 하 여 합니다.  
  
 <xref:System.Net.HttpWebRequest> 클래스는 로컬 프록시 바이패스를 지원 합니다. 클래스에는 다음 조건 중 하나가 충족 되는 경우에 로컬 대상을 간주 합니다.  
  
-   대상 플랫 이름 (URL에 점 없음)를 포함합니다.  
  
-   루프백 주소를 포함 하는 대상 (<xref:System.Net.IPAddress.Loopback> 또는 <xref:System.Net.IPAddress.IPv6Loopback>) 하거나 대상 포함는 <xref:System.Net.IPAddress> 로컬 컴퓨터에 할당 합니다.  
  
-   로컬 컴퓨터의 도메인 접미사를 일치 대상의 도메인 접미사 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 변경를 <xref:System.Net.HttpWebRequest.Proxy%2A> 호출 하 여 요청이 시작 된 후 속성을 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다. Proxy 요소에 대 한 내용은 [ \&lt; defaultProxy\&gt; 요소 (네트워크 설정)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Proxy%2A> 메서드는 요청에 대 한 프록시 정보를 가져올 수 있습니다.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.HttpWebRequest.Proxy" />이 <see langword="null" />로 설정됩니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 또는 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />를 호출하여 요청이 시작된 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 요청된 작업에 대한 권한이 없는 경우</exception>
        <permission cref="T:System.Net.WebPermission">가져오거나 설정할는 <see cref="P:System.Net.HttpWebRequest.Proxy" /> 속성입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">DefaultProxy 요소 (네트워크 설정)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">인터넷 애플리케이션 구성</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">프록시 구성</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">자동 프록시 검색</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스트림에 쓰거나 스트림에서 읽을 때의 제한 시간을 밀리초 단위로 가져오거나 설정합니다.</summary>
        <value>쓰기 또는 읽기가 가능한 제한 시간(밀리초)입니다. 기본값은 300,000밀리초(5분)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성에서 반환 된 스트림에 쓸 때 사용 되는 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드나 반환한 스트림의 읽을 <xref:System.Net.HttpWebResponse.GetResponseStream%2A> 메서드.  
  
 특히를 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성에 대 한 제한 시간을 제어 합니다 <xref:System.IO.Stream.Read%2A> 반환한 스트림을 읽는 데 사용 되는 메서드를를 <xref:System.Net.HttpWebResponse.GetResponseStream%2A> 메서드를 한를 <xref:System.IO.Stream.Write%2A> 합니다 에서반환된스트림으로쓰는데사용되는메서드를<xref:System.Net.HttpWebRequest.GetRequestStream%2A>메서드.  
  
 요청이 완료 될 때까지 기다리는 기간을 지정 하려면 사용 된 <xref:System.Net.HttpWebRequest.Timeout%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성을 설정하는 방법을 보여 줍니다.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">요청을 이미 보낸 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">set 작업에 지정된 값이 0보다 작거나 같고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Referer" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Referer" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> 속성은 `true`는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성은 다른 사이트로 요청을 리디렉션할 때 자동으로 설정 됩니다.  
  
 선택을 취소 합니다 `Referer` HTTP 헤더를 설정 합니다 <xref:System.Net.HttpWebRequest.Referer%2A> 속성을 `null`.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.Referer%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청의 원래 URI(Uniform Resource Identifier)를 가져옵니다.</summary>
        <value><see cref="T:System.Uri" /> 메서드에 전달된 인터넷 리소스의 URI가 들어 있는 <see cref="M:System.Net.WebRequest.Create(System.String)" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Uri> 에 전달 된 개체 <xref:System.Net.HttpWebRequest> 호출에 의해 <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>합니다.  
  
 리디렉션을 다음 헤더 변경 되지 않습니다는 <xref:System.Net.HttpWebRequest.RequestUri%2A> 속성입니다. 요청에 응답 하는 실제 URI를 가져오려면 검사는 <xref:System.Net.HttpWebRequest.Address%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 확인 하는 <xref:System.Net.HttpWebRequest> 개체 `req` 이 요청을 다른 위치로 리디렉션되고의 값을 설정 합니다 `hasChanged` 변수를 `true` 요청 되었으면이 고, 그렇지 않으면 리디렉션된 `hasChanged` 로 설정 된 `false`합니다.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인터넷 리소스에 데이터를 분할된 형태로 보낼 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>인터넷 리소스에 데이터를 분할된 형태로 보내려면 <see langword="true" />로 설정하고 그렇지 않으면 <see langword="false" />로 설정합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Net.HttpWebRequest.SendChunked%2A> 는 `true`, 요청이 인터넷 리소스 세그먼트에 데이터를 보냅니다. 인터넷 리소스는 청크 분할 된 데이터를 받는 지원 해야 합니다.  
  
 변경를 <xref:System.Net.HttpWebRequest.SendChunked%2A> 호출 하 여 요청이 시작 된 후 속성을 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, 또는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드가 throw는 <xref:System.InvalidOperationException>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true` 인터넷 리소스에 대 한 세그먼트에 데이터를 보낼 수 있도록 합니다.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> 또는 <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 메서드를 호출하여 요청이 시작되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 인증서의 유효성을 검사할 콜백 함수를 가져오거나 설정합니다.</summary>
        <value>서버 인증서의 유효성을 검사할 콜백 함수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본값은 콜백 함수가 설정 되어 있는지와 <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> 속성은 `null`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 사용할 서비스 지점을 가져옵니다.</summary>
        <value>인터넷 리소스에 네트워크 연결을 나타내는 <see cref="T:System.Net.ServicePoint" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> 속성에서 다를 수 <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> 요청을 리디렉션할 경우.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청이 <see cref="T:System.Net.CookieContainer" />를 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>요청이 <see cref="T:System.Net.CookieContainer" />를 지원하면 <see langword="true" />이고, 지원하지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">데이터로 채울 <see cref="T:System.Runtime.Serialization.SerializationInfo" />입니다.</param>
        <param name="streamingContext">이 직렬화의 대상을 지정하는 <see cref="T:System.Runtime.Serialization.StreamingContext" />입니다.</param>
        <summary>대상 개체를 직렬화하는 데 필요한 데이터로 <see cref="T:System.Runtime.Serialization.SerializationInfo" />를 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 된 모든 개체는 <xref:System.Runtime.Serialization.SerializationInfo> 자동으로 추적 되 고 포맷터가 serialize 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Net.HttpWebRequest.GetResponse" /> 및 <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> 메서드의 제한 시간 값을 밀리초 단위로 가져오거나 설정합니다.</summary>
        <value>요청이 시간 초과하기 전까지 기다리는 시간(밀리초)입니다. 기본값은 100,000밀리초(100초)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 후속 동기 요청을 사용 하 여 만든 시간 (밀리초)입니다 합니다 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드가 응답을 기다리는 및 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 메서드는 스트림에 대 한 대기 합니다. 합니다 <xref:System.Net.HttpWebRequest.Timeout%2A> 하지 개별적으로 전체 요청 및 응답에 적용 됩니다 합니다 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 및 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드 호출 합니다. 리소스 제한 시간 안에 반환 되지 않으면 요청이 throw를 <xref:System.Net.WebException> 사용 하 여 합니다 <xref:System.Net.WebException.Status%2A> 속성으로 설정 <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>합니다.  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 하기 전에 속성을 설정 해야 합니다 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 또는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드가 호출 됩니다. 변경 된 <xref:System.Net.HttpWebRequest.Timeout%2A> 호출한 후 속성을 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> 또는 <xref:System.Net.HttpWebRequest.GetResponse%2A> 메서드는 어떠한 영향도  
  
 합니다 <xref:System.Net.HttpWebRequest.Timeout%2A> 속성이 사용 하 여 비동기 요청에 영향을 주지 합니다 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 또는 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> 메서드.  
  
> [!CAUTION]
>  비동기 요청의 경우 클라이언트 응용 프로그램 자체 제한 시간 메커니즘을 구현합니다. 예제를 참조 하십시오는 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> 메서드.  
  
 읽기 또는 쓰기 작업 시간이 초과 하는 시간을 지정 하려면 사용 된 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 속성입니다.  
  
 도메인 이름 시스템 (DNS) 쿼리는 최대 15 초 반환할 또는 제한 시간 걸릴 수 있습니다. 요청 확인이 필요 하는 호스트 이름을 포함 하 고 설정한 경우 <xref:System.Net.FileWebRequest.Timeout%2A> 값 보다 작거나 15 초 걸릴 수 있습니다 이전 15 초 이상는 <xref:System.Net.WebException> 요청에서 제한 시간을 나타내기 위해 throw 되는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Net.HttpWebRequest.Timeout%2A> 의 속성을 <xref:System.Net.HttpWebRequest> 개체입니다.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">지정된 값이 0보다 작고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Transfer-encoding" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Transfer-encoding" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하기 전에 합니다 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성을 먼저 설정 해야 합니다 <xref:System.Net.HttpWebRequest.SendChunked%2A> 속성을 `true`입니다. 지우기 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 로 설정 하 여 `null` 의 값에 영향을 주지 <xref:System.Net.HttpWebRequest.SendChunked%2A>합니다.  
  
 에 할당 된 값을 <xref:System.Net.HttpWebRequest.TransferEncoding%2A> 속성에는 모든 기존 내용을 대체 합니다.  
  
> [!NOTE]
>  이 속성의 값은 <xref:System.Net.WebHeaderCollection>에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" />가 <see langword="false" />일 때, <see cref="P:System.Net.HttpWebRequest.SendChunked" />이 설정된 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.HttpWebRequest.TransferEncoding" />이 "Chunked" 값으로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>고속 NTLM 인증 연결 공유가 허용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>인증된 연결을 열어 두려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 기본값은 `false`, 요청이 완료 된 후에 닫을 수에 대 한 현재 연결에 이르게 합니다. 새 요청을 발급 될 때마다 응용 프로그램에 인증 시퀀스 거쳐야 합니다.  
  
 이 속성 설정 된 경우 `true`, 응답을 검색 하는 데 사용 하는 연결 인증을 수행한 후에 계속 열려 있습니다. 이 경우에이 속성이 설정 요청 다른 `true` 다시 인증 하지 않고 연결을 사용할 수 있습니다. 즉, 사용자 A에 대 한 연결을 인증 된 경우 사용자 B 다시 사용할 수 있습니다 A의 연결 1. 사용자의 자격 증명에 따라 사용자 B의 요청이 처리 된  
  
> [!CAUTION]
>  수 있는지 관리 문제가 시스템의 경우이 속성을 설정 해야 하는 응용 프로그램을 인증 하지 않고 연결을 사용 하도록 이기 때문에 `true`입니다. 응용 프로그램에서 여러 사용자에 대 한 요청을 전송 하는 경우 (여러 사용자 계정을 가장 합니다.) 하며 리소스를 보호 하는 인증,이 속성 설정 하지 않으면이 `true` 아래 설명 된 대로 연결 그룹을 사용 하지 않는 한 합니다.  
  
 하는 경우이 메커니즘을 사용 하도록 설정 하려는 경우에 성능 문제가 발생 하는 응용 프로그램 통합된 Windows 인증을 사용 하 여 웹 서버에서 실행 되 고 있습니다.  
  
 이 설정을 사용 하면 시스템 보안 위험을 엽니다. 설정한 경우에 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> 속성을 `true` 다음 예방 조치를 수행 해야 합니다.  
  
-   사용 된 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> 다른 사용자에 대 한 연결을 관리 하는 속성입니다. 이 인증 되지 않은 응용 프로그램에서 연결의 사용 가능성을 방지합니다. 예를 들어 사용자 A는 사용자 2. 다른 고유한 연결 그룹 이름이 있어야 각 사용자 계정에 대 한 격리 계층을 제공합니다.  
  
-   연결이 악용을 방지 하려면 보호 된 환경에서 응용 프로그램을 실행 합니다.  
  
 백 엔드 서버를 제어 하는 경우는 대 안으로 좋습니다 인증 지 속성을 해제 합니다. 어느 정도 성능이 향상 되지만 것이 더 안전 합니다. 자세한 내용은 MSDN library에서 AuthPersistence 검색 [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library)합니다.  
  
> [!NOTE]
>  모두 <xref:System.Net.WebRequest.PreAuthenticate%2A> 하 고 <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> 로 설정 됩니다 `true`, 각 요청은 안전 하지 않은 풀에서 하지만 권한 부여 헤더를 사용 하 여 연결을 사용 하 여 전송 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">이 속성을 설정 하려면 무제한 웹 권한이 필요 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기본 자격 증명을 요청과 함께 보내는지 여부를 제어하는 <see cref="T:System.Boolean" /> 값을 가져오거나 설정합니다.</summary>
        <value>기본 자격 증명이 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 에서이 요청을 수행 하는 경우 <xref:System.Net.HttpWebRequest> 개체, 서버에서 요청 하는 경우 인증 해야 현재 로그온된 한 사용자의 자격 증명을 사용 합니다. 클라이언트 응용 프로그램에 대 한 대부분의 시나리오에 필요한 동작은 이것이입니다. 이 속성을 사용 하는 대신 ASP.NET 응용 프로그램과 같은 중간 계층 응용 프로그램에 대 한 일반적으로 설정 된 <xref:System.Net.HttpWebRequest.Credentials%2A> 속성 대신 요청 클라이언트의 자격 증명을 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">요청을 보낸 후에 이 속성을 설정하려고 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="User-agent" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="User-agent" /> 헤더의 값입니다. 기본값은 <see langword="null" />입니다.  
  
 <block subset="none" type="note"><para>  
 이 속성의 값은 <see cref="T:System.Net.WebHeaderCollection" />에 저장됩니다. WebHeaderCollection이 설정되면 속성 값이 손실됩니다.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 <xref:System.Net.HttpWebRequest.UserAgent%2A> 속성입니다.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>