<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2c47bbf74c7f856bea7b4b54550203dc60592929" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53465144" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ee96c-101">부호 있는 임의의 큰 정수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-101">Represents an arbitrarily large signed integer.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-102"><xref:System.Numerics.BigInteger> 형식은 이론상에서 값에 상한이 나 하 한 범위 없음 임의로 큰 정수를 나타내는 변경할 수 없는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-102">The <xref:System.Numerics.BigInteger> type is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds.</span></span> <span data-ttu-id="ee96c-103">멤버는 <xref:System.Numerics.BigInteger> 형식에 다른 정수 계열 형식의 항목을 밀접 하 게 병렬 (합니다 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>를 <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, 및 <xref:System.UInt64> 형식).</span><span class="sxs-lookup"><span data-stu-id="ee96c-103">The members of the <xref:System.Numerics.BigInteger> type closely parallel those of other integral types (the <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64> types).</span></span> <span data-ttu-id="ee96c-104">이 형식에서 다른 정수 계열 형식에서 다른 합니다 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]에 표시 되는 범위를 포함 하는 해당 `MinValue` 및 `MaxValue` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-104">This type differs from the other integral types in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], which have a range indicated by their `MinValue` and `MaxValue` properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-105">때문에 <xref:System.Numerics.BigInteger> 유형을 변경할 수 없는 (참조 [반복성 및 BigInteger 구조체](#mutability)) 및 상한 또는 하 한 범위 없음 있기 때문에 <xref:System.OutOfMemoryException> 시키는 모든 작업에 대해 throw 할 수 있습니다를 <xref:System.Numerics.BigInteger> 너무 증가 하는 값 큰 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-105">Because the <xref:System.Numerics.BigInteger> type is immutable (see [Mutability and the BigInteger Structure](#mutability)) and because it has no upper or lower bounds, an <xref:System.OutOfMemoryException> can be thrown for any operation that causes a <xref:System.Numerics.BigInteger> value to grow too large.</span></span>  
  
## <a name="instantiating-a-biginteger-object"></a><span data-ttu-id="ee96c-106">BigInteger 개체 인스턴스화</span><span class="sxs-lookup"><span data-stu-id="ee96c-106">Instantiating a BigInteger Object</span></span>  
 <span data-ttu-id="ee96c-107">인스턴스화할 수 있습니다는 <xref:System.Numerics.BigInteger> 여러 가지 방법으로 개체:</span><span class="sxs-lookup"><span data-stu-id="ee96c-107">You can instantiate a <xref:System.Numerics.BigInteger> object in several ways:</span></span>  
  
-   <span data-ttu-id="ee96c-108">사용할 수는 `new` 키워드 정수 계열 또는 부동 소수점 값을 매개 변수로 제공 하 고는 <xref:System.Numerics.BigInteger> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-108">You can use the `new` keyword and provide any integral or floating-point value as a parameter to the <xref:System.Numerics.BigInteger> constructor.</span></span> <span data-ttu-id="ee96c-109">(부동 소수점 값을 할당 하기 전에 잘립니다는 <xref:System.Numerics.BigInteger>.) 다음 예제를 사용 하는 방법을 합니다 `new` 인스턴스화할 키워드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-109">(Floating-point values are truncated before they are assigned to the <xref:System.Numerics.BigInteger>.) The following example illustrates how to use the `new` keyword to instantiate <xref:System.Numerics.BigInteger> values.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   <span data-ttu-id="ee96c-110">선언할 수는 <xref:System.Numerics.BigInteger> 변수와 값 수는 해당 값이 정수 계열 형식으로 모든 숫자 유형 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-110">You can declare a <xref:System.Numerics.BigInteger> variable and assign it a value just as you would any numeric type, as long as that value is an integral type.</span></span> <span data-ttu-id="ee96c-111">다음 예제에서는 할당을 사용 하 여 만들려는 <xref:System.Numerics.BigInteger> 에서 값을 <xref:System.Int64>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-111">The following example uses assignment to create a <xref:System.Numerics.BigInteger> value from an <xref:System.Int64>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   <span data-ttu-id="ee96c-112">10 진수 또는 부동 소수점 값을 할당할 수 있습니다는 <xref:System.Numerics.BigInteger> 개체 값을 캐스팅 또는 먼저 변환 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ee96c-112">You can assign a decimal or floating-point value to a <xref:System.Numerics.BigInteger> object if you cast the value or convert it first.</span></span> <span data-ttu-id="ee96c-113">다음 예제에서는 명시적으로 캐스팅 (C#에서) 또는 변환 (Visual Basic)에서는 <xref:System.Double> 및 <xref:System.Decimal> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-113">The following example explicitly casts (in C#) or converts (in Visual Basic) a <xref:System.Double> and a <xref:System.Decimal> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 <span data-ttu-id="ee96c-114">이러한 메서드를 인스턴스화하는 데 사용 된 <xref:System.Numerics.BigInteger> 값인 하나의 기존 숫자 값의 범위 개체 형식 에서만.</span><span class="sxs-lookup"><span data-stu-id="ee96c-114">These methods enable you to instantiate a <xref:System.Numerics.BigInteger> object whose value is in the range of one of the existing numeric types only.</span></span> <span data-ttu-id="ee96c-115">인스턴스화할 수 있습니다는 <xref:System.Numerics.BigInteger> 개체 값을 갖는 세 가지 방법 중 하나에서 기존 숫자 형식의 범위를 초과할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-115">You can instantiate a <xref:System.Numerics.BigInteger> object whose value can exceed the range of the existing numeric types in one of three ways:</span></span>  
  
-   <span data-ttu-id="ee96c-116">사용할 수는 `new` 키워드 수 있는 모든 크기의 바이트 배열을 제공 하 고는 <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-116">You can use the `new` keyword and provide a byte array of any size to the <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="ee96c-117">예:</span><span class="sxs-lookup"><span data-stu-id="ee96c-117">For example:</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   <span data-ttu-id="ee96c-118">호출할 수 있습니다 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 또는 <xref:System.Numerics.BigInteger.TryParse%2A> 숫자의 문자열 표현을 변환 하는 메서드를 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-118">You can call the <xref:System.Numerics.BigInteger.Parse%2A> or <xref:System.Numerics.BigInteger.TryParse%2A> methods to convert the string representation of a number to a <xref:System.Numerics.BigInteger>.</span></span> <span data-ttu-id="ee96c-119">예:</span><span class="sxs-lookup"><span data-stu-id="ee96c-119">For example:</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   <span data-ttu-id="ee96c-120">호출할 수 있습니다는 `static` (`Shared` Visual basic에서) <xref:System.Numerics.BigInteger> 숫자 식의 일부 작업을 수행 하 고 계산을 반환 하는 메서드 <xref:System.Numerics.BigInteger> 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-120">You can call a `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> method that performs some operation on a numeric expression and returns a calculated <xref:System.Numerics.BigInteger> result.</span></span> <span data-ttu-id="ee96c-121">다음 예제는이 큐브를 위해 <xref:System.UInt64.MaxValue?displayProperty=nameWithType> 결과를 할당 하 고는 <xref:System.Numerics.BigInteger>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-121">The following example does this by cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> and assigning the result to a <xref:System.Numerics.BigInteger>.</span></span>  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 <span data-ttu-id="ee96c-122">초기화 되지 않은 값을 <xref:System.Numerics.BigInteger> 는 <xref:System.Numerics.BigInteger.Zero%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-122">The uninitialized value of a <xref:System.Numerics.BigInteger> is <xref:System.Numerics.BigInteger.Zero%2A>.</span></span>  
  
## <a name="performing-operations-on-biginteger-values"></a><span data-ttu-id="ee96c-123">BigInteger 값에 대 한 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-123">Performing Operations on BigInteger Values</span></span>  
 <span data-ttu-id="ee96c-124">사용할 수는 <xref:System.Numerics.BigInteger> 다른 정수 계열 형식을 사용 하는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ee96c-124">You can use a <xref:System.Numerics.BigInteger> instance as you would use any other integral type.</span></span> <span data-ttu-id="ee96c-125"><xref:System.Numerics.BigInteger> 더하기, 빼기, 나누기, 곱하기, 빼기, 부정, 및 단항 부정 연산자와 같은 기본 수치 연산을 수행할 수 있도록 표준 숫자 연산자 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-125"><xref:System.Numerics.BigInteger> overloads the standard numeric operators to enable you to perform basic mathematical operations such as addition, subtraction, division, multiplication, subtraction, negation, and unary negation.</span></span> <span data-ttu-id="ee96c-126">비교할 두 개의 표준 숫자 연산자를 사용할 수도 있습니다 <xref:System.Numerics.BigInteger> 서로 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-126">You can also use the standard numeric operators to compare two <xref:System.Numerics.BigInteger> values with each other.</span></span> <span data-ttu-id="ee96c-127">다른 정수 계열 형식과 마찬가지로 <xref:System.Numerics.BigInteger> 비트 지원 `And`를 `Or`, `XOr`, 왼쪽 시프트 및 오른쪽 시프트 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-127">Like the other integral types, <xref:System.Numerics.BigInteger> also supports the bitwise `And`, `Or`, `XOr`, left shift, and right shift operators.</span></span> <span data-ttu-id="ee96c-128">사용자 지정 연산자를 지원 하지 않는 언어를 <xref:System.Numerics.BigInteger> 구조 수치 연산을 수행 하기 위한 동등한 메서드도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-128">For languages that do not support custom operators, the <xref:System.Numerics.BigInteger> structure also provides equivalent methods for performing mathematical operations.</span></span> <span data-ttu-id="ee96c-129">여기에 포함 됩니다 <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>를 <xref:System.Numerics.BigInteger.Multiply%2A>를 <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, 등입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-129">These include <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, and several others.</span></span>  
  
 <span data-ttu-id="ee96c-130">많은 멤버를 <xref:System.Numerics.BigInteger> 구조 다른 정수 계열 형식의 멤버에 직접 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-130">Many members of the <xref:System.Numerics.BigInteger> structure correspond directly to members of the other integral types.</span></span> <span data-ttu-id="ee96c-131">또한 <xref:System.Numerics.BigInteger> 다음과 같은 멤버를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-131">In addition, <xref:System.Numerics.BigInteger> adds members such as the following:</span></span>  
  
-   <span data-ttu-id="ee96c-132"><xref:System.Numerics.BigInteger.Sign%2A>에서의 부호를 나타내는 값을 반환 하는 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-132"><xref:System.Numerics.BigInteger.Sign%2A>, which returns a value that indicates the sign of a <xref:System.Numerics.BigInteger> value.</span></span>  
  
-   <span data-ttu-id="ee96c-133"><xref:System.Numerics.BigInteger.Abs%2A>에서의 절대 값을 반환 하는 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-133"><xref:System.Numerics.BigInteger.Abs%2A>, which returns the absolute value of a <xref:System.Numerics.BigInteger> value.</span></span>  
  
-   <span data-ttu-id="ee96c-134"><xref:System.Numerics.BigInteger.DivRem%2A>몫과 나누기 연산의 나머지를 모두 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-134"><xref:System.Numerics.BigInteger.DivRem%2A>, which returns both the quotient and remainder of a division operation.</span></span>  
  
-   <span data-ttu-id="ee96c-135"><xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>를 2의 최대 공약수를 반환 하는 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-135"><xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, which returns the greatest common divisor of two <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="ee96c-136">멤버에 해당 하는 대부분의 이러한 추가 멤버를 <xref:System.Math> 기본 숫자 형식을 사용 하는 기능을 제공 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-136">Many of these additional members correspond to the members of the <xref:System.Math> class, which provides the functionality to work with the primitive numeric types.</span></span>  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a><span data-ttu-id="ee96c-137">반복성 및 BigInteger 구조체</span><span class="sxs-lookup"><span data-stu-id="ee96c-137">Mutability and the BigInteger Structure</span></span>  
 <span data-ttu-id="ee96c-138">다음 예제에서는 <xref:System.Numerics.BigInteger> 개체 및 해당 값 1 씩 증가 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-138">The following example instantiates a <xref:System.Numerics.BigInteger> object and then increments its value by one.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 <span data-ttu-id="ee96c-139">이 예제에서는 기존 개체의 값을 수정 하려면 나타나지만, 대/소문자 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-139">Although this example appears to modify the value of the existing object, this is not the case.</span></span> <span data-ttu-id="ee96c-140"><xref:System.Numerics.BigInteger> 개체는, 즉 내부적으로, 공용 언어 런타임에서 실제로 새로 만들고 <xref:System.Numerics.BigInteger> 개체 및 이전 값 보다 하나 더 큰 값을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-140"><xref:System.Numerics.BigInteger> objects are immutable, which means that internally, the common language runtime actually creates a new <xref:System.Numerics.BigInteger> object and assigns it a value one greater than its previous value.</span></span> <span data-ttu-id="ee96c-141">이 새 개체를 호출자에 게 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-141">This new object is then returned to the caller.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-142">.NET Framework의 다른 숫자 형식도 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-142">The other numeric types in the .NET Framework are also immutable.</span></span> <span data-ttu-id="ee96c-143">그러나 때문에 <xref:System.Numerics.BigInteger> 형식은 상한 또는 하 한 범위 없음, 해당 값 매우 커질 및 성능에 크게 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-143">However, because the <xref:System.Numerics.BigInteger> type has no upper or lower bounds, its values can grow extremely large and have a measurable impact on performance.</span></span>  
  
 <span data-ttu-id="ee96c-144">이 프로세스를 호출자에 게 투명 하지만 성능 저하를 유발 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-144">Although this process is transparent to the caller, it does incur a performance penalty.</span></span> <span data-ttu-id="ee96c-145">일부 경우에 특히 경우 반복된 작업은 수행 루프에서 매우 큰 <xref:System.Numerics.BigInteger> 값을 해당 성능이 중요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-145">In some cases, especially when repeated operations are performed in a loop on very large <xref:System.Numerics.BigInteger> values, that performance penalty can be significant.</span></span> <span data-ttu-id="ee96c-146">예를 들어, 다음 예제에서 작업이 수행 되는 백만 번을 반복적으로 <xref:System.Numerics.BigInteger> 될 때마다 작업에 성공 하면 값이 1 씩 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-146">For example, in the following example, an operation is performed repetitively up to a million times, and a <xref:System.Numerics.BigInteger> value is incremented by one every time the operation succeeds.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 <span data-ttu-id="ee96c-147">이러한 경우에 대 한 모든 중간 할당을 수행 하 여 성능을 개선할 수 있습니다는 <xref:System.Int32> 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-147">In such a case, you can improve performance by performing all intermediate assignments to an <xref:System.Int32> variable.</span></span> <span data-ttu-id="ee96c-148">변수의 최종 값 다음 할당할 수는 <xref:System.Numerics.BigInteger> 루프 종료 될 때 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-148">The final value of the variable can then be assigned to the <xref:System.Numerics.BigInteger> object when the loop exits.</span></span> <span data-ttu-id="ee96c-149">다음 예제에서 이에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-149">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a><span data-ttu-id="ee96c-150">16 진수 문자열과 바이트 배열 사용</span><span class="sxs-lookup"><span data-stu-id="ee96c-150">Working with Byte Arrays and Hexadecimal Strings</span></span>  
 <span data-ttu-id="ee96c-151">변환 하는 경우 <xref:System.Numerics.BigInteger> 값을 바이트 배열로, 바이트 배열에 변환 하는 경우 또는 <xref:System.Numerics.BigInteger> 값을 바이트의 순서를 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-151">If you convert <xref:System.Numerics.BigInteger> values to byte arrays, or if you convert byte arrays to <xref:System.Numerics.BigInteger> values, you must consider the order of bytes.</span></span> <span data-ttu-id="ee96c-152"><xref:System.Numerics.BigInteger> 구조 little endian 순서로 표시할 바이트 배열에서 개별 바이트를 예상 합니다 (즉, 값의 낮은 순서 바이트 앞에 야 고차 바이트)입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-152">The <xref:System.Numerics.BigInteger> structure expects the individual bytes in a byte array to appear in little-endian order (that is, the lower-order bytes of the value precede the higher-order bytes).</span></span> <span data-ttu-id="ee96c-153">왕복할 수 있습니다는 <xref:System.Numerics.BigInteger> 호출 하 여 값을 <xref:System.Numerics.BigInteger.ToByteArray%2A> 메서드와 전달 결과 바이트 배열을 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 다음 예제와 같이 생성자.</span><span class="sxs-lookup"><span data-stu-id="ee96c-153">You can round-trip a <xref:System.Numerics.BigInteger> value by calling the <xref:System.Numerics.BigInteger.ToByteArray%2A> method and then passing the resulting byte array to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 <span data-ttu-id="ee96c-154">인스턴스화하는 <xref:System.Numerics.BigInteger> 값 다른 정수 계열 형식의 값을 나타내는 바이트 배열에서 정수 계열 값을 전달할 수 있습니다 합니다 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 메서드를 전달 하 고 결과 바이트 배열를 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자.</span><span class="sxs-lookup"><span data-stu-id="ee96c-154">To instantiate a <xref:System.Numerics.BigInteger> value from a byte array that represents a value of some other integral type, you can pass the integral value to the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method, and then pass the resulting byte array to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span> <span data-ttu-id="ee96c-155">다음 예제에서는 한 <xref:System.Numerics.BigInteger> 나타내는 바이트 배열에서 값을 <xref:System.Int16> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-155">The following example instantiates a <xref:System.Numerics.BigInteger> value from a byte array that represents an <xref:System.Int16> value.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <span data-ttu-id="ee96c-156"><xref:System.Numerics.BigInteger> 구조 음수 값 2의 보수 표현을 사용 하 여 저장 된 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-156">The <xref:System.Numerics.BigInteger> structure assumes that negative values are stored by using two's complement representation.</span></span> <span data-ttu-id="ee96c-157">때문에 <xref:System.Numerics.BigInteger> 구조에 없는 고정된 길이 숫자 값을 나타내는 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자에는 항상 가장 중요 한 비트를 부호 비트로 배열의 마지막 바이트의 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-157">Because the <xref:System.Numerics.BigInteger> structure represents a numeric value with no fixed length, the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor always interprets the most significant bit of the last byte in the array as a sign bit.</span></span> <span data-ttu-id="ee96c-158">방지 하기 위해는 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 2의 보수 표현한 음수 값을 양수 값 이면 양수의 크기와 부호가 표현으로 혼동의 생성자는 가장 값 비트가 바이트 배열에서 마지막 바이트 일반적으로 추가 바이트 값이 0 인 집합에 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-158">To prevent the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor from confusing the two's complement representation of a negative value with the sign and magnitude representation of a positive value, positive values in which the most significant bit of the last byte in the byte array would ordinarily be set should include an additional byte whose value is 0.</span></span> <span data-ttu-id="ee96c-159">예를 들어 0xC0 0xBD 0xF0 0xFF-1,000,000 또는 4,293,967,296 little endian 16 진수 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-159">For example, 0xC0 0xBD 0xF0 0xFF is the little-endian hexadecimal representation of either -1,000,000 or 4,293,967,296.</span></span> <span data-ttu-id="ee96c-160">바이트 배열의 값으로 해석이 배열의 마지막 바이트의 가장 중요 한 비트 이기 때문에 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> -1,000,000 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-160">Because the most significant bit of the last byte in this array is on, the value of the byte array would be interpreted by the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor as -1,000,000.</span></span> <span data-ttu-id="ee96c-161">인스턴스화하는 <xref:System.Numerics.BigInteger> 해당 값이 양수 이면 요소가 0xC0 바이트 배열 0xBD 0xF0 0xFF 0x00 생성자에 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-161">To instantiate a <xref:System.Numerics.BigInteger> whose value is positive, a byte array whose elements are 0xC0 0xBD 0xF0 0xFF 0x00 must be passed to the constructor.</span></span> <span data-ttu-id="ee96c-162">다음은 이에 대한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-162">The following example illustrates this.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 <span data-ttu-id="ee96c-163">생성 된 바이트 배열은 <xref:System.Numerics.BigInteger.ToByteArray%2A> 메서드에서 양수 값이 추가 0 값 바이트를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-163">Byte arrays created by the <xref:System.Numerics.BigInteger.ToByteArray%2A> method from positive values include this extra zero-value byte.</span></span> <span data-ttu-id="ee96c-164">따라서는 <xref:System.Numerics.BigInteger> 구조를 할당 하 고 다음 예제와 같이 바이트 배열에서 복원 하 여 성공적으로 라운드트립 값 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-164">Therefore, the <xref:System.Numerics.BigInteger> structure can successfully round-trip values by assigning them to, and then restoring them from, byte arrays, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 <span data-ttu-id="ee96c-165">개발자가 동적으로 만들어지는 또는 부호 없는 정수를 바이트 배열로 변환 하는 메서드에서 반환 되는 바이트 배열에이 추가 값 0 바이트를 추가 해야 하는 반면 (같은 <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, 및 <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="ee96c-165">However, you may need to add this additional zero-value byte to byte arrays that are created dynamically by the developer or that are returned by methods that convert unsigned integers to byte arrays (such as <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, and <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="ee96c-166">16 진수 문자열을 구문 분석 하는 경우는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> 고 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드 가정 문자열의 첫 번째 바이트의 가장 중요 한 비트가 설정 된 경우 값은 문자열의 첫 번째 16 진수 바이트 값의 낮은 4 개의 비트를 나타내는 경우 2의 보수 표현을 사용 하 여 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-166">When parsing a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> and <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> methods assume that if the most significant bit of the first byte in the string is set, or if the first hexadecimal digit of the string represents the lower four bits of a byte value, the value is represented by using two's complement representation.</span></span> <span data-ttu-id="ee96c-167">예를 들어, "FF01" 및 "F01" 나타내는 10 진수 값-255를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-167">For example, both "FF01" and "F01" represent the decimal value -255.</span></span> <span data-ttu-id="ee96c-168">음수 값에서 양수를 구별 하려면 양수 값 앞에 0이 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-168">To differentiate positive from negative values, positive values should include a leading zero.</span></span> <span data-ttu-id="ee96c-169">관련 된 오버 로드는 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 "X" 형식 문자열에 전달 될 때 양수 값에 대해 반환 되는 16 진수 문자열에 선행 0을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-169">The relevant overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, when they are passed the "X" format string, add a leading zero to the returned hexadecimal string for positive values.</span></span> <span data-ttu-id="ee96c-170">따라서 왕복 <xref:System.Numerics.BigInteger> 를 사용 하 여 값을 <xref:System.Numerics.BigInteger.ToString%2A> 및 <xref:System.Numerics.BigInteger.Parse%2A> 메서드를 다음 예제와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-170">This makes it possible to round-trip <xref:System.Numerics.BigInteger> values by using the <xref:System.Numerics.BigInteger.ToString%2A> and <xref:System.Numerics.BigInteger.Parse%2A> methods, as the following example shows.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 <span data-ttu-id="ee96c-171">호출 하 여 16 진수 문자열을 생성 하는 반면를 `ToString` 다른 정수 형식 또는 오버 로드의 메서드를 <xref:System.Convert.ToString%2A> 포함 하는 메서드를 `toBase` 매개 변수는 원본 데이터 형식 또는 값의 부호를 나타내지 않습니다 16 진수 문자열 파생 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-171">However, the hexadecimal strings created by calling the `ToString` methods of the other integral types or the overloads of the <xref:System.Convert.ToString%2A> method that include a `toBase` parameter do not indicate the sign of the value or the source data type from which the hexadecimal string was derived.</span></span> <span data-ttu-id="ee96c-172">성공적으로 인스턴스화하는 <xref:System.Numerics.BigInteger> 이러한 문자열의 값에는 몇 가지 추가 논리가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-172">Successfully instantiating a <xref:System.Numerics.BigInteger> value from such a string requires some additional logic.</span></span> <span data-ttu-id="ee96c-173">다음 예제에서는 한 가지 구현을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-173">The following example provides one possible implementation.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-174"><see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-174">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-175">little-endian 순서로 된 바이트 값의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-175">An array of byte values in little-endian order.</span></span></param>
        <summary><span data-ttu-id="ee96c-176">바이트 배열의 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-176">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using the values in a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-177">개별 바이트를 `value` 가장 높은 순서 바이트가 최하위 바이트에서 little endian 순서로 배열 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-177">The individual bytes in the `value` array should be in little-endian order, from lowest-order byte to highest-order byte.</span></span> <span data-ttu-id="ee96c-178">예를 들어 1000000000000 숫자 값을 다음 표에 나와 있는 것 처럼 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-178">For example, the numeric value 1,000,000,000,000 is represented as shown in the following table:</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="ee96c-179">16 진수 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-179">Hexadecimal string</span></span>|<span data-ttu-id="ee96c-180">E8D4A51000</span><span class="sxs-lookup"><span data-stu-id="ee96c-180">E8D4A51000</span></span>|  
|<span data-ttu-id="ee96c-181">바이트 배열 (최저 인덱스를 먼저)</span><span class="sxs-lookup"><span data-stu-id="ee96c-181">Byte array (lowest index first)</span></span>|<span data-ttu-id="ee96c-182">00 10 A5 D4 E8 00</span><span class="sxs-lookup"><span data-stu-id="ee96c-182">00 10 A5 D4 E8 00</span></span>|  
  
 <span data-ttu-id="ee96c-183">와 같은 바이트 배열에 숫자 값을 변환 하는 대부분의 메서드 <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> 고 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, little endian 순서로 바이트 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-183">Most methods that convert numeric values to byte arrays, such as <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> and <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, return byte arrays in little-endian order.</span></span>  
  
 <span data-ttu-id="ee96c-184">생성자는 양수 값 및 사용 하 여 로그인 및 크기 표현을 음수 값 2의 보수 표현을 사용 하 여 바이트 배열 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-184">The constructor expects positive values in the byte array to use sign-and-magnitude representation, and negative values to use two's complement representation.</span></span> <span data-ttu-id="ee96c-185">즉, 가장 높은 순위의 비트에서 최상위 바이트의 경우 `value` 결과 집합은 <xref:System.Numerics.BigInteger> 값이 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-185">In other words, if the highest-order bit of the highest-order byte in `value` is set, the resulting <xref:System.Numerics.BigInteger> value is negative.</span></span> <span data-ttu-id="ee96c-186">바이트 배열의 원본에 따라이 음수 값으로 잘못 해석 될 수는 양수를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-186">Depending on the source of the byte array, this may cause a positive value to be misinterpreted as a negative value.</span></span> <span data-ttu-id="ee96c-187">바이트 배열은 일반적으로 다음과 같은 방법으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-187">Byte arrays are typically generated in the following ways:</span></span>  
  
-   <span data-ttu-id="ee96c-188">호출 하 여는 <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-188">By calling the <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ee96c-189">이 메서드를 반환 하므로 가장 높은 순위의 바이트의 최상위 비트를 사용 하 여 바이트 배열 배열 집합의 양수 값에 대 한 0 양수 값을 잘못의 확률이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-189">Because this method returns a byte array with the highest-order bit of the highest-order byte in the array set to zero for positive values, there is no chance of misinterpreting a positive value as negative.</span></span> <span data-ttu-id="ee96c-190">생성 된 바이트 배열 수정 되지 않은 합니다 <xref:System.Numerics.BigInteger.ToByteArray%2A> 에 전달 될 때 항상 성공적으로 라운드트립 메서드는 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-190">Unmodified byte arrays created by the <xref:System.Numerics.BigInteger.ToByteArray%2A> method always successfully round-trip when they are passed to the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span>  
  
-   <span data-ttu-id="ee96c-191">호출 하 여는 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 메서드와 부호 있는 정수를 매개 변수로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-191">By calling the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method and passing it a signed integer as a parameter.</span></span> <span data-ttu-id="ee96c-192">부호 있는 정수의 부호 및 크기 표현 및 2의 보수 표현 모두를 처리 되므로 양수 값을 잘못 가능성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-192">Because signed integers handle both sign-and-magnitude representation and two's complement representation, there is no chance of misinterpreting a positive value as negative.</span></span>  
  
-   <span data-ttu-id="ee96c-193">호출 하 여는 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 메서드와 부호 없는 정수를 매개 변수로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-193">By calling the <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> method and passing it an unsigned integer as a parameter.</span></span> <span data-ttu-id="ee96c-194">부호 없는 정수 크기 만으로 표시 되는 때문에 양수 값 음수 값으로 잘못 해석 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-194">Because unsigned integers are represented by their magnitude only, positive values can be misinterpreted as negative values.</span></span> <span data-ttu-id="ee96c-195">이 잘못 해석 하지 않으려면 0 바이트 값을 배열의 끝에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-195">To prevent this misinterpretation, you can add a zero-byte value to the end of the array.</span></span> <span data-ttu-id="ee96c-196">다음 섹션의 예제는 예시를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-196">The example in the next section provides an illustration.</span></span>  
  
-   <span data-ttu-id="ee96c-197">바이트 배열 생성 하거나 동적 또는 정적으로 없이 반드시 여 이전 방법 또는 기존 바이트 배열을 수정 하 여 하나를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-197">By creating a byte array either dynamically or statically without necessarily calling any of the previous methods, or by modifying an existing byte array.</span></span> <span data-ttu-id="ee96c-198">양수 값 음수 값으로 잘못 해석 될을 방지 하려면 0 바이트 값을 배열의 끝에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-198">To prevent positive values from being misinterpreted as negative values, you can add a zero-byte value to the end of the array.</span></span>  
  
 <span data-ttu-id="ee96c-199">하는 경우 `value` 빈 <xref:System.Byte> array, 새 <xref:System.Numerics.BigInteger> 개체의 값으로 초기화 됩니다 <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-199">If `value` is an empty <xref:System.Byte> array, the new <xref:System.Numerics.BigInteger> object is initialized to a value of <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-200">경우 `value` 됩니다 `null`, 생성자가 throw는 <xref:System.ArgumentNullException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-200">If `value` is `null`, the constructor throws an <xref:System.ArgumentNullException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-201">다음 예제에서는 <xref:System.Numerics.BigInteger> 값인 {5, 4, 3, 2, 1} 5 요소 바이트 배열에서 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-201">The following example instantiates a <xref:System.Numerics.BigInteger> object from a 5-element byte array whose value is {5, 4, 3, 2, 1}.</span></span> <span data-ttu-id="ee96c-202">그런 다음 표시는 <xref:System.Numerics.BigInteger> 값을 콘솔에 10 진수 및 16 진수 숫자로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-202">It then displays the <xref:System.Numerics.BigInteger> value, represented as both decimal and hexadecimal numbers, to the console.</span></span> <span data-ttu-id="ee96c-203">텍스트 출력을 사용 하 여 입력 배열의 비교 명확해 이유는이 오버 로드는 <xref:System.Numerics.BigInteger> 클래스 생성자를 만듭니다를 <xref:System.Numerics.BigInteger> 4328719365 (또는 0x102030405) 값인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-203">A comparison of the input array with the text output makes it clear why this overload of the <xref:System.Numerics.BigInteger> class constructor creates a <xref:System.Numerics.BigInteger> object whose value is 4328719365 (or 0x102030405).</span></span> <span data-ttu-id="ee96c-204">최하위 바이트의 값을 정의 하는 값은 5, 바이트 배열의 첫 번째 요소는 <xref:System.Numerics.BigInteger> 0x05 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-204">The first element of the byte array, whose value is 5, defines the value of the lowest-order byte of the <xref:System.Numerics.BigInteger> object, which is 0x05.</span></span> <span data-ttu-id="ee96c-205">두 번째 바이트의 값을 정의 하는 값이 4 인 바이트 배열의 두 번째 요소는 <xref:System.Numerics.BigInteger> 등에 0x04 인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-205">The second element of the byte array, whose value is 4, defines the value of the second byte of the <xref:System.Numerics.BigInteger> object, which is 0x04, and so on.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 <span data-ttu-id="ee96c-206">다음 예에서는 양수 및 음수 인스턴스화합니다 <xref:System.Numerics.BigInteger> 값을 전달 합니다는 <xref:System.Numerics.BigInteger.ToByteArray%2A> 메서드를 다음 원래 복원 <xref:System.Numerics.BigInteger> 결과 바이트 배열에서 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-206">The following example instantiates a positive and a negative <xref:System.Numerics.BigInteger> value, passes them to the <xref:System.Numerics.BigInteger.ToByteArray%2A> method, and then restores the original <xref:System.Numerics.BigInteger> values from the resulting byte array.</span></span> <span data-ttu-id="ee96c-207">두 값을 동일한 바이트 배열으로 표시 한다는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-207">Note that the two values are represented by identical byte arrays.</span></span> <span data-ttu-id="ee96c-208">유일한 차이점 바이트 배열에서 마지막 요소의 가장 중요 한 비트의 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-208">The only difference between them is in the most significant bit of the last element in the byte array.</span></span> <span data-ttu-id="ee96c-209">이 비트가 설정 (바이트의 값은 0xFF) 이면 음수에서 만든 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-209">This bit is set (the value of the byte is 0xFF) if the array is created from a negative <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="ee96c-210">비트 배열을 양수에서 만들어지는 경우 (바이트의 값이 0)을 설정 하지 않으면 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-210">The bit is not set (the value of the byte is zero), if the array is created from a positive <xref:System.Numerics.BigInteger> value.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 <span data-ttu-id="ee96c-211">다음 예제는 양수 값을 잘못 인스턴스화되지 않았습니다 음수 값으로 값이 배열의 끝에 0 인 바이트를 추가 하 여 있는지 확인 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-211">The following example illustrates how to make sure that a positive value is not incorrectly instantiated as a negative value by adding a byte whose value is zero to the end of the array.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee96c-212"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-212"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-213">10진수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-213">A decimal number.</span></span></param>
        <summary><span data-ttu-id="ee96c-214"><see cref="T:System.Numerics.BigInteger" /> 값을 사용하여 <see cref="T:System.Decimal" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-214">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a <see cref="T:System.Decimal" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-215">이 생성자를 호출 하는 결과 동일 명시적으로 할당 하는 <xref:System.Decimal> 값을 <xref:System.Numerics.BigInteger> 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-215">The result of calling this constructor is identical to explicitly assigning a <xref:System.Decimal> value to a <xref:System.Numerics.BigInteger> variable.</span></span>  
  
 <span data-ttu-id="ee96c-216">이 생성자를 호출 하면 데이터 손실이; 소수 부분은 `value` 인스턴스화할 때 잘립니다를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-216">Calling this constructor can cause data loss; any fractional part of `value` is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-217">다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-217">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="ee96c-218">배열을 정의 <xref:System.Decimal> 값을 가져온 다음 각 값을 전달 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-218">It defines an array of <xref:System.Decimal> values, and then passes each value to the <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor.</span></span> <span data-ttu-id="ee96c-219">합니다 <xref:System.Decimal> 대신에 할당 되는 경우 반올림 하는 값은 잘립니다는 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-219">Note that the <xref:System.Decimal> value is truncated instead of rounded when it is assigned to the <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-220">배정밀도 부동 소수점 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-220">A double-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="ee96c-221">배정밀도 부동 소수점 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-221">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a double-precision floating-point value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-222">소수 부분은 합니다 `value` 매개 변수를 인스턴스화할 때 잘립니다를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-222">Any fractional part of the `value` parameter is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="ee96c-223">전체 자릿수의 부족으로 인해는 <xref:System.Double> 이 생성자를 호출 하는 데이터 형식에 데이터 손실이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-223">Because of the lack of precision of the <xref:System.Double> data type, calling this constructor can cause data loss.</span></span>  
  
 <span data-ttu-id="ee96c-224">합니다 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값이 명시적으로 할당 한 결과 값과 동일한를 <xref:System.Double> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-224">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from explicitly assigning a <xref:System.Double> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-225">다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-225">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="ee96c-226">사용 하는 경우 발생할 수 있는 전체 자릿수 손실을 하는 방법도 보여 줍니다는 <xref:System.Double> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-226">It also illustrates the loss of precision that may occur when you use the <xref:System.Double> data type.</span></span> <span data-ttu-id="ee96c-227">A <xref:System.Double> 에 할당 됩니다는 큰 값이 할당 되는 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-227">A <xref:System.Double> is assigned a large value, which is then assigned to a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="ee96c-228">출력에서 볼 수 있듯이이 할당 포함 정밀도 손실이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-228">As the output shows, this assignment involves a loss of precision.</span></span> <span data-ttu-id="ee96c-229">값이 모두는 다음 1 씩 증가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-229">Both values are then incremented by one.</span></span> <span data-ttu-id="ee96c-230">출력에 표시 하는 합니다 <xref:System.Numerics.BigInteger> 반면 개체는 변경 된 값을 반영 합니다 <xref:System.Double> 개체는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-230">The output shows that the <xref:System.Numerics.BigInteger> object reflects the changed value, whereas the <xref:System.Double> object does not.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-231"><paramref name="value" />가 <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> 또는 <see cref="F:System.Double.PositiveInfinity" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-231"><paramref name="value" /> is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-232">32비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-232">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-233">부호 있는 32비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-233">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 32-bit signed integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-234">인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-234">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> object by using this constructor.</span></span>  
  
 <span data-ttu-id="ee96c-235"><xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.Int32> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-235">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning an <xref:System.Int32> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
 <span data-ttu-id="ee96c-236">합니다 <xref:System.Numerics.BigInteger> 구조 형식의 매개 변수를 사용 하 여 생성자를 포함 되지 않습니다 <xref:System.Byte>를 <xref:System.Int16>를 <xref:System.SByte>, 또는 <xref:System.UInt16>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-236">The <xref:System.Numerics.BigInteger> structure does not include constructors with a parameter of type <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, or <xref:System.UInt16>.</span></span> <span data-ttu-id="ee96c-237">그러나는 <xref:System.Int32> 형식은 8 비트와 16 비트 부호 있는 정수와 부호 있는 32 비트 정수를 암시적으로 변환 지원.</span><span class="sxs-lookup"><span data-stu-id="ee96c-237">However, the <xref:System.Int32> type supports the implicit conversion of 8-bit and 16-bit signed and unsigned integers to signed 32-bit integers.</span></span> <span data-ttu-id="ee96c-238">경우이 생성자를 호출 하는 결과적으로, `value` 이러한 네 개의 정수 형식 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-238">As a result, this constructor is called if `value` is any one of these four integral types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-239">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> 인스턴스화하는 생성자 <xref:System.Numerics.BigInteger> 값에서 32 비트 정수의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-239">The following example calls the <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> constructor to instantiate <xref:System.Numerics.BigInteger> values from an array of 32-bit integers.</span></span> <span data-ttu-id="ee96c-240">또한 사용 하 여 암시적 변환을 각 32 비트 정수 값을 할당 한 <xref:System.Numerics.BigInteger> 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-240">It also uses implicit conversion to assign each 32-bit integer value to a <xref:System.Numerics.BigInteger> variable.</span></span> <span data-ttu-id="ee96c-241">다음 비교는 연결할 두 값 결과 <xref:System.Numerics.BigInteger> 값이 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-241">It then compares the two values to establish that the resulting <xref:System.Numerics.BigInteger> values are the same.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-242">64비트 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-242">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-243">부호 있는 64비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-243">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a 64-bit signed integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-244">인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 하 여 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-244">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> object by using this constructor.</span></span>  
  
 <span data-ttu-id="ee96c-245"><xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.Int64> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-245">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning an <xref:System.Int64> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-246">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> 인스턴스화하는 생성자 <xref:System.Numerics.BigInteger> 64 비트 정수의 배열 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-246">The following example calls the <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> constructor to instantiate <xref:System.Numerics.BigInteger> values from an array of 64-bit integers.</span></span> <span data-ttu-id="ee96c-247">또한 사용 하 여 암시적 변환을 각 64 비트 정수 값을 할당 한 <xref:System.Numerics.BigInteger> 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-247">It also uses implicit conversion to assign each 64-bit integer value to a <xref:System.Numerics.BigInteger> variable.</span></span> <span data-ttu-id="ee96c-248">다음 비교는 연결할 두 값 결과 <xref:System.Numerics.BigInteger> 값이 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-248">It then compares the two values to establish that the resulting <xref:System.Numerics.BigInteger> values are the same.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-249">단정밀도 부동 소수점 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-249">A single-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="ee96c-250">단정밀도 부동 소수점 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-250">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using a single-precision floating-point value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-251">소수 부분은 합니다 `value` 매개 변수를 인스턴스화할 때 잘립니다를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-251">Any fractional part of the `value` parameter is truncated when instantiating a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="ee96c-252">전체 자릿수의 부족으로 인해는 <xref:System.Single> 이 생성자를 호출 하는 데이터 형식에 데이터 손실이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-252">Because of the lack of precision of the <xref:System.Single> data type, calling this constructor can result in data loss.</span></span>  
  
 <span data-ttu-id="ee96c-253">합니다 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값이 명시적으로 할당 한 결과 값과 동일한를 <xref:System.Single> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-253">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from explicitly assigning a <xref:System.Single> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-254">다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-254">The following example illustrates the use of the <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="ee96c-255">사용 하는 경우 발생할 수 있는 전체 자릿수 손실을 하는 방법도 보여 줍니다는 <xref:System.Single> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-255">It also illustrates the loss of precision that may occur when you use the <xref:System.Single> data type.</span></span> <span data-ttu-id="ee96c-256">A <xref:System.Single> 에 할당 됩니다 큰 음수 값을 할당 되는 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-256">A <xref:System.Single> is assigned a large negative value, which is then assigned to a <xref:System.Numerics.BigInteger> object.</span></span> <span data-ttu-id="ee96c-257">출력에서 볼 수 있듯이이 할당 포함 정밀도 손실이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-257">As the output shows, this assignment involves a loss of precision.</span></span> <span data-ttu-id="ee96c-258">값이 모두는 다음 1 씩 증가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-258">Both values are then incremented by one.</span></span> <span data-ttu-id="ee96c-259">출력에 표시 하는 합니다 <xref:System.Numerics.BigInteger> 반면 개체는 변경 된 값을 반영 합니다 <xref:System.Single> 개체는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-259">The output shows that the <xref:System.Numerics.BigInteger> object reflects the changed value, whereas the <xref:System.Single> object does not.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-260"><paramref name="value" />가 <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> 또는 <see cref="F:System.Single.PositiveInfinity" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-260"><paramref name="value" /> is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-261">부호 없는 32비트 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-261">An unsigned 32-bit integer value.</span></span></param>
        <summary><span data-ttu-id="ee96c-262">부호 없는 32비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-262">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure using an unsigned 32-bit integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-263">인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-263">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> using this constructor.</span></span>  
  
 <span data-ttu-id="ee96c-264"><xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.UInt32> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-264">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning a <xref:System.UInt32> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-265">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> 생성자 및 초기화 하려면 대입문 <xref:System.Numerics.BigInteger> 부호 없는 32 비트 정수 배열에서 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-265">The following example uses the <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> constructor and an assignment statement to initialize <xref:System.Numerics.BigInteger> values from an array of unsigned 32-bit integers.</span></span> <span data-ttu-id="ee96c-266">다음 비교는 두 값 초기화의 두 메서드는 <xref:System.Numerics.BigInteger> 동일한 결과 생성 하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-266">It then compares the two values to demonstrate that the two methods of initializing a <xref:System.Numerics.BigInteger> value produce identical results.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-267">부호 없는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-267">An unsigned 64-bit integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-268">부호 없는 64비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-268">Initializes a new instance of the <see cref="T:System.Numerics.BigInteger" /> structure with an unsigned 64-bit integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-269">인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-269">There is no loss of precision when instantiating a <xref:System.Numerics.BigInteger> using this constructor.</span></span>  
  
 <span data-ttu-id="ee96c-270"><xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.UInt64> 값을 <xref:System.Numerics.BigInteger>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-270">The <xref:System.Numerics.BigInteger> value that results from calling this constructor is identical to the value that results from assigning a <xref:System.UInt64> value to a <xref:System.Numerics.BigInteger>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-271">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 값인 같음 개체 <xref:System.UInt64.MaxValue>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-271">The following example uses the <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> constructor to instantiate a <xref:System.Numerics.BigInteger> object whose value is equal to <xref:System.UInt64.MaxValue>.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-272">숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-272">A number.</span></span></param>
        <summary><span data-ttu-id="ee96c-273"><see cref="T:System.Numerics.BigInteger" /> 개체의 절대 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-273">Gets the absolute value of a <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <returns><span data-ttu-id="ee96c-274"><paramref name="value" />의 절대값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-274">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-275">숫자의 절대 값을 다음 표에 나와 있는 것 처럼은 부호가 없는 해당 숫자는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-275">The absolute value of a number is that number without its sign, as shown in the following table.</span></span>  
  
|<span data-ttu-id="ee96c-276">`value` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="ee96c-276">`value` parameter</span></span>|<span data-ttu-id="ee96c-277">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-277">Return value</span></span>|  
|-----------------------|------------------|  
|<span data-ttu-id="ee96c-278">`value` >= 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-278">`value` >= 0</span></span>|`value`|  
|<span data-ttu-id="ee96c-279">`value` < 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-279">`value` < 0</span></span>|<span data-ttu-id="ee96c-280">`value` \* -1</span><span class="sxs-lookup"><span data-stu-id="ee96c-280">`value` \* -1</span></span>|  
  
 <span data-ttu-id="ee96c-281">합니다 <xref:System.Numerics.BigInteger.Abs%2A> 메서드는 해당 하는 <xref:System.Math.Abs%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-281">The <xref:System.Numerics.BigInteger.Abs%2A> method is equivalent to the <xref:System.Math.Abs%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-282">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Abs%2A> 변환할 메서드는 <xref:System.Numerics.BigInteger> 파일로 직렬화 하는 작업 하기 전에 로그인 및 크기 표현에 값 2의 보수 표현에서.</span><span class="sxs-lookup"><span data-stu-id="ee96c-282">The following example uses the <xref:System.Numerics.BigInteger.Abs%2A> method to convert a <xref:System.Numerics.BigInteger> value from two's complement representation to sign-and-magnitude representation before serializing it to a file.</span></span> <span data-ttu-id="ee96c-283">파일의에서 데이터를 한 다음 deserialize 및 새 할당할 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-283">Data in the file is then deserialized and assigned to a new <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-284">더할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-284">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-285">더할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-285">The second value to add.</span></span></param>
        <summary><span data-ttu-id="ee96c-286">두 개의 <see cref="T:System.Numerics.BigInteger" /> 값을 더한 다음 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-286">Adds two <see cref="T:System.Numerics.BigInteger" /> values and returns the result.</span></span></summary>
        <returns><span data-ttu-id="ee96c-287"><paramref name="left" />와 <paramref name="right" />의 합입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-287">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-288">연산자 오버 로드 또는 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.BigInteger.Add%2A> 메서드를 사용 하 여 추가 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-288">Languages that do not support operator overloading or custom operators can use the <xref:System.Numerics.BigInteger.Add%2A> method to perform addition using <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="ee96c-289">합니다 <xref:System.Numerics.BigInteger.Add%2A> 인스턴스화할 때 메서드는 더하기 연산자에 대 한 유용한 대체는 <xref:System.Numerics.BigInteger> 다음 예와에서 같이 또한 결과로 생성 되는 합계를 할당 하 여 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-289">The <xref:System.Numerics.BigInteger.Add%2A> method is a useful substitute for the addition operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it a sum that results from addition, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-290">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-290">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-291">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-291">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-292">두 <see cref="T:System.Numerics.BigInteger" /> 값을 비교하고 첫 번째 값이 두 번째 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-292">Compares two <see cref="T:System.Numerics.BigInteger" /> values and returns an integer that indicates whether the first value is less than, equal to, or greater than the second value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-293">다음 표와 같이 <paramref name="left" /> 및 <paramref name="right" />의 상대 값을 나타내는 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-293">A signed integer that indicates the relative values of <paramref name="left" /> and <paramref name="right" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ee96c-294">값</span><span class="sxs-lookup"><span data-stu-id="ee96c-294">Value</span></span> 
 </term><description> <span data-ttu-id="ee96c-295">조건</span><span class="sxs-lookup"><span data-stu-id="ee96c-295">Condition</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ee96c-296">0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ee96c-296">Less than zero</span></span> 
 </term><description><span data-ttu-id="ee96c-297"><paramref name="left" />가 <paramref name="right" />보다 작은 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-297"><paramref name="left" /> is less than <paramref name="right" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-298">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-298">Zero</span></span> 
 </term><description><span data-ttu-id="ee96c-299"><paramref name="left" />가 <paramref name="right" />와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-299"><paramref name="left" /> equals <paramref name="right" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-300">0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ee96c-300">Greater than zero</span></span> 
 </term><description><span data-ttu-id="ee96c-301"><paramref name="left" />가 <paramref name="right" />보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-301"><paramref name="left" /> is greater than <paramref name="right" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-302">하지만 합니다 <xref:System.Numerics.BigInteger> 형식이 고정 된 범위를 비교 <xref:System.Numerics.BigInteger> 값 비교의 부동 소수점 숫자의 특징인 정밀도 부족 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-302">Although the <xref:System.Numerics.BigInteger> type has no fixed range, comparisons of <xref:System.Numerics.BigInteger> values are not characterized by the lack of precision that characterizes the comparison of floating-point numbers.</span></span> <span data-ttu-id="ee96c-303">다음 예제에서는 두 개의 비교 <xref:System.Numerics.BigInteger> 1896 자릿수를 갖는 하나 있고 각각 다른 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-303">The following example compares two <xref:System.Numerics.BigInteger> values that differ by one and that each have 1,896 digits.</span></span> <span data-ttu-id="ee96c-304"><xref:System.Numerics.BigInteger.Compare%2A> 메서드는 두 값이 같지 않은지 올바르게 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-304">The <xref:System.Numerics.BigInteger.Compare%2A> method correctly reports that the two values are not equal.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-305">이 인스턴스의 값을 다른 값과 비교하고 이 인스턴스의 값이 다른 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-305">Compares the value of this instance with another value and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the other value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="ee96c-306">비교할 부호 있는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-306">The signed 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-307">이 인스턴스를 부호 있는 64비트 정수와 비교하고 이 인스턴스의 값이 부호 있는 64비트 정수 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-307">Compares this instance to a signed 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the signed 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-308">다음 표와 같이 이 인스턴스와 <paramref name="other" /> 사이의 관계를 나타내는 부호 있는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-308">A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ee96c-309">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-309">Return value</span></span> 
 </term><description> <span data-ttu-id="ee96c-310">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-310">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ee96c-311">0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ee96c-311">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-312">현재 인스턴스가 <paramref name="other" />보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-312">The current instance is less than <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-313">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-313">Zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-314">현재 인스턴스가 <paramref name="other" />와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-314">The current instance equals <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-315">0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ee96c-315">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-316">현재 인스턴스가 <paramref name="other" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-316">The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-317">경우 `other` 는 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할를 <xref:System.Int64> 경우이 값는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-317">If `other` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-318">다음 예제에서는 호출의 결과 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> 정수 값을 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-318">The following example illustrates the result of calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> method with integral values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="ee96c-319">비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-319">The object to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-320">이 인스턴스를 두 번째 <see cref="T:System.Numerics.BigInteger" />와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-320">Compares this instance to a second <see cref="T:System.Numerics.BigInteger" /> and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</span></span></summary>
        <returns><span data-ttu-id="ee96c-321">다음 표와 같이 이 인스턴스와 <paramref name="other" /> 사이의 관계를 나타내는 부호 있는 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-321">A signed integer value that indicates the relationship of this instance to <paramref name="other" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ee96c-322">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-322">Return value</span></span> 
 </term><description> <span data-ttu-id="ee96c-323">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-323">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ee96c-324">0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ee96c-324">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-325">현재 인스턴스가 <paramref name="other" />보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-325">The current instance is less than <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-326">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-326">Zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-327">현재 인스턴스가 <paramref name="other" />와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-327">The current instance equals <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-328">0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ee96c-328">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-329">현재 인스턴스가 <paramref name="other" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-329">The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-330">이 오버 로드는 <xref:System.Numerics.BigInteger.CompareTo%2A> 메서드 구현 된 <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-330">This overload of the <xref:System.Numerics.BigInteger.CompareTo%2A> method implements the <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ee96c-331">컬렉션에서 항목을 주문 하려면 제네릭 컬렉션 개체에 의해 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-331">It is used by generic collection objects to order the items in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-332">다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> 메서드는 목록의 순서를 `StarInfo` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-332">The following example illustrates the use of the <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> method to order a list of `StarInfo` objects.</span></span> <span data-ttu-id="ee96c-333">각 `StarInfo` 개체 별의 이름과 (마일)이 지구 로부터의 거리에 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-333">Each `StarInfo` object provides information about a star's name and its distance from the Earth in miles.</span></span> <span data-ttu-id="ee96c-334">`StarInfo` 구현 된 <xref:System.IComparable%601> 인터페이스를 `StarInfo` 제네릭 컬렉션 클래스에서 정렬할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-334">`StarInfo` implements the <xref:System.IComparable%601> interface, which enables `StarInfo` objects to be sorted by generic collection classes.</span></span> <span data-ttu-id="ee96c-335">해당 <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> 구현에 대 한 호출 래핑하기만 <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-335">Its <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementation just wraps a call to <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 <span data-ttu-id="ee96c-336">다음 코드는 다음 네 가지 인스턴스화합니다 `StarInfo` 개체 및 제네릭에 저장 합니다 <xref:System.Collections.Generic.List%601> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-336">The following code then instantiates four `StarInfo` objects and stores them in a generic <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="ee96c-337">후 합니다 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 메서드를 호출 `StarInfo` 개체 지구 로부터의 거리의 순서로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-337">After the <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> method is called, `StarInfo` objects are displayed in order of their distance from the Earth.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ee96c-338">비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-338">The object to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-339">이 인스턴스를 지정된 개체와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-339">Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</span></span></summary>
        <returns><span data-ttu-id="ee96c-340">다음 표와 같이 현재 인스턴스와 <paramref name="obj" /> 매개 변수 사이의 관계를 나타내는 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-340">A signed integer that indicates the relationship of the current instance to the <paramref name="obj" /> parameter, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ee96c-341">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-341">Return value</span></span> 
 </term><description> <span data-ttu-id="ee96c-342">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-342">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ee96c-343">0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ee96c-343">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-344">현재 인스턴스가 <paramref name="obj" />보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-344">The current instance is less than <paramref name="obj" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-345">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-345">Zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-346">현재 인스턴스가 <paramref name="obj" />와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-346">The current instance equals <paramref name="obj" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-347">0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ee96c-347">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-348">현재 인스턴스가 <paramref name="obj" />보다 크거나 <paramref name="obj" /> 매개 변수가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-348">The current instance is greater than <paramref name="obj" />, or the <paramref name="obj" /> parameter is <see langword="null" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-349">이 오버 로드는 <xref:System.Numerics.BigInteger.CompareTo%2A> 메서드 구현 된 <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-349">This overload of the <xref:System.Numerics.BigInteger.CompareTo%2A> method implements the <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ee96c-350">컬렉션에서 항목을 주문 하려면 제네릭이 아닌 컬렉션 개체에 의해 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-350">It is used by non-generic collection objects to order the items in the collection.</span></span>  
  
 <span data-ttu-id="ee96c-351">`obj` 매개 변수는 다음 중 하나 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-351">The `obj` parameter must be one of the following:</span></span>  
  
-   <span data-ttu-id="ee96c-352">개체 런타임 형식이 <xref:System.Numerics.BigInteger>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-352">An object whose run-time type is <xref:System.Numerics.BigInteger>.</span></span>  
  
-   <span data-ttu-id="ee96c-353"><xref:System.Object> 변수 값을 갖는 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-353">An <xref:System.Object> variable whose value is `null`.</span></span> <span data-ttu-id="ee96c-354">경우의 값을 `obj` 매개 변수가 `null`, 메서드가 반환 된 현재 인스턴스의 보다 큰지 여부를 나타내는 1 `obj`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-354">If the value of the `obj` parameter is `null`, the method returns 1, which indicates that the current instance is greater than `obj`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-355">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> 비교할 메서드는 <xref:System.Numerics.BigInteger> 개체 배열의 각 요소를 사용 하 여 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-355">The following example calls the <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> method to compare a <xref:System.Numerics.BigInteger> value with each element in an object array</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ee96c-356"><paramref name="obj" />가 <see cref="T:System.Numerics.BigInteger" />가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-356"><paramref name="obj" /> is not a <see cref="T:System.Numerics.BigInteger" />.</span></span></exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="ee96c-357">비교할 부호 없는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-357">The unsigned 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-358">이 인스턴스를 부호 없는 64비트 정수와 비교하고 이 인스턴스의 값이 부호 없는 64비트 정수 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-358">Compares this instance to an unsigned 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the unsigned 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-359">다음 표와 같이 이 인스턴스와 <paramref name="other" />의 상대 값을 나타내는 부호 있는 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-359">A signed integer that indicates the relative value of this instance and <paramref name="other" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ee96c-360">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-360">Return value</span></span> 
 </term><description> <span data-ttu-id="ee96c-361">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-361">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ee96c-362">0보다 작음</span><span class="sxs-lookup"><span data-stu-id="ee96c-362">Less than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-363">현재 인스턴스가 <paramref name="other" />보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-363">The current instance is less than <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-364">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-364">Zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-365">현재 인스턴스가 <paramref name="other" />와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-365">The current instance equals <paramref name="other" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-366">0보다 큼</span><span class="sxs-lookup"><span data-stu-id="ee96c-366">Greater than zero</span></span> 
 </term><description> <span data-ttu-id="ee96c-367">현재 인스턴스가 <paramref name="other" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-367">The current instance is greater than <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="ee96c-368">나눌 대상 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-368">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="ee96c-369">나눌 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-369">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="ee96c-370">하나의 <see cref="T:System.Numerics.BigInteger" /> 값을 다른 값으로 나눈 후 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-370">Divides one <see cref="T:System.Numerics.BigInteger" /> value by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="ee96c-371">나누기의 몫입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-371">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-372"><xref:System.Numerics.BigInteger.Divide%2A> 정수 나누기를 수행 하는 메서드, 나누기 결과로 생성 되는 나머지는 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-372">The <xref:System.Numerics.BigInteger.Divide%2A> method performs integer division; any remainder that results from the division is discarded.</span></span> <span data-ttu-id="ee96c-373">나머지 계속 사용 하면서 정수 나누기를 수행 하려면 호출을 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-373">To perform integer division while preserving the remainder, call the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span> <span data-ttu-id="ee96c-374">나머지만을 검색 하려면 호출을 <xref:System.Numerics.BigInteger.Remainder%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-374">To retrieve only the remainder, call the <xref:System.Numerics.BigInteger.Remainder%2A> method.</span></span>  
  
 <span data-ttu-id="ee96c-375"><xref:System.Numerics.BigInteger.Divide%2A> 메서드 오버 로드 된 연산자를 지원 하지 않는 언어에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-375">The <xref:System.Numerics.BigInteger.Divide%2A> method can be used by languages that do not support operator overloading.</span></span> <span data-ttu-id="ee96c-376">해당 동작 나누기는 나누기 연산자를 사용 하는 것과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-376">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-377">다음 예제에서는 배열을 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-377">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-378">다음 각 요소를 사용 하는 나누기 연산에서 몫으로 사용 하 여는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드를 나누기 연산자 (/) 및 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-378">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="ee96c-379"><paramref name="divisor" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-379"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="ee96c-380">나눌 대상 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-380">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="ee96c-381">나눌 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-381">The value to divide by.</span></span></param>
        <param name="remainder"><span data-ttu-id="ee96c-382">이 메서드가 반환되면 나누기의 나머지를 나타내는 <see cref="T:System.Numerics.BigInteger" /> 값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-382">When this method returns, contains a <see cref="T:System.Numerics.BigInteger" /> value that represents the remainder from the division.</span></span> <span data-ttu-id="ee96c-383">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-383">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="ee96c-384">하나의 <see cref="T:System.Numerics.BigInteger" /> 값을 다른 값으로 나눈 후 결과를 반환하고 출력 매개 변수에 나머지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-384">Divides one <see cref="T:System.Numerics.BigInteger" /> value by another, returns the result, and returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="ee96c-385">나누기의 몫입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-385">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-386">이 메서드는 몫과 나머지 정수 나누기에서 결과 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-386">This method preserves both the quotient and the remainder that results from integer division.</span></span> <span data-ttu-id="ee96c-387">나머지 관심이 없는 경우 사용 합니다 <xref:System.Numerics.BigInteger.Divide%2A> 메서드나 나누기 연산자; 경우 나머지 부분에서는 관심이 사용 하 여를 <xref:System.Numerics.BigInteger.Remainder%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-387">If you are not interested in the remainder, use the <xref:System.Numerics.BigInteger.Divide%2A> method or the division operator; if you are only interested in the remainder, use the <xref:System.Numerics.BigInteger.Remainder%2A> method.</span></span>  
  
 <span data-ttu-id="ee96c-388">반환 된 부호 `remainder` 값의 부호와 같습니다는 `dividend` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-388">The sign of the returned `remainder` value is the same as the sign of the `dividend` parameter.</span></span>  
  
 <span data-ttu-id="ee96c-389">동작을 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드는 동일 합니다는 <xref:System.Math.DivRem%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-389">The behavior of the <xref:System.Numerics.BigInteger.DivRem%2A> method is identical to that of the <xref:System.Math.DivRem%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-390">다음 예제에서는 배열을 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-390">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-391">다음 각 요소를 사용 하는 나누기 연산에서 몫으로 사용 하 여는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드를 나누기 연산자 (/) 및 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-391">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="ee96c-392"><paramref name="divisor" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-392"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-393">두 개의 숫자 값이 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-393">Returns a value that indicates whether two numeric values are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="ee96c-394">비교할 부호 있는 64비트 정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-394">The signed 64-bit integer value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-395">현재 인스턴스와 부호 있는 64비트 정수의 값이 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-395">Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-396">부호 있는 64비트 정수와 현재 인스턴스의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-396"><see langword="true" /> if the signed 64-bit integer and the current instance have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-397">경우 `other` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 메서드를 호출 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-397">If `other` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the method is called.</span></span>  
  
 <span data-ttu-id="ee96c-398">같은지 테스트 하는 대신 두 개체 간의 관계를 확인 하려면 호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-398">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-399">다음 예제는 <xref:System.Numerics.BigInteger> 제외 하 고 각 정수 계열 형식에서 개체 <xref:System.UInt64>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-399">The following example instantiates a <xref:System.Numerics.BigInteger> object from each integral type except <xref:System.UInt64>.</span></span> <span data-ttu-id="ee96c-400">그런 다음 호출 하는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> 비교할 메서드를 <xref:System.Numerics.BigInteger> 에 전달 된 원래 정수 값을 사용 하 여 값을 <xref:System.Numerics.BigInteger> 생성자.</span><span class="sxs-lookup"><span data-stu-id="ee96c-400">It then calls the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> method to compare the <xref:System.Numerics.BigInteger> value with the original integer value that was passed to the <xref:System.Numerics.BigInteger> constructor.</span></span> <span data-ttu-id="ee96c-401">출력에서 볼 수 있듯이 값은 각 사례에서 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-401">As the output shows, the values are equal in each case.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="ee96c-402">비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-402">The object to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-403">현재 인스턴스와 지정된 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-403">Returns a value that indicates whether the current instance and a specified <see cref="T:System.Numerics.BigInteger" /> object have the same value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-404">이 <see cref="T:System.Numerics.BigInteger" /> 개체와 <paramref name="other" />의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-404"><see langword="true" /> if this <see cref="T:System.Numerics.BigInteger" /> object and <paramref name="other" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-405">이 메서드를 구현 하는 <xref:System.IEquatable%601> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.Numerics.BigInteger.Equals%28System.Object%29> 변환할 필요가 없기 때문에 `other` 매개 변수를를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-405">This method implements the <xref:System.IEquatable%601> interface and performs slightly better than <xref:System.Numerics.BigInteger.Equals%28System.Object%29> because it does not have to convert the `other` parameter to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 <span data-ttu-id="ee96c-406">둘 사이의 관계를 결정할 <xref:System.Numerics.BigInteger> 같은지를 테스트 하는 대신 개체를 호출 합니다 <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-406">To determine the relationship between the two <xref:System.Numerics.BigInteger> objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-407">다음 예제에서는 엡실론 표시 하려면 같은지 여부를 결정 하는 지구에서의 거리를 사용 하 여 지구에서 몇몇 별의 근사 거리를 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-407">The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</span></span> <span data-ttu-id="ee96c-408">예제에서는 각 오버 로드는 <xref:System.Numerics.BigInteger.Equals%2A> 같은지 테스트 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-408">The example uses each overload of the <xref:System.Numerics.BigInteger.Equals%2A> method to test for equality.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ee96c-409">비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-409">The object to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-410">현재 인스턴스와 지정된 개체의 값이 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-410">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-411"><paramref name="obj" /> 인수가 <see cref="T:System.Numerics.BigInteger" /> 개체이고 값이 현재 <see cref="T:System.Numerics.BigInteger" /> 인스턴스의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-411"><see langword="true" /> if the <paramref name="obj" /> argument is a <see cref="T:System.Numerics.BigInteger" /> object, and its value is equal to the value of the current <see cref="T:System.Numerics.BigInteger" /> instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-412">경우는 `obj` 인수가 아닙니다를 <xref:System.Numerics.BigInteger> 값을 메서드 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-412">If the `obj` argument is not a <xref:System.Numerics.BigInteger> value, the method returns `false`.</span></span> <span data-ttu-id="ee96c-413">메서드는 반환 `true` 경우에만 `obj` 는 <xref:System.Numerics.BigInteger> 값이 현재 인스턴스와 같으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-413">The method returns `true` only if `obj` is a <xref:System.Numerics.BigInteger> instance whose value is equal to the current instance.</span></span>  
  
 <span data-ttu-id="ee96c-414">같은지 테스트 하는 대신 두 개체 간의 관계를 확인 하려면 호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-414">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-415">다음 예제에서는 병렬 <xref:System.Object> 고 <xref:System.Numerics.BigInteger> 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-415">The following example defines parallel <xref:System.Object> and <xref:System.Numerics.BigInteger> arrays.</span></span> <span data-ttu-id="ee96c-416">한 배열의 각 요소에는 두 번째 배열의 해당 요소와 동일한 값을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-416">Each element of one array has the same value as the corresponding element of the second array.</span></span> <span data-ttu-id="ee96c-417">예제에 있는 인스턴스의에서 출력으로는 <xref:System.Numerics.BigInteger> 배열에서 인스턴스를 동일한 것으로 간주 됩니다 합니다 <xref:System.Object> 후자는 경우에를 <xref:System.Numerics.BigInteger> 해당 값이 같으면.</span><span class="sxs-lookup"><span data-stu-id="ee96c-417">As the output from the example shows, the instance in the <xref:System.Numerics.BigInteger> array is considered to be equal to the instance in the <xref:System.Object> array only if the latter is a <xref:System.Numerics.BigInteger> and their values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="ee96c-418">비교할 부호 없는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-418">The unsigned 64-bit integer to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-419">현재 인스턴스와 부호 없는 64비트 정수의 값이 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-419">Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-420">현재 인스턴스와 부호 없는 64비트 정수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-420"><see langword="true" /> if the current instance and the unsigned 64-bit integer have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-421">같은지 테스트 하는 대신 두 개체 간의 관계를 확인 하려면 호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-421">To determine the relationship between the two objects instead of just testing for equality, call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-422">다음 예제에서는 엡실론 표시 하려면 같은지 여부를 결정 하는 지구에서의 거리를 사용 하 여 지구에서 몇몇 별의 근사 거리를 비교 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-422">The following example compares the approximate distance of several stars from Earth with the distance of Epsilon Indi from Earth to determine whether they are equal.</span></span> <span data-ttu-id="ee96c-423">예제에서는 각 오버 로드는 <xref:System.Numerics.BigInteger.Equals%2A> 같은지 테스트 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-423">The example uses each overload of the <xref:System.Numerics.BigInteger.Equals%2A> method to test for equality.</span></span>  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee96c-424">현재 <see cref="T:System.Numerics.BigInteger" /> 개체에 대한 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-424">Returns the hash code for the current <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <returns><span data-ttu-id="ee96c-425">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-425">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-426">첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-426">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-427">두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-427">The second value.</span></span></param>
        <summary><span data-ttu-id="ee96c-428">두 <see cref="T:System.Numerics.BigInteger" /> 값의 최대 공약수를 구합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-428">Finds the greatest common divisor of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-429"><paramref name="left" />와 <paramref name="right" />의 최대 공약수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-429">The greatest common divisor of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-430">가장 일반적인 제 수는 최대 수는 두 <xref:System.Numerics.BigInteger> 나머지를 반환 하지 않고 값을 나눌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-430">The greatest common divisor is the largest number into which the two <xref:System.Numerics.BigInteger> values can be divided without returning a remainder.</span></span>  
  
 <span data-ttu-id="ee96c-431">경우는 `left` 고 `right` 매개 변수는 0이 아닌 숫자, 메서드는 항상 하나 이상의 값이 1 반환 하므로 1만 모든 숫자를 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-431">If the `left` and `right` parameters are non-zero numbers, the method always returns at least a value of 1 because all numbers can be divided by 1.</span></span> <span data-ttu-id="ee96c-432">매개 변수 중 하나가 0 인 경우 메서드는 0이 아닌 매개 변수의 절대 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-432">If either parameter is zero, the method returns the absolute value of the non-zero parameter.</span></span> <span data-ttu-id="ee96c-433">값이 모두 0 인 경우 메서드는 0을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-433">If both values are zero, the method returns zero.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-434">매우 큰 값의 최대 공약수 컴퓨팅 `left` 고 `right` 작업을 매우 많은 시간이 소요 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-434">Computing the greatest common divisor of very large values of `left` and `right` can be a very time-consuming operation.</span></span>  
  
 <span data-ttu-id="ee96c-435">값을 반환 합니다 <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> 메서드는 항상의 부호에 관계 없이 양수를 `left` 및 `right` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="ee96c-435">The value returned by the <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> method is always positive regardless of the sign of the `left` and `right` parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-436">다음 예제에 대 한 호출을 <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> 메서드 및 예외에 대 한 유용한 정보를 제공 하는 데 필요한 처리를 <xref:System.ArgumentOutOfRangeException>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-436">The following example illustrates a call to the <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> method and the exception handling necessary to provide useful information about an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="ee96c-437">결과 이러한 두 숫자의 최대 공약수 1 임을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-437">The result indicates that the greatest common divisor of these two numbers is 1.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-438">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 짝수인지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-438">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is an even number.</span></span></summary>
        <value><span data-ttu-id="ee96c-439"><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 짝수이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-439"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is an even number; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-440">이 속성은 표시 하는 편리한 기능 여부는 <xref:System.Numerics.BigInteger> 값은 두 개의 균등 하 게 나눌 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-440">This property is a convenience feature that indicates whether a <xref:System.Numerics.BigInteger> value is evenly divisible by two.</span></span> <span data-ttu-id="ee96c-441">다음 식은 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-441">It is equivalent to the following expression:</span></span>  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 <span data-ttu-id="ee96c-442">하는 경우 현재 값 <xref:System.Numerics.BigInteger> 개체가 <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, 속성 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-442">If the value of the current <xref:System.Numerics.BigInteger> object is <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, the property returns `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-443">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.One" />인지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-443">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />.</span></span></summary>
        <value><span data-ttu-id="ee96c-444"><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.One" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-444"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.One" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-445">이 속성은 하나를 사용 하 여 다른 비교 보다 훨씬 더 나은 성능을 같은 `thisBigInteger.Equals(BigInteger.One)`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-445">This property offers significantly better performance than other comparisons with one, such as `thisBigInteger.Equals(BigInteger.One)`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-446">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 2의 거듭제곱인지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-446">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is a power of two.</span></span></summary>
        <value><span data-ttu-id="ee96c-447"><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 2의 거듭제곱이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-447"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is a power of two; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-448">이 속성을 결정 하는지 여부를 <xref:System.Numerics.BigInteger> 값에 단일 0이 아닌 비트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-448">This property determines whether a <xref:System.Numerics.BigInteger> value has a single non-zero bit set.</span></span> <span data-ttu-id="ee96c-449">이 반환 됨을 의미 `true` 경우 현재 값 <xref:System.Numerics.BigInteger> 개체는 1 (즉, 2<sup>0</sup>) 또는 두 개의 모든 강화 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-449">This means that it returns `true` if the value of the current <xref:System.Numerics.BigInteger> object is 1 (that is, 2<sup>0</sup>) or any greater power of two.</span></span> <span data-ttu-id="ee96c-450">반환 `false` 하는 경우 현재 값 <xref:System.Numerics.BigInteger> 개체는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-450">It returns `false` if the value of the current <xref:System.Numerics.BigInteger> object is 0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-451">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.Zero" />인지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-451">Indicates whether the value of the current <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />.</span></span></summary>
        <value><span data-ttu-id="ee96c-452"><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.Zero" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-452"><see langword="true" /> if the value of the <see cref="T:System.Numerics.BigInteger" /> object is <see cref="P:System.Numerics.BigInteger.Zero" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-453">이 속성 보다 훨씬 나은 성능을 제공 `BigInteger.Equals(BigInteger.Zero)`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-453">This property offers significantly better performance than `BigInteger.Equals(BigInteger.Zero)`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-454">지정된 숫자의 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-454">Returns the logarithm of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-455">로그가 있는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-455">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="ee96c-456">지정된 숫자의 자연(밑 <see langword="e" />) 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-456">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="ee96c-457">설명 단원의 표와 같이 <paramref name="value" />의 자연(밑 <see langword="e" />) 로그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-457">The natural (base <see langword="e" />) logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-458">`value` 매개 변수를 10 진수로로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-458">The `value` parameter is specified as a base 10 number.</span></span>  
  
 <span data-ttu-id="ee96c-459">이 메서드는 값의 부호에 따라 달라 집니다 정확한 반환 `value`다음 표와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-459">The precise return value of this method depends on the sign of `value`, as the following table shows.</span></span>  
  
|<span data-ttu-id="ee96c-460">로그인 `value` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="ee96c-460">Sign of `value` parameter</span></span>|<span data-ttu-id="ee96c-461">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-461">Return value</span></span>|  
|-------------------------------|------------------|  
|<span data-ttu-id="ee96c-462">양수</span><span class="sxs-lookup"><span data-stu-id="ee96c-462">Positive</span></span>|<span data-ttu-id="ee96c-463">자연 `value`; ln `value`, 또는 log e`value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-463">The natural logarithm of `value`; that is, ln `value`, or log e`value`.</span></span>|  
|<span data-ttu-id="ee96c-464">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-464">Zero</span></span>|<span data-ttu-id="ee96c-465"><xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="ee96c-465"><xref:System.Double.NegativeInfinity>.</span></span>|  
|<span data-ttu-id="ee96c-466">음수</span><span class="sxs-lookup"><span data-stu-id="ee96c-466">Negative</span></span>|<span data-ttu-id="ee96c-467"><xref:System.Double.NaN>.</span><span class="sxs-lookup"><span data-stu-id="ee96c-467"><xref:System.Double.NaN>.</span></span>|  
  
 <span data-ttu-id="ee96c-468">계산의 밑수 10에 <xref:System.Numerics.BigInteger> 값, 호출 된 <xref:System.Numerics.BigInteger.Log10%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-468">To calculate the base 10 logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log10%2A> method.</span></span> <span data-ttu-id="ee96c-469">다른 기본 숫자의 밑을 계산 하려면 호출을 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-469">To calculate the logarithm of a number in another base, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> method.</span></span>  
  
 <span data-ttu-id="ee96c-470">호출 하 여 숫자의 제곱근을 찾을 수 있습니다 합니다 <xref:System.Numerics.BigInteger.Log%2A> 와 함께 메서드는 <xref:System.Math.Exp%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-470">You can find the square root of a number by calling the <xref:System.Numerics.BigInteger.Log%2A> method along with the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ee96c-471">결과 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 결과 보다 크면 <xref:System.Double.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-471">Note that the result is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> if the result is greater than <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-472">다음 예제에서는 배열에서 각 요소의 제곱근을 계산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-472">The following example calculates the square root of each element in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 <span data-ttu-id="ee96c-473">에 해당 하는이 메서드는 <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-473">This method corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee96c-474"><paramref name="value" />의 자연 로그가 <see cref="T:System.Double" /> 데이터 형식의 범위를 벗어납니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-474">The natural log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-475">로그가 있는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-475">A number whose logarithm is to be found.</span></span></param>
        <param name="baseValue"><span data-ttu-id="ee96c-476">로그의 밑입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-476">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="ee96c-477">지정된 밑을 사용하여 지정된 숫자의 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-477">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="ee96c-478">설명 단원의 표와 같이 밑이 <paramref name="baseValue" />인 <paramref name="value" />의 로그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-478">The base <paramref name="baseValue" /> logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-479">합니다 `value` 및 `baseValue` 번호가 10 개를 기반으로 매개 변수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-479">The `value` and `baseValue` parameters are specified as base 10 numbers.</span></span>  
  
 <span data-ttu-id="ee96c-480">정확한 반환 메서드의 값의 부호에 따라 달라 집니다 `value` 부호와 값 및 `baseValue`다음 표와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-480">The precise return value of the method depends on the sign of `value` and on the sign and value of `baseValue`, as the following table shows.</span></span>  
  
|<span data-ttu-id="ee96c-481">`value` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="ee96c-481">`value` parameter</span></span>|<span data-ttu-id="ee96c-482">`baseValue` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="ee96c-482">`baseValue` parameter</span></span>|<span data-ttu-id="ee96c-483">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-483">Return value</span></span>|  
|-----------------------|---------------------------|------------------|  
|<span data-ttu-id="ee96c-484">`value` > 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-484">`value` > 0</span></span>|<span data-ttu-id="ee96c-485">(0 < `baseValue` < 1)-또는-(`baseValue` > 1)</span><span class="sxs-lookup"><span data-stu-id="ee96c-485">(0 < `baseValue` < 1) -or-(`baseValue` > 1)</span></span>|<span data-ttu-id="ee96c-486">logbaseValue(`value`)</span><span class="sxs-lookup"><span data-stu-id="ee96c-486">logbaseValue(`value`)</span></span>|  
|<span data-ttu-id="ee96c-487">`value` < 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-487">`value` < 0</span></span>|<span data-ttu-id="ee96c-488">(모든 값)</span><span class="sxs-lookup"><span data-stu-id="ee96c-488">(any value)</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-489">(모든 값)</span><span class="sxs-lookup"><span data-stu-id="ee96c-489">(any value)</span></span>|<span data-ttu-id="ee96c-490">`baseValue` < 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-490">`baseValue` < 0</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-491">`value` != 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-491">`value` != 1</span></span>|<span data-ttu-id="ee96c-492">`baseValue` = 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-492">`baseValue` = 0</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-493">`value` != 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-493">`value` != 1</span></span>|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-494">(모든 값)</span><span class="sxs-lookup"><span data-stu-id="ee96c-494">(any value)</span></span>|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-495">(모든 값)</span><span class="sxs-lookup"><span data-stu-id="ee96c-495">(any value)</span></span>|<span data-ttu-id="ee96c-496">`baseValue` = 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-496">`baseValue` = 1</span></span>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-497">`value` = 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-497">`value` = 0</span></span>|<span data-ttu-id="ee96c-498">0 < `baseValue` < 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-498">0 < `baseValue` < 1</span></span>|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-499">`value` = 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-499">`value` = 0</span></span>|<span data-ttu-id="ee96c-500">`baseValue` > 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-500">`baseValue` > 1</span></span>|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|<span data-ttu-id="ee96c-501">`value` = 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-501">`value` = 1</span></span>|<span data-ttu-id="ee96c-502">`baseValue` = 0</span><span class="sxs-lookup"><span data-stu-id="ee96c-502">`baseValue` = 0</span></span>|<span data-ttu-id="ee96c-503">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-503">0</span></span>|  
|<span data-ttu-id="ee96c-504">`value` = 1</span><span class="sxs-lookup"><span data-stu-id="ee96c-504">`value` = 1</span></span>|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<span data-ttu-id="ee96c-505">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-505">0</span></span>|  
  
 <span data-ttu-id="ee96c-506">계산의 밑수 10에 <xref:System.Numerics.BigInteger> 값, 호출 된 <xref:System.Numerics.BigInteger.Log10%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-506">To calculate the base 10 logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log10%2A> method.</span></span> <span data-ttu-id="ee96c-507">숫자의 자연 로그를 계산 하기 위해 호출 된 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-507">To calculate the natural logarithm of a number, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> method.</span></span>  
  
 <span data-ttu-id="ee96c-508">에 해당 하는이 메서드는 <xref:System.Math.Log%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-508">This method corresponds to the <xref:System.Math.Log%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee96c-509"><paramref name="value" />의 로그가 <see cref="T:System.Double" /> 데이터 형식의 범위를 벗어납니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-509">The log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-510">로그가 있는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-510">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="ee96c-511">밑을 10으로 사용하여 지정된 숫자의 로그를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-511">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="ee96c-512">설명 단원의 표와 같이 밑이 10인 <paramref name="value" />의 로그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-512">The base 10 logarithm of <paramref name="value" />, as shown in the table in the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-513">`value` 매개 변수를 10 진수로로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-513">The `value` parameter is specified as a base 10 number.</span></span>  
  
 <span data-ttu-id="ee96c-514">정확한 반환 메서드의 값의 부호에 따라 달라 집니다 `value`다음 표와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-514">The precise return value of the method depends on the sign of `value`, as the following table shows.</span></span>  
  
|<span data-ttu-id="ee96c-515">매개 변수 값의 부호</span><span class="sxs-lookup"><span data-stu-id="ee96c-515">Sign of value parameter</span></span>|<span data-ttu-id="ee96c-516">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-516">Return value</span></span>|  
|-----------------------------|------------------|  
|<span data-ttu-id="ee96c-517">양수</span><span class="sxs-lookup"><span data-stu-id="ee96c-517">Positive</span></span>|<span data-ttu-id="ee96c-518">기본 10 로그가 `value`; log10`value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-518">The base 10 log of `value`; that is, log10`value`.</span></span>|  
|<span data-ttu-id="ee96c-519">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-519">Zero</span></span>|<span data-ttu-id="ee96c-520"><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ee96c-520"><xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="ee96c-521">음수</span><span class="sxs-lookup"><span data-stu-id="ee96c-521">Negative</span></span>|<span data-ttu-id="ee96c-522"><xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ee96c-522"><xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="ee96c-523">자연 로그를 계산 하는 <xref:System.Numerics.BigInteger> 값, 호출 된 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-523">To calculate the natural logarithm of a <xref:System.Numerics.BigInteger> value, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ee96c-524">다른 기본 숫자의 밑을 계산 하려면 호출을 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-524">To calculate the logarithm of a number in another base, call the <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ee96c-525">에 해당 하는이 메서드는 <xref:System.Math.Log10%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-525">This method corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee96c-526"><paramref name="value" />의 기본 10 로그가 <see cref="T:System.Double" /> 데이터 형식의 범위를 벗어납니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-526">The base 10 log of <paramref name="value" /> is out of range of the <see cref="T:System.Double" /> data type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-527">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-527">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-528">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-528">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-529">두 <see cref="T:System.Numerics.BigInteger" /> 값 중 더 큰 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-529">Returns the larger of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-530"><paramref name="left" /> 또는 <paramref name="right" /> 매개 변수 중 더 큰 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-530">The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-531">에 해당 하는이 메서드는 <xref:System.Math.Max%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-531">This method corresponds to the <xref:System.Math.Max%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-532">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Max%2A> 배열에 가장 큰 수를 선택 하는 방법 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-532">The following example uses the <xref:System.Numerics.BigInteger.Max%2A> method to select the largest number in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-533">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-533">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-534">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-534">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-535">두 <see cref="T:System.Numerics.BigInteger" /> 값 중 더 작은 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-535">Returns the smaller of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-536"><paramref name="left" /> 또는 <paramref name="right" /> 매개 변수 중 더 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-536">The <paramref name="left" /> or <paramref name="right" /> parameter, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-537">에 해당 하는이 메서드는 <xref:System.Math.Min%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-537">This method corresponds to the <xref:System.Math.Min%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-538">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Min%2A> 의 배열에서 가장 작은 숫자를 선택 하는 방법 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-538">The following example uses the <xref:System.Numerics.BigInteger.Min%2A> method to select the smallest number in an array of <xref:System.Numerics.BigInteger> values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-539">숫자 -1을 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-539">Gets a value that represents the number negative one (-1).</span></span></summary>
        <value><span data-ttu-id="ee96c-540">값이 -1인 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-540">An integer whose value is negative one (-1).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-541"><xref:System.Numerics.BigInteger.MinusOne%2A> 속성 비교에 사용 되는 <xref:System.Numerics.BigInteger> 값-1 또는-1을 할당 하는 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-541">The <xref:System.Numerics.BigInteger.MinusOne%2A> property is used to compare a <xref:System.Numerics.BigInteger> value to -1 or to assign -1 to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-542"><paramref name="exponent" /> 지수로 사용할 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-542">The number to raise to the <paramref name="exponent" /> power.</span></span></param>
        <param name="exponent"><span data-ttu-id="ee96c-543"><paramref name="value" />를 거듭제곱할 지수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-543">The exponent to raise <paramref name="value" /> by.</span></span></param>
        <param name="modulus"><span data-ttu-id="ee96c-544"><paramref name="value" />의 <paramref name="exponent" />승을 나눌 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-544">The number by which to divide <paramref name="value" /> raised to the <paramref name="exponent" /> power.</span></span></param>
        <summary><span data-ttu-id="ee96c-545">다른 숫자의 승수로 거듭제곱한 숫자에 대해 모듈러스 나누기를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-545">Performs modulus division on a number raised to the power of another number.</span></span></summary>
        <returns><span data-ttu-id="ee96c-546"><paramref name="value" /><sup>지수</sup>를 <paramref name="modulus" />로 나눈 나머지입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-546">The remainder after dividing <paramref name="value" /><sup>exponent</sup> by <paramref name="modulus" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-547"><xref:System.Numerics.BigInteger.ModPow%2A> 메서드는 다음 식을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-547">The <xref:System.Numerics.BigInteger.ModPow%2A> method evaluates the following expression:</span></span>  
  
 <span data-ttu-id="ee96c-548">(baseValue ^ 지 수) Mod 모듈러스</span><span class="sxs-lookup"><span data-stu-id="ee96c-548">(baseValue ^ exponent) Mod modulus</span></span>  
  
 <span data-ttu-id="ee96c-549">지 수에서 수행할 <xref:System.Numerics.BigInteger> 모듈러스 나누기 없이 값을 사용 합니다 <xref:System.Numerics.BigInteger.Pow%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-549">To perform exponentiation on <xref:System.Numerics.BigInteger> values without modulus division, use the <xref:System.Numerics.BigInteger.Pow%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-550">다음 예제에서는 호출 하는 간단한 설명을 제공 합니다 <xref:System.Numerics.BigInteger.ModPow%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-550">The following example provides a simple illustration of calling the <xref:System.Numerics.BigInteger.ModPow%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="ee96c-551"><paramref name="modulus" />가 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-551"><paramref name="modulus" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee96c-552"><paramref name="exponent" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-552"><paramref name="exponent" /> is negative.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-553">곱할 첫 번째 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-553">The first number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-554">곱할 두 번째 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-554">The second number to multiply.</span></span></param>
        <summary><span data-ttu-id="ee96c-555">두 <see cref="T:System.Numerics.BigInteger" /> 값의 곱을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-555">Returns the product of two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-556"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 곱입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-556">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-557"><xref:System.Numerics.BigInteger.Multiply%2A> 연산자 오버 로드를 지원 하지 않는 언어에 대 한 메서드 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-557">The <xref:System.Numerics.BigInteger.Multiply%2A> method is implemented for languages that do not support operator overloading.</span></span> <span data-ttu-id="ee96c-558">해당 동작은 곱셈 연산자를 사용 하는 곱하기 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-558">Its behavior is identical to multiplication using the multiplication operator.</span></span> <span data-ttu-id="ee96c-559">또한 합니다 <xref:System.Numerics.BigInteger.Multiply%2A> 인스턴스화할 때 메서드는 곱하기 연산자에 대 한 유용한 대체를 <xref:System.Numerics.BigInteger> 다음 예와에서 같이 곱하기에서 발생 하는 제품을 할당 하 여 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-559">In addition, the <xref:System.Numerics.BigInteger.Multiply%2A> method is a useful substitute for the multiplication operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it a product that results from multiplication, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 <span data-ttu-id="ee96c-560">하는 경우 필요에 따라이 메서드가 자동으로 수행 다른 정수 계열 형식으로의 암시적 변환 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-560">If necessary, this method automatically performs implicit conversion of other integral types to <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="ee96c-561">이 코드는 다음 섹션의 예제에서 확인할 수 있습니다 위치 합니다 <xref:System.Numerics.BigInteger.Multiply%2A> 두 메서드에 전달 됩니다 <xref:System.Int64> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-561">This is illustrated in the example in the next section, where the <xref:System.Numerics.BigInteger.Multiply%2A> method is passed two <xref:System.Int64> values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-562">다음 예제에서는 두 정수 (long) 사용 하 여 곱하기를 수행 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-562">The following example tries to perform multiplication with two long integers.</span></span> <span data-ttu-id="ee96c-563">Long 정수의 범위를 초과 하는 결과 <xref:System.OverflowException> throw 되 고 <xref:System.Numerics.BigInteger.Multiply%2A> 메서드를 호출 하는 곱셈을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-563">Because the result exceeds the range of a long integer, an <xref:System.OverflowException> is thrown, and the <xref:System.Numerics.BigInteger.Multiply%2A> method is called to handle the multiplication.</span></span> <span data-ttu-id="ee96c-564">C#는 사용 하는 참고 합니다 `checked` 이 예에서 같이 키워드 또는 `/checked+` 숫자 오버플로에 예외가 throw 되었는지 확인 하려면 컴파일러 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-564">Note that C# requires that you use either the `checked` keyword (as in this example) or the `/checked+` compiler option to make sure an exception is thrown on a numeric overflow.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-565">부정할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-565">The value to negate.</span></span></param>
        <summary><span data-ttu-id="ee96c-566">지정된 <see cref="T:System.Numerics.BigInteger" /> 값을 부정합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-566">Negates a specified <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-567"><paramref name="value" /> 매개 변수에 -1을 곱한 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-567">The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-568">부정 덧셈 역 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-568">Negation obtains the additive inverse of a number.</span></span> <span data-ttu-id="ee96c-569">숫자의 덧셈 역 원을 원래 수에 추가 될 때 0 값을 생성 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-569">The additive inverse of a number is a number that produces a value of zero when it is added to the original number.</span></span>  
  
 <span data-ttu-id="ee96c-570"><xref:System.Numerics.BigInteger.Negate%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-570">The <xref:System.Numerics.BigInteger.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="ee96c-571">해당 동작 단항 부정 연산자를 사용 하 여 부정 하는 것과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-571">Its behavior is identical to negation using the unary negation operator.</span></span> <span data-ttu-id="ee96c-572">또한 합니다 <xref:System.Numerics.BigInteger.Negate%2A> 메서드를 인스턴스화할 때 부정 연산자에 대 한 유용한 대체는를 <xref:System.Numerics.BigInteger> 변수를 다음 예제에서와 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-572">In addition, the <xref:System.Numerics.BigInteger.Negate%2A> method is a useful substitute for the negation operator when instantiating a <xref:System.Numerics.BigInteger> variable, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-573">다음 예의 값을 부정 하는 세 가지를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-573">The following example illustrates three ways to negate the value of a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-574">숫자 1을 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-574">Gets a value that represents the number one (1).</span></span></summary>
        <value><span data-ttu-id="ee96c-575">값이 1인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-575">An object whose value is one (1).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-576"><xref:System.Numerics.BigInteger.One%2A> 속성을 비교 하는 데 주로 사용 되는 <xref:System.Numerics.BigInteger> 값을 1 또는 1을 할당 하는 <xref:System.Numerics.BigInteger> 개체.</span><span class="sxs-lookup"><span data-stu-id="ee96c-576">The <xref:System.Numerics.BigInteger.One%2A> property is usually used to compare a <xref:System.Numerics.BigInteger> value to 1 or to assign 1 to a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-577">더할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-577">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-578">더할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-578">The second value to add.</span></span></param>
        <summary><span data-ttu-id="ee96c-579">지정한 두 <see cref="T:System.Numerics.BigInteger" />의 값을 더합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-579">Adds the values of two specified <see cref="T:System.Numerics.BigInteger" /> objects.</span></span></summary>
        <returns><span data-ttu-id="ee96c-580"><paramref name="left" />와 <paramref name="right" />의 합입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-580">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-581">합니다 <xref:System.Numerics.BigInteger.op_Addition%2A> 메서드 정의 대해 더하기 연산을 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-581">The <xref:System.Numerics.BigInteger.op_Addition%2A> method defines the addition operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-582">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-582">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 <span data-ttu-id="ee96c-583">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Add%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-583">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Add%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-584">첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-584">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-585">두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-585">The second value.</span></span></param>
        <summary><span data-ttu-id="ee96c-586">두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 비트 <see langword="And" /> 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-586">Performs a bitwise <see langword="And" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-587">비트 <see langword="And" /> 연산의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-587">The result of the bitwise <see langword="And" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-588">합니다 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> 메서드 정의 비트 `And` 에 대 한 작업 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-588">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method defines the bitwise `And` operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-589">비트 `And` 작업 설정 결과 비트 유일한 경우는 해당 비트 `left` 및 `right` 다음 표에 나와 있는 것 처럼는 설정도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-589">The bitwise `And` operation sets a result bit only if the corresponding bits in `left` and `right` are also set, as shown in the following table.</span></span>  
  
|<span data-ttu-id="ee96c-590">비트 `left`</span><span class="sxs-lookup"><span data-stu-id="ee96c-590">Bit in `left`</span></span>|<span data-ttu-id="ee96c-591">비트 `right`</span><span class="sxs-lookup"><span data-stu-id="ee96c-591">Bit in `right`</span></span>|<span data-ttu-id="ee96c-592">결과의 비트</span><span class="sxs-lookup"><span data-stu-id="ee96c-592">Bit in result</span></span>|  
|-------------------|--------------------|-------------------|  
|<span data-ttu-id="ee96c-593">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-593">0</span></span>|<span data-ttu-id="ee96c-594">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-594">0</span></span>|<span data-ttu-id="ee96c-595">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-595">0</span></span>|  
|<span data-ttu-id="ee96c-596">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-596">1</span></span>|<span data-ttu-id="ee96c-597">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-597">0</span></span>|<span data-ttu-id="ee96c-598">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-598">0</span></span>|  
|<span data-ttu-id="ee96c-599">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-599">1</span></span>|<span data-ttu-id="ee96c-600">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-600">1</span></span>|<span data-ttu-id="ee96c-601">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-601">1</span></span>|  
|<span data-ttu-id="ee96c-602">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-602">0</span></span>|<span data-ttu-id="ee96c-603">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-603">1</span></span>|<span data-ttu-id="ee96c-604">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-604">0</span></span>|  
  
 <span data-ttu-id="ee96c-605"><xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-605">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 <span data-ttu-id="ee96c-606">합니다 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> 메서드 비트 연산을 수행 `And` 두 작업 <xref:System.Numerics.BigInteger> 가상 부호 확장을 사용 하 여 2의 보수 표현에서 둘 다 있는 것 처럼 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-606">The <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> method performs the bitwise `And` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-607">첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-607">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-608">두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-608">The second value.</span></span></param>
        <summary><span data-ttu-id="ee96c-609">두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 비트 <see langword="Or" /> 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-609">Performs a bitwise <see langword="Or" /> operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-610">비트 <see langword="Or" /> 연산의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-610">The result of the bitwise <see langword="Or" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-611">합니다 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> 메서드 정의 비트 `Or` 에 대 한 작업 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-611">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method defines the bitwise `Or` operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-612">비트 `Or` 작업의 해당 비트 중 하나 또는 모두 경우에만 결과 비트를 설정 합니다 `left` 고 `right` 표에 표시 된 것과 같이 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-612">The bitwise `Or` operation sets a result bit only if either or both of the corresponding bits in `left` and `right` are set, as shown in the following table.</span></span>  
  
|<span data-ttu-id="ee96c-613">비트 `left`</span><span class="sxs-lookup"><span data-stu-id="ee96c-613">Bit in `left`</span></span>|<span data-ttu-id="ee96c-614">비트 `right`</span><span class="sxs-lookup"><span data-stu-id="ee96c-614">Bit in `right`</span></span>|<span data-ttu-id="ee96c-615">결과의 비트</span><span class="sxs-lookup"><span data-stu-id="ee96c-615">Bit in result</span></span>|  
|-------------------|--------------------|-------------------|  
|<span data-ttu-id="ee96c-616">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-616">0</span></span>|<span data-ttu-id="ee96c-617">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-617">0</span></span>|<span data-ttu-id="ee96c-618">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-618">0</span></span>|  
|<span data-ttu-id="ee96c-619">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-619">1</span></span>|<span data-ttu-id="ee96c-620">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-620">0</span></span>|<span data-ttu-id="ee96c-621">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-621">1</span></span>|  
|<span data-ttu-id="ee96c-622">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-622">1</span></span>|<span data-ttu-id="ee96c-623">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-623">1</span></span>|<span data-ttu-id="ee96c-624">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-624">1</span></span>|  
|<span data-ttu-id="ee96c-625">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-625">0</span></span>|<span data-ttu-id="ee96c-626">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-626">1</span></span>|<span data-ttu-id="ee96c-627">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-627">1</span></span>|  
  
 <span data-ttu-id="ee96c-628"><xref:System.Numerics.BigInteger.op_BitwiseOr%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-628">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 <span data-ttu-id="ee96c-629">합니다 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> 메서드 비트 연산을 수행 `Or` 두 작업 <xref:System.Numerics.BigInteger> 가상 부호 확장을 사용 하 여 2의 보수 표현에서 둘 다 있는 것 처럼 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-629">The <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> method performs the bitwise `Or` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-630">감소시킬 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-630">The value to decrement.</span></span></param>
        <summary><span data-ttu-id="ee96c-631"><see cref="T:System.Numerics.BigInteger" /> 값을 1씩 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-631">Decrements a <see cref="T:System.Numerics.BigInteger" /> value by 1.</span></span></summary>
        <returns><span data-ttu-id="ee96c-632">1씩 감소하는 <paramref name="value" /> 매개 변수의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-632">The value of the <paramref name="value" /> parameter decremented by 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-633">합니다 <xref:System.Numerics.BigInteger.op_Decrement%2A> 메서드는 감소 연산을 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-633">The <xref:System.Numerics.BigInteger.op_Decrement%2A> method defines the decrement operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-634">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-634">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 <span data-ttu-id="ee96c-635">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Subtract%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-635">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Subtract%2A> method instead.</span></span> <span data-ttu-id="ee96c-636">예:</span><span class="sxs-lookup"><span data-stu-id="ee96c-636">For example:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 <span data-ttu-id="ee96c-637">때문에 <xref:System.Numerics.BigInteger> 개체를 변경할 수 없는 합니다 <xref:System.Numerics.BigInteger.op_Decrement%2A> 연산자를 새로 만듭니다 <xref:System.Numerics.BigInteger> 하나 값인 개체 보다 작은 <xref:System.Numerics.BigInteger> 가 나타내는 개체 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-637">Because <xref:System.Numerics.BigInteger> objects are immutable, the <xref:System.Numerics.BigInteger.op_Decrement%2A> operator creates a new <xref:System.Numerics.BigInteger> object whose value is one less than the <xref:System.Numerics.BigInteger> object represented by `value`.</span></span> <span data-ttu-id="ee96c-638">이 즉, 반복 호출을 <xref:System.Numerics.BigInteger.op_Decrement%2A> 성능이 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-638">This means that repeated calls to <xref:System.Numerics.BigInteger.op_Decrement%2A> may be expensive.</span></span>  
  
 <span data-ttu-id="ee96c-639">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-639">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="ee96c-640">나눌 대상 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-640">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="ee96c-641">나눌 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-641">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="ee96c-642">정수 나누기를 사용하여 지정된 <see cref="T:System.Numerics.BigInteger" /> 값을 지정된 다른 <see cref="T:System.Numerics.BigInteger" /> 값으로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-642">Divides a specified <see cref="T:System.Numerics.BigInteger" /> value by another specified <see cref="T:System.Numerics.BigInteger" /> value by using integer division.</span></span></summary>
        <returns><span data-ttu-id="ee96c-643">나누기의 정수 계열 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-643">The integral result of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-644">합니다 <xref:System.Numerics.BigInteger.op_Division%2A> 메서드 정의 대 한 나누기 연산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-644">The <xref:System.Numerics.BigInteger.op_Division%2A> method defines the division operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-645">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-645">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 <span data-ttu-id="ee96c-646">사용자 지정 연산자 및 연산자 오버 로드를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-646">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.BigInteger.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="ee96c-647">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ee96c-647">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="ee96c-648">다음 예제에서는 배열을 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-648">The following example creates an array of <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-649">다음 각 요소를 사용 하는 나누기 연산에서 몫으로 사용 하 여는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드를 나누기 연산자 (/) 및 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-649">It then uses each element as the quotient in a division operation that uses the <xref:System.Numerics.BigInteger.Divide%2A> method, the division operator (/), and the <xref:System.Numerics.BigInteger.DivRem%2A> method.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="ee96c-650"><paramref name="divisor" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-650"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-651">두 값이 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-651">Returns a value that indicates whether two values are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-652">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-652">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-653">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-653">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-654">부호 있는 정수(Long) 값과 <see cref="T:System.Numerics.BigInteger" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-654">Returns a value that indicates whether a signed long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-655"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-655"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-656">합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-656">The <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-657">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-657">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 <span data-ttu-id="ee96c-658">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-658">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="ee96c-659">경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-659">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-660">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-660">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-661">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-661">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-662">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-662">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-663"><see cref="T:System.Numerics.BigInteger" /> 값과 부호 있는 정수(Long) 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-663">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a signed long integer value are equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-664"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-664"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-665">합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-665">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-666">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-666">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 <span data-ttu-id="ee96c-667">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-667">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="ee96c-668">경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-668">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-669">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-669">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-670">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-670">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-671">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-671">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-672">두 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-672">Returns a value that indicates whether the values of two <see cref="T:System.Numerics.BigInteger" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-673"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-673"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-674">합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드 정의 작업에 대 한 같음 연산자의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-674">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method defines the operation of the equality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-675">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-675">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 <span data-ttu-id="ee96c-676">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-676">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 <span data-ttu-id="ee96c-677">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-677">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-678">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-678">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-679">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-679">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-680"><see cref="T:System.Numerics.BigInteger" /> 값과 부호 없는 정수(Long) 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-680">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and an unsigned long integer value are equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-681"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-681"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-682">합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-682">The <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-683">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-683">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 <span data-ttu-id="ee96c-684">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-684">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-685">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-685">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-686">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-686">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-687">부호 없는 정수(Long) 값과 <see cref="T:System.Numerics.BigInteger" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-687">Returns a value that indicates whether an unsigned long integer value and a <see cref="T:System.Numerics.BigInteger" /> value are equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-688"><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-688"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-689">합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-689">The <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> method defines the equality comparison operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-690">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-690">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 <span data-ttu-id="ee96c-691">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-691">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> instance method instead.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-692">첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-692">The first value.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-693">두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-693">The second value.</span></span></param>
        <summary><span data-ttu-id="ee96c-694">두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 비트 배타적 <see langword="Or" />(<see langword="XOr" />) 연산을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-694">Performs a bitwise exclusive <see langword="Or" /> (<see langword="XOr" />) operation on two <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-695">비트 <see langword="Or" /> 연산의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-695">The result of the bitwise <see langword="Or" /> operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-696">결과 비트 배타적 `Or` 작업이 `true` 는 2 비트의 값이 고 그렇지 않으면 다른 경우 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-696">The result of a bitwise exclusive `Or` operation is `true` if the values of the two bits are different; otherwise, it is `false`.</span></span> <span data-ttu-id="ee96c-697">다음 표에서 전용 `Or` 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-697">The following table illustrates the exclusive `Or` operation.</span></span>  
  
|<span data-ttu-id="ee96c-698">비트 x `left`</span><span class="sxs-lookup"><span data-stu-id="ee96c-698">Bit x in `left`</span></span>|<span data-ttu-id="ee96c-699">비트 x `right`</span><span class="sxs-lookup"><span data-stu-id="ee96c-699">Bit x in `right`</span></span>|<span data-ttu-id="ee96c-700">반환 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-700">Return value</span></span>|  
|---------------------|----------------------|------------------|  
|<span data-ttu-id="ee96c-701">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-701">0</span></span>|<span data-ttu-id="ee96c-702">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-702">0</span></span>|<span data-ttu-id="ee96c-703">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-703">0</span></span>|  
|<span data-ttu-id="ee96c-704">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-704">0</span></span>|<span data-ttu-id="ee96c-705">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-705">1</span></span>|<span data-ttu-id="ee96c-706">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-706">1</span></span>|  
|<span data-ttu-id="ee96c-707">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-707">1</span></span>|<span data-ttu-id="ee96c-708">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-708">0</span></span>|<span data-ttu-id="ee96c-709">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-709">1</span></span>|  
|<span data-ttu-id="ee96c-710">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-710">1</span></span>|<span data-ttu-id="ee96c-711">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-711">1</span></span>|<span data-ttu-id="ee96c-712">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-712">0</span></span>|  
  
 <span data-ttu-id="ee96c-713"><xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-713">The <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 <span data-ttu-id="ee96c-714">합니다 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> 배타적 비트를 수행 하는 메서드 `Or` 두 작업 <xref:System.Numerics.BigInteger> 가상 부호 확장을 사용 하 여 2의 보수 표현에서 둘 다 있는 것 처럼 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-714">The <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> method performs the bitwise exclusive `Or` operation on two <xref:System.Numerics.BigInteger> values as if they were both in two's complement representation with virtual sign extension.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-715"><see cref="T:System.Numerics.BigInteger" /> 개체와 다른 형식 간의 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-715">Defines an explicit conversion between a <see cref="T:System.Numerics.BigInteger" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-716"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-716">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-717"><see cref="T:System.Decimal" /> 개체를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-717">Defines an explicit conversion of a <see cref="T:System.Decimal" /> object to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-718"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-718">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-719">소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-719">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="ee96c-720">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-720">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-721">때문에 변환 <xref:System.Decimal> 에 <xref:System.Numerics.BigInteger> 잘라내기 소수 부분이 포함 될 수 있습니다 `value`, 언어 컴파일러는이 변환을 자동으로 수행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-721">Because the conversion from <xref:System.Decimal> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="ee96c-722">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-722">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-723">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-723">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="ee96c-724">사용자 지정 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-724">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="ee96c-725">다음 예제에서는 배열의 개별 요소를 변환 <xref:System.Decimal> 값을 <xref:System.Numerics.BigInteger> 개체 이며 각 변환의 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-725">The following example converts the individual elements in an array of <xref:System.Decimal> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="ee96c-726">참고는 소수 부분을 <xref:System.Decimal> 변환 하는 동안 값이 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-726">Note that any fractional part of a <xref:System.Decimal> value is truncated during the conversion.</span></span>   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-727"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-727">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-728"><see cref="T:System.Double" /> 값을 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-728">Defines an explicit conversion of a <see cref="T:System.Double" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-729"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-729">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-730">소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-730">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="ee96c-731">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-731">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-732">때문에 변환 <xref:System.Double> 에 <xref:System.Numerics.BigInteger> 잘라내기 소수 부분이 포함 될 수 있습니다 `value`, 언어 컴파일러는이 변환을 자동으로 수행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-732">Because the conversion from <xref:System.Double> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="ee96c-733">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-733">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-734">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-734">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="ee96c-735">사용자 지정 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-735">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="ee96c-736">다음 예제에서는 배열의 개별 요소를 변환 <xref:System.Double> 값을 <xref:System.Numerics.BigInteger> 개체 이며 각 변환의 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-736">The following example converts the individual elements in an array of <xref:System.Double> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="ee96c-737">참고는 소수 부분을 <xref:System.Double> 변환 하는 동안 값이 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-737">Note that any fractional part of a <xref:System.Double> value is truncated during the conversion.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-738"><paramref name="value" />가 <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-738"><paramref name="value" /> is <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NegativeInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-739"><see cref="T:System.Byte" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-739">The value to convert to a <see cref="T:System.Byte" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-740"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 바이트 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-740">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned byte value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-741"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-741">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-742">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-742">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-743">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-743">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-744">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CByte` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-744">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CByte` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-745">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-745">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="ee96c-746">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Byte> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-746">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Byte> data type.</span></span> <span data-ttu-id="ee96c-747">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.Byte> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-747">There is no loss of precision in the resulting <xref:System.Byte> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-748">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Byte> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-748">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Byte> values.</span></span> <span data-ttu-id="ee96c-749">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Byte> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-749">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Byte> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-750"><paramref name="value" />가 <see cref="F:System.Byte.MinValue" />보다 작거나 <see cref="F:System.Byte.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-750"><paramref name="value" /> is less than <see cref="F:System.Byte.MinValue" /> or greater than <see cref="F:System.Byte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-751"><see cref="T:System.Decimal" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-751">The value to convert to a <see cref="T:System.Decimal" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-752"><see cref="T:System.Numerics.BigInteger" /> 개체를 <see cref="T:System.Decimal" /> 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-752">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Decimal" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-753"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-753">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-754">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-754">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-755">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-755">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-756">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CDec` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-756">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CDec` in Visual Basic) is used.</span></span>   

 <span data-ttu-id="ee96c-757">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Decimal> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-757">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Decimal> data type.</span></span> 

## Examples
 <span data-ttu-id="ee96c-758">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Decimal> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-758">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Decimal> values.</span></span> <span data-ttu-id="ee96c-759">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Decimal> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-759">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Decimal> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-760"><paramref name="value" />가 <see cref="F:System.Decimal.MinValue" />보다 작거나 <see cref="F:System.Decimal.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-760"><paramref name="value" /> is less than <see cref="F:System.Decimal.MinValue" /> or greater than <see cref="F:System.Decimal.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-761"><see cref="T:System.Double" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-761">The value to convert to a <see cref="T:System.Double" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-762"><see cref="T:System.Numerics.BigInteger" /> 개체를 <see cref="T:System.Double" /> 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-762">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a <see cref="T:System.Double" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-763"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-763">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-764">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-764">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-765">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-765">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-766">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CDbl` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-766">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CDbl` in Visual Basic) is used.</span></span>   

 <span data-ttu-id="ee96c-767">때문에 <xref:System.Numerics.BigInteger> 범위를 벗어나는 값 수는 <xref:System.Double> 이 작업은 데이터 형식으로 축소 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-767">Because the <xref:System.Numerics.BigInteger> value can be outside the range of the <xref:System.Double> data type, this operation is a narrowing conversion.</span></span> <span data-ttu-id="ee96c-768">Throw 하지 않는 경우 변환이 실패 한 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-768">If the conversion is unsuccessful, it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-769">대신 경우 합니다 <xref:System.Numerics.BigInteger> 값이 보다 작거나 <xref:System.Double.MinValue?displayProperty=nameWithType>, 결과 <xref:System.Double> 값은 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-769">Instead, if the <xref:System.Numerics.BigInteger> value is less than <xref:System.Double.MinValue?displayProperty=nameWithType>, the resulting <xref:System.Double> value is <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-770">경우는 <xref:System.Numerics.BigInteger> 값 보다 크면 <xref:System.Double.MaxValue?displayProperty=nameWithType>, 결과 <xref:System.Double> 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-770">If the <xref:System.Numerics.BigInteger> value is greater than <xref:System.Double.MaxValue?displayProperty=nameWithType>, the resulting <xref:System.Double> value is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>
 
 <span data-ttu-id="ee96c-771">변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Double> 정밀도의 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-771">The conversion of a <xref:System.Numerics.BigInteger> to a <xref:System.Double> may involve a loss of precision.</span></span> <span data-ttu-id="ee96c-772">전체 자릿수 손실을 캐스팅 또는 변환 작업을 수행 하려면 일부 경우에 발생할 수 있습니다 경우에 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Double> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-772">In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Double> data type.</span></span> <span data-ttu-id="ee96c-773">다음 예제에서 이에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-773">The following example provides an illustration.</span></span> <span data-ttu-id="ee96c-774">최대 값을 할당 하는 <xref:System.Double> 두 개의 <xref:System.Numerics.BigInteger> 변수, 하나의 <xref:System.Numerics.BigInteger> 9.999 e 291 증가, 같음에 대 한 두 변수는 테스트를 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-774">It assigns the maximum value of a <xref:System.Double> to two <xref:System.Numerics.BigInteger> variables, increments one <xref:System.Numerics.BigInteger> variable by 9.999e291, and tests the two variables for equality.</span></span> <span data-ttu-id="ee96c-775">에 대 한 호출을 예상 대로 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드는 서로 다른 지 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-775">As expected, the call to the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method shows that they are unequal.</span></span> <span data-ttu-id="ee96c-776">그러나 더 큰 숫자를 변환 <xref:System.Numerics.BigInteger> 값을 다시를 <xref:System.Double> 성공 합니다 합니다 <xref:System.Numerics.BigInteger> 값을 초과 하면 이제 <xref:System.Double.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-776">However, the conversion of the larger <xref:System.Numerics.BigInteger> value back to a <xref:System.Double> succeeds, although the <xref:System.Numerics.BigInteger> value now exceeds <xref:System.Double.MaxValue?displayProperty=nameWithType>.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 <span data-ttu-id="ee96c-777">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Double> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-777">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Double> values.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-778">부호 있는 16비트 정수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-778">The value to convert to a 16-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-779"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 16비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-779">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 16-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-780"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-780">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-781">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-781">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-782">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-782">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-783">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CShort` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-783">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CShort` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-784">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-784">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="ee96c-785">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Int16> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-785">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int16> data type.</span></span> <span data-ttu-id="ee96c-786">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.Int16> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-786">There is no loss of precision in the resulting <xref:System.Int16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-787">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Int16> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-787">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int16> values.</span></span> <span data-ttu-id="ee96c-788">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Int16> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-788">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int16> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-789"><paramref name="value" />가 <see cref="F:System.Int16.MinValue" />보다 작거나 <see cref="F:System.Int16.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-789"><paramref name="value" /> is less than <see cref="F:System.Int16.MinValue" /> or is greater than <see cref="F:System.Int16.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-790">부호 있는 32비트 정수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-790">The value to convert to a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-791"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 32비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-791">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 32-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-792"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-792">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-793">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-793">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-794">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-794">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-795">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CInt` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-795">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CInt` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-796">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-796">Otherwise, they display a compiler error.</span></span>   

 <span data-ttu-id="ee96c-797">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Int32> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-797">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int32> data type.</span></span> <span data-ttu-id="ee96c-798">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.Int16> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-798">There is no loss of precision in the resulting <xref:System.Int16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-799">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Int32> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-799">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int32> values.</span></span> <span data-ttu-id="ee96c-800">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Int32> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-800">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int32> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-801"><paramref name="value" />가 <see cref="F:System.Int32.MinValue" />보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-801"><paramref name="value" /> is less than <see cref="F:System.Int32.MinValue" /> or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-802">부호 있는 64비트 정수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-802">The value to convert to a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-803"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 64비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-803">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-804"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-804">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-805">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-805">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-806">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-806">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-807">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CLng` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-807">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CLng` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-808">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-808">Otherwise, they display a compiler error.</span></span>  

 <span data-ttu-id="ee96c-809">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Int64> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-809">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int64> data type.</span></span> 

## Examples
 <span data-ttu-id="ee96c-810">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Int64> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-810">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Int64> values.</span></span> <span data-ttu-id="ee96c-811">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Int64> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-811">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Int64> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-812"><paramref name="value" />가 <see cref="F:System.Int64.MinValue" />보다 작거나 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-812"><paramref name="value" /> is less than <see cref="F:System.Int64.MinValue" /> or is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-813">부호 있는 8비트 값으로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-813">The value to convert to a signed 8-bit value.</span></span></param>
        <summary><span data-ttu-id="ee96c-814"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 8비트 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-814">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a signed 8-bit value.</span></span>  
  
<span data-ttu-id="ee96c-815">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-815">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-816">규격 대체 항목은 <see cref="T:System.Int16" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-816">The compliant alternative is <see cref="T:System.Int16" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-817"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-817">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-818">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-818">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-819">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-819">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-820">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CSByte` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-820">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CSByte` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-821">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-821">Otherwise, they display a compiler error.</span></span>  

 <span data-ttu-id="ee96c-822">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.SByte> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-822">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.SByte> data type.</span></span> <span data-ttu-id="ee96c-823">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.SByte> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-823">There is no loss of precision in the resulting <xref:System.SByte> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-824">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.SByte> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-824">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.SByte> values.</span></span> <span data-ttu-id="ee96c-825">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.SByte> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-825">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.SByte> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-826"><paramref name="value" />가 <see cref="F:System.SByte.MinValue" />보다 작거나 <see cref="F:System.SByte.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-826"><paramref name="value" /> is less than <see cref="F:System.SByte.MinValue" /> or is greater than <see cref="F:System.SByte.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-827">단정밀도 부동 소수점 값으로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-827">The value to convert to a single-precision floating-point value.</span></span></param>
        <summary><span data-ttu-id="ee96c-828"><see cref="T:System.Numerics.BigInteger" /> 개체를 단정밀도 부동 소수점 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-828">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to a single-precision floating-point value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-829"><paramref name="value" /> 매개 변수의 가능한 가장 가까운 표현을 포함하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-829">An object that contains the closest possible representation of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-830">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-830">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-831">데이터가 손실 되거나 정밀도 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-831">Language compilers do not perform this conversion automatically because it can involve data loss or a loss of precision.</span></span> <span data-ttu-id="ee96c-832">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CSng` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-832">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CSng` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-833">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-833">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="ee96c-834">때문에 <xref:System.Numerics.BigInteger> 범위를 벗어나는 값 수는 <xref:System.Single> 이 작업은 데이터 형식으로 축소 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-834">Because the <xref:System.Numerics.BigInteger> value can be outside the range of the <xref:System.Single> data type, this operation is a narrowing conversion.</span></span> <span data-ttu-id="ee96c-835">Throw 하지 않는 경우 변환이 실패 한 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-835">If the conversion is unsuccessful, it does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-836">대신 경우 합니다 <xref:System.Numerics.BigInteger> 값이 보다 작거나 <xref:System.Single.MinValue?displayProperty=nameWithType>, 결과 <xref:System.Single> 값은 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-836">Instead, if the <xref:System.Numerics.BigInteger> value is less than <xref:System.Single.MinValue?displayProperty=nameWithType>, the resulting <xref:System.Single> value is <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-837">경우는 <xref:System.Numerics.BigInteger> 값 보다 크면 <xref:System.Single.MaxValue?displayProperty=nameWithType>, 결과 <xref:System.Single> 값은 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-837">If the <xref:System.Numerics.BigInteger> value is greater than <xref:System.Single.MaxValue?displayProperty=nameWithType>, the resulting <xref:System.Single> value is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="ee96c-838">변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Single> 정밀도의 손실 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-838">The conversion of a <xref:System.Numerics.BigInteger> to a <xref:System.Single> may involve a loss of precision.</span></span> <span data-ttu-id="ee96c-839">전체 자릿수 손실을 캐스팅 또는 변환 작업을 수행 하려면 일부 경우에 발생할 수 있습니다 경우에 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Single> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-839">In some cases, the loss of precision may cause the casting or conversion operation to succeed even if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.Single> data type.</span></span> <span data-ttu-id="ee96c-840">다음 예제에서 이에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-840">The following example provides an illustration.</span></span> <span data-ttu-id="ee96c-841">최대 값을 할당 하는 <xref:System.Single> 두 개의 <xref:System.Numerics.BigInteger> 변수, 하나의 <xref:System.Numerics.BigInteger> 9.999 e 291 증가, 같음에 대 한 두 변수는 테스트를 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-841">It assigns the maximum value of a <xref:System.Single> to two <xref:System.Numerics.BigInteger> variables, increments one <xref:System.Numerics.BigInteger> variable by 9.999e291, and tests the two variables for equality.</span></span> <span data-ttu-id="ee96c-842">에 대 한 호출을 예상 대로 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드는 서로 다른 지 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-842">As expected, the call to the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method shows that they are unequal.</span></span> <span data-ttu-id="ee96c-843">그러나 더 큰 숫자를 변환 <xref:System.Numerics.BigInteger> 값을 다시를 <xref:System.Single> 성공 합니다 합니다 <xref:System.Numerics.BigInteger> 값을 초과 하면 이제 <xref:System.Single.MaxValue?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-843">However, the conversion of the larger <xref:System.Numerics.BigInteger> value back to a <xref:System.Single> succeeds, although the <xref:System.Numerics.BigInteger> value now exceeds <xref:System.Single.MaxValue?displayProperty=nameWithType>.</span></span>   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 <span data-ttu-id="ee96c-844">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Single> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-844">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.Single> values.</span></span>   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-845">부호 없는 16비트 정수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-845">The value to convert to an unsigned 16-bit integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-846"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 16비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-846">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 16-bit integer value.</span></span>  
  
<span data-ttu-id="ee96c-847">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-847">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-848">규격 대체 항목은 <see cref="T:System.Int32" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-848">The compliant alternative is <see cref="T:System.Int32" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-849"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-849">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-850">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-850">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-851">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-851">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-852">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CUShort` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-852">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CUShort` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-853">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-853">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="ee96c-854">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.UInt16> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-854">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt16> data type.</span></span> <span data-ttu-id="ee96c-855">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.UInt16> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-855">There is no loss of precision in the resulting <xref:System.UInt16> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-856">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.UInt16> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-856">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt16> values.</span></span> <span data-ttu-id="ee96c-857">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.UInt16> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-857">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt16> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-858"><paramref name="value" />가 <see cref="F:System.UInt16.MinValue" />보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-858"><paramref name="value" /> is less than <see cref="F:System.UInt16.MinValue" /> or is greater than <see cref="F:System.UInt16.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-859">부호 없는 32비트 정수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-859">The value to convert to an unsigned 32-bit integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-860"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 32비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-860">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 32-bit integer value.</span></span>  
  
<span data-ttu-id="ee96c-861">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-861">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-862">규격 대체 항목은 <see cref="T:System.Int64" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-862">The compliant alternative is <see cref="T:System.Int64" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-863"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-863">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-864">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-864">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-865">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-865">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-866">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CUInt` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-866">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CUInt` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-867">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-867">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="ee96c-868">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.UInt32> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-868">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt32> data type.</span></span> <span data-ttu-id="ee96c-869">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.UInt32> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-869">There is no loss of precision in the resulting <xref:System.UInt32> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-870">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.UInt32> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-870">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt32> values.</span></span> <span data-ttu-id="ee96c-871">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.UInt32> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-871">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt32> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-872"><paramref name="value" />가 <see cref="F:System.UInt32.MinValue" />보다 작거나 <see cref="F:System.UInt32.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-872"><paramref name="value" /> is less than <see cref="F:System.UInt32.MinValue" /> or is greater than <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-873">부호 없는 64비트 정수로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-873">The value to convert to an unsigned 64-bit integer.</span></span></param>
        <summary><span data-ttu-id="ee96c-874"><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 64비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-874">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> object to an unsigned 64-bit integer value.</span></span>  
  
<span data-ttu-id="ee96c-875">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-875">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-876">규격 대체 항목은 <see cref="T:System.Double" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-876">The compliant alternative is <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-877"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-877">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-878">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-878">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-879">데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-879">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="ee96c-880">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CULng` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-880">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` or `CULng` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-881">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-881">Otherwise, they display a compiler error.</span></span>    

 <span data-ttu-id="ee96c-882">Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.UInt64> 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-882">Because this operation defines a narrowing conversion, it can throw an <xref:System.OverflowException> at run time if the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt64> data type.</span></span> <span data-ttu-id="ee96c-883">결과의 전체 자릿수 손실 되지 않습니다 <xref:System.UInt64> 변환이 성공 하는 경우 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-883">There is no loss of precision in the resulting <xref:System.UInt64> value if the conversion is successful.</span></span>

## Examples
 <span data-ttu-id="ee96c-884">다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.UInt64> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-884">The following example illustrates the conversion of <xref:System.Numerics.BigInteger> to <xref:System.UInt64> values.</span></span> <span data-ttu-id="ee96c-885">또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.UInt64> 데이터 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-885">It also handles an <xref:System.OverflowException> that is thrown because the <xref:System.Numerics.BigInteger> value is outside the range of the <xref:System.UInt64> data type.</span></span>   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-886"><paramref name="value" />가 <see cref="F:System.UInt64.MinValue" />보다 작거나 <see cref="F:System.UInt64.MaxValue" />보다 큽니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-886"><paramref name="value" /> is less than <see cref="F:System.UInt64.MinValue" /> or is greater than <see cref="F:System.UInt64.MaxValue" />.</span></span></exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-887"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-887">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-888"><see cref="T:System.Single" /> 값을 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 명시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-888">Defines an explicit conversion of a <see cref="T:System.Single" /> value to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-889"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-889">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-890">소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-890">Any fractional part of the `value` parameter is truncated before conversion.</span></span>
 
 <span data-ttu-id="ee96c-891">오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-891">The overloads of the <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> method define the types to which or from which a <xref:System.Numerics.BigInteger> object can be converted.</span></span> <span data-ttu-id="ee96c-892">때문에 변환 <xref:System.Single> 에 <xref:System.Numerics.BigInteger> 잘라내기 소수 부분이 포함 될 수 있습니다 `value`, 언어 컴파일러는이 변환을 자동으로 수행 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-892">Because the conversion from <xref:System.Single> to <xref:System.Numerics.BigInteger> can involve truncating any fractional part of `value`, language compilers do not perform this conversion automatically.</span></span> <span data-ttu-id="ee96c-893">대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-893">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="ee96c-894">그렇지 않으면 컴파일러 오류가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-894">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="ee96c-895">사용자 지정 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-895">For languages that do not support custom operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.</span></span>


## Examples
 <span data-ttu-id="ee96c-896">다음 예제에서는 배열의 개별 요소를 변환 <xref:System.Single> 값을 <xref:System.Numerics.BigInteger> 개체 이며 각 변환의 결과 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-896">The following example converts the individual elements in an array of <xref:System.Single> values to <xref:System.Numerics.BigInteger> objects, and then displays the result of each conversion.</span></span> <span data-ttu-id="ee96c-897">참고는 소수 부분을 <xref:System.Single> 변환 하는 동안 값이 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-897">Note that any fractional part of a <xref:System.Single> value is truncated during the conversion.</span></span>
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="ee96c-898"><paramref name="value" />가 <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> 또는 <see cref="F:System.Single.NegativeInfinity" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-898"><paramref name="value" /> is <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NegativeInfinity" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-899">지정된 값이 지정된 다른 값보다 큰지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-899">Returns a value that indicates whether a specified value is greater than another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-900">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-900">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-901">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-901">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-902">부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-902">Returns a value that indicates whether a 64-bit signed integer is greater than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-903"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-903"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-904">합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-904">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-905">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-905">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 <span data-ttu-id="ee96c-906">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-906">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instance method instead.</span></span> <span data-ttu-id="ee96c-907">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-907">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 <span data-ttu-id="ee96c-908">경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-908">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-909">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-909">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-910">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-910">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-911">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-911">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-912"><see cref="T:System.Numerics.BigInteger" />가 부호 있는 64 정수 값보다 큰지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-912">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> is greater than a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-913"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-913"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-914">합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-914">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-915">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-915">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 <span data-ttu-id="ee96c-916">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-916">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-917">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-917">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 <span data-ttu-id="ee96c-918">경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-918">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-919">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-919">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-920">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-920">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-921">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-921">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-922"><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-922">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-923"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-923"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-924">합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-924">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-925">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-925">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 <span data-ttu-id="ee96c-926">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-926">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-927">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-927">They can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 <span data-ttu-id="ee96c-928">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-928">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-929">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-929">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-930">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-930">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-931"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 큰지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-931">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-932"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-932"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-933">합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-933">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-934">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-934">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 <span data-ttu-id="ee96c-935">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-935">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-936">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-936">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-937">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-937">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-938">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-938">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-939"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 큰지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-939">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-940"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-940"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-941">합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-941">The <xref:System.Numerics.BigInteger.op_GreaterThan%2A> method defines the operation of the greater than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-942">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-942">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 <span data-ttu-id="ee96c-943">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-943">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-944">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-944">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-945">지정된 값이 지정된 다른 값보다 크거나 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-945">Returns a value that indicates whether a specified value is greater than or equal to another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-946">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-946">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-947">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-947">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-948">부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-948">Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-949"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-949"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-950">합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-950">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-951">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-951">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 <span data-ttu-id="ee96c-952">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-952">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-953">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-953">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 <span data-ttu-id="ee96c-954">경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-954">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-955">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-955">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-956">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-956">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-957">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-957">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-958"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 있는 64비트 정수 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-958">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit signed integer value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-959"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-959"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-960">합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-960">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-961">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-961">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 <span data-ttu-id="ee96c-962">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-962">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-963">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-963">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 <span data-ttu-id="ee96c-964">경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-964">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-965">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-965">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-966">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-966">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-967">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-967">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-968"><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-968">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-969"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-969"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-970">합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-970">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-971">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-971">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 <span data-ttu-id="ee96c-972">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-972">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-973">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-973">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 <span data-ttu-id="ee96c-974">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-974">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-975">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-975">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-976">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-976">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-977"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-977">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is greater than or equal to a 64-bit unsigned integer value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-978"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-978"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-979">합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-979">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-980">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-980">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 <span data-ttu-id="ee96c-981">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-981">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-982">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-982">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 <span data-ttu-id="ee96c-983">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-983">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-984">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-984">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-985">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-985">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-986">부호 없는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-986">Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-987"><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-987"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-988">합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-988">The <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> method defines the operation of the greater than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-989">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-989">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 <span data-ttu-id="ee96c-990">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-990">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-991">일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-991">Some languages can also call the <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 <span data-ttu-id="ee96c-992">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-992">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-993"><see cref="T:System.Numerics.BigInteger" /> 개체와 다른 형식 간의 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-993">Defines an implicit conversion between a <see cref="T:System.Numerics.BigInteger" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-994"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-994">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-995">부호 없는 바이트를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-995">Defines an implicit conversion of an unsigned byte to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-996"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-996">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-997">소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-997">Any fractional part of the `value` parameter is truncated before conversion.</span></span>

 <span data-ttu-id="ee96c-998">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-998">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="ee96c-999">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-999">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1000">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1000">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1001">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Byte> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1001">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1002"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1002">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1003">부호 있는 16비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1003">Defines an implicit conversion of a signed 16-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1004"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1004">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1005">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1005">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="ee96c-1006">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1006">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1007">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1007">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1008">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Int16> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1008">This overload lets the compiler handle conversions from a <xref:System.Int16> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1009"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1009">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1010">부호 있는 32비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1010">Defines an implicit conversion of a signed 32-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1011"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1011">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1012">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1012">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="ee96c-1013">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1013">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1014">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1014">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1015">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Int32> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1015">This overload lets the compiler handle conversions from a <xref:System.Int32> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1016"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1016">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1017">부호 있는 64비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1017">Defines an implicit conversion of a signed 64-bit integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1018"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1018">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1019">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1019">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.</span></span>   
 
 <span data-ttu-id="ee96c-1020">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1020">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1021">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1021">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1022">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Int64> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1022">This overload lets the compiler handle conversions from a <xref:System.Int64> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1023"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1023">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1024">부호 있는 8비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1024">Defines an implicit conversion of an 8-bit signed integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1025">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1025">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-1026">규격 대체 항목은 <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1026">The compliant alternative is <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1027"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1027">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1028">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1028">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="ee96c-1029">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1029">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1030">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1030">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1031">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.SByte> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1031">This overload lets the compiler handle conversions from a <xref:System.SByte> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1032"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1032">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1033">부호 없는 16비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1033">Defines an implicit conversion of a 16-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1034">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1034">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-1035">규격 대체 항목은 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1035">The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1036"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1036">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1037">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1037">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="ee96c-1038">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1038">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1039">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1039">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1040">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.UInt16> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1040">This overload lets the compiler handle conversions from a <xref:System.UInt16> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1041"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1041">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1042">부호 없는 32비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1042">Defines an implicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1043">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1043">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-1044">규격 대체 항목은 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1044">The compliant alternative is <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1045"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1045">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1046">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1046">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="ee96c-1047">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1047">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1048">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1048">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1049">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.UInt32> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1049">This overload lets the compiler handle conversions from a <xref:System.UInt32> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1050"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1050">The value to convert to a <see cref="T:System.Numerics.BigInteger" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1051">부호 없는 64비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1051">Defines an implicit conversion of a 64-bit unsigned integer to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1052">이 API는 CLS 규격이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1052">This API is not CLS-compliant.</span></span> <span data-ttu-id="ee96c-1053">규격 대체 항목은 <see cref="T:System.Double" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1053">The compliant alternative is <see cref="T:System.Double" />.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1054"><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1054">An object that contains the value of the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1055">암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1055">For languages that do not support implicit operators, the alternative method is <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.</span></span>   

 <span data-ttu-id="ee96c-1056">오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1056">The overloads of the <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> method define the types to which or from which a compiler can automatically convert a <xref:System.Numerics.BigInteger> value without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="ee96c-1057">확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1057">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="ee96c-1058">이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.UInt64> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1058">This overload lets the compiler handle conversions from a <xref:System.UInt64> value to a <xref:System.Numerics.BigInteger> value, as the following example shows.</span></span>   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1059">증가시킬 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1059">The value to increment.</span></span></param>
        <summary><span data-ttu-id="ee96c-1060"><see cref="T:System.Numerics.BigInteger" /> 값을 1씩 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1060">Increments a <see cref="T:System.Numerics.BigInteger" /> value by 1.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1061">1씩 증가하는 <paramref name="value" /> 매개 변수의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1061">The value of the <paramref name="value" /> parameter incremented by 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1062">합니다 <xref:System.Numerics.BigInteger.op_Increment%2A> 메서드 정의 대 한 증가 연산 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1062">The <xref:System.Numerics.BigInteger.op_Increment%2A> method defines the increment operation for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1063">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1063">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 <span data-ttu-id="ee96c-1064">증가 연산자 부족 또는 연산자 오버 로드를 지원 하지 않습니다 하는 일부 언어 (예: Visual Basic)를 호출할 수는 <xref:System.Numerics.BigInteger.op_Increment%2A> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1064">Some languages (such as Visual Basic) that lack an increment operator or do not support operator overloading can call the <xref:System.Numerics.BigInteger.op_Increment%2A> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 <span data-ttu-id="ee96c-1065">때문에 <xref:System.Numerics.BigInteger> 개체를 변경할 수 없는 합니다 <xref:System.Numerics.BigInteger.op_Increment%2A> 연산자를 새로 만듭니다 <xref:System.Numerics.BigInteger> 하나 값인 개체 보다 <xref:System.Numerics.BigInteger> 가 나타내는 개체 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1065">Because <xref:System.Numerics.BigInteger> objects are immutable, the <xref:System.Numerics.BigInteger.op_Increment%2A> operator creates a new <xref:System.Numerics.BigInteger> object whose value is one more than the <xref:System.Numerics.BigInteger> object represented by `value`.</span></span> <span data-ttu-id="ee96c-1066">따라서 반복 호출을 <xref:System.Numerics.BigInteger.op_Increment%2A> 성능이 떨어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1066">Therefore, repeated calls to <xref:System.Numerics.BigInteger.op_Increment%2A> may be expensive.</span></span>  
  
 <span data-ttu-id="ee96c-1067">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1067">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-1068">두 개의 숫자 값이 다른지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1068">Returns a value that indicates whether two numeric values are not equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1069">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1069">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1070">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1070">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1071">부호 있는 64비트 정수와 <see cref="T:System.Numerics.BigInteger" /> 값이 다른지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1071">Returns a value that indicates whether a 64-bit signed integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1072"><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1072"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1073">합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1073">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1074">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1074">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 <span data-ttu-id="ee96c-1075">사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1075">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="ee96c-1076">호출 된 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 인스턴스 간의 관계를 나타내는 메서드를를 <xref:System.Numerics.BigInteger> 부호 있는 정수 (long) 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1076">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instance method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and a signed long integer value.</span></span>  
  
-   <span data-ttu-id="ee96c-1077">호출 된 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1077">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> instance method and reversing its value.</span></span>  
  
 <span data-ttu-id="ee96c-1078">경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1078">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1079">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1079">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1080">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1080">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1081"><see cref="T:System.Numerics.BigInteger" /> 값과 부호 있는 64비트 정수가 다른지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1081">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit signed integer are not equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1082"><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1082"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1083">합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1083">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1084">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1084">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 <span data-ttu-id="ee96c-1085">사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1085">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="ee96c-1086">호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 간의 관계를 나타내는 메서드를 <xref:System.Numerics.BigInteger> 부호 있는 정수 (long) 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1086">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and a signed long integer value.</span></span>  
  
-   <span data-ttu-id="ee96c-1087">호출 된 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1087">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 <span data-ttu-id="ee96c-1088">경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1088">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-1089">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1089">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1090">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1090">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1091">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1091">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1092">두 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 다른지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1092">Returns a value that indicates whether two <see cref="T:System.Numerics.BigInteger" /> objects have different values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1093"><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1093"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1094">합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1094">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1095">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1095">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 <span data-ttu-id="ee96c-1096">사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1096">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="ee96c-1097">호출 된 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> 간 관계를 나타내는 메서드를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1097">Calling the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method, which indicates the relationship between two <xref:System.Numerics.BigInteger> objects.</span></span>  
  
-   <span data-ttu-id="ee96c-1098">호출 된 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1098">Calling the <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 <span data-ttu-id="ee96c-1099">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1099">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1100">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1100">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1101">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1101">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1102"><see cref="T:System.Numerics.BigInteger" /> 값과 부호 없는 64비트 정수가 다른지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1102">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value and a 64-bit unsigned integer are not equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1103"><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1103"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1104">합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1104">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1105">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1105">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 <span data-ttu-id="ee96c-1106">사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1106">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="ee96c-1107">호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 간의 관계를 나타내는 <xref:System.Numerics.BigInteger> 부호 없는 정수 (long) 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1107">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and an unsigned long integer value.</span></span>  
  
-   <span data-ttu-id="ee96c-1108">호출 된 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1108">Calling the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1109">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1109">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1110">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1110">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1111">부호 없는 64비트 정수와 <see cref="T:System.Numerics.BigInteger" /> 값이 다른지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1111">Returns a value that indicates whether a 64-bit unsigned integer and a <see cref="T:System.Numerics.BigInteger" /> value are not equal.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1112"><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1112"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1113">합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1113">The <xref:System.Numerics.BigInteger.op_Inequality%2A> method defines the operation of the inequality operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1114">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1114">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 <span data-ttu-id="ee96c-1115">사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1115">Languages that do not support custom operators can test for inequality by using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="ee96c-1116">호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 간의 관계를 나타내는 <xref:System.Numerics.BigInteger> 부호 없는 정수 (long) 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1116">Calling the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method, which indicates the relationship between a <xref:System.Numerics.BigInteger> and an unsigned long integer value.</span></span>  
  
-   <span data-ttu-id="ee96c-1117">호출 된 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1117">Calling the <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> method and reversing its value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1118">비트를 이동할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1118">The value whose bits are to be shifted.</span></span></param>
        <param name="shift"><span data-ttu-id="ee96c-1119"><paramref name="value" />를 왼쪽으로 이동할 비트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1119">The number of bits to shift <paramref name="value" /> to the left.</span></span></param>
        <summary><span data-ttu-id="ee96c-1120"><see cref="T:System.Numerics.BigInteger" /> 값을 지정된 비트 수만큼 왼쪽으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1120">Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the left.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1121">지정된 비트 수만큼 왼쪽으로 이동한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1121">A value that has been shifted to the left by the specified number of bits.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1122">합니다 <xref:System.Numerics.BigInteger.op_LeftShift%2A> 메서드 정의 작업에 대 한 비트 왼쪽 시프트 연산자의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1122">The <xref:System.Numerics.BigInteger.op_LeftShift%2A> method defines the operation of the bitwise left-shift operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1123">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1123">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1124">정수 기본 요소를 사용 하 여 비트 왼쪽 시프트 작업과 달리 합니다 <xref:System.Numerics.BigInteger.op_LeftShift%2A> 메서드는 원래의 부호를 유지 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1124">Unlike the bitwise left-shift operation with integer primitives, the <xref:System.Numerics.BigInteger.op_LeftShift%2A> method preserves the sign of the original <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="ee96c-1125">사용자 지정 연산자를 지원 하지 않는 언어와 왼쪽 시프트 연산을 수행할 수 `value` 여 `BigInteger.Pow(2, shift)`입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1125">Languages that do not support custom operators can perform a bitwise left-shift operation by multiplying `value` by `BigInteger.Pow(2, shift)`.</span></span> <span data-ttu-id="ee96c-1126">다음 예제에서는 결과 동일한이 연산자를 사용 하 여 결과에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1126">The following example shows that the results are identical to the results of using this operator.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-1127">지정된 값이 지정된 두 번째 값보다 작은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1127">Returns a value that indicates whether a specified value is less than a second specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1128">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1128">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1129">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1129">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1130">부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1130">Returns a value that indicates whether a 64-bit signed integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1131"><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1131"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1132">합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1132">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1133">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1133">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 <span data-ttu-id="ee96c-1134">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1134">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1135">일부 언어는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1135">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 <span data-ttu-id="ee96c-1136">경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1136">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-1137">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1137">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1138">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1138">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1139">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1139">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1140"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 있는 64비트 정수보다 작은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1140">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1141"><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1141"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1142">합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1142">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1143">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1143">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 <span data-ttu-id="ee96c-1144">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1144">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1145">일부 언어는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1145">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 <span data-ttu-id="ee96c-1146">경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1146">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-1147">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1147">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1148">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1148">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1149">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1149">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1150"><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1150">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1151"><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1151"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1152">합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1152">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1153">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1153">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 <span data-ttu-id="ee96c-1154">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1154">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1155">일부 언어는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1155">Some languages can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 <span data-ttu-id="ee96c-1156">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1156">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1157">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1157">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1158">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1158">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1159"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 작은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1159">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1160"><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1160"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1161">합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1161">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1162">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1162">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 <span data-ttu-id="ee96c-1163">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1163">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1164">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1164">They can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 <span data-ttu-id="ee96c-1165">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1165">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1166">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1166">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1167">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1167">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1168">부호 없는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1168">Returns a value that indicates whether a 64-bit unsigned integer is less than a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1169"><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1169"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1170">합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1170">The <xref:System.Numerics.BigInteger.op_LessThan%2A> method defines the operation of the less than operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1171">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1171">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 <span data-ttu-id="ee96c-1172">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1172">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1173">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1173">They can also call the <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 <span data-ttu-id="ee96c-1174">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1174">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-1175">지정된 값이 지정된 다른 값보다 작거나 같은지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1175">Returns a value that indicates whether a specified value is less than or equal to another specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1176">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1176">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1177">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1177">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1178">부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1178">Returns a value that indicates whether a 64-bit signed integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1179"><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1179"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1180">합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1180">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1181">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1181">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 <span data-ttu-id="ee96c-1182">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1182">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1183">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1183">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 <span data-ttu-id="ee96c-1184">경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1184">If `left` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-1185">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1185">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1186">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1186">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1187">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1187">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1188"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 있는 64비트 정수보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1188">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1189"><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1189"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1190">합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1190">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1191">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1191">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 <span data-ttu-id="ee96c-1192">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1192">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1193">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1193">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 <span data-ttu-id="ee96c-1194">경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1194">If `right` is a <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, or <xref:System.UInt32> value, it is implicitly converted to an <xref:System.Int64> value when the operation is performed.</span></span>  
  
 <span data-ttu-id="ee96c-1195">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1195">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1196">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1196">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1197">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1197">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1198"><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1198">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1199"><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1199"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1200">합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1200">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1201">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1201">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 <span data-ttu-id="ee96c-1202">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1202">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Compare%2A> method instead.</span></span> <span data-ttu-id="ee96c-1203">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1203">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 <span data-ttu-id="ee96c-1204">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1204">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1205">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1205">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1206">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1206">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1207"><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1207">Returns a value that indicates whether a <see cref="T:System.Numerics.BigInteger" /> value is less than or equal to a 64-bit unsigned integer.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1208"><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1208"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1209">합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1209">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1210">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1210">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 <span data-ttu-id="ee96c-1211">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1211">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1212">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1212">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 <span data-ttu-id="ee96c-1213">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1213">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1214">비교할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1214">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1215">비교할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1215">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="ee96c-1216">부호 없는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1216">Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1217"><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1217"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1218">합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1218">The <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> method defines the operation of the less than or equal to operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1219">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1219">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 <span data-ttu-id="ee96c-1220">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1220">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> method instead.</span></span> <span data-ttu-id="ee96c-1221">호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1221">They can also call the <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> method directly, as the following example shows.</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 <span data-ttu-id="ee96c-1222">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1222">The equivalent method for this operator is <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="ee96c-1223">나눌 대상 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1223">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="ee96c-1224">나눌 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1224">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="ee96c-1225">지정된 두 <see cref="T:System.Numerics.BigInteger" /> 값을 나눈 나머지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1225">Returns the remainder that results from division with two specified <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1226">나눈 나머지입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1226">The remainder that results from the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1227">합니다 <xref:System.Numerics.BigInteger.op_Modulus%2A> 메서드는 모듈러스 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1227">The <xref:System.Numerics.BigInteger.op_Modulus%2A> method defines the operation of the modulus operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1228">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1228">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 <span data-ttu-id="ee96c-1229">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1229">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> method instead.</span></span>  
  
 <span data-ttu-id="ee96c-1230">모듈러스 연산에서 반환 된 값의 부호의 부호에 따라 달라 집니다 `dividend`: 경우 `dividend` 이 양수인 경우 모듈러스 연산 결과도 양의; 모듈러스 연산 음수 이면 음수 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1230">The sign of the value returned by the modulus operation depends on the sign of `dividend`: If `dividend` is positive, the modulus operation returns a positive result; if it is negative, the modulus operation returns a negative result.</span></span> <span data-ttu-id="ee96c-1231">모듈러스 작업의 동작 <xref:System.Numerics.BigInteger> 값이 다른 정수 형식과 함께 모듈러스 연산과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1231">The behavior of the modulus operation with <xref:System.Numerics.BigInteger> values is identical to the modulus operation with other integral types.</span></span>  
  
 <span data-ttu-id="ee96c-1232">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1232">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="ee96c-1233"><paramref name="divisor" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1233"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1234">곱할 첫 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1234">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1235">곱할 두 번째 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1235">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="ee96c-1236">지정된 두 <see cref="T:System.Numerics.BigInteger" /> 값을 곱합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1236">Multiplies two specified <see cref="T:System.Numerics.BigInteger" /> values.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1237"><paramref name="left" />와 <paramref name="right" />의 곱입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1237">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1238">합니다 <xref:System.Numerics.BigInteger.op_Multiply%2A> 메서드 정의 작업에 대 한 곱하기 연산자의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1238">The <xref:System.Numerics.BigInteger.op_Multiply%2A> method defines the operation of the multiplication operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1239">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1239">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 <span data-ttu-id="ee96c-1240">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1240">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1241">정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1241">An integer value.</span></span></param>
        <summary><span data-ttu-id="ee96c-1242"><see cref="T:System.Numerics.BigInteger" /> 값에 대한 비트 1의 보수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1242">Returns the bitwise one's complement of a <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1243"><paramref name="value" />에 대한 비트 1의 보수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1243">The bitwise one's complement of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1244">합니다 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> 비트의 작업을 정의 하는 방법에 대 한 1의 보수 연산자 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1244">The <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method defines the operation of the bitwise one's complement operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1245">숫자 값에서 각가 비트 비트 1의 보수 연산자를 반대로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1245">The bitwise one's complement operator reverses each bit in a numeric value.</span></span> <span data-ttu-id="ee96c-1246">즉,에서 비트 `value` 된 0 결과 1로 설정 되 고 1 인 비트 결과에 0으로 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1246">That is, bits in `value` that are 0 are set to 1 in the result, and bits that are 1 are set to 0 in the result.</span></span> <span data-ttu-id="ee96c-1247"><xref:System.Numerics.BigInteger.op_OnesComplement%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1247">The <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 <span data-ttu-id="ee96c-1248">사용자 지정 연산자를 지원 하지 않는 언어를 호출 하는 일을 할 수 있습니다는 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> 1의 연산을 수행 하려면 직접 메서드 작업을 보완 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1248">Languages that do not support custom operators may be able to call the <xref:System.Numerics.BigInteger.op_OnesComplement%2A> method directly to perform a bitwise one's complement operation.</span></span> <span data-ttu-id="ee96c-1249">예:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1249">For example:</span></span>  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1250">비트를 이동할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1250">The value whose bits are to be shifted.</span></span></param>
        <param name="shift"><span data-ttu-id="ee96c-1251"><paramref name="value" />를 오른쪽으로 이동할 비트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1251">The number of bits to shift <paramref name="value" /> to the right.</span></span></param>
        <summary><span data-ttu-id="ee96c-1252"><see cref="T:System.Numerics.BigInteger" /> 값을 지정된 비트 수만큼 오른쪽으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1252">Shifts a <see cref="T:System.Numerics.BigInteger" /> value a specified number of bits to the right.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1253">지정된 비트 수만큼 오른쪽으로 이동한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1253">A value that has been shifted to the right by the specified number of bits.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1254">합니다 <xref:System.Numerics.BigInteger.op_RightShift%2A> 메서드 정의 작업에 대 한 비트 오른쪽 시프트 연산자의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1254">The <xref:System.Numerics.BigInteger.op_RightShift%2A> method defines the operation of the bitwise right-shift operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1255">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1255">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 <span data-ttu-id="ee96c-1256">언어 사용자 지정 연산자를 지원 하지 않는 나누어 비트 오른쪽 시프트 연산을 수행할 수 `value` 하 여 `BigInteger.Pow(2, shift)` 을 1 시간을 빼는 방법 `shift` 음수 값에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1256">Languages that do not support custom operators can perform a bitwise right-shift operation by dividing `value` by `BigInteger.Pow(2, shift)` and subtracting 1 times `shift` for negative values.</span></span> <span data-ttu-id="ee96c-1257">다음 예제에서는 결과 동일한이 연산자를 사용 하 여 결과에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1257">The following example shows that the results are identical to the results of using this operator.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 <span data-ttu-id="ee96c-1258">하는 경우 `shift` 보다 크거나 양수의 비트 수와 같고 <xref:System.Numerics.BigInteger> 값을 오른쪽 시프트 연산의 결과 <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1258">If `shift` is greater than or equal to the number of bits in a positive <xref:System.Numerics.BigInteger> value, the result of the right-shift operation is <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-1259">하는 경우 `shift` 음수의 비트 수보다 크면 <xref:System.Numerics.BigInteger> 값을 오른쪽 시프트 연산의 결과 <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1259">If `shift` is greater than the number of bits in a negative <xref:System.Numerics.BigInteger> value, the result of the right-shift operation is <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1260">뺄 대상 값(피감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1260">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1261">뺄 값(감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1261">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="ee96c-1262">다른 <see cref="T:System.Numerics.BigInteger" /> 값에서 <see cref="T:System.Numerics.BigInteger" /> 값을 뺍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1262">Subtracts a <see cref="T:System.Numerics.BigInteger" /> value from another <see cref="T:System.Numerics.BigInteger" /> value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1263"><paramref name="right" />에서 <paramref name="left" />를 뺀 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1263">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1264">합니다 <xref:System.Numerics.BigInteger.op_Subtraction%2A> 빼기 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1264">The <xref:System.Numerics.BigInteger.op_Subtraction%2A> method defines the operation of the subtraction operator for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1265">다음과 같은 코드 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1265">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 <span data-ttu-id="ee96c-1266">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1266">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> method instead.</span></span>  
  
 <span data-ttu-id="ee96c-1267">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1267">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1268">부정할 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1268">The value to negate.</span></span></param>
        <summary><span data-ttu-id="ee96c-1269">지정된 BigInteger 값을 부정합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1269">Negates a specified BigInteger value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1270"><paramref name="value" /> 매개 변수에 -1을 곱한 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1270">The result of the <paramref name="value" /> parameter multiplied by negative one (-1).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1271">합니다 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> 메서드는 단항 부정 연산자 (또는 덧셈 역 원을 연산자)의 작업에 대 한 정의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1271">The <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> method defines the operation of the unary negation operator (or the additive inverse operator) for <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1272">작업 원본 수를 추가할 때 0 (영)에서 발생 하는 값을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1272">The operation produces a value that results in 0 (zero) when it is added to the original number.</span></span> <span data-ttu-id="ee96c-1273">사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Negate%2A> 메서드 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1273">Languages that do not support custom operators can call the <xref:System.Numerics.BigInteger.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="ee96c-1274">이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ee96c-1274">The equivalent method for this operator is <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="ee96c-1275">다음 예의 값을 부정 하는 세 가지를 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1275">The following example illustrates three different ways to negate the value of a <xref:System.Numerics.BigInteger> object.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1276">정수 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1276">An integer value.</span></span></param>
        <summary><span data-ttu-id="ee96c-1277"><see cref="T:System.Numerics.BigInteger" /> 피연산자의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1277">Returns the value of the <see cref="T:System.Numerics.BigInteger" /> operand.</span></span> <span data-ttu-id="ee96c-1278">피연산자의 부호는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1278">(The sign of the operand is unchanged.)</span></span></summary>
        <returns><span data-ttu-id="ee96c-1279"><paramref name="value" /> 피연산자의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1279">The value of the <paramref name="value" /> operand.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1280">합니다 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> 메서드 정의 대 한 단항 부정 연산자 연산의 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1280">The <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> method defines the operation of the unary positive operator for <xref:System.Numerics.BigInteger> values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-1281">숫자의 문자열 표현을 해당하는 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1281">Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1282">변환할 숫자가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1282">A string that contains the number to convert.</span></span></param>
        <summary><span data-ttu-id="ee96c-1283">숫자의 문자열 표현을 해당하는 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1283">Converts the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1284"><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1284">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1285">`value` 매개 변수 형식은 숫자의 문자열 표현 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1285">The `value` parameter should be the string representation of a number in the following form.</span></span>  
  
 <span data-ttu-id="ee96c-1286">[*ws*][*sign*]*digits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1286">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1287">대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1287">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="ee96c-1288">다음 표에서는 각 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1288">The following table describes each element.</span></span>  
  
|<span data-ttu-id="ee96c-1289">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1289">Element</span></span>|<span data-ttu-id="ee96c-1290">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1290">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ee96c-1291">*ws*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1291">*ws*</span></span>|<span data-ttu-id="ee96c-1292">선택적 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1292">Optional white space.</span></span>|  
|<span data-ttu-id="ee96c-1293">*sign*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1293">*sign*</span></span>|<span data-ttu-id="ee96c-1294">가 선택적 부호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1294">An optional sign.</span></span> <span data-ttu-id="ee96c-1295">유효한 부호 문자는 기준 합니다 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1295">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the current culture.</span></span>|  
|<span data-ttu-id="ee96c-1296">*digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1296">*digits*</span></span>|<span data-ttu-id="ee96c-1297">0에서 9 까지의 숫자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1297">A sequence of digits ranging from 0 to 9.</span></span> <span data-ttu-id="ee96c-1298">모든 선행 0은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1298">Any leading zeros are ignored.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1299">지정 된 문자열을 `value` 매개 변수를 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1299">The string specified by the `value` parameter is interpreted by using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="ee96c-1300">그룹 구분 기호나 소수 구분 기호를 포함할 수 없습니다 하며에 소수 부분이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1300">It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
 <span data-ttu-id="ee96c-1301">`value` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> 현재 시스템 문화권에 대 한 초기화 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1301">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> object that is initialized for the current system culture.</span></span> <span data-ttu-id="ee96c-1302">자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1302">For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-1303">특정 문화권의 서식 지정 정보를 사용 하 여 문자열의 구문을 분석을 사용 하 여를 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1303">To parse a string by using the formatting information of a specific culture, use the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee96c-1304">사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1304">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="ee96c-1305">이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1305">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1306">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Parse%28System.String%29> 메서드를 두 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1306">The following example uses the <xref:System.Numerics.BigInteger.Parse%28System.String%29> method to instantiate two <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="ee96c-1307">각 개체는 다른 수를 곱하고 그 다음 호출을 <xref:System.Numerics.BigInteger.Compare%2A> 두 값 간의 관계를 확인 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1307">It multiplies each object by another number and then calls the <xref:System.Numerics.BigInteger.Compare%2A> method to determine the relationship between the two values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee96c-1308"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1308"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ee96c-1309"><paramref name="value" />가 올바른 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1309"><paramref name="value" /> is not in the correct format.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1310">변환할 숫자가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1310">A string that contains a number to convert.</span></span></param>
        <param name="style"><span data-ttu-id="ee96c-1311"><paramref name="value" />에 사용할 수 있는 서식을 지정하는 열거형 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1311">A bitwise combination of the enumeration values that specify the permitted format of <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1312">숫자를 지정된 스타일로 나타낸 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1312">Converts the string representation of a number in a specified style to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1313"><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1313">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1314">합니다 `style` 매개 변수 (예: 공백, 양수 또는 음수 기호, 그룹 구분 기호 또는 소수점 기호)에 사용할 수 있는 스타일 요소를 정의 합니다 `value` 구문 분석 작업이 성공 하기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1314">The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="ee96c-1315">`styles` 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1315">`styles` must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="ee96c-1316">합니다 `style` 매개 변수 오버 로드 유용할 경우 이러한 메서드를 만듭니다 `value` 수 시스템 (10 진수 또는 16 진수)을 나타내는 16 진수 값의 문자열 표현이 포함 되어 `value` 실행된 시간에만 알려진 때나 있습니다 공백 문자를 허용 하지 않도록 하거나 부호 기호를 `value`입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1316">The `style` parameter makes this method overload useful when `value` contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by `value` is known only at run time, or when you want to disallow white space or a sign symbol in `value`.</span></span>  
  
 <span data-ttu-id="ee96c-1317">값에 따라 `style`, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1317">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="ee96c-1318">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1318">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1319">하는 경우 `style` 포함 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1319">If `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, the `value` parameter may contain the following elements:</span></span>  
  
 <span data-ttu-id="ee96c-1320">[*ws*]*hexdigits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1320">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1321">대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1321">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="ee96c-1322">다음 표에서는 각 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1322">The following table describes each element.</span></span>  
  
|<span data-ttu-id="ee96c-1323">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1323">Element</span></span>|<span data-ttu-id="ee96c-1324">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1324">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ee96c-1325">*ws*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1325">*ws*</span></span>|<span data-ttu-id="ee96c-1326">선택적 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1326">Optional white space.</span></span> <span data-ttu-id="ee96c-1327">공백의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1327">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="ee96c-1328">Culture 별 통화 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1328">A culture-specific currency symbol.</span></span> <span data-ttu-id="ee96c-1329">문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1329">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the current culture.</span></span> <span data-ttu-id="ee96c-1330">현재 문화권의 통화 기호에 나타날 수 있습니다 `value` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1330">The current culture's currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1331">*sign*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1331">*sign*</span></span>|<span data-ttu-id="ee96c-1332">가 선택적 부호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1332">An optional sign.</span></span> <span data-ttu-id="ee96c-1333">로그인의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1333">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee96c-1334">괄호를 사용할 수 있습니다 `value` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1334">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1335">*digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1335">*digits*</span></span><br /><br /> <span data-ttu-id="ee96c-1336">*fractional_digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1336">*fractional_digits*</span></span><br /><br /> <span data-ttu-id="ee96c-1337">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1337">*exponential_digits*</span></span>|<span data-ttu-id="ee96c-1338">0부터 9 까지의 숫자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1338">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="ee96c-1339">에 대 한 *소수 자릿수*숫자 0 유효만 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1339">For *fractional_digits*, only the digit 0 is valid.</span></span>|  
|<span data-ttu-id="ee96c-1340">*,*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1340">*,*</span></span>|<span data-ttu-id="ee96c-1341">Culture 별 그룹 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1341">A culture-specific group separator symbol.</span></span> <span data-ttu-id="ee96c-1342">현재 문화권의 그룹 구분 기호에 나타날 수 있습니다 `value` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1342">The current culture's group separator can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1343">*.*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1343">*.*</span></span>|<span data-ttu-id="ee96c-1344">Culture 별 소수점 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1344">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="ee96c-1345">현재 문화권의 소수점 기호에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1345">The current culture's decimal point symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee96c-1346">구문 분석 작업이 성공 하기 위해 소수 자릿수로 숫자 0만 나타날 수 있습니다. 경우 *소수 자릿수* 다른 숫자를 포함 한 <xref:System.FormatException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1346">Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, a <xref:System.FormatException> is thrown.</span></span>|  
|<span data-ttu-id="ee96c-1347">E</span><span class="sxs-lookup"><span data-stu-id="ee96c-1347">E</span></span>|<span data-ttu-id="ee96c-1348">"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1348">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="ee96c-1349">`value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1349">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1350">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1350">*hexdigits*</span></span>|<span data-ttu-id="ee96c-1351">16 진수 숫자 0 ~ f 또는 0 ~ 6. 시퀀스</span><span class="sxs-lookup"><span data-stu-id="ee96c-1351">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="ee96c-1352">종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1352">Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.</span></span>

 <span data-ttu-id="ee96c-1353">숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1353">A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully.</span></span> <span data-ttu-id="ee96c-1354">나머지 대부분 <xref:System.Globalization.NumberStyles> 멤버가 있을 수 있지만 입력된 문자열에 나타날 수 필요가 없습니다 요소를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1354">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in the input string.</span></span> <span data-ttu-id="ee96c-1355">다음 표에서 개별 <xref:System.Globalization.NumberStyles> 멤버에 나타날 수 있는 요소에 영향을 줄 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1355">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="ee96c-1356">`NumberStyles` 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-1356">`NumberStyles` value</span></span>|<span data-ttu-id="ee96c-1357">허용 되는 요소 `value` 숫자 외에도</span><span class="sxs-lookup"><span data-stu-id="ee96c-1357">Elements permitted in `value` in addition to digits</span></span>|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="ee96c-1358">합니다 *자릿수* 요소에만 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1358">The *digits* element only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="ee96c-1359">소수점 (.) 및 *소수 자릿수* 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1359">The decimal point (.) and *fractional-digits* elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="ee96c-1360">"E" 또는 "E" 문자를 함께 지 수 표기법으로 나타냅니다 *지 수 표기법*합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1360">The "e" or "E" character, which indicates exponential notation, along with *exponential_digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="ee96c-1361">합니다 *ws* 의 시작 부분에 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1361">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="ee96c-1362">합니다 *ws* 의 끝에 있는 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1362">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="ee96c-1363">합니다 *sign* 의 시작 부분에 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1363">The *sign* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="ee96c-1364">합니다 *sign* 의 끝에 있는 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1364">The *sign* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="ee96c-1365">합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1365">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="ee96c-1366">그룹 구분 기호 (,) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1366">The group separator (,) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="ee96c-1367">통화 ($) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1367">The currency ($) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="ee96c-1368">모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1368">All elements.</span></span> <span data-ttu-id="ee96c-1369">그러나 `value` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1369">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="ee96c-1370">합니다 *ws* 시작 또는 끝에 요소 `value`, *로그인* 의 시작 부분에 `value`, 및 소수점 (*.*) 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1370">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (*.*) symbol.</span></span> <span data-ttu-id="ee96c-1371">`value` 매개 변수 지 수 표기법을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1371">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="ee96c-1372">`ws`, `sign`, 그룹 구분 기호 (*,*), 소수점 및 (*.*) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1372">The `ws`, `sign`, group separator (*,*), and decimal point (*.*) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="ee96c-1373">모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1373">All elements.</span></span> <span data-ttu-id="ee96c-1374">그러나 `value` 16 진수 숫자를 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1374">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee96c-1375">사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1375">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="ee96c-1376">이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1376">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="ee96c-1377">다른 달리 <xref:System.Globalization.NumberStyles> 값을 허용 하지만 특정 스타일 요소에 있으면 필요 하지 않습니다 `value`서 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 스타일 값의 개별 숫자 문자를 의미 `value` 항상로 해석 됩니다 16 진수 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1377">Unlike the other <xref:System.Globalization.NumberStyles> values, which allow for, but do not require, the presence of particular style elements in `value`, the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> style value means that the individual numeric characters in `value` are always interpreted as hexadecimal characters.</span></span> <span data-ttu-id="ee96c-1378">유효한 16 진수는 0-9, A-f 및 a-f 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1378">Valid hexadecimal characters are 0-9, A-F, and a-f.</span></span> <span data-ttu-id="ee96c-1379">만 다른 플래그와 결합 될 수 있는 합니다 `style` 매개 변수에 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1379">The only other flags that can be combined with the `style` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-1380">(합니다 <xref:System.Globalization.NumberStyles> 열거형은 복합 숫자 스타일을 포함 <xref:System.Globalization.NumberStyles.HexNumber>, 모두 공백 플래그를 포함 하는.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1380">(The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1381">하는 경우 `value` 문자열 표현인 16 진수 숫자의 고 수 없습니다. 뒤에 야 모든 장식 (같은 `0x` 또는 `&h`) 16 진수 숫자로 구분 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1381">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="ee96c-1382">이렇게 하면 변환이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1382">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="ee96c-1383">경우 `value` 16 진수 문자열을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 보다 크거나 같습니다 `value` 음수로 처음 두 16 진수 보다 크거나 같은 경우에 2의 보수 표현이 사용 하 여 저장 `0x80`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1383">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="ee96c-1384">메서드는 첫 번째 바이트의 최상위 비트를 해석 하는 즉, `value` 부호 비트로입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1384">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="ee96c-1385">16 진수 문자열에서 첫 번째 숫자가 양수 숫자로 해석 됩니다 있도록 `value` 0의 값이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1385">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="ee96c-1386">예를 들어이 메서드는 해석 `0x80` 음수 값을 해석 하거나 대로 `0x080` 또는 `0x0080` 양수 값으로.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1386">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="ee96c-1387">다음 예에서는 양수 및 음수 값을 나타내는 16 진수 문자열 간의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1387">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 <span data-ttu-id="ee96c-1388">`value` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 대 한 초기화 되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1388">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture.</span></span> <span data-ttu-id="ee96c-1389">서식 지정 정보를 가져올 구문 분석 작업에 사용 되는 문화권을 지정 하려면 호출을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1389">To specify the culture whose formatting information is used for the parse operation, call the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1390">다음 예제에 대 한 호출을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 에 대 한 몇 가지 가능한 값을 사용 하 여 메서드를 `style` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1390">The following example illustrates calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method with several possible values for the `style` parameter.</span></span> <span data-ttu-id="ee96c-1391">16 진수 값으로 문자열을 해석 하는 방법 및 공간을 허용 하지 않습니다 하 고 기호를 서명 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1391">It illustrates how to interpret a string as a hexadecimal value, and how to disallow spaces and sign symbols.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ee96c-1392"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1392"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1393">또는</span><span class="sxs-lookup"><span data-stu-id="ee96c-1393">-or-</span></span> 
 <span data-ttu-id="ee96c-1394"><paramref name="style" />에는 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 또는 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 플래그가 다른 값과 함께 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1394"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee96c-1395"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1395"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ee96c-1396"><paramref name="value" />는 <see cref="T:System.Globalization.NumberStyles" />에 의해 지정된 입력 패턴에 맞지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1396"><paramref name="value" /> does not comply with the input pattern specified by <see cref="T:System.Globalization.NumberStyles" />.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1397">변환할 숫자가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1397">A string that contains a number to convert.</span></span></param>
        <param name="provider"><span data-ttu-id="ee96c-1398"><paramref name="value" />에 대한 문화권별 서식 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1398">An object that provides culture-specific formatting information about <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1399">숫자를 지정된 문화권별 형식으로 나타낸 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1399">Converts the string representation of a number in a specified culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1400"><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1400">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1401">`value` 매개 변수 형식은 숫자의 문자열 표현 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1401">The `value` parameter should be the string representation of a number in the following form:</span></span>  
  
 <span data-ttu-id="ee96c-1402">[*ws*][*sign*]*digits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1402">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1403">대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1403">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="ee96c-1404">다음 표에서는 각 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1404">The following table describes each element.</span></span>  
  
|<span data-ttu-id="ee96c-1405">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1405">Element</span></span>|<span data-ttu-id="ee96c-1406">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1406">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ee96c-1407">*ws*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1407">*ws*</span></span>|<span data-ttu-id="ee96c-1408">선택적 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1408">Optional white space.</span></span>|  
|<span data-ttu-id="ee96c-1409">*sign*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1409">*sign*</span></span>|<span data-ttu-id="ee96c-1410">가 선택적 부호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1410">An optional sign.</span></span> <span data-ttu-id="ee96c-1411">유효한 부호 문자에 의해 결정 됩니다는 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 의 속성을 <xref:System.Globalization.NumberFormatInfo> 에서 반환 되는 개체를 `provider` 개체의 <xref:System.IFormatProvider.GetFormat%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1411">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the <xref:System.Globalization.NumberFormatInfo> object that is returned by the `provider` object's <xref:System.IFormatProvider.GetFormat%2A> method.</span></span>|  
|<span data-ttu-id="ee96c-1412">*digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1412">*digits*</span></span>|<span data-ttu-id="ee96c-1413">0에서 9 까지의 숫자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1413">A sequence of digits ranging from 0 to 9.</span></span> <span data-ttu-id="ee96c-1414">모든 선행 0은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1414">Any leading zeros are ignored.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1415">지정 된 문자열을 `value` 매개 변수를 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1415">The string specified by the `value` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="ee96c-1416">그룹 구분 기호나 소수 구분 기호를 포함할 수 없습니다 하며에 소수 부분이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1416">It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee96c-1417">사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1417">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="ee96c-1418">이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1418">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="ee96c-1419">`provider` 매개 변수는는 <xref:System.IFormatProvider> 구현입니다 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> culture 별 서식 지정 정보를 제공 하는 개체.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1419">The `provider` parameter is an <xref:System.IFormatProvider> implementation whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific formatting information.</span></span> <span data-ttu-id="ee96c-1420">경우는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드가 호출 되 면 호출를 `provider` 매개 변수의 <xref:System.IFormatProvider.GetFormat%2A> 메서드 전달를 <xref:System.Type> 나타내는 개체를 <xref:System.Globalization.NumberFormatInfo> 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1420">When the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> method is invoked, it calls the `provider` parameter's <xref:System.IFormatProvider.GetFormat%2A> method and passes it a <xref:System.Type> object that represents the <xref:System.Globalization.NumberFormatInfo> type.</span></span> <span data-ttu-id="ee96c-1421"><xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 됩니다 합니다 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 정보를 제공 하는 `value` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1421">The <xref:System.IFormatProvider.GetFormat%2A> method then returns the <xref:System.Globalization.NumberFormatInfo> object that provides information about the format of the `value` parameter.</span></span> <span data-ttu-id="ee96c-1422">사용 하는 방법은 세 가지를 `provider` 매개 변수를 구문 분석 작업에 사용자 지정 서식 지정 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1422">There are three ways to use the `provider` parameter to supply custom formatting information to the parse operation:</span></span>  
  
-   <span data-ttu-id="ee96c-1423">전달할 수는 <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1423">You can pass a <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="ee96c-1424">해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 문화권에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1424">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="ee96c-1425">실제 전달할 수 있습니다 <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1425">You can pass the actual <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="ee96c-1426">(해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1426">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="ee96c-1427">구현 하는 사용자 지정 개체를 전달할 수 있습니다 <xref:System.IFormatProvider>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1427">You can pass a custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="ee96c-1428">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1428">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="ee96c-1429">경우 `provider` 됩니다 `null`의 서식을 `value` 기준으로 해석 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1429">If `provider` is `null`, the formatting of `value` is interpreted based on the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1430">다음 예제에서는 서식 지정에 대 한 음수 부호로 물결표 (~)를 정의 하는 방법을 보여 줍니다 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1430">The following examples show two ways to define the tilde (~) as a negative sign for formatting <xref:System.Numerics.BigInteger> values.</span></span> <span data-ttu-id="ee96c-1431">표시 하는 합니다 <xref:System.Numerics.BigInteger> 같은 형식으로 원본 문자열 값을 코드를 호출 해야 합니다는 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 메서드 전달는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1431">Note that to display the <xref:System.Numerics.BigInteger> values in the same format as the original strings, your code must call the <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> method and pass it the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="ee96c-1432">구현 하는 클래스를 정의 하는 첫 번째 예제 <xref:System.IFormatProvider> 사용 하는 <xref:System.IFormatProvider.GetFormat%2A> 반환 하는 방법의 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1432">The first example defines a class that implements <xref:System.IFormatProvider> and uses the <xref:System.IFormatProvider.GetFormat%2A> method to return the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 <span data-ttu-id="ee96c-1433"><xref:System.Numerics.BigInteger> 다음 코드를 사용 하 여 개체를 인스턴스화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1433">A <xref:System.Numerics.BigInteger> object can then be instantiated with the following code:</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 <span data-ttu-id="ee96c-1434">두 번째 예제는 더 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1434">The second example is more straightforward.</span></span> <span data-ttu-id="ee96c-1435">전달 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체는 `provider` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1435">It passes the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information to the `provider` parameter.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee96c-1436"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1436"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ee96c-1437"><paramref name="value" />가 올바른 형식이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1437"><paramref name="value" /> is not in the correct format.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1438">변환할 숫자가 포함된 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1438">A string that contains a number to convert.</span></span></param>
        <param name="style"><span data-ttu-id="ee96c-1439"><paramref name="value" />에 사용할 수 있는 서식을 지정하는 열거형 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1439">A bitwise combination of the enumeration values that specify the permitted format of <paramref name="value" />.</span></span></param>
        <param name="provider"><span data-ttu-id="ee96c-1440"><paramref name="value" />에 대한 문화권별 서식 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1440">An object that provides culture-specific formatting information about <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="ee96c-1441">지정된 스타일 및 문화권별 형식으로 된 숫자의 문자열 표현을 해당하는 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1441">Converts the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1442"><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1442">A value that is equivalent to the number specified in the <paramref name="value" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1443">합니다 `style` 매개 변수 (예: 공백, 양수 또는 음수 기호, 그룹 구분 기호 또는 소수점 기호)에 사용할 수 있는 스타일 요소를 정의 합니다 `value` 구문 분석 작업이 성공 하기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1443">The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="ee96c-1444">`styles` 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1444">`styles` must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="ee96c-1445">합니다 `style` 매개 변수 오버 로드 유용할 경우 이러한 메서드를 만듭니다 `value` 수 시스템 (10 진수 또는 16 진수)을 나타내는 16 진수 값의 문자열 표현이 포함 되어 `value` 실행된 시간에만 알려진 때나 있습니다 공백 문자를 허용 하지 않도록 하거나 부호 기호를 `value`입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1445">The `style` parameter makes this method overload useful when `value` contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by `value` is known only at run time, or when you want to disallow white space or a sign symbol in `value`.</span></span>  
  
 <span data-ttu-id="ee96c-1446">값에 따라 `style`, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1446">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="ee96c-1447">[*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1447">[*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1448">하는 경우 `style` 포함 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1448">If `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="ee96c-1449">[*ws*]*hexdigits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1449">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1450">대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1450">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="ee96c-1451">다음 표에서는 각 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1451">The following table describes each element.</span></span>  
  
|<span data-ttu-id="ee96c-1452">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1452">Element</span></span>|<span data-ttu-id="ee96c-1453">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1453">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ee96c-1454">*ws*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1454">*ws*</span></span>|<span data-ttu-id="ee96c-1455">선택적 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1455">Optional white space.</span></span> <span data-ttu-id="ee96c-1456">공백의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1456">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="ee96c-1457">Culture 별 통화 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1457">A culture-specific currency symbol.</span></span> <span data-ttu-id="ee96c-1458">문자열의 해당 위치에서 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 하 고 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 문화권의 속성에 나타난를 `provider` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1458">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the culture indicated by the `provider` parameter.</span></span> <span data-ttu-id="ee96c-1459">현재 문화권의 통화 기호에 나타날 수 있습니다 `value` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1459">The current culture's currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1460">*sign*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1460">*sign*</span></span>|<span data-ttu-id="ee96c-1461">가 선택적 부호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1461">An optional sign.</span></span> <span data-ttu-id="ee96c-1462">로그인의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1462">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee96c-1463">괄호를 사용할 수 있습니다 `value` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1463">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1464">*digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1464">*digits*</span></span><br /><br /> <span data-ttu-id="ee96c-1465">*fractional_digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1465">*fractional_digits*</span></span><br /><br /> <span data-ttu-id="ee96c-1466">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1466">*exponential_digits*</span></span>|<span data-ttu-id="ee96c-1467">0부터 9 까지의 숫자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1467">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="ee96c-1468">에 대 한 *소수 자릿수*숫자 0 유효만 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1468">For *fractional_digits*, only the digit 0 is valid.</span></span>|  
|<span data-ttu-id="ee96c-1469">*,*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1469">*,*</span></span>|<span data-ttu-id="ee96c-1470">Culture 별 그룹 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1470">A culture-specific group separator symbol.</span></span> <span data-ttu-id="ee96c-1471">지정 된 문화권의 그룹 구분 기호 `provider` 에 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1471">The group separator symbol of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1472">*.*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1472">*.*</span></span>|<span data-ttu-id="ee96c-1473">Culture 별 소수점 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1473">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="ee96c-1474">지정 된 문화권의 소수점 기호 `provider` 에 나타날 수 있습니다 `value` 하는 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1474">The decimal point symbol of the culture designated by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee96c-1475">구문 분석 작업이 성공 하기 위해 소수 자릿수로 숫자 0만 나타날 수 있습니다. 경우 *소수 자릿수* 다른 숫자를 포함 한 <xref:System.FormatException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1475">Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, a <xref:System.FormatException> is thrown.</span></span>|  
|<span data-ttu-id="ee96c-1476">E</span><span class="sxs-lookup"><span data-stu-id="ee96c-1476">E</span></span>|<span data-ttu-id="ee96c-1477">"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1477">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="ee96c-1478">`value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1478">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1479">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1479">*hexdigits*</span></span>|<span data-ttu-id="ee96c-1480">16 진수 숫자 0 ~ f 또는 0 ~ 6. 시퀀스</span><span class="sxs-lookup"><span data-stu-id="ee96c-1480">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="ee96c-1481">종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1481">Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.</span></span>

 <span data-ttu-id="ee96c-1482">숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1482">A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully.</span></span> <span data-ttu-id="ee96c-1483">나머지 대부분 <xref:System.Globalization.NumberStyles> 멤버가 있을 수 있지만 입력된 문자열에 나타날 수 필요가 없습니다 요소를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1483">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in the input string.</span></span> <span data-ttu-id="ee96c-1484">다음 표에서 개별 <xref:System.Globalization.NumberStyles> 멤버에 나타날 수 있는 요소에 영향을 줄 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1484">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="ee96c-1485">NumberStyles 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-1485">NumberStyles value</span></span>|<span data-ttu-id="ee96c-1486">숫자 외에도 값에 허용 되는 요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1486">Elements permitted in value in addition to digits</span></span>|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="ee96c-1487">합니다 *자릿수* 요소에만 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1487">The *digits* element only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="ee96c-1488">소수점 (.) 및 *소수 자릿수* 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1488">The decimal point (.) and *fractional-digits* elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="ee96c-1489">"E" 또는 "E" 문자를 지 수 표기법을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1489">The "e" or "E" character, which indicates exponential notation.</span></span> <span data-ttu-id="ee96c-1490">와 함께 *지 수 표기법*합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1490">along with *exponential_digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="ee96c-1491">합니다 *ws* 의 시작 부분에 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1491">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="ee96c-1492">합니다 *ws* 의 끝에 있는 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1492">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="ee96c-1493">합니다 *sign* 의 시작 부분에 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1493">The *sign* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="ee96c-1494">합니다 *sign* 의 끝에 있는 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1494">The *sign* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="ee96c-1495">합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1495">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="ee96c-1496">그룹 구분 기호 (,) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1496">The group separator (,) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="ee96c-1497">통화 ($) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1497">The currency ($) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="ee96c-1498">모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1498">All elements.</span></span> <span data-ttu-id="ee96c-1499">그러나 `value` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1499">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="ee96c-1500">*ws* 시작 또는 끝에 요소 `value`, *sign* 의 시작 부분에 `value`, 및 소수점 (.).</span><span class="sxs-lookup"><span data-stu-id="ee96c-1500">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (.) symbol.</span></span> <span data-ttu-id="ee96c-1501">`value` 매개 변수 지 수 표기법을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1501">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="ee96c-1502">합니다 `ws`, `sign`, 그룹 구분 기호 (,), 및 소수점 (.) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1502">The `ws`, `sign`, group separator (,), and decimal point (.) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="ee96c-1503">모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1503">All elements.</span></span> <span data-ttu-id="ee96c-1504">그러나 `value` 16 진수 숫자를 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1504">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee96c-1505">사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1505">If you use the <xref:System.Numerics.BigInteger.Parse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="ee96c-1506">이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1506">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.Parse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="ee96c-1507">다른 달리 <xref:System.Globalization.NumberStyles> 값을 허용 하지만 특정 스타일 요소에 존재 하지 않아도 `value`의 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 스타일 값 즉 숫자의 개별 문자에서 `value` 항상로 해석 됩니다 16 진수 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1507">Unlike the other <xref:System.Globalization.NumberStyles> values, which allow for but do not require the presence of particular style elements in `value`, the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> style value means that the individual numeric characters in `value` are always interpreted as hexadecimal characters.</span></span> <span data-ttu-id="ee96c-1508">유효한 16 진수는 0-9, A-f 및 a-f 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1508">Valid hexadecimal characters are 0-9, A-F, and a-f.</span></span> <span data-ttu-id="ee96c-1509">만 다른 플래그와 결합 될 수 있는 합니다 `style` 매개 변수에 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1509">The only other flags that can be combined with the `style` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-1510">(합니다 <xref:System.Globalization.NumberStyles> 열거형은 복합 숫자 스타일을 포함 <xref:System.Globalization.NumberStyles.HexNumber>, 모두 공백 플래그를 포함 하는.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1510">(The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1511">하는 경우 `value` 문자열 표현인 16 진수 숫자의 고 수 없습니다. 뒤에 야 모든 장식 (같은 `0x` 또는 `&h`) 16 진수 숫자로 구분 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1511">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="ee96c-1512">이렇게 하면 변환이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1512">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="ee96c-1513">경우 `value` 16 진수 문자열을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 보다 크거나 같습니다 `value` 음수로 처음 두 16 진수 보다 크거나 같은 경우에 2의 보수 표현이 사용 하 여 저장 `0x80`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1513">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="ee96c-1514">메서드는 첫 번째 바이트의 최상위 비트를 해석 하는 즉, `value` 부호 비트로입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1514">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="ee96c-1515">16 진수 문자열에서 첫 번째 숫자가 양수 숫자로 해석 됩니다 있도록 `value` 0의 값이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1515">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="ee96c-1516">예를 들어이 메서드는 해석 `0x80` 음수 값을 해석 하거나 대로 `0x080` 또는 `0x0080` 양수 값으로.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1516">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="ee96c-1517">다음 예에서는 양수 및 음수 값을 나타내는 16 진수 문자열 간의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1517">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 <span data-ttu-id="ee96c-1518">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1518">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="ee96c-1519">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 문화권별 형식 정보를 제공 하는 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1519">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of `value`.</span></span> <span data-ttu-id="ee96c-1520">일반적으로 `provider` 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1520">Typically, `provider` can be any one of the following:</span></span>  
  
-   <span data-ttu-id="ee96c-1521"><xref:System.Globalization.CultureInfo> 숫자 형식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1521">A <xref:System.Globalization.CultureInfo> object that represents the culture that provides numeric formatting information.</span></span> <span data-ttu-id="ee96c-1522">해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1522">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span>  
  
-   <span data-ttu-id="ee96c-1523"><xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1523">A <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span> <span data-ttu-id="ee96c-1524">(해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1524">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="ee96c-1525">구현 하는 사용자 지정 개체 <xref:System.IFormatProvider> 사용 하는 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 인스턴스화하고 반환 하는 메서드는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1525">A custom object that implements <xref:System.IFormatProvider> and uses the <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> method to instantiate and return the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="ee96c-1526">하는 경우 `provider` 됩니다 `null`는 <xref:System.Globalization.NumberFormatInfo> 개체가 현재 문화권이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1526">If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1527">다음 예에서는 몇 번 호출 하는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 다양 한 조합에 대 한 값을 사용 하 여 메서드를 `style` 및 `provider` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1527">The following example makes several calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method using various combinations of values for the `style` and `provider` parameters.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 <span data-ttu-id="ee96c-1528">에 대 한 개별 호출 수를 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드는 다음의 인스턴스를 전달 `BigIntegerFormatProvider` 음수 부호와 물결표 (~)를 정의 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1528">A number of the individual calls to the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method pass an instance of the following `BigIntegerFormatProvider` class, which defines a tilde (~) as the negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ee96c-1529"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1529"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1530">또는</span><span class="sxs-lookup"><span data-stu-id="ee96c-1530">-or-</span></span> 
 <span data-ttu-id="ee96c-1531"><paramref name="style" />에는 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 또는 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 플래그가 다른 값과 함께 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1531"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee96c-1532"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1532"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="ee96c-1533"><paramref name="value" />는 <paramref name="style" />에 의해 지정된 입력 패턴에 맞지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1533"><paramref name="value" /> does not comply with the input pattern specified by <paramref name="style" />.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1534"><paramref name="exponent" /> 지수로 사용할 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1534">The number to raise to the <paramref name="exponent" /> power.</span></span></param>
        <param name="exponent"><span data-ttu-id="ee96c-1535"><paramref name="value" />를 거듭제곱할 지수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1535">The exponent to raise <paramref name="value" /> by.</span></span></param>
        <summary><span data-ttu-id="ee96c-1536"><see cref="T:System.Numerics.BigInteger" /> 값을 지정된 값의 거듭제곱으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1536">Raises a <see cref="T:System.Numerics.BigInteger" /> value to the power of a specified value.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1537"><paramref name="value" />를 <paramref name="exponent" />번 거듭제곱한 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1537">The result of raising <paramref name="value" /> to the <paramref name="exponent" /> power.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1538">합니다 <xref:System.Numerics.BigInteger.Pow%2A> 메서드 1을 반환 하는 경우 또는 지 수 매개 변수 값이 0 인 경우의 값이 모두를 `value` 및 `exponent` 매개 변수는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1538">The <xref:System.Numerics.BigInteger.Pow%2A> method returns 1 if the value of the exponent parameter is 0, or if the values of both the `value` and `exponent` parameters are 0.</span></span> <span data-ttu-id="ee96c-1539">경우 `exponent` 가 1 이면 합니다 <xref:System.Numerics.BigInteger.Pow%2A> 메서드가 반환 되는 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1539">If `exponent` is 1, the <xref:System.Numerics.BigInteger.Pow%2A> method returns `value`.</span></span> <span data-ttu-id="ee96c-1540">경우 `value` 가 음수인 경우 메서드는 음수 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1540">If `value` is negative, the method returns a negative result.</span></span>  
  
 <span data-ttu-id="ee96c-1541">에 해당 하는이 메서드는 <xref:System.Math.Pow%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1541">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1542">다음 예제를 사용 하 여 지 수는 <xref:System.Numerics.BigInteger> 값과 값 범위는 0에서 10 지 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1542">The following example illustrates exponentiation using a <xref:System.Numerics.BigInteger> value and an exponent whose value ranges from 0 to 10.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ee96c-1543"><paramref name="exponent" />가 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1543"><paramref name="exponent" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="ee96c-1544">나눌 대상 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1544">The value to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="ee96c-1545">나눌 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1545">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="ee96c-1546">두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 정수 나누기를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1546">Performs integer division on two <see cref="T:System.Numerics.BigInteger" /> values and returns the remainder.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1547"><paramref name="dividend" />를 <paramref name="divisor" />로 나눈 나머지입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1547">The remainder after dividing <paramref name="dividend" /> by <paramref name="divisor" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1548">나머지의 부호는의 부호는 `dividend` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1548">The sign of the remainder is the sign of the `dividend` parameter.</span></span>  
  
 <span data-ttu-id="ee96c-1549"><xref:System.Numerics.BigInteger.Remainder%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1549">The <xref:System.Numerics.BigInteger.Remainder%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="ee96c-1550">해당 동작 나누기 모듈러스 연산자를 사용 하는 것과 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1550">Its behavior is identical to division using the modulus operator.</span></span>  
  
 <span data-ttu-id="ee96c-1551">경우 필요한 메서드에서 자동으로 수행 하는 다른 정수 계열 형식으로의 암시적 변환 <xref:System.Numerics.BigInteger> 나머지 작업을 수행 하기 전에 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1551">If necessary, the method automatically performs implicit conversion of other integral types to <xref:System.Numerics.BigInteger> objects before it performs the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1552">다음 예제를 비교 합니다 <xref:System.Numerics.BigInteger.DivRem%2A> 반환한 나머지 메서드는 <xref:System.Numerics.BigInteger.Remainder%2A> 에 두 메서드에 동일한 나머지를 계산 하는 설정 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1552">The following example compares the remainder from the <xref:System.Numerics.BigInteger.DivRem%2A> method with the remainder returned by the <xref:System.Numerics.BigInteger.Remainder%2A> method to establish that the two methods calculate identical remainders.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><span data-ttu-id="ee96c-1553"><paramref name="divisor" />가 0인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1553"><paramref name="divisor" /> is 0 (zero).</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-1554">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 부호(음수, 양수 또는 0)를 나타내는 숫자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1554">Gets a number that indicates the sign (negative, positive, or zero) of the current <see cref="T:System.Numerics.BigInteger" /> object.</span></span></summary>
        <value><span data-ttu-id="ee96c-1555">다음 표와 같이 <see cref="T:System.Numerics.BigInteger" /> 개체의 부호를 나타내는 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1555">A number that indicates the sign of the <see cref="T:System.Numerics.BigInteger" /> object, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="ee96c-1556">수</span><span class="sxs-lookup"><span data-stu-id="ee96c-1556">Number</span></span> 
 </term><description> <span data-ttu-id="ee96c-1557">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1557">Description</span></span> 
 </description></listheader><item><term> <span data-ttu-id="ee96c-1558">-1</span><span class="sxs-lookup"><span data-stu-id="ee96c-1558">-1</span></span> 
 </term><description> <span data-ttu-id="ee96c-1559">이 개체의 값이 음수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1559">The value of this object is negative.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-1560">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-1560">0</span></span> 
 </term><description> <span data-ttu-id="ee96c-1561">이 개체의 값이 0입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1561">The value of this object is 0 (zero).</span></span>  
  
 </description></item><item><term> <span data-ttu-id="ee96c-1562">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-1562">1</span></span> 
 </term><description> <span data-ttu-id="ee96c-1563">이 개체의 값이 양수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1563">The value of this object is positive.</span></span>  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1564"><xref:System.Numerics.BigInteger.Sign%2A> 속성은 해당 하는 <xref:System.Math.Sign%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1564">The <xref:System.Numerics.BigInteger.Sign%2A> property is equivalent to the <xref:System.Math.Sign%2A?displayProperty=nameWithType> method for the primitive numeric types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ee96c-1565">뺄 대상 값(피감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1565">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="ee96c-1566">뺄 값(감수)입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1566">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="ee96c-1567">다른 값에서 하나의 <see cref="T:System.Numerics.BigInteger" /> 값을 뺀 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1567">Subtracts one <see cref="T:System.Numerics.BigInteger" /> value from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1568"><paramref name="right" />에서 <paramref name="left" />를 뺀 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1568">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1569">사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.BigInteger.Subtract%2A> 빼기를 사용 하 여 수행 하는 방법 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1569">Languages that do not support custom operators can use the <xref:System.Numerics.BigInteger.Subtract%2A> method to perform subtraction using <xref:System.Numerics.BigInteger> values.</span></span>  
  
 <span data-ttu-id="ee96c-1570">합니다 <xref:System.Numerics.BigInteger.Subtract%2A> 인스턴스화할 때 메서드는 빼기 연산자에 대 한 유용한 대체는 <xref:System.Numerics.BigInteger> 다음 예와에서 같이 빼기, 결과로 생성 되는 차이점을 할당 하 여 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1570">The <xref:System.Numerics.BigInteger.Subtract%2A> method is a useful substitute for the subtraction operator when instantiating a <xref:System.Numerics.BigInteger> variable by assigning it the difference that results from subtraction, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee96c-1571"><see cref="T:System.Numerics.BigInteger" /> 값을 바이트 배열로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1571">Converts a <see cref="T:System.Numerics.BigInteger" /> value to a byte array.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1572">현재 <see cref="T:System.Numerics.BigInteger" /> 개체를 바이트 배열로 변환한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1572">The value of the current <see cref="T:System.Numerics.BigInteger" /> object converted to an array of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1573">이 메서드에서 반환 된 배열의 각 바이트는 little endian 순서로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1573">The individual bytes in the array returned by this method appear in little-endian order.</span></span> <span data-ttu-id="ee96c-1574">즉, 값의 낮은 순서 바이트 고차 바이트 앞에 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1574">That is, the lower-order bytes of the value precede the higher-order bytes.</span></span> <span data-ttu-id="ee96c-1575">배열의 첫 번째 바이트의 처음 8 비트를 반영 합니다 <xref:System.Numerics.BigInteger> 다음 8 비트를 등에 값, 두 번째 바이트를 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1575">The first byte of the array reflects the first eight bits of the <xref:System.Numerics.BigInteger> value, the second byte reflects the next eight bits, and so on.</span></span> <span data-ttu-id="ee96c-1576">예를 들어, 1024, 값 또는 0x0400에는 다음 2 바이트 배열로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1576">For example, the value 1024, or 0x0400, is stored as the following array of two bytes:</span></span>  
  
|<span data-ttu-id="ee96c-1577">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1577">Element</span></span>|<span data-ttu-id="ee96c-1578">바이트 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-1578">Byte value</span></span>|  
|-------------|----------------|  
|<span data-ttu-id="ee96c-1579">0</span><span class="sxs-lookup"><span data-stu-id="ee96c-1579">0</span></span>|<span data-ttu-id="ee96c-1580">0x00</span><span class="sxs-lookup"><span data-stu-id="ee96c-1580">0x00</span></span>|  
|<span data-ttu-id="ee96c-1581">1</span><span class="sxs-lookup"><span data-stu-id="ee96c-1581">1</span></span>|<span data-ttu-id="ee96c-1582">0x04</span><span class="sxs-lookup"><span data-stu-id="ee96c-1582">0x04</span></span>|  
  
 <span data-ttu-id="ee96c-1583">음수 값은 2의 보수 표현이 가장 간단한 가능한 폼에서 사용 하 여 배열에 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1583">Negative values are written to the array using two's complement representation in the most compact form possible.</span></span> <span data-ttu-id="ee96c-1584">예를 들어,-1은 값이 단일 바이트도 표시 됩니다 `0xFF` 대신 여러 요소가 있는 배열로 같은 `0xFF`, `0xFF` 또는 `0xFF`, `0xFF`를 `0xFF`, `0xFF`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1584">For example, -1 is represented as a single byte whose value is `0xFF` instead of as an array with multiple elements, such as `0xFF`, `0xFF` or `0xFF`, `0xFF`, `0xFF`, `0xFF`.</span></span>  
  
 <span data-ttu-id="ee96c-1585">2의 보수 표현이 항상 때문에 해석 마지막 바이트 배열에서 가장 높은 순위의 비트 (위치의 바이트 <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) 부호 비트로 메서드는 값이 0 인 추가 요소를 사용 하 여 바이트 배열을 반환 하려면 설정 하 여 기호 비트를 가진 것으로 해석 될 수도 있는 양수 값을 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1585">Because two's complement representation always interprets the highest-order bit of the last byte in the array (the byte at position <xref:System.Array.Length%2A?displayProperty=nameWithType>`- 1`) as the sign bit, the method returns a byte array with an extra element whose value is zero to disambiguate positive values that could otherwise be interpreted as having their sign bits set.</span></span> <span data-ttu-id="ee96c-1586">예를 들어 값이 120 또는 `0x78` 단일 바이트 배열로 표시 됩니다: `0x78`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1586">For example, the value 120 or `0x78` is represented as a single-byte array: `0x78`.</span></span> <span data-ttu-id="ee96c-1587">그러나 128, 또는 `0x80`, 2 바이트 배열로 표시 됩니다: `0x80`, `0x00`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1587">However, 128, or `0x80`, is represented as a two-byte array: `0x80`, `0x00`.</span></span>  
  
 <span data-ttu-id="ee96c-1588">왕복할 수 있습니다는 <xref:System.Numerics.BigInteger> 를 사용 하 여 다음 복원 하는 바이트 배열에 저장 하 여 값을 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1588">You can round-trip a <xref:System.Numerics.BigInteger> value by storing it to a byte array and then restoring it using the <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ee96c-1589">코드 값을 복원 하기 전에이 메서드에서 반환 된 배열의 각 바이트의 값을 수정 해야 부호 비트 실수로 변경 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1589">If your code modifies the value of individual bytes in the array returned by this method before it restores the value, you must make sure that you do not unintentionally change the sign bit.</span></span> <span data-ttu-id="ee96c-1590">예를 들어 가장 높은 순위의 비트 바이트 배열의 마지막 요소에는 양수 값을 늘리면 됩니다 설정 값이 배열의 끝에 0 인 새 바이트를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1590">For example, if your modifications increase a positive value so that the highest-order bit in the last element of the byte array becomes set, you can add a new byte whose value is zero to the end of the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1591">다음 예제에서는 몇 가지 방법을 보여 줍니다 <xref:System.Numerics.BigInteger> 바이트 배열에 값 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1591">The following example illustrates how some <xref:System.Numerics.BigInteger> values are represented in byte arrays.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-1592">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1592">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ee96c-1593">현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1593">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1594">현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1594">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1595"><xref:System.Numerics.BigInteger.ToString> 메서드 형식을 <xref:System.Numerics.BigInteger> 값 "R" 또는 왕복을 현재 문화권의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1595">The <xref:System.Numerics.BigInteger.ToString> method formats a <xref:System.Numerics.BigInteger> value in the "R", or round-trip, format of the current culture.</span></span> <span data-ttu-id="ee96c-1596">다른 형식으로 또는 문화권을 지정 하려는 경우 사용 하 여 다른 오버 로드는 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 다음과 같이:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1596">If you want to specify a different format or culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="ee96c-1597">형식을 사용 하려면</span><span class="sxs-lookup"><span data-stu-id="ee96c-1597">To use format</span></span>|<span data-ttu-id="ee96c-1598">문화권에 대 한</span><span class="sxs-lookup"><span data-stu-id="ee96c-1598">For culture</span></span>|<span data-ttu-id="ee96c-1599">오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1599">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="ee96c-1600">Round-trip ("R") 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1600">Round-trip ("R") format</span></span>|<span data-ttu-id="ee96c-1601">특정 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1601">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%2A>|  
|<span data-ttu-id="ee96c-1602">특정 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1602">A specific format</span></span>|<span data-ttu-id="ee96c-1603">기본 (현재) 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1603">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|<span data-ttu-id="ee96c-1604">특정 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1604">A specific format</span></span>|<span data-ttu-id="ee96c-1605">특정 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1605">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="ee96c-1606">문자열 표현 된 <xref:System.Numerics.BigInteger> 값 앞에 오는 0 없이 0에서 9 까지의 숫자 시퀀스와 음수 값이 음수 기호가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1606">The string representation of the <xref:System.Numerics.BigInteger> value includes a negative sign if its value is negative, and a sequence of digits ranging from 0 to 9 without leading zeros.</span></span> <span data-ttu-id="ee96c-1607">음수 기호를 정의한는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1607">The negative sign is defined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1608">다음 예제에서는 표시 된 <xref:System.Numerics.BigInteger> 기본값을 사용 하 여 값 <xref:System.Numerics.BigInteger.ToString> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1608">The following example displays a <xref:System.Numerics.BigInteger> value by using the default <xref:System.Numerics.BigInteger.ToString> method.</span></span> <span data-ttu-id="ee96c-1609">또한의 문자열 표현을 표시 합니다 <xref:System.Numerics.BigInteger> 일부 표준 서식 지정자를 사용 하 여 얻은 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1609">It also displays the string representations of the <xref:System.Numerics.BigInteger> value that results from using some standard format specifiers.</span></span> <span data-ttu-id="ee96c-1610">예제에서는 EN-US 문화권의 서식 규칙을 사용 하 여 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1610">The examples are displayed using the formatting conventions of the en-US culture.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ee96c-1611">표준 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-1611">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ee96c-1612">사용자 지정 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-1612">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="ee96c-1613">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1613">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ee96c-1614">지정된 문화권별 서식 지정 정보를 사용하여 현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1614">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1615"><paramref name="provider" /> 매개 변수로 지정된 서식에 따른 현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1615">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="provider" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1616">합니다 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> 메서드 형식을 <xref:System.Numerics.BigInteger> 값 "R" 또는 왕복에서 사용 하 여 서식을 <xref:System.Globalization.NumberFormatInfo> 지정된 된 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1616">The <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> method formats a <xref:System.Numerics.BigInteger> value in the "R", or round-trip, format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture.</span></span> <span data-ttu-id="ee96c-1617">다른 오버 로드를 사용 하 여 현재 문화권 또는 다른 형식으로 지정 하려는 경우를 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 다음과 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1617">If you want to specify a different format or the current culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="ee96c-1618">형식을 사용 하려면</span><span class="sxs-lookup"><span data-stu-id="ee96c-1618">To use format</span></span>|<span data-ttu-id="ee96c-1619">문화권에 대 한</span><span class="sxs-lookup"><span data-stu-id="ee96c-1619">For culture</span></span>|<span data-ttu-id="ee96c-1620">오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1620">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="ee96c-1621">Round-trip ("R") 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1621">Round-trip ("R") format</span></span>|<span data-ttu-id="ee96c-1622">기본 (현재) 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1622">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="ee96c-1623">특정 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1623">A specific format</span></span>|<span data-ttu-id="ee96c-1624">기본 (현재) 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1624">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|<span data-ttu-id="ee96c-1625">특정 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1625">A specific format</span></span>|<span data-ttu-id="ee96c-1626">특정 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1626">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="ee96c-1627">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1627">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="ee96c-1628">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 이 메서드에서 반환 된 문자열의 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1628">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string returned by this method.</span></span> <span data-ttu-id="ee96c-1629">경우 `provider` 됩니다 `null`의 <xref:System.Numerics.BigInteger> 값을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1629">If `provider` is `null`, the <xref:System.Numerics.BigInteger> value is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span> <span data-ttu-id="ee96c-1630">유일한 속성을 <xref:System.Globalization.NumberFormatInfo> 의 문자열 표현을 제어 하는 개체를 <xref:System.Numerics.BigInteger> 일반 서식 지정자를 사용 하 여 값이 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, 음수 기호를 나타내는 문자를 정의 하는.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1630">The only property of the <xref:System.Globalization.NumberFormatInfo> object that controls the string representation of the <xref:System.Numerics.BigInteger> value using the general format specifier is <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, which defines the character that represents the negative sign.</span></span>  
  
 <span data-ttu-id="ee96c-1631">`provider` 매개 변수는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1631">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="ee96c-1632"><xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1632">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="ee96c-1633"><xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1633">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="ee96c-1634">구현 하는 사용자 지정 개체 <xref:System.IFormatProvider>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1634">A custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="ee96c-1635">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1635">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1636">다음 예제에서는 사용자 지정을 인스턴스화하고 <xref:System.Globalization.NumberFormatInfo> 음수 부호로 물결표 (~)를 정의 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1636">The following example instantiates a custom <xref:System.Globalization.NumberFormatInfo> object that defines the tilde (~) as a negative sign.</span></span> <span data-ttu-id="ee96c-1637">합니다 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> 메서드 사용 하 여 사용자 지정 <xref:System.Globalization.NumberFormatInfo> 음수를 표시할 개체 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1637">The <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> method then uses the custom <xref:System.Globalization.NumberFormatInfo> object to display a negative <xref:System.Numerics.BigInteger> value.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ee96c-1638">표준 또는 사용자 지정 숫자 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1638">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="ee96c-1639">지정된 서식을 사용하여 현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1639">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1640"><paramref name="format" /> 매개 변수로 지정된 서식에 따른 현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1640">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value in the format specified by the <paramref name="format" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1641">합니다 <xref:System.Numerics.BigInteger.ToString%28System.String%29> 메서드 형식을 <xref:System.Numerics.BigInteger> 사용 하 여 지정 된 형식으로 값을 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 규칙을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1641">The <xref:System.Numerics.BigInteger.ToString%28System.String%29> method formats a <xref:System.Numerics.BigInteger> value in a specified format by using a <xref:System.Globalization.NumberFormatInfo> object that represents the conventions of the current culture.</span></span> <span data-ttu-id="ee96c-1642">"R" 또는 라운드트립 사용 하려는 경우 형식 또는 다른 문화권을 지정, 다른 오버 로드를 사용 하 여는 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 다음과 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1642">If you want to use the "R", or round-trip, format or specify a different culture, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="ee96c-1643">형식을 사용 하려면</span><span class="sxs-lookup"><span data-stu-id="ee96c-1643">To use format</span></span>|<span data-ttu-id="ee96c-1644">문화권에 대 한</span><span class="sxs-lookup"><span data-stu-id="ee96c-1644">For culture</span></span>|<span data-ttu-id="ee96c-1645">오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1645">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="ee96c-1646">Round-trip ("R") 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1646">Round-trip ("R") format</span></span>|<span data-ttu-id="ee96c-1647">기본 (현재) 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1647">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="ee96c-1648">Round-trip ("R") 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1648">Round-trip ("R") format</span></span>|<span data-ttu-id="ee96c-1649">특정 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1649">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|<span data-ttu-id="ee96c-1650">특정 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1650">A specific format</span></span>|<span data-ttu-id="ee96c-1651">특정 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1651">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 <span data-ttu-id="ee96c-1652">`format` 매개 변수는 유효한 수 있습니다 [표준 숫자 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md), 또는의 임의 조합 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1652">The `format` parameter can be any valid [standard numeric string](~/docs/standard/base-types/standard-numeric-format-strings.md), or any combination of [custom numeric format strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="ee96c-1653">경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 현재의 반환 값 <xref:System.Numerics.BigInteger> 개체 라운드트립 서식 지정자 ("R")로 포맷 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1653">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the return value of the current <xref:System.Numerics.BigInteger> object is formatted with the round-trip format specifier ("R").</span></span> <span data-ttu-id="ee96c-1654">하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1654">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="ee96c-1655">다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1655">The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</span></span>  
  
-   <span data-ttu-id="ee96c-1656">숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1656">For more information about numeric format specifiers, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ee96c-1657">.NET Framework의 서식 지정에 대 한 지원에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1657">For more information about support for formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="ee96c-1658">반환된 된 문자열의 형식은 의해 결정 되는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1658">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="ee96c-1659">에 따라는 `format` 매개 변수를이 개체는 출력 문자열에 소수점 기호가 음수 기호, 그룹 구분 기호 등 기호를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1659">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="ee96c-1660">현재 문화권이 아닌 문화권에 대 한 서식 지정 정보를 제공 하려면 호출을 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1660">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1661">다음 예제에서는 초기화를 <xref:System.Numerics.BigInteger> 값 및 각 표준 형식 문자열 및 일부 사용자 지정 형식 문자열을 사용 하 여 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1661">The following example initializes a <xref:System.Numerics.BigInteger> value and displays it by using each standard format string and some custom format strings.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ee96c-1662"><paramref name="format" />은 유효한 서식 문자열이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1662"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ee96c-1663">표준 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-1663">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ee96c-1664">사용자 지정 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-1664">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="ee96c-1665">표준 또는 사용자 지정 숫자 서식 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1665">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="ee96c-1666">문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1666">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="ee96c-1667">지정된 형식 및 문화권별 형식 정보를 사용하여 현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당 문자열 표현으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1667">Converts the numeric value of the current <see cref="T:System.Numerics.BigInteger" /> object to its equivalent string representation by using the specified format and culture-specific format information.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1668"><paramref name="format" /> 및 <paramref name="provider" /> 매개 변수로 지정된 현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1668">The string representation of the current <see cref="T:System.Numerics.BigInteger" /> value as specified by the <paramref name="format" /> and <paramref name="provider" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1669"><xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드 형식을 <xref:System.Numerics.BigInteger> 를 사용 하 여 지정 된 형식으로 값을 <xref:System.Globalization.NumberFormatInfo> 지정된 된 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1669">The <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method formats a <xref:System.Numerics.BigInteger> value in a specified format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture.</span></span> <span data-ttu-id="ee96c-1670">다른 오버 로드를 사용 하 여 라운드 트립 형식 또는 기본 문화권 설정을 사용 하려는 경우는 <xref:System.Numerics.BigInteger.ToString%2A> 같이 메서드:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1670">If you want to use the round-trip format or default culture settings, use the other overloads of the <xref:System.Numerics.BigInteger.ToString%2A> method, as follows:</span></span>  
  
|<span data-ttu-id="ee96c-1671">형식을 사용 하려면</span><span class="sxs-lookup"><span data-stu-id="ee96c-1671">To use format</span></span>|<span data-ttu-id="ee96c-1672">문화권에 대 한</span><span class="sxs-lookup"><span data-stu-id="ee96c-1672">For culture</span></span>|<span data-ttu-id="ee96c-1673">오버 로드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1673">Use the overload</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="ee96c-1674">Round-trip ("R") 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1674">Round-trip ("R") format</span></span>|<span data-ttu-id="ee96c-1675">기본 (현재) 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1675">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString>|  
|<span data-ttu-id="ee96c-1676">Round-trip ("R") 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1676">Round-trip ("R") format</span></span>|<span data-ttu-id="ee96c-1677">특정 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1677">A specific culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|<span data-ttu-id="ee96c-1678">특정 형식</span><span class="sxs-lookup"><span data-stu-id="ee96c-1678">A specific format</span></span>|<span data-ttu-id="ee96c-1679">기본 (현재) 문화권</span><span class="sxs-lookup"><span data-stu-id="ee96c-1679">Default (current) culture</span></span>|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 <span data-ttu-id="ee96c-1680">`format` 매개 변수는 유효한 수 있습니다 [표준 숫자 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md), 또는의 임의 조합 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1680">The `format` parameter can be any valid  [standard numeric string](~/docs/standard/base-types/standard-numeric-format-strings.md), or any combination of [custom numeric format strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="ee96c-1681">경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 현재의 반환 값 <xref:System.Numerics.BigInteger> 개체 라운드트립 서식 지정자 ("R")로 포맷 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1681">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the return value of the current <xref:System.Numerics.BigInteger> object is formatted with the round-trip format specifier ("R").</span></span> <span data-ttu-id="ee96c-1682">하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1682">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="ee96c-1683">다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1683">The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</span></span>  
  
-   <span data-ttu-id="ee96c-1684">숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1684">For more information about numeric format specifiers, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="ee96c-1685">.NET Framework의 서식 지정에 대 한 지원에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1685">For more information about support for formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="ee96c-1686">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1686">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="ee96c-1687">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 이 메서드에서 반환 된 문자열의 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1687">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string returned by this method.</span></span> <span data-ttu-id="ee96c-1688">경우는 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드가 호출 되 면 호출를 `provider` 매개 변수의 <xref:System.IFormatProvider.GetFormat%2A> 메서드 전달를 <xref:System.Type> 나타내는 개체를 <xref:System.Globalization.NumberFormatInfo> 형식.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1688">When the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method is invoked, it calls the `provider` parameter's <xref:System.IFormatProvider.GetFormat%2A> method and passes it a <xref:System.Type> object that represents the <xref:System.Globalization.NumberFormatInfo> type.</span></span> <span data-ttu-id="ee96c-1689"><xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 됩니다 합니다 <xref:System.Globalization.NumberFormatInfo> 서식 지정에 대 한 정보를 제공 하는 개체는 `value` 소수점 기호가 음수 기호, 그룹 구분 기호 등의 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1689">The <xref:System.IFormatProvider.GetFormat%2A> method then returns the <xref:System.Globalization.NumberFormatInfo> object that provides information for formatting the `value` parameter, such as the negative sign symbol, the group separator symbol, or the decimal point symbol.</span></span> <span data-ttu-id="ee96c-1690">세 가지 방법으로 사용 하는 `provider` 매개 변수 형식 지정 정보를 제공 하기는 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드:</span><span class="sxs-lookup"><span data-stu-id="ee96c-1690">There are three ways to use the `provider` parameter to supply formatting information to the <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> method:</span></span>  
  
-   <span data-ttu-id="ee96c-1691">전달할 수는 <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1691">You can pass a <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="ee96c-1692">해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 문화권에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1692">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="ee96c-1693">실제 전달할 수 있습니다 <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1693">You can pass the actual <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="ee96c-1694">(해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1694">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="ee96c-1695">구현 하는 사용자 지정 개체를 전달할 수 있습니다 <xref:System.IFormatProvider>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1695">You can pass a custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="ee96c-1696">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1696">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="ee96c-1697">경우 `provider` 됩니다 `null`를 기반으로 반환된 된 문자열의 서식을 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1697">If `provider` is `null`, the formatting of the returned string is based on the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1698">다음 예제에서는 초기화 된 <xref:System.Numerics.BigInteger> 값을 표준 형식 문자열을 사용 하 여 콘솔에 표시 및 <xref:System.Globalization.NumberFormatInfo> 음수 부호로 물결표 (~)를 정의 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1698">The following example initializes a <xref:System.Numerics.BigInteger> value, and displays it to the console using a standard format string and a <xref:System.Globalization.NumberFormatInfo> object that defines the tilde (~) as a negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="ee96c-1699"><paramref name="format" />은 유효한 서식 문자열이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1699"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="ee96c-1700">표준 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-1700">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="ee96c-1701">사용자 지정 숫자 형식 문자열</span><span class="sxs-lookup"><span data-stu-id="ee96c-1701">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ee96c-1702">숫자의 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환하고, 변환에 성공했는지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1702">Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1703">숫자의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1703">The string representation of a number.</span></span></param>
        <param name="result"><span data-ttu-id="ee96c-1704">이 메서드가 반환되면 <paramref name="value" />에 포함된 숫자 또는 변환에 실패한 경우 0에 해당하는 <see cref="T:System.Numerics.BigInteger" />를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1704">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <paramref name="value" />, or zero (0) if the conversion fails.</span></span> <span data-ttu-id="ee96c-1705"><paramref name="value" /> 매개 변수가 <see langword="null" />이거나 올바른 서식이 아니면 변환에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1705">The conversion fails if the <paramref name="value" /> parameter is <see langword="null" /> or is not of the correct format.</span></span> <span data-ttu-id="ee96c-1706">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1706">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="ee96c-1707">숫자의 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환하고, 변환에 성공했는지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1707">Tries to convert the string representation of a number to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1708"><see langword="true" />가 성공적으로 변환되었으면 <paramref name="value" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1708"><see langword="true" /> if <paramref name="value" /> was converted successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1709">합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> 메서드와 비슷합니다는 <xref:System.Numerics.BigInteger.Parse%28System.String%29> 메서드와 변환에 실패 하면 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1709">The <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> method is like the <xref:System.Numerics.BigInteger.Parse%28System.String%29> method, except that it does not throw an exception if the conversion fails.</span></span> <span data-ttu-id="ee96c-1710">이 메서드는 테스트 하기 위해 예외 처리를 사용할 필요가 없습니다를 <xref:System.FormatException> 경우 `value` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1710">This method eliminates the need to use exception handling to test for a <xref:System.FormatException> if `value` is invalid and cannot be successfully parsed.</span></span>  
  
 <span data-ttu-id="ee96c-1711">`value` 매개 변수 형식은 10 진수 숫자의 문자열 표현 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1711">The `value` parameter should be the string representation of a decimal number in the following form:</span></span>  
  
 <span data-ttu-id="ee96c-1712">[*ws*][*sign*]*digits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1712">[*ws*][*sign*]*digits*[*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1713">대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1713">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="ee96c-1714">다음 표에서는 각 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1714">The following table describes each element.</span></span>  
  
|<span data-ttu-id="ee96c-1715">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1715">Element</span></span>|<span data-ttu-id="ee96c-1716">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1716">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ee96c-1717">*ws*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1717">*ws*</span></span>|<span data-ttu-id="ee96c-1718">선택적 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1718">Optional white space.</span></span>|  
|<span data-ttu-id="ee96c-1719">*sign*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1719">*sign*</span></span>|<span data-ttu-id="ee96c-1720">가 선택적 부호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1720">An optional sign.</span></span> <span data-ttu-id="ee96c-1721">유효한 부호 문자는 기준 합니다 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1721">Valid sign characters are determined by the <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> properties of the current culture.</span></span>|  
|<span data-ttu-id="ee96c-1722">*digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1722">*digits*</span></span>|<span data-ttu-id="ee96c-1723">0에서 9 까지의 10 진수 시퀀스로,</span><span class="sxs-lookup"><span data-stu-id="ee96c-1723">A sequence of decimal digits ranging from 0 to 9.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1724">지정 된 문자열을 `value` 매개 변수는 그룹 구분 기호 또는 소수 구분 기호를 포함할 수 없습니다 및 소수 부분이 가질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1724">The string specified by the `value` parameter cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</span></span>  
  
 <span data-ttu-id="ee96c-1725">합니다 `value` 매개 변수를 사용 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1725">The `value` parameter is interpreted by using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style.</span></span> <span data-ttu-id="ee96c-1726">10 진수 외에도 선행 및 후행 공백을 앞에 부호가 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1726">In addition to the decimal digits, only leading and trailing spaces with a leading sign are allowed.</span></span> <span data-ttu-id="ee96c-1727">사용할 수 있는 culture 별 서식 지정 정보를 사용 하 여 스타일 요소를 명시적으로 정의 하려면 `value`를 호출 합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1727">To explicitly define the style elements with the culture-specific formatting information that can be present in `value`, call the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method.</span></span>  
  
 <span data-ttu-id="ee96c-1728">합니다 `value` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1728">The `value` parameter is parsed by using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="ee96c-1729">자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1729">For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ee96c-1730">모든 숫자를 해석 하는이 오버 로드는 `value` 소수 자릿수 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1730">This overload interprets all digits in the `value` parameter as decimal digits.</span></span> <span data-ttu-id="ee96c-1731">16 진수 숫자의 문자열 표현으로 구문 분석 하려면 호출을 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 오버 로드를 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1731">To parse the string representation of a hexadecimal number, call the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> overload instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1732">다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> 메서드를 두 <xref:System.Numerics.BigInteger> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1732">The following example uses the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> method to instantiate two <xref:System.Numerics.BigInteger> objects.</span></span> <span data-ttu-id="ee96c-1733">각 개체는 다른 수를 곱하고 그 다음 변환이 성공할 경우는 <xref:System.Numerics.BigInteger.Compare%2A> 두 개체 간의 관계를 확인 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1733">If the conversions succeed, it multiplies each object by another number and then calls the <xref:System.Numerics.BigInteger.Compare%2A> method to determine the relationship between the two objects.</span></span>  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ee96c-1734"><paramref name="value" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="ee96c-1734"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ee96c-1735">숫자의 문자열 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1735">The string representation of a number.</span></span> <span data-ttu-id="ee96c-1736">이 문자열은 <paramref name="style" />이 지정하는 스타일을 사용하여 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1736">The string is interpreted using the style specified by <paramref name="style" />.</span></span></param>
        <param name="style"><span data-ttu-id="ee96c-1737"><paramref name="value" />에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1737">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="value" />.</span></span> <span data-ttu-id="ee96c-1738">지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.Integer" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1738">A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</span></span></param>
        <param name="provider"><span data-ttu-id="ee96c-1739"><paramref name="value" />에 대한 문화권별 서식 지정 정보를 제공하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1739">An object that supplies culture-specific formatting information about <paramref name="value" />.</span></span></param>
        <param name="result"><span data-ttu-id="ee96c-1740">이 메서드가 반환되면 <paramref name="value" />에 포함된 숫자 또는 변환에 실패한 경우 <see cref="T:System.Numerics.BigInteger" />에 해당하는 <see cref="P:System.Numerics.BigInteger.Zero" />를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1740">When this method returns, contains the <see cref="T:System.Numerics.BigInteger" /> equivalent to the number that is contained in <paramref name="value" />, or <see cref="P:System.Numerics.BigInteger.Zero" /> if the conversion failed.</span></span> <span data-ttu-id="ee96c-1741"><paramref name="value" /> 매개 변수가 <see langword="null" />이거나 <paramref name="style" />과 호환되지 않는 서식으로 되어 있으면 변환에 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1741">The conversion fails if the <paramref name="value" /> parameter is <see langword="null" /> or is not in a format that is compliant with <paramref name="style" />.</span></span> <span data-ttu-id="ee96c-1742">이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1742">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="ee96c-1743">지정된 문화권별 형식과 지정된 스타일을 사용한 숫자의 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환해 보고, 변환에 성공했는지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1743">Tries to convert the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Numerics.BigInteger" /> equivalent, and returns a value that indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="ee96c-1744"><see langword="true" /> 매개 변수가 변환되었으면 <paramref name="value" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1744"><see langword="true" /> if the <paramref name="value" /> parameter was converted successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1745">합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 메서드와 비슷합니다는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드와 변환에 실패 하면 예외를 throw 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1745">The <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method is like the <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> method, except that it does not throw an exception if the conversion fails.</span></span> <span data-ttu-id="ee96c-1746">이 메서드는 테스트 하기 위해 예외 처리를 사용할 필요가 없습니다를 <xref:System.FormatException> 경우 `value` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1746">This method eliminates the need to use exception handling to test for a <xref:System.FormatException> if `value` is invalid and cannot be parsed successfully.</span></span>  
  
 <span data-ttu-id="ee96c-1747">합니다 `style` 매개 변수 (예: 공백 또는 양수 또는 음수 기호)에 사용할 수 있는 스타일 요소를 정의 합니다 `value` 구문 분석 작업이 성공 하기 위해 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1747">The `style` parameter defines the style elements (such as white space or a positive or negative sign) that are allowed in the `value` parameter for the parse operation to succeed.</span></span> <span data-ttu-id="ee96c-1748">비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1748">It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration.</span></span> <span data-ttu-id="ee96c-1749">값에 따라 `style`, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1749">Depending on the value of `style`, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="ee96c-1750">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1750">[*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1751">경우는 `style` 매개 변수 포함 <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1751">If the `style` parameter includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, the `value` parameter may include the following elements:</span></span>  
  
 <span data-ttu-id="ee96c-1752">[*ws*]*hexdigits*[*ws*]</span><span class="sxs-lookup"><span data-stu-id="ee96c-1752">[*ws*]*hexdigits*[*ws*]</span></span>  
  
 <span data-ttu-id="ee96c-1753">대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1753">Elements in square brackets ([ and ]) are optional.</span></span> <span data-ttu-id="ee96c-1754">다음 표에서는 각 요소에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1754">The following table describes each element.</span></span>  
  
|<span data-ttu-id="ee96c-1755">요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1755">Element</span></span>|<span data-ttu-id="ee96c-1756">설명</span><span class="sxs-lookup"><span data-stu-id="ee96c-1756">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ee96c-1757">*ws*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1757">*ws*</span></span>|<span data-ttu-id="ee96c-1758">선택적 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1758">Optional white space.</span></span> <span data-ttu-id="ee96c-1759">공백의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 플래그를 또는 끝에 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1759">White space can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.</span></span>|  
|*$*|<span data-ttu-id="ee96c-1760">Culture 별 통화 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1760">A culture-specific currency symbol.</span></span> <span data-ttu-id="ee96c-1761">문자열의 해당 위치에서 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> 의 속성을 <xref:System.Globalization.NumberFormatInfo> 에서 반환 된 개체를 <xref:System.IFormatProvider.GetFormat%2A> 메서드의 `provider` 매개 변수.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1761">Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter.</span></span> <span data-ttu-id="ee96c-1762">통화 기호에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1762">The currency symbol can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1763">*sign*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1763">*sign*</span></span>|<span data-ttu-id="ee96c-1764">가 선택적 부호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1764">An optional sign.</span></span> <span data-ttu-id="ee96c-1765">로그인의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1765">The sign can appear at the start of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="ee96c-1766">괄호를 사용할 수 있습니다 `value` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1766">Parentheses can be used in `value` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1767">*digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1767">*digits*</span></span>|<span data-ttu-id="ee96c-1768">0부터 9 까지의 숫자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1768">A sequence of digits from 0 through 9.</span></span>|  
|<span data-ttu-id="ee96c-1769">*,*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1769">*,*</span></span>|<span data-ttu-id="ee96c-1770">Culture 별 그룹 구분 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1770">A culture-specific group separator.</span></span> <span data-ttu-id="ee96c-1771">에 지정 된 문화권의 그룹 구분 기호 `provider` 에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1771">The group separator of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1772">*.*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1772">*.*</span></span>|<span data-ttu-id="ee96c-1773">Culture 별 소수점 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1773">A culture-specific decimal point symbol.</span></span> <span data-ttu-id="ee96c-1774">에 지정 된 문화권의 소수점 기호가 `provider` 에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1774">The decimal point symbol of the culture specified by `provider` can appear in `value` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1775">*fractional_digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1775">*fractional_digits*</span></span>|<span data-ttu-id="ee96c-1776">숫자 0 개 이상의 발견 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1776">One or more occurrences of the digit 0.</span></span> <span data-ttu-id="ee96c-1777">소수 자릿수에 나타날 수 있습니다 `value` 경우에만 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1777">Fractional digits can appear in `value` only if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1778">E</span><span class="sxs-lookup"><span data-stu-id="ee96c-1778">E</span></span>|<span data-ttu-id="ee96c-1779">"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1779">The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</span></span> <span data-ttu-id="ee96c-1780">`value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1780">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1781">*exponential_digits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1781">*exponential_digits*</span></span>|<span data-ttu-id="ee96c-1782">0부터 9 까지의 숫자 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1782">A sequence of digits from 0 through 9.</span></span> <span data-ttu-id="ee96c-1783">`value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1783">The `value` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.</span></span>|  
|<span data-ttu-id="ee96c-1784">*hexdigits*</span><span class="sxs-lookup"><span data-stu-id="ee96c-1784">*hexdigits*</span></span>|<span data-ttu-id="ee96c-1785">16 진수 숫자 0 ~ f 또는 0 ~ 6. 시퀀스</span><span class="sxs-lookup"><span data-stu-id="ee96c-1785">A sequence of hexadecimal digits from 0 through f, or 0 through F.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="ee96c-1786">종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1786">Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.</span></span>

 <span data-ttu-id="ee96c-1787">진수만 포함 된 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 플래그) 항상 성공적으로 구문 분석 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1787">A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flag) always parses successfully.</span></span> <span data-ttu-id="ee96c-1788">나머지 대부분 <xref:System.Globalization.NumberStyles> 멤버 있을 수 있지만 하지 않아도이 입력된 문자열에 나타날 수 있는 요소를 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1788">Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be present, but are not required to be present, in this input string.</span></span> <span data-ttu-id="ee96c-1789">다음 표에서 개별 <xref:System.Globalization.NumberStyles> 멤버에 나타날 수 있는 요소에 영향을 줄 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1789">The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `value`.</span></span>  
  
|<span data-ttu-id="ee96c-1790">비 복합 `NumberStyles` 값</span><span class="sxs-lookup"><span data-stu-id="ee96c-1790">Non-composite `NumberStyles` values</span></span>|<span data-ttu-id="ee96c-1791">숫자 외에도 값에 허용 되는 요소</span><span class="sxs-lookup"><span data-stu-id="ee96c-1791">Elements permitted in value in addition to digits</span></span>|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|<span data-ttu-id="ee96c-1792">소수 자릿수에만 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1792">Decimal digits only.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|<span data-ttu-id="ee96c-1793">소수점 (*합니다.*) 및 *소수 자릿수* 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1793">The decimal point (*.*) and *fractional_digits* elements.</span></span> <span data-ttu-id="ee96c-1794">그러나 *소수 자릿수* 하나 이상의 0 숫자 또는 메서드 반환으로 구성 되어야 합니다 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1794">However, *fractional_digits* must consist of only one or more 0 digits, or the method returns `false`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|<span data-ttu-id="ee96c-1795">"E" 또는 "E" 문자를 함께 지 수 표기법으로 나타냅니다 *지 수 표기법*합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1795">The "e" or "E" character, which indicates exponential notation, along with *exponential_digits*.</span></span> <span data-ttu-id="ee96c-1796">경우 `value` 숫자를 나타내는 지 수 표기법으로, 소수 자릿수 0이 아닌 구성 요소를 가질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1796">If `value` represents a number in exponential notation, it cannot have a non-zero, fractional component.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|<span data-ttu-id="ee96c-1797">합니다 *ws* 의 시작 부분에 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1797">The *ws* element at the start of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|<span data-ttu-id="ee96c-1798">합니다 *ws* 의 끝에 있는 요소 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1798">The *ws* element at the end of `value`.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|<span data-ttu-id="ee96c-1799">*sign* 앞에 요소 *자릿수*합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1799">The *sign* element before *digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|<span data-ttu-id="ee96c-1800">합니다 *기호* 요소 뒤 *자릿수*합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1800">The *sign* element after *digits*.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|<span data-ttu-id="ee96c-1801">합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1801">The *sign* element in the form of parentheses enclosing the numeric value.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|<span data-ttu-id="ee96c-1802">그룹 구분 기호 (*,*) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1802">The group separator (*,*) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|<span data-ttu-id="ee96c-1803">통화 (*$*) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1803">The currency (*$*) element.</span></span>|  
|<xref:System.Globalization.NumberStyles.Currency>|<span data-ttu-id="ee96c-1804">모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1804">All elements.</span></span> <span data-ttu-id="ee96c-1805">그러나 `value` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1805">However, `value` cannot represent a hexadecimal number or a number in exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Float>|<span data-ttu-id="ee96c-1806">합니다 *ws* 시작 또는 끝에 요소 `value`, *로그인* 의 시작 부분에 `value`, 및 소수점 (*.*) 기호입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1806">The *ws* element at the start or end of `value`, *sign* at the start of `value`, and the decimal point (*.*) symbol.</span></span> <span data-ttu-id="ee96c-1807">`value` 매개 변수 지 수 표기법을 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1807">The `value` parameter can also use exponential notation.</span></span>|  
|<xref:System.Globalization.NumberStyles.Number>|<span data-ttu-id="ee96c-1808">*ws*, *로그인*, 그룹 구분 기호 (*,*), 소수점 및 (*.*) 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1808">The *ws*, *sign*, group separator (*,*), and decimal point (*.*) elements.</span></span>|  
|<xref:System.Globalization.NumberStyles.Any>|<span data-ttu-id="ee96c-1809">모든 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1809">All elements.</span></span> <span data-ttu-id="ee96c-1810">그러나 `value` 16 진수 숫자를 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1810">However, `value` cannot represent a hexadecimal number.</span></span>|  
  
> [!IMPORTANT]
>  <span data-ttu-id="ee96c-1811">사용 하는 경우는 <xref:System.Numerics.BigInteger.TryParse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1811">If you use the <xref:System.Numerics.BigInteger.TryParse%2A> method to round-trip the string representation of a <xref:System.Numerics.BigInteger> value that was output by the <xref:System.Numerics.BigInteger.ToString%2A> method, you should use the <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> method with the "R" format specifier to generate the string representation of the <xref:System.Numerics.BigInteger> value.</span></span> <span data-ttu-id="ee96c-1812">이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.TryParse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1812">Otherwise, the string representation of the <xref:System.Numerics.BigInteger> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <xref:System.Numerics.BigInteger.TryParse%2A> method to restore the <xref:System.Numerics.BigInteger> value.</span></span>  
  
 <span data-ttu-id="ee96c-1813">경우는 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 플래그를 사용할 `value` 16 진수 값 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1813">If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `value` must be a hexadecimal value.</span></span> <span data-ttu-id="ee96c-1814">만 다른 플래그에 있을 수 있는 `style` 됩니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 고 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1814">The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ee96c-1815">(합니다 <xref:System.Globalization.NumberStyles> 열거형에는 복합 스타일 인 <xref:System.Globalization.NumberStyles.HexNumber>, 모두 공백 플래그를 포함 하는.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1815">(The <xref:System.Globalization.NumberStyles> enumeration has a composite style, <xref:System.Globalization.NumberStyles.HexNumber>, that includes both white-space flags.)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ee96c-1816">하는 경우 `value` 문자열 표현인 16 진수 숫자의 고 수 없습니다. 뒤에 야 모든 장식 (같은 `0x` 또는 `&h`) 16 진수 숫자로 구분 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1816">If `value` is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as `0x` or `&h`) that differentiates it as a hexadecimal number.</span></span> <span data-ttu-id="ee96c-1817">이렇게 하면 변환이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1817">This causes the conversion to fail.</span></span>  
  
 <span data-ttu-id="ee96c-1818">경우 `value` 16 진수 문자열을 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 보다 크거나 같습니다 `value` 음수로 처음 두 16 진수 보다 크거나 같은 경우에 2의 보수 표현이 사용 하 여 저장 `0x80`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1818">If `value` is a hexadecimal string, the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method interprets `value` as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to `0x80`.</span></span> <span data-ttu-id="ee96c-1819">메서드는 첫 번째 바이트의 최상위 비트를 해석 하는 즉, `value` 부호 비트로입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1819">In other words, the method interprets the highest-order bit of the first byte in `value` as the sign bit.</span></span> <span data-ttu-id="ee96c-1820">16 진수 문자열에서 첫 번째 숫자가 양수 숫자로 해석 됩니다 있도록 `value` 0의 값이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1820">To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in `value` must have a value of zero.</span></span> <span data-ttu-id="ee96c-1821">예를 들어이 메서드는 해석 `0x80` 음수 값을 해석 하거나 대로 `0x080` 또는 `0x0080` 양수 값으로.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1821">For example, the method interprets `0x80` as a negative value, but it interprets either `0x080` or `0x0080` as a positive value.</span></span> <span data-ttu-id="ee96c-1822">다음 예에서는 양수 및 음수 값을 나타내는 16 진수 문자열 간의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1822">The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 <span data-ttu-id="ee96c-1823">합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1823">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="ee96c-1824">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 문화권별 형식 정보를 제공 하는 `value`합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1824">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of `value`.</span></span> <span data-ttu-id="ee96c-1825">`provider` 매개 변수는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1825">The `provider` parameter can be any one of the following:</span></span>  
  
-   <span data-ttu-id="ee96c-1826"><xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1826">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information.</span></span> <span data-ttu-id="ee96c-1827">해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 문화권에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1827">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information for that culture.</span></span>  
  
-   <span data-ttu-id="ee96c-1828"><xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1828">A <xref:System.Globalization.NumberFormatInfo> object that provides numeric formatting information.</span></span> <span data-ttu-id="ee96c-1829">(해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)</span><span class="sxs-lookup"><span data-stu-id="ee96c-1829">(Its implementation of <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> just returns itself.)</span></span>  
  
-   <span data-ttu-id="ee96c-1830">구현 하는 사용자 지정 개체 <xref:System.IFormatProvider>합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1830">A custom object that implements <xref:System.IFormatProvider>.</span></span> <span data-ttu-id="ee96c-1831">해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1831">Its <xref:System.IFormatProvider.GetFormat%2A> method instantiates and returns the <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.</span></span>  
  
 <span data-ttu-id="ee96c-1832">하는 경우 `provider` 됩니다 `null`는 <xref:System.Globalization.NumberFormatInfo> 개체가 현재 문화권이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1832">If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ee96c-1833">다음 예제에서는 일부 호출을 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 다양 한 조합에 대 한 값을 사용 하 여 메서드를 `style` 및 `provider` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1833">The following example makes some calls to the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method using various combinations of values for the `style` and `provider` parameters.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 <span data-ttu-id="ee96c-1834">에 대 한 개별 호출 수를 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 메서드는 다음의 인스턴스를 전달 `BigIntegerFormatProvider` 음수 부호와 물결표 (~)를 정의 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1834">A number of the individual calls to the <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> method pass an instance of the following `BigIntegerFormatProvider` class, which defines a tilde (~) as the negative sign.</span></span>  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ee96c-1835"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1835"><paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.</span></span>  
  
<span data-ttu-id="ee96c-1836">또는</span><span class="sxs-lookup"><span data-stu-id="ee96c-1836">-or-</span></span> 
 <span data-ttu-id="ee96c-1837"><paramref name="style" />에는 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 또는 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 플래그가 다른 값과 함께 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1837"><paramref name="style" /> includes the <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> or <see cref="F:System.Globalization.NumberStyles.HexNumber" /> flag along with another value.</span></span></exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ee96c-1838">숫자 0을 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1838">Gets a value that represents the number 0 (zero).</span></span></summary>
        <value><span data-ttu-id="ee96c-1839">값이 0인 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1839">An integer whose value is 0 (zero).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ee96c-1840"><xref:System.Numerics.BigInteger> 이 속성에 의해 반환 되는 개체 할당과 비교에 사용할 값이 0 이면의 편리한 원본을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ee96c-1840">The <xref:System.Numerics.BigInteger> object returned by this property provides a convenient source of a zero value for use in assignments and comparisons.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>