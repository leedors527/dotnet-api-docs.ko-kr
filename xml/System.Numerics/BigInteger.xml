<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="85a4380915d6023fb6b118226ee2acaef322ca38" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58710156" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>부호 있는 임의의 큰 정수를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> 형식은 이론상에서 값에 상한이 나 하 한 범위 없음 임의로 큰 정수를 나타내는 변경할 수 없는 형식입니다. 멤버는 <xref:System.Numerics.BigInteger> 형식에 다른 정수 계열 형식의 항목을 밀접 하 게 병렬 (합니다 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>를 <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, 및 <xref:System.UInt64> 형식). 이 형식에서 다른 정수 계열 형식에서 다른 합니다 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]에 표시 되는 범위를 포함 하는 해당 `MinValue` 및 `MaxValue` 속성입니다.  
  
> [!NOTE]
>  때문에 <xref:System.Numerics.BigInteger> 유형을 변경할 수 없는 (참조 [반복성 및 BigInteger 구조체](#mutability)) 및 상한 또는 하 한 범위 없음 있기 때문에 <xref:System.OutOfMemoryException> 시키는 모든 작업에 대해 throw 할 수 있습니다를 <xref:System.Numerics.BigInteger> 너무 증가 하는 값 큰 합니다.  
  
## <a name="instantiating-a-biginteger-object"></a>BigInteger 개체 인스턴스화  
 인스턴스화할 수 있습니다는 <xref:System.Numerics.BigInteger> 여러 가지 방법으로 개체:  
  
-   사용할 수는 `new` 키워드 정수 계열 또는 부동 소수점 값을 매개 변수로 제공 하 고는 <xref:System.Numerics.BigInteger> 생성자입니다. (부동 소수점 값을 할당 하기 전에 잘립니다는 <xref:System.Numerics.BigInteger>.) 다음 예제를 사용 하는 방법을 합니다 `new` 인스턴스화할 키워드 <xref:System.Numerics.BigInteger> 값입니다.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   선언할 수는 <xref:System.Numerics.BigInteger> 변수와 값 수는 해당 값이 정수 계열 형식으로 모든 숫자 유형 할당 합니다. 다음 예제에서는 할당을 사용 하 여 만들려는 <xref:System.Numerics.BigInteger> 에서 값을 <xref:System.Int64>입니다.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   10 진수 또는 부동 소수점 값을 할당할 수 있습니다는 <xref:System.Numerics.BigInteger> 개체 값을 캐스팅 또는 먼저 변환 하는 경우. 다음 예제에서는 명시적으로 캐스팅 (C#에서) 또는 변환 (Visual Basic)에서는 <xref:System.Double> 및 <xref:System.Decimal> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 이러한 메서드를 인스턴스화하는 데 사용 된 <xref:System.Numerics.BigInteger> 값인 하나의 기존 숫자 값의 범위 개체 형식 에서만. 인스턴스화할 수 있습니다는 <xref:System.Numerics.BigInteger> 개체 값을 갖는 세 가지 방법 중 하나에서 기존 숫자 형식의 범위를 초과할 수 있습니다.  
  
-   사용할 수는 `new` 키워드 수 있는 모든 크기의 바이트 배열을 제공 하 고는 <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> 생성자입니다. 예:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   호출할 수 있습니다 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 또는 <xref:System.Numerics.BigInteger.TryParse%2A> 숫자의 문자열 표현을 변환 하는 메서드를 <xref:System.Numerics.BigInteger>입니다. 예:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   호출할 수 있습니다는 `static` (`Shared` Visual Basic에서) <xref:System.Numerics.BigInteger> 숫자 식의 일부 작업을 수행 하 고 계산을 반환 하는 메서드 <xref:System.Numerics.BigInteger> 결과입니다. 다음 예제는이 큐브를 위해 <xref:System.UInt64.MaxValue?displayProperty=nameWithType> 결과를 할당 하 고는 <xref:System.Numerics.BigInteger>합니다.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 초기화 되지 않은 값을 <xref:System.Numerics.BigInteger> 는 <xref:System.Numerics.BigInteger.Zero%2A>합니다.  
  
## <a name="performing-operations-on-biginteger-values"></a>BigInteger 값에 대 한 작업을 수행합니다.  
 사용할 수는 <xref:System.Numerics.BigInteger> 다른 정수 계열 형식을 사용 하는 인스턴스. <xref:System.Numerics.BigInteger> 더하기, 빼기, 나누기, 곱하기, 빼기, 부정, 및 단항 부정 연산자와 같은 기본 수치 연산을 수행할 수 있도록 표준 숫자 연산자 오버 로드 합니다. 비교할 두 개의 표준 숫자 연산자를 사용할 수도 있습니다 <xref:System.Numerics.BigInteger> 서로 값입니다. 다른 정수 계열 형식과 마찬가지로 <xref:System.Numerics.BigInteger> 비트 지원 `And`를 `Or`, `XOr`, 왼쪽 시프트 및 오른쪽 시프트 연산자입니다. 사용자 지정 연산자를 지원 하지 않는 언어를 <xref:System.Numerics.BigInteger> 구조 수치 연산을 수행 하기 위한 동등한 메서드도 제공 합니다. 여기에 포함 됩니다 <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>를 <xref:System.Numerics.BigInteger.Multiply%2A>를 <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, 등입니다.  
  
 많은 멤버를 <xref:System.Numerics.BigInteger> 구조 다른 정수 계열 형식의 멤버에 직접 해당 합니다. 또한 <xref:System.Numerics.BigInteger> 다음과 같은 멤버를 추가 합니다.  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>에서의 부호를 나타내는 값을 반환 하는 <xref:System.Numerics.BigInteger> 값입니다.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>에서의 절대 값을 반환 하는 <xref:System.Numerics.BigInteger> 값입니다.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>몫과 나누기 연산의 나머지를 모두 반환 합니다.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>를 2의 최대 공약수를 반환 하는 <xref:System.Numerics.BigInteger> 값입니다.  
  
 멤버에 해당 하는 대부분의 이러한 추가 멤버를 <xref:System.Math> 기본 숫자 형식을 사용 하는 기능을 제공 하는 클래스입니다.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>반복성 및 BigInteger 구조체  
 다음 예제에서는 <xref:System.Numerics.BigInteger> 개체 및 해당 값 1 씩 증가 시킵니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 이 예제에서는 기존 개체의 값을 수정 하려면 나타나지만, 대/소문자 아닙니다. <xref:System.Numerics.BigInteger> 개체는, 즉 내부적으로, 공용 언어 런타임에서 실제로 새로 만들고 <xref:System.Numerics.BigInteger> 개체 및 이전 값 보다 하나 더 큰 값을 할당 합니다. 이 새 개체를 호출자에 게 반환 됩니다.  
  
> [!NOTE]
>  .NET Framework의 다른 숫자 형식도 변경할 수 없습니다. 그러나 때문에 <xref:System.Numerics.BigInteger> 형식은 상한 또는 하 한 범위 없음, 해당 값 매우 커질 및 성능에 크게 영향을 미칠 수 있습니다.  
  
 이 프로세스를 호출자에 게 투명 하지만 성능 저하를 유발 하지는 않습니다. 일부 경우에 특히 경우 반복된 작업은 수행 루프에서 매우 큰 <xref:System.Numerics.BigInteger> 값을 해당 성능이 중요할 수 있습니다. 예를 들어, 다음 예제에서 작업이 수행 되는 백만 번을 반복적으로 <xref:System.Numerics.BigInteger> 될 때마다 작업에 성공 하면 값이 1 씩 증가 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 이러한 경우에 대 한 모든 중간 할당을 수행 하 여 성능을 개선할 수 있습니다는 <xref:System.Int32> 변수입니다. 변수의 최종 값 다음 할당할 수는 <xref:System.Numerics.BigInteger> 루프 종료 될 때 개체입니다. 다음 예제에서 이에 대해 설명합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>16 진수 문자열과 바이트 배열 사용  
 변환 하는 경우 <xref:System.Numerics.BigInteger> 값을 바이트 배열로, 바이트 배열에 변환 하는 경우 또는 <xref:System.Numerics.BigInteger> 값을 바이트의 순서를 고려해 야 합니다. <xref:System.Numerics.BigInteger> 구조 little endian 순서로 표시할 바이트 배열에서 개별 바이트를 예상 합니다 (즉, 값의 낮은 순서 바이트 앞에 야 고차 바이트)입니다. 왕복할 수 있습니다는 <xref:System.Numerics.BigInteger> 호출 하 여 값을 <xref:System.Numerics.BigInteger.ToByteArray%2A> 메서드와 전달 결과 바이트 배열을 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 다음 예제와 같이 생성자.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 인스턴스화하는 <xref:System.Numerics.BigInteger> 값 다른 정수 계열 형식의 값을 나타내는 바이트 배열에서 정수 계열 값을 전달할 수 있습니다 합니다 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 메서드를 전달 하 고 결과 바이트 배열를 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자. 다음 예제에서는 한 <xref:System.Numerics.BigInteger> 나타내는 바이트 배열에서 값을 <xref:System.Int16> 값입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 <xref:System.Numerics.BigInteger> 구조 음수 값 2의 보수 표현을 사용 하 여 저장 된 있다고 가정 합니다. 때문에 <xref:System.Numerics.BigInteger> 구조에 없는 고정된 길이 숫자 값을 나타내는 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자에는 항상 가장 중요 한 비트를 부호 비트로 배열의 마지막 바이트의 해석 합니다. 방지 하기 위해는 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 2의 보수 표현한 음수 값을 양수 값 이면 양수의 크기와 부호가 표현으로 혼동의 생성자는 가장 값 비트가 바이트 배열에서 마지막 바이트 일반적으로 추가 바이트 값이 0 인 집합에 포함 되어야 합니다. 예를 들어 0xC0 0xBD 0xF0 0xFF-1,000,000 또는 4,293,967,296 little endian 16 진수 표현입니다. 바이트 배열의 값으로 해석이 배열의 마지막 바이트의 가장 중요 한 비트 이기 때문에 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> -1,000,000 생성자입니다. 인스턴스화하는 <xref:System.Numerics.BigInteger> 해당 값이 양수 이면 요소가 0xC0 바이트 배열 0xBD 0xF0 0xFF 0x00 생성자에 전달 해야 합니다. 다음은 이에 대한 예입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 생성 된 바이트 배열은 <xref:System.Numerics.BigInteger.ToByteArray%2A> 메서드에서 양수 값이 추가 0 값 바이트를 포함 합니다. 따라서는 <xref:System.Numerics.BigInteger> 구조를 할당 하 고 다음 예제와 같이 바이트 배열에서 복원 하 여 성공적으로 라운드트립 값 수입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 개발자가 동적으로 만들어지는 또는 부호 없는 정수를 바이트 배열로 변환 하는 메서드에서 반환 되는 바이트 배열에이 추가 값 0 바이트를 추가 해야 하는 반면 (같은 <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, 및 <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 16 진수 문자열을 구문 분석 하는 경우는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> 고 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> 메서드 가정 문자열의 첫 번째 바이트의 가장 중요 한 비트가 설정 된 경우 값은 문자열의 첫 번째 16 진수 바이트 값의 낮은 4 개의 비트를 나타내는 경우 2의 보수 표현을 사용 하 여 표시 합니다. 예를 들어, "FF01" 및 "F01" 나타내는 10 진수 값-255를 나타냅니다. 음수 값에서 양수를 구별 하려면 양수 값 앞에 0이 포함 되어야 합니다. 관련 된 오버 로드는 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 "X" 형식 문자열에 전달 될 때 양수 값에 대해 반환 되는 16 진수 문자열에 선행 0을 추가 합니다. 따라서 왕복 <xref:System.Numerics.BigInteger> 를 사용 하 여 값을 <xref:System.Numerics.BigInteger.ToString%2A> 및 <xref:System.Numerics.BigInteger.Parse%2A> 메서드를 다음 예제와 같이 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 호출 하 여 16 진수 문자열을 생성 하는 반면를 `ToString` 다른 정수 형식 또는 오버 로드의 메서드를 <xref:System.Convert.ToString%2A> 포함 하는 메서드를 `toBase` 매개 변수는 원본 데이터 형식 또는 값의 부호를 나타내지 않습니다 16 진수 문자열 파생 되었습니다. 성공적으로 인스턴스화하는 <xref:System.Numerics.BigInteger> 이러한 문자열의 값에는 몇 가지 추가 논리가 필요 합니다. 다음 예제에서는 한 가지 구현을 제공 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">little-endian 순서로 된 바이트 값의 배열입니다.</param>
        <summary>바이트 배열의 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개별 바이트를 `value` 가장 높은 순서 바이트가 최하위 바이트에서 little endian 순서로 배열 이어야 합니다. 예를 들어 1000000000000 숫자 값을 다음 표에 나와 있는 것 처럼 표시 됩니다.  
  
|||  
|-|-|  
|16 진수 문자열|E8D4A51000|  
|바이트 배열 (최저 인덱스를 먼저)|00 10 A5 D4 E8 00|  
  
 와 같은 바이트 배열에 숫자 값을 변환 하는 대부분의 메서드 <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> 고 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, little endian 순서로 바이트 배열을 반환 합니다.  
  
 생성자는 양수 값 및 사용 하 여 로그인 및 크기 표현을 음수 값 2의 보수 표현을 사용 하 여 바이트 배열 필요 합니다. 즉, 가장 높은 순위의 비트에서 최상위 바이트의 경우 `value` 결과 집합은 <xref:System.Numerics.BigInteger> 값이 음수입니다. 바이트 배열의 원본에 따라이 음수 값으로 잘못 해석 될 수는 양수를 발생할 수 있습니다. 바이트 배열은 일반적으로 다음과 같은 방법으로 생성 됩니다.  
  
-   호출 하 여는 <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> 메서드. 이 메서드를 반환 하므로 가장 높은 순위의 바이트의 최상위 비트를 사용 하 여 바이트 배열 배열 집합의 양수 값에 대 한 0 양수 값을 잘못의 확률이 없습니다. 생성 된 바이트 배열 수정 되지 않은 합니다 <xref:System.Numerics.BigInteger.ToByteArray%2A> 에 전달 될 때 항상 성공적으로 라운드트립 메서드는 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자입니다.  
  
-   호출 하 여는 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 메서드와 부호 있는 정수를 매개 변수로 전달 합니다. 부호 있는 정수의 부호 및 크기 표현 및 2의 보수 표현 모두를 처리 되므로 양수 값을 잘못 가능성이 없습니다.  
  
-   호출 하 여는 <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> 메서드와 부호 없는 정수를 매개 변수로 전달 합니다. 부호 없는 정수 크기 만으로 표시 되는 때문에 양수 값 음수 값으로 잘못 해석 될 수 있습니다. 이 잘못 해석 하지 않으려면 0 바이트 값을 배열의 끝에 추가할 수 있습니다. 다음 섹션의 예제는 예시를 제공합니다.  
  
-   바이트 배열 생성 하거나 동적 또는 정적으로 없이 반드시 여 이전 방법 또는 기존 바이트 배열을 수정 하 여 하나를 호출 합니다. 양수 값 음수 값으로 잘못 해석 될을 방지 하려면 0 바이트 값을 배열의 끝에 추가할 수 있습니다.  
  
 하는 경우 `value` 빈 <xref:System.Byte> array, 새 <xref:System.Numerics.BigInteger> 개체의 값으로 초기화 됩니다 <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>합니다. 경우 `value` 됩니다 `null`, 생성자가 throw는 <xref:System.ArgumentNullException>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Numerics.BigInteger> 값인 {5, 4, 3, 2, 1} 5 요소 바이트 배열에서 개체입니다. 그런 다음 표시는 <xref:System.Numerics.BigInteger> 값을 콘솔에 10 진수 및 16 진수 숫자로 표시 합니다. 텍스트 출력을 사용 하 여 입력 배열의 비교 명확해 이유는이 오버 로드는 <xref:System.Numerics.BigInteger> 클래스 생성자를 만듭니다를 <xref:System.Numerics.BigInteger> 4328719365 (또는 0x102030405) 값인 개체입니다. 최하위 바이트의 값을 정의 하는 값은 5, 바이트 배열의 첫 번째 요소는 <xref:System.Numerics.BigInteger> 0x05 개체입니다. 두 번째 바이트의 값을 정의 하는 값이 4 인 바이트 배열의 두 번째 요소는 <xref:System.Numerics.BigInteger> 등에 0x04 인 개체입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 다음 예에서는 양수 및 음수 인스턴스화합니다 <xref:System.Numerics.BigInteger> 값을 전달 합니다는 <xref:System.Numerics.BigInteger.ToByteArray%2A> 메서드를 다음 원래 복원 <xref:System.Numerics.BigInteger> 결과 바이트 배열에서 값입니다. 두 값을 동일한 바이트 배열으로 표시 한다는 참고 합니다. 유일한 차이점 바이트 배열에서 마지막 요소의 가장 중요 한 비트의 경우 이 비트가 설정 (바이트의 값은 0xFF) 이면 음수에서 만든 <xref:System.Numerics.BigInteger> 값입니다. 비트 배열을 양수에서 만들어지는 경우 (바이트의 값이 0)을 설정 하지 않으면 <xref:System.Numerics.BigInteger> 값입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 다음 예제는 양수 값을 잘못 인스턴스화되지 않았습니다 음수 값으로 값이 배열의 끝에 0 인 바이트를 추가 하 여 있는지 확인 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">10진수입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 사용하여 <see cref="T:System.Decimal" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 호출 하는 결과 동일 명시적으로 할당 하는 <xref:System.Decimal> 값을 <xref:System.Numerics.BigInteger> 변수입니다.  
  
 이 생성자를 호출 하면 데이터 손실이; 소수 부분은 `value` 인스턴스화할 때 잘립니다를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
   
  
## Examples  
 다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 개체입니다. 배열을 정의 <xref:System.Decimal> 값을 가져온 다음 각 값을 전달 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> 생성자입니다. 합니다 <xref:System.Decimal> 대신에 할당 되는 경우 반올림 하는 값은 잘립니다는 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">배정밀도 부동 소수점 값입니다.</param>
        <summary>배정밀도 부동 소수점 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소수 부분은 합니다 `value` 매개 변수를 인스턴스화할 때 잘립니다를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 전체 자릿수의 부족으로 인해는 <xref:System.Double> 이 생성자를 호출 하는 데이터 형식에 데이터 손실이 발생할 수 있습니다.  
  
 합니다 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값이 명시적으로 할당 한 결과 값과 동일한를 <xref:System.Double> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
   
  
## Examples  
 다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 개체입니다. 사용 하는 경우 발생할 수 있는 전체 자릿수 손실을 하는 방법도 보여 줍니다는 <xref:System.Double> 데이터 형식입니다. A <xref:System.Double> 에 할당 됩니다는 큰 값이 할당 되는 <xref:System.Numerics.BigInteger> 개체입니다. 출력에서 볼 수 있듯이이 할당 포함 정밀도 손실이 됩니다. 값이 모두는 다음 1 씩 증가 됩니다. 출력에 표시 하는 합니다 <xref:System.Numerics.BigInteger> 반면 개체는 변경 된 값을 반영 합니다 <xref:System.Double> 개체는 그렇지 않습니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> 또는 <see cref="F:System.Double.PositiveInfinity" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32비트 부호 있는 정수입니다.</param>
        <summary>부호 있는 32비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 하 여 개체입니다.  
  
 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.Int32> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
 합니다 <xref:System.Numerics.BigInteger> 구조 형식의 매개 변수를 사용 하 여 생성자를 포함 되지 않습니다 <xref:System.Byte>를 <xref:System.Int16>를 <xref:System.SByte>, 또는 <xref:System.UInt16>합니다. 그러나는 <xref:System.Int32> 형식은 8 비트와 16 비트 부호 있는 정수와 부호 있는 32 비트 정수를 암시적으로 변환 지원. 경우이 생성자를 호출 하는 결과적으로, `value` 이러한 네 개의 정수 형식 중 하나입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> 인스턴스화하는 생성자 <xref:System.Numerics.BigInteger> 값에서 32 비트 정수의 배열입니다. 또한 사용 하 여 암시적 변환을 각 32 비트 정수 값을 할당 한 <xref:System.Numerics.BigInteger> 변수입니다. 다음 비교는 연결할 두 값 결과 <xref:System.Numerics.BigInteger> 값이 동일 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">64비트 부호 있는 정수입니다.</param>
        <summary>부호 있는 64비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 하 여 개체입니다.  
  
 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.Int64> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> 인스턴스화하는 생성자 <xref:System.Numerics.BigInteger> 64 비트 정수의 배열 값입니다. 또한 사용 하 여 암시적 변환을 각 64 비트 정수 값을 할당 한 <xref:System.Numerics.BigInteger> 변수입니다. 다음 비교는 연결할 두 값 결과 <xref:System.Numerics.BigInteger> 값이 동일 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">단정밀도 부동 소수점 값입니다.</param>
        <summary>단정밀도 부동 소수점 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소수 부분은 합니다 `value` 매개 변수를 인스턴스화할 때 잘립니다를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 전체 자릿수의 부족으로 인해는 <xref:System.Single> 이 생성자를 호출 하는 데이터 형식에 데이터 손실이 발생할 수 있습니다.  
  
 합니다 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값이 명시적으로 할당 한 결과 값과 동일한를 <xref:System.Single> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
   
  
## Examples  
 다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 개체입니다. 사용 하는 경우 발생할 수 있는 전체 자릿수 손실을 하는 방법도 보여 줍니다는 <xref:System.Single> 데이터 형식입니다. A <xref:System.Single> 에 할당 됩니다 큰 음수 값을 할당 되는 <xref:System.Numerics.BigInteger> 개체입니다. 출력에서 볼 수 있듯이이 할당 포함 정밀도 손실이 됩니다. 값이 모두는 다음 1 씩 증가 됩니다. 출력에 표시 하는 합니다 <xref:System.Numerics.BigInteger> 반면 개체는 변경 된 값을 반영 합니다 <xref:System.Single> 개체는 그렇지 않습니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> 또는 <see cref="F:System.Single.PositiveInfinity" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">부호 없는 32비트 정수 값입니다.</param>
        <summary>부호 없는 32비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 합니다.  
  
 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.UInt32> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> 생성자 및 초기화 하려면 대입문 <xref:System.Numerics.BigInteger> 부호 없는 32 비트 정수 배열에서 값입니다. 다음 비교는 두 값 초기화의 두 메서드는 <xref:System.Numerics.BigInteger> 동일한 결과 생성 하는 값입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">부호 없는 64비트 정수입니다.</param>
        <summary>부호 없는 64비트 정수 값을 사용하여 <see cref="T:System.Numerics.BigInteger" /> 구조체의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스화할 때 전체 자릿수가 손실 되지 않습니다는 <xref:System.Numerics.BigInteger> 이 생성자를 사용 합니다.  
  
 <xref:System.Numerics.BigInteger> 이 생성자를 호출한 결과로 생성 되는 값은 할당 결과로 생성 되는 값과 동일한를 <xref:System.UInt64> 값을 <xref:System.Numerics.BigInteger>입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> 인스턴스화하는 생성자를 <xref:System.Numerics.BigInteger> 값인 같음 개체 <xref:System.UInt64.MaxValue>합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">숫자입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체의 절대 값을 가져옵니다.</summary>
        <returns><paramref name="value" />의 절대값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 숫자의 절대 값을 다음 표에 나와 있는 것 처럼은 부호가 없는 해당 숫자는 합니다.  
  
|`value` 매개 변수|반환 값|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 합니다 <xref:System.Numerics.BigInteger.Abs%2A> 메서드는 해당 하는 <xref:System.Math.Abs%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Abs%2A> 변환할 메서드는 <xref:System.Numerics.BigInteger> 파일로 직렬화 하는 작업 하기 전에 로그인 및 크기 표현에 값 2의 보수 표현에서. 파일의에서 데이터를 한 다음 deserialize 및 새 할당할 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">더할 첫 번째 값입니다.</param>
        <param name="right">더할 두 번째 값입니다.</param>
        <summary>두 개의 <see cref="T:System.Numerics.BigInteger" /> 값을 더한 다음 결과를 반환합니다.</summary>
        <returns><paramref name="left" />와 <paramref name="right" />의 합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연산자 오버 로드 또는 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.BigInteger.Add%2A> 메서드를 사용 하 여 추가 <xref:System.Numerics.BigInteger> 값입니다.  
  
 합니다 <xref:System.Numerics.BigInteger.Add%2A> 인스턴스화할 때 메서드는 더하기 연산자에 대 한 유용한 대체는 <xref:System.Numerics.BigInteger> 다음 예와에서 같이 또한 결과로 생성 되는 합계를 할당 하 여 변수입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값을 비교하고 첫 번째 값이 두 번째 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>다음 표와 같이 <paramref name="left" /> 및 <paramref name="right" />의 상대 값을 나타내는 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 값 
 </term><description> 조건 
 </description></listheader><item><term> 0보다 작음 
 </term><description><paramref name="left" />가 <paramref name="right" />보다 작은 경우  
  
 </description></item><item><term> 0 
 </term><description><paramref name="left" />가 <paramref name="right" />와 같습니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description><paramref name="left" />가 <paramref name="right" />보다 큰 경우  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하지만 합니다 <xref:System.Numerics.BigInteger> 형식이 고정 된 범위를 비교 <xref:System.Numerics.BigInteger> 값 비교의 부동 소수점 숫자의 특징인 정밀도 부족 발생 하지 않습니다. 다음 예제에서는 두 개의 비교 <xref:System.Numerics.BigInteger> 1896 자릿수를 갖는 하나 있고 각각 다른 값입니다. <xref:System.Numerics.BigInteger.Compare%2A> 메서드는 두 값이 같지 않은지 올바르게 보고 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 값을 다른 값과 비교하고 이 인스턴스의 값이 다른 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">비교할 부호 있는 64비트 정수입니다.</param>
        <summary>이 인스턴스를 부호 있는 64비트 정수와 비교하고 이 인스턴스의 값이 부호 있는 64비트 정수 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>다음 표와 같이 이 인스턴스와 <paramref name="other" /> 사이의 관계를 나타내는 부호 있는 정수 값입니다.  
  
 <list type="table"><listheader><term> 반환 값 
 </term><description> 설명 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 현재 인스턴스가 <paramref name="other" />보다 작습니다.  
  
 </description></item><item><term> 0 
 </term><description> 현재 인스턴스가 <paramref name="other" />와 같습니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 현재 인스턴스가 <paramref name="other" />보다 큽니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `other` 는 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할를 <xref:System.Int64> 경우이 값는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> 메서드가 호출 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호출의 결과 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> 정수 값을 사용 하 여 메서드.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">비교할 개체입니다.</param>
        <summary>이 인스턴스를 두 번째 <see cref="T:System.Numerics.BigInteger" />와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>다음 표와 같이 이 인스턴스와 <paramref name="other" /> 사이의 관계를 나타내는 부호 있는 정수 값입니다.  
  
 <list type="table"><listheader><term> 반환 값 
 </term><description> 설명 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 현재 인스턴스가 <paramref name="other" />보다 작습니다.  
  
 </description></item><item><term> 0 
 </term><description> 현재 인스턴스가 <paramref name="other" />와 같습니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 현재 인스턴스가 <paramref name="other" />보다 큽니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 <xref:System.Numerics.BigInteger.CompareTo%2A> 메서드 구현 된 <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> 메서드. 컬렉션에서 항목을 주문 하려면 제네릭 컬렉션 개체에 의해 사용 됩니다.  
  
   
  
## Examples  
 다음 예제를 사용 합니다 <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> 메서드는 목록의 순서를 `StarInfo` 개체입니다. 각 `StarInfo` 개체 별의 이름과 (마일)이 지구 로부터의 거리에 대 한 정보를 제공 합니다. `StarInfo` 구현 된 <xref:System.IComparable%601> 인터페이스를 `StarInfo` 제네릭 컬렉션 클래스에서 정렬할 개체입니다. 해당 <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> 구현에 대 한 호출 래핑하기만 <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 다음 코드는 다음 네 가지 인스턴스화합니다 `StarInfo` 개체 및 제네릭에 저장 합니다 <xref:System.Collections.Generic.List%601> 개체입니다. 후 합니다 <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> 메서드를 호출 `StarInfo` 개체 지구 로부터의 거리의 순서로 표시 됩니다.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">비교할 개체입니다.</param>
        <summary>이 인스턴스를 지정된 개체와 비교하고 이 인스턴스의 값이 지정된 개체의 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>다음 표와 같이 현재 인스턴스와 <paramref name="obj" /> 매개 변수 사이의 관계를 나타내는 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 반환 값 
 </term><description> 설명 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 현재 인스턴스가 <paramref name="obj" />보다 작습니다.  
  
 </description></item><item><term> 0 
 </term><description> 현재 인스턴스가 <paramref name="obj" />와 같습니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 현재 인스턴스가 <paramref name="obj" />보다 크거나 <paramref name="obj" /> 매개 변수가 <see langword="null" />입니다.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 <xref:System.Numerics.BigInteger.CompareTo%2A> 메서드 구현 된 <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> 메서드. 컬렉션에서 항목을 주문 하려면 제네릭이 아닌 컬렉션 개체에 의해 사용 됩니다.  
  
 `obj` 매개 변수는 다음 중 하나 여야 합니다.  
  
-   개체 런타임 형식이 <xref:System.Numerics.BigInteger>합니다.  
  
-   <xref:System.Object> 변수 값을 갖는 `null`합니다. 경우의 값을 `obj` 매개 변수가 `null`, 메서드가 반환 된 현재 인스턴스의 보다 큰지 여부를 나타내는 1 `obj`합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> 비교할 메서드는 <xref:System.Numerics.BigInteger> 개체 배열의 각 요소를 사용 하 여 값  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />가 <see cref="T:System.Numerics.BigInteger" />가 아닌 경우</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">비교할 부호 없는 64비트 정수입니다.</param>
        <summary>이 인스턴스를 부호 없는 64비트 정수와 비교하고 이 인스턴스의 값이 부호 없는 64비트 정수 값보다 작은지, 같은지 또는 큰지를 나타내는 정수를 반환합니다.</summary>
        <returns>다음 표와 같이 이 인스턴스와 <paramref name="other" />의 상대 값을 나타내는 부호 있는 정수입니다.  
  
 <list type="table"><listheader><term> 반환 값 
 </term><description> 설명 
 </description></listheader><item><term> 0보다 작음 
 </term><description> 현재 인스턴스가 <paramref name="other" />보다 작습니다.  
  
 </description></item><item><term> 0 
 </term><description> 현재 인스턴스가 <paramref name="other" />와 같습니다.  
  
 </description></item><item><term> 0보다 큼 
 </term><description> 현재 인스턴스가 <paramref name="other" />보다 큽니다.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">나눌 대상 값입니다.</param>
        <param name="divisor">나눌 값입니다.</param>
        <summary>하나의 <see cref="T:System.Numerics.BigInteger" /> 값을 다른 값으로 나눈 후 결과를 반환합니다.</summary>
        <returns>나누기의 몫입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Divide%2A> 정수 나누기를 수행 하는 메서드, 나누기 결과로 생성 되는 나머지는 삭제 됩니다. 나머지 계속 사용 하면서 정수 나누기를 수행 하려면 호출을 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드. 나머지만을 검색 하려면 호출을 <xref:System.Numerics.BigInteger.Remainder%2A> 메서드.  
  
 <xref:System.Numerics.BigInteger.Divide%2A> 메서드 오버 로드 된 연산자를 지원 하지 않는 언어에서 사용할 수 있습니다. 해당 동작 나누기는 나누기 연산자를 사용 하는 것과 동일 합니다.  
  
   
  
## Examples  
 다음 예제에서는 배열을 <xref:System.Numerics.BigInteger> 값입니다. 다음 각 요소를 사용 하는 나누기 연산에서 몫으로 사용 하 여는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드를 나누기 연산자 (/) 및 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />가 0인 경우</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">나눌 대상 값입니다.</param>
        <param name="divisor">나눌 값입니다.</param>
        <param name="remainder">이 메서드가 반환되면 나누기의 나머지를 나타내는 <see cref="T:System.Numerics.BigInteger" /> 값을 포함합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>하나의 <see cref="T:System.Numerics.BigInteger" /> 값을 다른 값으로 나눈 후 결과를 반환하고 출력 매개 변수에 나머지를 반환합니다.</summary>
        <returns>나누기의 몫입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 몫과 나머지 정수 나누기에서 결과 유지 합니다. 나머지 관심이 없는 경우 사용 합니다 <xref:System.Numerics.BigInteger.Divide%2A> 메서드나 나누기 연산자; 경우 나머지 부분에서는 관심이 사용 하 여를 <xref:System.Numerics.BigInteger.Remainder%2A> 메서드.  
  
 반환 된 부호 `remainder` 값의 부호와 같습니다는 `dividend` 매개 변수입니다.  
  
 동작을 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드는 동일 합니다는 <xref:System.Math.DivRem%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 배열을 <xref:System.Numerics.BigInteger> 값입니다. 다음 각 요소를 사용 하는 나누기 연산에서 몫으로 사용 하 여는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드를 나누기 연산자 (/) 및 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />가 0인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 개의 숫자 값이 같은지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">비교할 부호 있는 64비트 정수 값입니다.</param>
        <summary>현재 인스턴스와 부호 있는 64비트 정수의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>부호 있는 64비트 정수와 현재 인스턴스의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `other` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 메서드를 호출 하는 경우 값입니다.  
  
 같은지 테스트 하는 대신 두 개체 간의 관계를 확인 하려면 호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Numerics.BigInteger> 제외 하 고 각 정수 계열 형식에서 개체 <xref:System.UInt64>합니다. 그런 다음 호출 하는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> 비교할 메서드를 <xref:System.Numerics.BigInteger> 에 전달 된 원래 정수 값을 사용 하 여 값을 <xref:System.Numerics.BigInteger> 생성자. 출력에서 볼 수 있듯이 값은 각 사례에서 같습니다.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">비교할 개체입니다.</param>
        <summary>현재 인스턴스와 지정된 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>이 <see cref="T:System.Numerics.BigInteger" /> 개체와 <paramref name="other" />의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 구현 하는 <xref:System.IEquatable%601> 인터페이스 및 수행 보다 조금 더 나은 <xref:System.Numerics.BigInteger.Equals%28System.Object%29> 변환할 필요가 없기 때문에 `other` 매개 변수를를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 둘 사이의 관계를 결정할 <xref:System.Numerics.BigInteger> 같은지를 테스트 하는 대신 개체를 호출 합니다 <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 엡실론 표시 하려면 같은지 여부를 결정 하는 지구에서의 거리를 사용 하 여 지구에서 몇몇 별의 근사 거리를 비교 합니다. 예제에서는 각 오버 로드는 <xref:System.Numerics.BigInteger.Equals%2A> 같은지 테스트 하는 방법입니다.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">비교할 개체입니다.</param>
        <summary>현재 인스턴스와 지정된 개체의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="obj" /> 인수가 <see cref="T:System.Numerics.BigInteger" /> 개체이고 값이 현재 <see cref="T:System.Numerics.BigInteger" /> 인스턴스의 값과 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `obj` 인수가 아닙니다를 <xref:System.Numerics.BigInteger> 값을 메서드 반환 `false`합니다. 메서드는 반환 `true` 경우에만 `obj` 는 <xref:System.Numerics.BigInteger> 값이 현재 인스턴스와 같으면 합니다.  
  
 같은지 테스트 하는 대신 두 개체 간의 관계를 확인 하려면 호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 병렬 <xref:System.Object> 고 <xref:System.Numerics.BigInteger> 배열입니다. 한 배열의 각 요소에는 두 번째 배열의 해당 요소와 동일한 값을 갖습니다. 예제에 있는 인스턴스의에서 출력으로는 <xref:System.Numerics.BigInteger> 배열에서 인스턴스를 동일한 것으로 간주 됩니다 합니다 <xref:System.Object> 후자는 경우에를 <xref:System.Numerics.BigInteger> 해당 값이 같으면.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">비교할 부호 없는 64비트 정수입니다.</param>
        <summary>현재 인스턴스와 부호 없는 64비트 정수의 값이 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>현재 인스턴스와 부호 없는 64비트 정수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 같은지 테스트 하는 대신 두 개체 간의 관계를 확인 하려면 호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 엡실론 표시 하려면 같은지 여부를 결정 하는 지구에서의 거리를 사용 하 여 지구에서 몇몇 별의 근사 거리를 비교 합니다. 예제에서는 각 오버 로드는 <xref:System.Numerics.BigInteger.Equals%2A> 같은지 테스트 하는 방법입니다.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체에 대한 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">첫 번째 값입니다.</param>
        <param name="right">두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값의 최대 공약수를 구합니다.</summary>
        <returns><paramref name="left" />와 <paramref name="right" />의 최대 공약수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가장 일반적인 제 수는 최대 수는 두 <xref:System.Numerics.BigInteger> 나머지를 반환 하지 않고 값을 나눌 수 있습니다.  
  
 경우는 `left` 고 `right` 매개 변수는 0이 아닌 숫자, 메서드는 항상 하나 이상의 값이 1 반환 하므로 1만 모든 숫자를 구분할 수 있습니다. 매개 변수 중 하나가 0 인 경우 메서드는 0이 아닌 매개 변수의 절대 값을 반환 합니다. 값이 모두 0 인 경우 메서드는 0을 반환 합니다.  
  
> [!NOTE]
>  매우 큰 값의 최대 공약수 컴퓨팅 `left` 고 `right` 작업을 매우 많은 시간이 소요 될 수 있습니다.  
  
 값을 반환 합니다 <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> 메서드는 항상의 부호에 관계 없이 양수를 `left` 및 `right` 매개 변수.  
  
   
  
## Examples  
 다음 예제에 대 한 호출을 <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> 메서드 및 예외에 대 한 유용한 정보를 제공 하는 데 필요한 처리를 <xref:System.ArgumentOutOfRangeException>입니다. 결과 이러한 두 숫자의 최대 공약수 1 임을 나타냅니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 짝수인지 여부를 나타냅니다.</summary>
        <value><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 짝수이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 표시 하는 편리한 기능 여부는 <xref:System.Numerics.BigInteger> 값은 두 개의 균등 하 게 나눌 합니다. 다음 식은 동일 합니다.  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 하는 경우 현재 값 <xref:System.Numerics.BigInteger> 개체가 <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, 속성 `true`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.One" />인지 여부를 나타냅니다.</summary>
        <value><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.One" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 하나를 사용 하 여 다른 비교 보다 훨씬 더 나은 성능을 같은 `thisBigInteger.Equals(BigInteger.One)`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 2의 거듭제곱인지 여부를 나타냅니다.</summary>
        <value><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 2의 거듭제곱이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 결정 하는지 여부를 <xref:System.Numerics.BigInteger> 값에 단일 0이 아닌 비트를 설정 합니다. 이 반환 됨을 의미 `true` 경우 현재 값 <xref:System.Numerics.BigInteger> 개체는 1 (즉, 2<sup>0</sup>) 또는 두 개의 모든 강화 합니다. 반환 `false` 하는 경우 현재 값 <xref:System.Numerics.BigInteger> 개체는 0입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.Zero" />인지 여부를 나타냅니다.</summary>
        <value><see cref="T:System.Numerics.BigInteger" /> 개체의 값이 <see cref="P:System.Numerics.BigInteger.Zero" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 보다 훨씬 나은 성능을 제공 `BigInteger.Equals(BigInteger.Zero)`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 숫자의 로그를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">로그가 있는 숫자입니다.</param>
        <summary>지정된 숫자의 자연(밑 <see langword="e" />) 로그를 반환합니다.</summary>
        <returns>설명 단원의 표와 같이 <paramref name="value" />의 자연(밑 <see langword="e" />) 로그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 매개 변수를 10 진수로로 지정 합니다.  
  
 이 메서드는 값의 부호에 따라 달라 집니다 정확한 반환 `value`다음 표와 같이 합니다.  
  
|로그인 `value` 매개 변수|반환 값|  
|-------------------------------|------------------|  
|양수|자연 `value`; ln `value`, 또는 log e`value`합니다.|  
|0|<xref:System.Double.NegativeInfinity>.|  
|음수|<xref:System.Double.NaN>.|  
  
 계산의 밑수 10에 <xref:System.Numerics.BigInteger> 값, 호출 된 <xref:System.Numerics.BigInteger.Log10%2A> 메서드. 다른 기본 숫자의 밑을 계산 하려면 호출을 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> 메서드.  
  
 호출 하 여 숫자의 제곱근을 찾을 수 있습니다 합니다 <xref:System.Numerics.BigInteger.Log%2A> 와 함께 메서드는 <xref:System.Math.Exp%2A?displayProperty=nameWithType> 메서드. 결과 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> 결과 보다 크면 <xref:System.Double.MaxValue?displayProperty=nameWithType>합니다. 다음 예제에서는 배열에서 각 요소의 제곱근을 계산 <xref:System.Numerics.BigInteger> 값입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 에 해당 하는이 메서드는 <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />의 자연 로그가 <see cref="T:System.Double" /> 데이터 형식의 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">로그가 있는 숫자입니다.</param>
        <param name="baseValue">로그의 밑입니다.</param>
        <summary>지정된 밑을 사용하여 지정된 숫자의 로그를 반환합니다.</summary>
        <returns>설명 단원의 표와 같이 밑이 <paramref name="baseValue" />인 <paramref name="value" />의 로그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `value` 및 `baseValue` 번호가 10 개를 기반으로 매개 변수를 지정 합니다.  
  
 정확한 반환 메서드의 값의 부호에 따라 달라 집니다 `value` 부호와 값 및 `baseValue`다음 표와 같이 합니다.  
  
|`value` 매개 변수|`baseValue` 매개 변수|반환 값|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1)-또는-(`baseValue` > 1)|logbaseValue(`value`)|  
|`value` < 0|(모든 값)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(모든 값)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(모든 값)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(모든 값)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 계산의 밑수 10에 <xref:System.Numerics.BigInteger> 값, 호출 된 <xref:System.Numerics.BigInteger.Log10%2A> 메서드. 숫자의 자연 로그를 계산 하기 위해 호출 된 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> 메서드.  
  
 에 해당 하는이 메서드는 <xref:System.Math.Log%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />의 로그가 <see cref="T:System.Double" /> 데이터 형식의 범위를 벗어납니다.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">로그가 있는 숫자입니다.</param>
        <summary>밑을 10으로 사용하여 지정된 숫자의 로그를 반환합니다.</summary>
        <returns>설명 단원의 표와 같이 밑이 10인 <paramref name="value" />의 로그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 매개 변수를 10 진수로로 지정 합니다.  
  
 정확한 반환 메서드의 값의 부호에 따라 달라 집니다 `value`다음 표와 같이 합니다.  
  
|매개 변수 값의 부호|반환 값|  
|-----------------------------|------------------|  
|양수|기본 10 로그가 `value`; log10`value`합니다.|  
|0|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|음수|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 자연 로그를 계산 하는 <xref:System.Numerics.BigInteger> 값, 호출 된 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드. 다른 기본 숫자의 밑을 계산 하려면 호출을 <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> 메서드.  
  
 에 해당 하는이 메서드는 <xref:System.Math.Log10%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />의 기본 10 로그가 <see cref="T:System.Double" /> 데이터 형식의 범위를 벗어납니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값 중 더 큰 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 또는 <paramref name="right" /> 매개 변수 중 더 큰 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 해당 하는이 메서드는 <xref:System.Math.Max%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Max%2A> 배열에 가장 큰 수를 선택 하는 방법 <xref:System.Numerics.BigInteger> 값입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값 중 더 작은 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 또는 <paramref name="right" /> 매개 변수 중 더 작은 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 해당 하는이 메서드는 <xref:System.Math.Min%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Min%2A> 의 배열에서 가장 작은 숫자를 선택 하는 방법 <xref:System.Numerics.BigInteger> 값입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>숫자 -1을 나타내는 값을 가져옵니다.</summary>
        <value>값이 -1인 정수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.MinusOne%2A> 속성 비교에 사용 되는 <xref:System.Numerics.BigInteger> 값-1 또는-1을 할당 하는 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><paramref name="exponent" /> 지수로 사용할 숫자입니다.</param>
        <param name="exponent"><paramref name="value" />를 거듭제곱할 지수입니다.</param>
        <param name="modulus"><paramref name="value" />의 <paramref name="exponent" />승을 나눌 숫자입니다.</param>
        <summary>다른 숫자의 승수로 거듭제곱한 숫자에 대해 모듈러스 나누기를 수행합니다.</summary>
        <returns><paramref name="value" /><sup>지수</sup>를 <paramref name="modulus" />로 나눈 나머지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ModPow%2A> 메서드는 다음 식을 계산 합니다.  
  
 (baseValue ^ 지 수) Mod 모듈러스  
  
 지 수에서 수행할 <xref:System.Numerics.BigInteger> 모듈러스 나누기 없이 값을 사용 합니다 <xref:System.Numerics.BigInteger.Pow%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 간단한 설명을 제공 합니다 <xref:System.Numerics.BigInteger.ModPow%2A> 메서드.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" />가 0입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" />가 음수입니다.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">곱할 첫 번째 숫자입니다.</param>
        <param name="right">곱할 두 번째 숫자입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값의 곱을 반환합니다.</summary>
        <returns><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 곱입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Multiply%2A> 연산자 오버 로드를 지원 하지 않는 언어에 대 한 메서드 구현 됩니다. 해당 동작은 곱셈 연산자를 사용 하는 곱하기 동일 합니다. 또한 합니다 <xref:System.Numerics.BigInteger.Multiply%2A> 인스턴스화할 때 메서드는 곱하기 연산자에 대 한 유용한 대체를 <xref:System.Numerics.BigInteger> 다음 예와에서 같이 곱하기에서 발생 하는 제품을 할당 하 여 변수입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 하는 경우 필요에 따라이 메서드가 자동으로 수행 다른 정수 계열 형식으로의 암시적 변환 <xref:System.Numerics.BigInteger> 개체입니다. 이 코드는 다음 섹션의 예제에서 확인할 수 있습니다 위치 합니다 <xref:System.Numerics.BigInteger.Multiply%2A> 두 메서드에 전달 됩니다 <xref:System.Int64> 값입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 정수 (long) 사용 하 여 곱하기를 수행 하려고 시도 합니다. Long 정수의 범위를 초과 하는 결과 <xref:System.OverflowException> throw 되 고 <xref:System.Numerics.BigInteger.Multiply%2A> 메서드를 호출 하는 곱셈을 처리 합니다. C#는 사용 하는 참고 합니다 `checked` 이 예에서 같이 키워드 또는 `/checked+` 숫자 오버플로에 예외가 throw 되었는지 확인 하려면 컴파일러 옵션입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부정할 값입니다.</param>
        <summary>지정된 <see cref="T:System.Numerics.BigInteger" /> 값을 부정합니다.</summary>
        <returns><paramref name="value" /> 매개 변수에 -1을 곱한 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부정 덧셈 역 수를 가져옵니다. 숫자의 덧셈 역 원을 원래 수에 추가 될 때 0 값을 생성 하는입니다.  
  
 <xref:System.Numerics.BigInteger.Negate%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다. 해당 동작 단항 부정 연산자를 사용 하 여 부정 하는 것과 동일 합니다. 또한 합니다 <xref:System.Numerics.BigInteger.Negate%2A> 메서드를 인스턴스화할 때 부정 연산자에 대 한 유용한 대체는를 <xref:System.Numerics.BigInteger> 변수를 다음 예제에서와 같이 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 다음 예의 값을 부정 하는 세 가지를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>숫자 1을 나타내는 값을 가져옵니다.</summary>
        <value>값이 1인 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.One%2A> 속성을 비교 하는 데 주로 사용 되는 <xref:System.Numerics.BigInteger> 값을 1 또는 1을 할당 하는 <xref:System.Numerics.BigInteger> 개체.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">더할 첫 번째 값입니다.</param>
        <param name="right">더할 두 번째 값입니다.</param>
        <summary>지정한 두 <see cref="T:System.Numerics.BigInteger" />의 값을 더합니다.</summary>
        <returns><paramref name="left" />와 <paramref name="right" />의 합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Addition%2A> 메서드 정의 대해 더하기 연산을 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Add%2A> 메서드 대신 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">첫 번째 값입니다.</param>
        <param name="right">두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 비트 <see langword="And" /> 연산을 수행합니다.</summary>
        <returns>비트 <see langword="And" /> 연산의 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> 메서드 정의 비트 `And` 에 대 한 작업 <xref:System.Numerics.BigInteger> 값입니다. 비트 `And` 작업 설정 결과 비트 유일한 경우는 해당 비트 `left` 및 `right` 다음 표에 나와 있는 것 처럼는 설정도 됩니다.  
  
|비트 `left`|비트 `right`|결과의 비트|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 합니다 <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> 메서드 비트 연산을 수행 `And` 두 작업 <xref:System.Numerics.BigInteger> 가상 부호 확장을 사용 하 여 2의 보수 표현에서 둘 다 있는 것 처럼 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">첫 번째 값입니다.</param>
        <param name="right">두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 비트 <see langword="Or" /> 연산을 수행합니다.</summary>
        <returns>비트 <see langword="Or" /> 연산의 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> 메서드 정의 비트 `Or` 에 대 한 작업 <xref:System.Numerics.BigInteger> 값입니다. 비트 `Or` 작업의 해당 비트 중 하나 또는 모두 경우에만 결과 비트를 설정 합니다 `left` 고 `right` 표에 표시 된 것과 같이 설정 됩니다.  
  
|비트 `left`|비트 `right`|결과의 비트|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 합니다 <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> 메서드 비트 연산을 수행 `Or` 두 작업 <xref:System.Numerics.BigInteger> 가상 부호 확장을 사용 하 여 2의 보수 표현에서 둘 다 있는 것 처럼 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">감소시킬 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 1씩 감소합니다.</summary>
        <returns>1씩 감소하는 <paramref name="value" /> 매개 변수의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Decrement%2A> 메서드는 감소 연산을 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Subtract%2A> 메서드 대신 합니다. 예:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 때문에 <xref:System.Numerics.BigInteger> 개체를 변경할 수 없는 합니다 <xref:System.Numerics.BigInteger.op_Decrement%2A> 연산자를 새로 만듭니다 <xref:System.Numerics.BigInteger> 하나 값인 개체 보다 작은 <xref:System.Numerics.BigInteger> 가 나타내는 개체 `value`합니다. 이 즉, 반복 호출을 <xref:System.Numerics.BigInteger.op_Decrement%2A> 성능이 떨어질 수 있습니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">나눌 대상 값입니다.</param>
        <param name="divisor">나눌 값입니다.</param>
        <summary>정수 나누기를 사용하여 지정된 <see cref="T:System.Numerics.BigInteger" /> 값을 지정된 다른 <see cref="T:System.Numerics.BigInteger" /> 값으로 나눕니다.</summary>
        <returns>나누기의 정수 계열 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Division%2A> 메서드 정의 대 한 나누기 연산 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 사용자 지정 연산자 및 연산자 오버 로드를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드 대신 합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 배열을 <xref:System.Numerics.BigInteger> 값입니다. 다음 각 요소를 사용 하는 나누기 연산에서 몫으로 사용 하 여는 <xref:System.Numerics.BigInteger.Divide%2A> 메서드를 나누기 연산자 (/) 및 <xref:System.Numerics.BigInteger.DivRem%2A> 메서드.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />가 0인 경우</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 값이 같은지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 있는 정수(Long) 값과 <see cref="T:System.Numerics.BigInteger" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.  
  
 경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값과 부호 있는 정수(Long) 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.  
  
 경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드 정의 작업에 대 한 같음 연산자의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값과 부호 없는 정수(Long) 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 없는 정수(Long) 값과 <see cref="T:System.Numerics.BigInteger" /> 값이 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" /> 및 <paramref name="right" /> 매개 변수의 값이 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드 정의 대 한 같음 비교 연산 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">첫 번째 값입니다.</param>
        <param name="right">두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 비트 배타적 <see langword="Or" />(<see langword="XOr" />) 연산을 수행합니다.</summary>
        <returns>비트 <see langword="Or" /> 연산의 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 결과 비트 배타적 `Or` 작업이 `true` 는 2 비트의 값이 고 그렇지 않으면 다른 경우 `false`합니다. 다음 표에서 전용 `Or` 작업 합니다.  
  
|비트 x `left`|비트 x `right`|반환 값|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 합니다 <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> 배타적 비트를 수행 하는 메서드 `Or` 두 작업 <xref:System.Numerics.BigInteger> 가상 부호 확장을 사용 하 여 2의 보수 표현에서 둘 다 있는 것 처럼 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체와 다른 형식 간의 명시적 변환을 정의합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary><see cref="T:System.Decimal" /> 개체를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.

 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 때문에 변환 <xref:System.Decimal> 에 <xref:System.Numerics.BigInteger> 잘라내기 소수 부분이 포함 될 수 있습니다 `value`, 언어 컴파일러는이 변환을 자동으로 수행 되지 않습니다. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.   

 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>합니다.


## Examples
 다음 예제에서는 배열의 개별 요소를 변환 <xref:System.Decimal> 값을 <xref:System.Numerics.BigInteger> 개체 이며 각 변환의 결과 표시 합니다. 참고는 소수 부분을 <xref:System.Decimal> 변환 하는 동안 값이 잘립니다.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary><see cref="T:System.Double" /> 값을 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.

 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 때문에 변환 <xref:System.Double> 에 <xref:System.Numerics.BigInteger> 잘라내기 소수 부분이 포함 될 수 있습니다 `value`, 언어 컴파일러는이 변환을 자동으로 수행 되지 않습니다. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.

 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>합니다.


## Examples
 다음 예제에서는 배열의 개별 요소를 변환 <xref:System.Double> 값을 <xref:System.Numerics.BigInteger> 개체 이며 각 변환의 결과 표시 합니다. 참고는 소수 부분을 <xref:System.Double> 변환 하는 동안 값이 잘립니다.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> 또는 <see cref="F:System.Double.NegativeInfinity" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Byte" />로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 바이트 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CByte` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.   

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Byte> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.Byte> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Byte> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Byte> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Byte.MinValue" />보다 작거나 <see cref="F:System.Byte.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Decimal" />로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 <see cref="T:System.Decimal" /> 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CDec` Visual Basic에서) 사용 됩니다.   

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Decimal> 데이터 형식입니다. 

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Decimal> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Decimal> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Decimal.MinValue" />보다 작거나 <see cref="F:System.Decimal.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Double" />로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 <see cref="T:System.Double" /> 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CDbl` Visual Basic에서) 사용 됩니다.   

 때문에 <xref:System.Numerics.BigInteger> 범위를 벗어나는 값 수는 <xref:System.Double> 이 작업은 데이터 형식으로 축소 변환 합니다. Throw 하지 않는 경우 변환이 실패 한 <xref:System.OverflowException>합니다. 대신 경우 합니다 <xref:System.Numerics.BigInteger> 값이 보다 작거나 <xref:System.Double.MinValue?displayProperty=nameWithType>, 결과 <xref:System.Double> 값은 <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>합니다. 경우는 <xref:System.Numerics.BigInteger> 값 보다 크면 <xref:System.Double.MaxValue?displayProperty=nameWithType>, 결과 <xref:System.Double> 값은 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다.
 
 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Double> 정밀도의 손실 될 수 있습니다. 전체 자릿수 손실을 캐스팅 또는 변환 작업을 수행 하려면 일부 경우에 발생할 수 있습니다 경우에 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Double> 데이터 형식입니다. 다음 예제에서 이에 대해 설명합니다. 최대 값을 할당 하는 <xref:System.Double> 두 개의 <xref:System.Numerics.BigInteger> 변수, 하나의 <xref:System.Numerics.BigInteger> 9.999 e 291 증가, 같음에 대 한 두 변수는 테스트를 변수입니다. 에 대 한 호출을 예상 대로 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드는 서로 다른 지 보여 줍니다. 그러나 더 큰 숫자를 변환 <xref:System.Numerics.BigInteger> 값을 다시를 <xref:System.Double> 성공 합니다 합니다 <xref:System.Numerics.BigInteger> 값을 초과 하면 이제 <xref:System.Double.MaxValue?displayProperty=nameWithType>합니다.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Double> 값입니다.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 있는 16비트 정수로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 16비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CShort` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.   

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Int16> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.Int16> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Int16> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Int16> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Int16.MinValue" />보다 작거나 <see cref="F:System.Int16.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 있는 32비트 정수로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 32비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CInt` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.   

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Int32> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.Int16> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Int32> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Int32> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Int32.MinValue" />보다 작거나 <see cref="F:System.Int32.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 있는 64비트 정수로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 64비트 정수 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CLng` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.  

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Int64> 데이터 형식입니다. 

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Int64> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.Int64> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Int64.MinValue" />보다 작거나 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 있는 8비트 값으로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 있는 8비트 값으로 변환하는 명시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="T:System.Int16" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CSByte` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.  

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.SByte> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.SByte> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.SByte> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.SByte> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.SByte.MinValue" />보다 작거나 <see cref="F:System.SByte.MaxValue" />보다 큽니다.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">단정밀도 부동 소수점 값으로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 단정밀도 부동 소수점 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 가능한 가장 가까운 표현을 포함하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터가 손실 되거나 정밀도 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CSng` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.    

 때문에 <xref:System.Numerics.BigInteger> 범위를 벗어나는 값 수는 <xref:System.Single> 이 작업은 데이터 형식으로 축소 변환 합니다. Throw 하지 않는 경우 변환이 실패 한 <xref:System.OverflowException>합니다. 대신 경우 합니다 <xref:System.Numerics.BigInteger> 값이 보다 작거나 <xref:System.Single.MinValue?displayProperty=nameWithType>, 결과 <xref:System.Single> 값은 <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>합니다. 경우는 <xref:System.Numerics.BigInteger> 값 보다 크면 <xref:System.Single.MaxValue?displayProperty=nameWithType>, 결과 <xref:System.Single> 값은 <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>합니다.

 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Single> 정밀도의 손실 될 수 있습니다. 전체 자릿수 손실을 캐스팅 또는 변환 작업을 수행 하려면 일부 경우에 발생할 수 있습니다 경우에 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.Single> 데이터 형식입니다. 다음 예제에서 이에 대해 설명합니다. 최대 값을 할당 하는 <xref:System.Single> 두 개의 <xref:System.Numerics.BigInteger> 변수, 하나의 <xref:System.Numerics.BigInteger> 9.999 e 291 증가, 같음에 대 한 두 변수는 테스트를 변수입니다. 에 대 한 호출을 예상 대로 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드는 서로 다른 지 보여 줍니다. 그러나 더 큰 숫자를 변환 <xref:System.Numerics.BigInteger> 값을 다시를 <xref:System.Single> 성공 합니다 합니다 <xref:System.Numerics.BigInteger> 값을 초과 하면 이제 <xref:System.Single.MaxValue?displayProperty=nameWithType>합니다.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.Single> 값입니다.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 없는 16비트 정수로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 16비트 정수 값으로 변환하는 명시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="T:System.Int32" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CUShort` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.    

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.UInt16> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.UInt16> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.UInt16> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.UInt16> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.UInt16.MinValue" />보다 작거나 <see cref="F:System.UInt16.MaxValue" />보다 큽니다.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 없는 32비트 정수로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 32비트 정수 값으로 변환하는 명시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="T:System.Int64" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CUInt` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.    

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.UInt32> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.UInt32> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.UInt32> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.UInt32> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.UInt32.MinValue" />보다 작거나 <see cref="F:System.UInt32.MaxValue" />보다 큽니다.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부호 없는 64비트 정수로 변환할 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체를 부호 없는 64비트 정수 값으로 변환하는 명시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="T:System.Double" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 데이터 손실 포함할 수 있으므로 언어 컴파일러에서는이 변환을 자동으로 수행 하지 마십시오. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` 또는 `CULng` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.    

 Throw 할 수 있으므로이 작업은 축소 변환을 정의 합니다는 <xref:System.OverflowException> 경우 런타임에 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다는 <xref:System.UInt64> 데이터 형식입니다. 결과의 전체 자릿수 손실 되지 않습니다 <xref:System.UInt64> 변환이 성공 하는 경우 값입니다.

## Examples
 다음 예제에서는 변환을 <xref:System.Numerics.BigInteger> 에 <xref:System.UInt64> 값입니다. 또한 처리는 <xref:System.OverflowException> 때문에 throw 되는 합니다 <xref:System.Numerics.BigInteger> 값의 범위를 벗어났습니다를 <xref:System.UInt64> 데이터 형식.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.UInt64.MinValue" />보다 작거나 <see cref="F:System.UInt64.MaxValue" />보다 큽니다.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary><see cref="T:System.Single" /> 값을 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 명시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.
 
 오버 로드는 <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> 메서드를 가져오거나 형식을 정의 <xref:System.Numerics.BigInteger> 개체가 변환 될 수 있습니다. 때문에 변환 <xref:System.Single> 에 <xref:System.Numerics.BigInteger> 잘라내기 소수 부분이 포함 될 수 있습니다 `value`, 언어 컴파일러는이 변환을 자동으로 수행 되지 않습니다. 대신 수행 하며 변환 (C#에서)에 캐스팅 연산자나 변환 함수는 경우에 (같은 `CType` Visual Basic에서) 사용 됩니다. 그렇지 않으면 컴파일러 오류가 표시 됩니다.

 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>합니다.


## Examples
 다음 예제에서는 배열의 개별 요소를 변환 <xref:System.Single> 값을 <xref:System.Numerics.BigInteger> 개체 이며 각 변환의 결과 표시 합니다. 참고는 소수 부분을 <xref:System.Single> 변환 하는 동안 값이 잘립니다.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" />가 <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> 또는 <see cref="F:System.Single.NegativeInfinity" />입니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 값이 지정된 다른 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드를 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" />가 부호 있는 64 정수 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 큰지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThan%2A> 메서드 정의 대 한 연산자 보다 큼 연산의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 값이 지정된 다른 값보다 크거나 같은지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 있는 64비트 정수 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 없는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 크거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />이 <paramref name="left" />보다 크면 <paramref name="right" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> 메서드는 보다 크거나 같음 연산자에 대 한 작업을 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Numerics.BigInteger" /> 개체와 다른 형식 간의 암시적 변환을 정의합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 없는 바이트를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소수 부분은 `value` 변환 하기 전에 매개 변수는 잘립니다.

 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.   

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Byte> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 있는 16비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.   

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Int16> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 있는 32비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.  

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Int32> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 있는 64비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>합니다.   
 
 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.Int64> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 있는 8비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>합니다.   

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.SByte> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 없는 16비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>합니다.   

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.UInt16> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 없는 32비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>합니다.   

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.UInt32> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Numerics.BigInteger" />로 변환할 값입니다.</param>
        <summary>부호 없는 64비트 정수를 <see cref="T:System.Numerics.BigInteger" /> 값으로 변환하는 암시적 변환을 정의합니다.  
  
이 API는 CLS 규격이 아닙니다. 규격 대체 항목은 <see cref="T:System.Double" />입니다.</summary>
        <returns><paramref name="value" /> 매개 변수의 값이 들어 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 연산자를 지원 하지 않는 언어에 대 한 대체 방법은 <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>합니다.   

 오버 로드는 <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> 메서드는 또는 컴파일러 수 자동으로 변환 하는 형식을 정의 <xref:System.Numerics.BigInteger> 가 명시적 캐스트 연산자 (C#) 또는 (Visual Basic)에서는 변환 함수를 호출 하지 않고 값입니다. 확대 변환 데이터가 손실 되지 않습니다 발생 하지 않도록 하는 <xref:System.OverflowException>합니다. 이 오버 로드를 사용 하면 변환에서 처리할 컴파일러는 <xref:System.UInt64> 값을 <xref:System.Numerics.BigInteger> 다음 예제와 같이 값입니다.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">증가시킬 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 1씩 증가합니다.</summary>
        <returns>1씩 증가하는 <paramref name="value" /> 매개 변수의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Increment%2A> 메서드 정의 대 한 증가 연산 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 증가 연산자 부족 또는 연산자 오버 로드를 지원 하지 않습니다 하는 일부 언어 (예: Visual Basic)를 호출할 수는 <xref:System.Numerics.BigInteger.op_Increment%2A> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 때문에 <xref:System.Numerics.BigInteger> 개체를 변경할 수 없는 합니다 <xref:System.Numerics.BigInteger.op_Increment%2A> 연산자를 새로 만듭니다 <xref:System.Numerics.BigInteger> 하나 값인 개체 보다 <xref:System.Numerics.BigInteger> 가 나타내는 개체 `value`합니다. 따라서 반복 호출을 <xref:System.Numerics.BigInteger.op_Increment%2A> 성능이 떨어질 수 있습니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 개의 숫자 값이 다른지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 있는 64비트 정수와 <see cref="T:System.Numerics.BigInteger" /> 값이 다른지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:  
  
-   호출 된 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 인스턴스 간의 관계를 나타내는 메서드를를 <xref:System.Numerics.BigInteger> 부호 있는 정수 (long) 값입니다.  
  
-   호출 된 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 인스턴스 메서드 및 해당 값을 반전 합니다.  
  
 경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값과 부호 있는 64비트 정수가 다른지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:  
  
-   호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 간의 관계를 나타내는 메서드를 <xref:System.Numerics.BigInteger> 부호 있는 정수 (long) 값.  
  
-   호출 된 <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.  
  
 경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 개체의 값이 다른지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:  
  
-   호출 된 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> 간 관계를 나타내는 메서드를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
-   호출 된 <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값과 부호 없는 64비트 정수가 다른지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:  
  
-   호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 간의 관계를 나타내는 <xref:System.Numerics.BigInteger> 부호 없는 정수 (long) 값입니다.  
  
-   호출 된 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 없는 64비트 정수와 <see cref="T:System.Numerics.BigInteger" /> 값이 다른지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />과 <paramref name="right" />가 다르면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Inequality%2A> 같지 않음 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어는 다음 방법 중 하나를 사용 하 여 같지 않은지 테스트할 수 있습니다.:  
  
-   호출을 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 간의 관계를 나타내는 <xref:System.Numerics.BigInteger> 부호 없는 정수 (long) 값입니다.  
  
-   호출 된 <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> 메서드 및 해당 값을 반전 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">비트를 이동할 값입니다.</param>
        <param name="shift"><paramref name="value" />를 왼쪽으로 이동할 비트 수입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 지정된 비트 수만큼 왼쪽으로 이동합니다.</summary>
        <returns>지정된 비트 수만큼 왼쪽으로 이동한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LeftShift%2A> 메서드 정의 작업에 대 한 비트 왼쪽 시프트 연산자의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  정수 기본 요소를 사용 하 여 비트 왼쪽 시프트 작업과 달리 합니다 <xref:System.Numerics.BigInteger.op_LeftShift%2A> 메서드는 원래의 부호를 유지 <xref:System.Numerics.BigInteger> 값입니다.  
  
 사용자 지정 연산자를 지원 하지 않는 언어와 왼쪽 시프트 연산을 수행할 수 `value` 여 `BigInteger.Pow(2, shift)`입니다. 다음 예제에서는 결과 동일한이 연산자를 사용 하 여 결과에 표시 됩니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 값이 지정된 두 번째 값보다 작은지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 있는 64비트 정수보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> 메서드 대신 합니다. 일부 언어는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 없는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThan%2A> 메서드를 보다 작음 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 값이 지정된 다른 값보다 작거나 같은지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 있는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 경우 `left` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 있는 64비트 정수보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 경우 `right` 은 <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, 또는 <xref:System.UInt32> 값을 암시적으로 변환할는 <xref:System.Int64> 작업을 수행할 때 값입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 다른 <see cref="T:System.Numerics.BigInteger" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Compare%2A> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값이 부호 없는 64비트 정수보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 값입니다.</param>
        <param name="right">비교할 두 번째 값입니다.</param>
        <summary>부호 없는 64비트 정수가 <see cref="T:System.Numerics.BigInteger" /> 값보다 작거나 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><paramref name="left" />가 <paramref name="right" />보다 작거나 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> 메서드 정의의 작업에 대 한 운영자에 게 less than 또는 equal <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> 메서드 대신 합니다. 호출할 수도 있습니다는 <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> 메서드를 직접 다음 예제와 같이 보여 줍니다.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">나눌 대상 값입니다.</param>
        <param name="divisor">나눌 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Numerics.BigInteger" /> 값을 나눈 나머지를 반환합니다.</summary>
        <returns>나눈 나머지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Modulus%2A> 메서드는 모듈러스 연산자에 대 한 작업 정의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> 메서드 대신 합니다.  
  
 모듈러스 연산에서 반환 된 값의 부호의 부호에 따라 달라 집니다 `dividend`: 경우 `dividend` 이 양수인 경우 모듈러스 연산 결과도 양의; 모듈러스 연산 음수 이면 음수 결과 반환 합니다. 모듈러스 작업의 동작 <xref:System.Numerics.BigInteger> 값이 다른 정수 형식과 함께 모듈러스 연산과 동일 합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />가 0인 경우</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">곱할 첫 번째 값입니다.</param>
        <param name="right">곱할 두 번째 값입니다.</param>
        <summary>지정된 두 <see cref="T:System.Numerics.BigInteger" /> 값을 곱합니다.</summary>
        <returns><paramref name="left" />와 <paramref name="right" />의 곱입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Multiply%2A> 메서드 정의 작업에 대 한 곱하기 연산자의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">정수 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값에 대한 비트 1의 보수를 반환합니다.</summary>
        <returns><paramref name="value" />에 대한 비트 1의 보수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> 비트의 작업을 정의 하는 방법에 대 한 1의 보수 연산자 <xref:System.Numerics.BigInteger> 값입니다. 숫자 값에서 각가 비트 비트 1의 보수 연산자를 반대로 바꿉니다. 즉,에서 비트 `value` 된 0 결과 1로 설정 되 고 1 인 비트 결과에 0으로 설정 됩니다. <xref:System.Numerics.BigInteger.op_OnesComplement%2A> 메서드를 사용 하면 다음과 같은 코드가 있습니다.  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출 하는 일을 할 수 있습니다는 <xref:System.Numerics.BigInteger.op_OnesComplement%2A> 1의 연산을 수행 하려면 직접 메서드 작업을 보완 합니다. 예:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">비트를 이동할 값입니다.</param>
        <param name="shift"><paramref name="value" />를 오른쪽으로 이동할 비트 수입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 지정된 비트 수만큼 오른쪽으로 이동합니다.</summary>
        <returns>지정된 비트 수만큼 오른쪽으로 이동한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_RightShift%2A> 메서드 정의 작업에 대 한 비트 오른쪽 시프트 연산자의 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 언어 사용자 지정 연산자를 지원 하지 않는 나누어 비트 오른쪽 시프트 연산을 수행할 수 `value` 하 여 `BigInteger.Pow(2, shift)` 을 1 시간을 빼는 방법 `shift` 음수 값에 대 한 합니다. 다음 예제에서는 결과 동일한이 연산자를 사용 하 여 결과에 표시 됩니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 하는 경우 `shift` 보다 크거나 양수의 비트 수와 같고 <xref:System.Numerics.BigInteger> 값을 오른쪽 시프트 연산의 결과 <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>합니다. 하는 경우 `shift` 음수의 비트 수보다 크면 <xref:System.Numerics.BigInteger> 값을 오른쪽 시프트 연산의 결과 <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">뺄 대상 값(피감수)입니다.</param>
        <param name="right">뺄 값(감수)입니다.</param>
        <summary>다른 <see cref="T:System.Numerics.BigInteger" /> 값에서 <see cref="T:System.Numerics.BigInteger" /> 값을 뺍니다.</summary>
        <returns><paramref name="left" />에서 <paramref name="right" />를 뺀 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_Subtraction%2A> 빼기 연산자에 대 한 작업을 정의 하는 메서드 <xref:System.Numerics.BigInteger> 값입니다. 다음과 같은 코드 수 있도록 합니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> 메서드 대신 합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>합니다.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">부정할 값입니다.</param>
        <summary>지정된 BigInteger 값을 부정합니다.</summary>
        <returns><paramref name="value" /> 매개 변수에 -1을 곱한 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> 메서드는 단항 부정 연산자 (또는 덧셈 역 원을 연산자)의 작업에 대 한 정의 <xref:System.Numerics.BigInteger> 값입니다. 작업 원본 수를 추가할 때 0 (영)에서 발생 하는 값을 생성 합니다. 사용자 지정 연산자를 지원 하지 않는 언어를 호출할 수는 <xref:System.Numerics.BigInteger.Negate%2A> 메서드 대신 합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예의 값을 부정 하는 세 가지를 <xref:System.Numerics.BigInteger> 개체입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">정수 값입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 피연산자의 값을 반환합니다. 피연산자의 부호는 변경되지 않습니다.</summary>
        <returns><paramref name="value" /> 피연산자의 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> 메서드 정의 대 한 단항 부정 연산자 연산의 <xref:System.Numerics.BigInteger> 값입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 해당하는 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">변환할 숫자가 포함된 문자열입니다.</param>
        <summary>숫자의 문자열 표현을 해당하는 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</summary>
        <returns><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 매개 변수 형식은 숫자의 문자열 표현 이어야 합니다.  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다.|  
|*sign*|가 선택적 부호입니다. 유효한 부호 문자는 기준 합니다 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다.|  
|*digits*|0에서 9 까지의 숫자 시퀀스입니다. 모든 선행 0은 무시 됩니다.|  
  
> [!NOTE]
>  지정 된 문자열을 `value` 매개 변수를 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> 스타일입니다. 그룹 구분 기호나 소수 구분 기호를 포함할 수 없습니다 하며에 소수 부분이 없습니다.  
  
 `value` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> 현재 시스템 문화권에 대 한 초기화 되는 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>를 참조하십시오. 특정 문화권의 서식 지정 정보를 사용 하 여 문자열의 구문을 분석을 사용 하 여를 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드.  
  
> [!IMPORTANT]
>  사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다. 이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.Parse%28System.String%29> 메서드를 두 <xref:System.Numerics.BigInteger> 개체입니다. 각 개체는 다른 수를 곱하고 그 다음 호출을 <xref:System.Numerics.BigInteger.Compare%2A> 두 값 간의 관계를 확인 하는 방법입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />가 올바른 형식이 아닙니다.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style"><paramref name="value" />에 사용할 수 있는 서식을 지정하는 열거형 값의 비트 조합입니다.</param>
        <summary>숫자를 지정된 스타일로 나타낸 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</summary>
        <returns><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `style` 매개 변수 (예: 공백, 양수 또는 음수 기호, 그룹 구분 기호 또는 소수점 기호)에 사용할 수 있는 스타일 요소를 정의 합니다 `value` 구문 분석 작업이 성공 하기 위해 매개 변수입니다. `styles` 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 합니다 `style` 매개 변수 오버 로드 유용할 경우 이러한 메서드를 만듭니다 `value` 수 시스템 (10 진수 또는 16 진수)을 나타내는 16 진수 값의 문자열 표현이 포함 되어 `value` 실행된 시간에만 알려진 때나 있습니다 공백 문자를 허용 하지 않도록 하거나 부호 기호를 `value`입니다.  
  
 값에 따라 `style`, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 하는 경우 `style` 포함 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [*ws*]*hexdigits*[*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다. 공백의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그 합니다.|  
|*$*|Culture 별 통화 기호입니다. 문자열에 해당 위치는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다. 현재 문화권의 통화 기호에 나타날 수 있습니다 `value` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그 합니다.|  
|*sign*|가 선택적 부호입니다. 로그인의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그. 괄호를 사용할 수 있습니다 `value` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|0부터 9 까지의 숫자 시퀀스입니다. 에 대 한 *소수 자릿수*숫자 0 유효만 합니다.|  
|*,*|Culture 별 그룹 구분 기호입니다. 현재 문화권의 그룹 구분 기호에 나타날 수 있습니다 `value` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.|  
|*.*|Culture 별 소수점 기호입니다. 현재 문화권의 소수점 기호에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다. 구문 분석 작업이 성공 하기 위해 소수 자릿수로 숫자 0만 나타날 수 있습니다. 경우 *소수 자릿수* 다른 숫자를 포함 한 <xref:System.FormatException> throw 됩니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.|  
|*hexdigits*|16 진수 숫자 0 ~ f 또는 0 ~ 6. 시퀀스|  
  
> [!NOTE]
> 종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.

 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 대부분 <xref:System.Globalization.NumberStyles> 멤버가 있을 수 있지만 입력된 문자열에 나타날 수 필요가 없습니다 요소를 제어할 수 있습니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 멤버에 나타날 수 있는 요소에 영향을 줄 `value`합니다.  
  
|`NumberStyles` 값|허용 되는 요소 `value` 숫자 외에도|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|합니다 *자릿수* 요소에만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (.) 및 *소수 자릿수* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자를 함께 지 수 표기법으로 나타냅니다 *지 수 표기법*합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|합니다 *ws* 의 시작 부분에 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|합니다 *ws* 의 끝에 있는 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|합니다 *sign* 의 시작 부분에 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|합니다 *sign* 의 끝에 있는 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|그룹 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `value` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|합니다 *ws* 시작 또는 끝에 요소 `value`, *로그인* 의 시작 부분에 `value`, 및 소수점 (*.*) 기호입니다. `value` 매개 변수 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, 그룹 구분 기호 (*,*), 소수점 및 (*.*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `value` 16 진수 숫자를 나타낼 수 없습니다.|  
  
> [!IMPORTANT]
>  사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다. 이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.  
  
 다른 달리 <xref:System.Globalization.NumberStyles> 값을 허용 하지만 특정 스타일 요소에 있으면 필요 하지 않습니다 `value`서 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 스타일 값의 개별 숫자 문자를 의미 `value` 항상로 해석 됩니다 16 진수 문자입니다. 유효한 16 진수는 0-9, A-f 및 a-f 문자입니다. 만 다른 플래그와 결합 될 수 있는 합니다 `style` 매개 변수에 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>합니다. (합니다 <xref:System.Globalization.NumberStyles> 열거형은 복합 숫자 스타일을 포함 <xref:System.Globalization.NumberStyles.HexNumber>, 모두 공백 플래그를 포함 하는.)  
  
> [!NOTE]
>  하는 경우 `value` 문자열 표현인 16 진수 숫자의 고 수 없습니다. 뒤에 야 모든 장식 (같은 `0x` 또는 `&h`) 16 진수 숫자로 구분 하는 합니다. 이렇게 하면 변환이 실패할 수 있습니다.  
  
 경우 `value` 16 진수 문자열을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 보다 크거나 같습니다 `value` 음수로 처음 두 16 진수 보다 크거나 같은 경우에 2의 보수 표현이 사용 하 여 저장 `0x80`합니다. 메서드는 첫 번째 바이트의 최상위 비트를 해석 하는 즉, `value` 부호 비트로입니다. 16 진수 문자열에서 첫 번째 숫자가 양수 숫자로 해석 됩니다 있도록 `value` 0의 값이 있어야 합니다. 예를 들어이 메서드는 해석 `0x80` 음수 값을 해석 하거나 대로 `0x080` 또는 `0x0080` 양수 값으로. 다음 예에서는 양수 및 음수 값을 나타내는 16 진수 문자열 간의 차이점을 보여 줍니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 `value` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 시스템 문화권에 대 한 초기화 되는 개체입니다. 서식 지정 정보를 가져올 구문 분석 작업에 사용 되는 문화권을 지정 하려면 호출을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 오버 로드 합니다.  
  
   
  
## Examples  
 다음 예제에 대 한 호출을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 에 대 한 몇 가지 가능한 값을 사용 하 여 메서드를 `style` 매개 변수. 16 진수 값으로 문자열을 해석 하는 방법 및 공간을 허용 하지 않습니다 하 고 기호를 서명 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  
  
또는 
 <paramref name="style" />에는 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 또는 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 플래그가 다른 값과 함께 포함됩니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />는 <see cref="T:System.Globalization.NumberStyles" />에 의해 지정된 입력 패턴에 맞지 않습니다.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="provider"><paramref name="value" />에 대한 문화권별 서식 정보를 제공하는 개체입니다.</param>
        <summary>숫자를 지정된 문화권별 형식으로 나타낸 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</summary>
        <returns><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 매개 변수 형식은 숫자의 문자열 표현 이어야 합니다.  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다.|  
|*sign*|가 선택적 부호입니다. 유효한 부호 문자에 의해 결정 됩니다는 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 의 속성을 <xref:System.Globalization.NumberFormatInfo> 에서 반환 되는 개체를 `provider` 개체의 <xref:System.IFormatProvider.GetFormat%2A> 메서드.|  
|*digits*|0에서 9 까지의 숫자 시퀀스입니다. 모든 선행 0은 무시 됩니다.|  
  
> [!NOTE]
>  지정 된 문자열을 `value` 매개 변수를 사용 하 여 해석 됩니다는 <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> 스타일입니다. 그룹 구분 기호나 소수 구분 기호를 포함할 수 없습니다 하며에 소수 부분이 없습니다.  
  
> [!IMPORTANT]
>  사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다. 이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.  
  
 `provider` 매개 변수는는 <xref:System.IFormatProvider> 구현입니다 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> culture 별 서식 지정 정보를 제공 하는 개체. 경우는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> 메서드가 호출 되 면 호출를 `provider` 매개 변수의 <xref:System.IFormatProvider.GetFormat%2A> 메서드 전달를 <xref:System.Type> 나타내는 개체를 <xref:System.Globalization.NumberFormatInfo> 형식. <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 됩니다 합니다 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 정보를 제공 하는 `value` 매개 변수입니다. 사용 하는 방법은 세 가지를 `provider` 매개 변수를 구문 분석 작업에 사용자 지정 서식 지정 정보를 제공 합니다.  
  
-   전달할 수는 <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 문화권에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.  
  
-   실제 전달할 수 있습니다 <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다. (해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체를 전달할 수 있습니다 <xref:System.IFormatProvider>합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 경우 `provider` 됩니다 `null`의 서식을 `value` 기준으로 해석 됩니다는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 서식 지정에 대 한 음수 부호로 물결표 (~)를 정의 하는 방법을 보여 줍니다 <xref:System.Numerics.BigInteger> 값입니다. 표시 하는 합니다 <xref:System.Numerics.BigInteger> 같은 형식으로 원본 문자열 값을 코드를 호출 해야 합니다는 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 메서드 전달는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 구현 하는 클래스를 정의 하는 첫 번째 예제 <xref:System.IFormatProvider> 사용 하는 <xref:System.IFormatProvider.GetFormat%2A> 반환 하는 방법의 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 <xref:System.Numerics.BigInteger> 다음 코드를 사용 하 여 개체를 인스턴스화할 수 있습니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 두 번째 예제는 더 간단 합니다. 전달 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체는 `provider` 매개 변수입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />가 올바른 형식이 아닙니다.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">변환할 숫자가 포함된 문자열입니다.</param>
        <param name="style"><paramref name="value" />에 사용할 수 있는 서식을 지정하는 열거형 값의 비트 조합입니다.</param>
        <param name="provider"><paramref name="value" />에 대한 문화권별 서식 정보를 제공하는 개체입니다.</param>
        <summary>지정된 스타일 및 문화권별 형식으로 된 숫자의 문자열 표현을 해당하는 <see cref="T:System.Numerics.BigInteger" />로 변환합니다.</summary>
        <returns><paramref name="value" /> 매개 변수에 지정된 숫자에 해당하는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `style` 매개 변수 (예: 공백, 양수 또는 음수 기호, 그룹 구분 기호 또는 소수점 기호)에 사용할 수 있는 스타일 요소를 정의 합니다 `value` 구문 분석 작업이 성공 하기 위해 매개 변수입니다. `styles` 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 합니다 `style` 매개 변수 오버 로드 유용할 경우 이러한 메서드를 만듭니다 `value` 수 시스템 (10 진수 또는 16 진수)을 나타내는 16 진수 값의 문자열 표현이 포함 되어 `value` 실행된 시간에만 알려진 때나 있습니다 공백 문자를 허용 하지 않도록 하거나 부호 기호를 `value`입니다.  
  
 값에 따라 `style`, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 하는 경우 `style` 포함 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [*ws*]*hexdigits*[*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다. 공백의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그 합니다.|  
|*$*|Culture 별 통화 기호입니다. 문자열의 해당 위치에서 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> 하 고 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> 문화권의 속성에 나타난를 `provider` 매개 변수입니다. 현재 문화권의 통화 기호에 나타날 수 있습니다 `value` 하는 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그 합니다.|  
|*sign*|가 선택적 부호입니다. 로그인의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그. 괄호를 사용할 수 있습니다 `value` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|0부터 9 까지의 숫자 시퀀스입니다. 에 대 한 *소수 자릿수*숫자 0 유효만 합니다.|  
|*,*|Culture 별 그룹 구분 기호입니다. 지정 된 문화권의 그룹 구분 기호 `provider` 에 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그 합니다.|  
|*.*|Culture 별 소수점 기호입니다. 지정 된 문화권의 소수점 기호 `provider` 에 나타날 수 있습니다 `value` 하는 경우 `style` 포함는 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다. 구문 분석 작업이 성공 하기 위해 소수 자릿수로 숫자 0만 나타날 수 있습니다. 경우 *소수 자릿수* 다른 숫자를 포함 한 <xref:System.FormatException> throw 됩니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.|  
|*hexdigits*|16 진수 숫자 0 ~ f 또는 0 ~ 6. 시퀀스|  
  
> [!NOTE]
> 종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.

 숫자만 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 스타일) 항상 성공적으로 구문 분석 합니다. 나머지 대부분 <xref:System.Globalization.NumberStyles> 멤버가 있을 수 있지만 입력된 문자열에 나타날 수 필요가 없습니다 요소를 제어할 수 있습니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 멤버에 나타날 수 있는 요소에 영향을 줄 `value`합니다.  
  
|NumberStyles 값|숫자 외에도 값에 허용 되는 요소|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|합니다 *자릿수* 요소에만 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (.) 및 *소수 자릿수* 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자를 지 수 표기법을 나타냅니다. 와 함께 *지 수 표기법*합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|합니다 *ws* 의 시작 부분에 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|합니다 *ws* 의 끝에 있는 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|합니다 *sign* 의 시작 부분에 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|합니다 *sign* 의 끝에 있는 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|그룹 구분 기호 (,) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 ($) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `value` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|*ws* 시작 또는 끝에 요소 `value`, *sign* 의 시작 부분에 `value`, 및 소수점 (.). `value` 매개 변수 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|합니다 `ws`, `sign`, 그룹 구분 기호 (,), 및 소수점 (.) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `value` 16 진수 숫자를 나타낼 수 없습니다.|  
  
> [!IMPORTANT]
>  사용 하는 경우는 <xref:System.Numerics.BigInteger.Parse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다. 이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.Parse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.  
  
 다른 달리 <xref:System.Globalization.NumberStyles> 값을 허용 하지만 특정 스타일 요소에 존재 하지 않아도 `value`의 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 스타일 값 즉 숫자의 개별 문자에서 `value` 항상로 해석 됩니다 16 진수 문자입니다. 유효한 16 진수는 0-9, A-f 및 a-f 문자입니다. 만 다른 플래그와 결합 될 수 있는 합니다 `style` 매개 변수에 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>합니다. (합니다 <xref:System.Globalization.NumberStyles> 열거형은 복합 숫자 스타일을 포함 <xref:System.Globalization.NumberStyles.HexNumber>, 모두 공백 플래그를 포함 하는.)  
  
> [!NOTE]
>  하는 경우 `value` 문자열 표현인 16 진수 숫자의 고 수 없습니다. 뒤에 야 모든 장식 (같은 `0x` 또는 `&h`) 16 진수 숫자로 구분 하는 합니다. 이렇게 하면 변환이 실패할 수 있습니다.  
  
 경우 `value` 16 진수 문자열을 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> 보다 크거나 같습니다 `value` 음수로 처음 두 16 진수 보다 크거나 같은 경우에 2의 보수 표현이 사용 하 여 저장 `0x80`합니다. 메서드는 첫 번째 바이트의 최상위 비트를 해석 하는 즉, `value` 부호 비트로입니다. 16 진수 문자열에서 첫 번째 숫자가 양수 숫자로 해석 됩니다 있도록 `value` 0의 값이 있어야 합니다. 예를 들어이 메서드는 해석 `0x80` 음수 값을 해석 하거나 대로 `0x080` 또는 `0x0080` 양수 값으로. 다음 예에서는 양수 및 음수 값을 나타내는 16 진수 문자열 간의 차이점을 보여 줍니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 문화권별 형식 정보를 제공 하는 `value`합니다. 일반적으로 `provider` 다음 중 하나일 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> 숫자 형식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다.  
  
-   <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다. (해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체 <xref:System.IFormatProvider> 사용 하는 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 인스턴스화하고 반환 하는 메서드는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 하는 경우 `provider` 됩니다 `null`는 <xref:System.Globalization.NumberFormatInfo> 개체가 현재 문화권이 사용 됩니다.  
  
   
  
## Examples  
 다음 예에서는 몇 번 호출 하는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 다양 한 조합에 대 한 값을 사용 하 여 메서드를 `style` 및 `provider` 매개 변수입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 에 대 한 개별 호출 수를 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드는 다음의 인스턴스를 전달 `BigIntegerFormatProvider` 음수 부호와 물결표 (~)를 정의 하는 클래스입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  
  
또는 
 <paramref name="style" />에는 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 또는 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 플래그가 다른 값과 함께 포함됩니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" />는 <paramref name="style" />에 의해 지정된 입력 패턴에 맞지 않습니다.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><paramref name="exponent" /> 지수로 사용할 숫자입니다.</param>
        <param name="exponent"><paramref name="value" />를 거듭제곱할 지수입니다.</param>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 지정된 값의 거듭제곱으로 변환합니다.</summary>
        <returns><paramref name="value" />를 <paramref name="exponent" />번 거듭제곱한 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.Pow%2A> 메서드 1을 반환 하는 경우 또는 지 수 매개 변수 값이 0 인 경우의 값이 모두를 `value` 및 `exponent` 매개 변수는 0입니다. 경우 `exponent` 가 1 이면 합니다 <xref:System.Numerics.BigInteger.Pow%2A> 메서드가 반환 되는 `value`합니다. 경우 `value` 가 음수인 경우 메서드는 음수 결과 반환 합니다.  
  
 에 해당 하는이 메서드는 <xref:System.Math.Pow%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
   
  
## Examples  
 다음 예제를 사용 하 여 지 수는 <xref:System.Numerics.BigInteger> 값과 값 범위는 0에서 10 지 수입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" />가 음수입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">나눌 대상 값입니다.</param>
        <param name="divisor">나눌 값입니다.</param>
        <summary>두 <see cref="T:System.Numerics.BigInteger" /> 값에 대해 정수 나누기를 수행합니다.</summary>
        <returns><paramref name="dividend" />를 <paramref name="divisor" />로 나눈 나머지입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 나머지의 부호는의 부호는 `dividend` 매개 변수입니다.  
  
 <xref:System.Numerics.BigInteger.Remainder%2A> 메서드는 사용자 지정 연산자를 지원 하지 않는 언어에 대 한 구현 됩니다. 해당 동작 나누기 모듈러스 연산자를 사용 하는 것과 동일 합니다.  
  
 경우 필요한 메서드에서 자동으로 수행 하는 다른 정수 계열 형식으로의 암시적 변환 <xref:System.Numerics.BigInteger> 나머지 작업을 수행 하기 전에 개체입니다.  
  
   
  
## Examples  
 다음 예제를 비교 합니다 <xref:System.Numerics.BigInteger.DivRem%2A> 반환한 나머지 메서드는 <xref:System.Numerics.BigInteger.Remainder%2A> 에 두 메서드에 동일한 나머지를 계산 하는 설정 하는 방법입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" />가 0인 경우</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 부호(음수, 양수 또는 0)를 나타내는 숫자를 가져옵니다.</summary>
        <value>다음 표와 같이 <see cref="T:System.Numerics.BigInteger" /> 개체의 부호를 나타내는 숫자입니다.  
  
 <list type="table"><listheader><term> 수 
 </term><description> 설명 
 </description></listheader><item><term> -1 
 </term><description> 이 개체의 값이 음수입니다.  
  
 </description></item><item><term> 0 
 </term><description> 이 개체의 값이 0입니다.  
  
 </description></item><item><term> 1 
 </term><description> 이 개체의 값이 양수입니다.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.Sign%2A> 속성은 해당 하는 <xref:System.Math.Sign%2A?displayProperty=nameWithType> 기본 숫자 형식에 대 한 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">뺄 대상 값(피감수)입니다.</param>
        <param name="right">뺄 값(감수)입니다.</param>
        <summary>다른 값에서 하나의 <see cref="T:System.Numerics.BigInteger" /> 값을 뺀 결과를 반환합니다.</summary>
        <returns><paramref name="left" />에서 <paramref name="right" />를 뺀 결과입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 연산자를 지원 하지 않는 언어에서 사용할 수는 <xref:System.Numerics.BigInteger.Subtract%2A> 빼기를 사용 하 여 수행 하는 방법 <xref:System.Numerics.BigInteger> 값입니다.  
  
 합니다 <xref:System.Numerics.BigInteger.Subtract%2A> 인스턴스화할 때 메서드는 빼기 연산자에 대 한 유용한 대체는 <xref:System.Numerics.BigInteger> 다음 예와에서 같이 빼기, 결과로 생성 되는 차이점을 할당 하 여 변수입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Numerics.BigInteger" /> 값을 바이트 배열로 변환합니다.</summary>
        <returns>현재 <see cref="T:System.Numerics.BigInteger" /> 개체를 바이트 배열로 변환한 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에서 반환 된 배열의 각 바이트는 little endian 순서로 표시 됩니다. 즉, 값의 낮은 순서 바이트 고차 바이트 앞에 야 합니다. 배열의 첫 번째 바이트의 처음 8 비트를 반영 합니다 <xref:System.Numerics.BigInteger> 다음 8 비트를 등에 값, 두 번째 바이트를 반영 합니다. 예를 들어, 1024, 값 또는 0x0400에는 다음 2 바이트 배열로 저장 됩니다.  
  
|요소|바이트 값|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 음수 값은 2의 보수 표현이 가장 간단한 가능한 폼에서 사용 하 여 배열에 기록 됩니다. 예를 들어,-1은 값이 단일 바이트도 표시 됩니다 `0xFF` 대신 여러 요소가 있는 배열로 같은 `0xFF`, `0xFF` 또는 `0xFF`, `0xFF`를 `0xFF`, `0xFF`합니다.  
  
 2의 보수 표현이 항상 때문에 해석 마지막 바이트 배열에서 가장 높은 순위의 비트 (위치의 바이트 <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) 부호 비트로 메서드는 값이 0 인 추가 요소를 사용 하 여 바이트 배열을 반환 하려면 설정 하 여 기호 비트를 가진 것으로 해석 될 수도 있는 양수 값을 구분 합니다. 예를 들어 값이 120 또는 `0x78` 단일 바이트 배열로 표시 됩니다: `0x78`합니다. 그러나 128, 또는 `0x80`, 2 바이트 배열로 표시 됩니다: `0x80`, `0x00`합니다.  
  
 왕복할 수 있습니다는 <xref:System.Numerics.BigInteger> 를 사용 하 여 다음 복원 하는 바이트 배열에 저장 하 여 값을 <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> 생성자입니다.  
  
> [!CAUTION]
>  코드 값을 복원 하기 전에이 메서드에서 반환 된 배열의 각 바이트의 값을 수정 해야 부호 비트 실수로 변경 하지 마십시오. 예를 들어 가장 높은 순위의 비트 바이트 배열의 마지막 요소에는 양수 값을 늘리면 됩니다 설정 값이 배열의 끝에 0 인 새 바이트를 추가할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 몇 가지 방법을 보여 줍니다 <xref:System.Numerics.BigInteger> 바이트 배열에 값 표시 됩니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns>현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString> 메서드 형식을 <xref:System.Numerics.BigInteger> 값 "R" 또는 왕복을 현재 문화권의 형식입니다. 다른 형식으로 또는 문화권을 지정 하려는 경우 사용 하 여 다른 오버 로드는 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 다음과 같이:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 형식|특정 문화권|<xref:System.Numerics.BigInteger.ToString%2A>|  
|특정 형식|기본 (현재) 문화권|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|특정 형식|특정 문화권|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 문자열 표현 된 <xref:System.Numerics.BigInteger> 값 앞에 오는 0 없이 0에서 9 까지의 숫자 시퀀스와 음수 값이 음수 기호가 포함 되어 있습니다. 음수 기호를 정의한는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 표시 된 <xref:System.Numerics.BigInteger> 기본값을 사용 하 여 값 <xref:System.Numerics.BigInteger.ToString> 메서드. 또한의 문자열 표현을 표시 합니다 <xref:System.Numerics.BigInteger> 일부 표준 서식 지정자를 사용 하 여 얻은 값. 예제에서는 EN-US 문화권의 서식 규칙을 사용 하 여 표시 됩니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 문화권별 서식 지정 정보를 사용하여 현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns><paramref name="provider" /> 매개 변수로 지정된 서식에 따른 현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> 메서드 형식을 <xref:System.Numerics.BigInteger> 값 "R" 또는 왕복에서 사용 하 여 서식을 <xref:System.Globalization.NumberFormatInfo> 지정된 된 문화권의 개체입니다. 다른 오버 로드를 사용 하 여 현재 문화권 또는 다른 형식으로 지정 하려는 경우를 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 다음과 같이 합니다.  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 형식|기본 (현재) 문화권|<xref:System.Numerics.BigInteger.ToString>|  
|특정 형식|기본 (현재) 문화권|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|특정 형식|특정 문화권|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 이 메서드에서 반환 된 문자열의 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다. 경우 `provider` 됩니다 `null`의 <xref:System.Numerics.BigInteger> 값을 사용 하 여 형식이 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다. 유일한 속성을 <xref:System.Globalization.NumberFormatInfo> 의 문자열 표현을 제어 하는 개체를 <xref:System.Numerics.BigInteger> 일반 서식 지정자를 사용 하 여 값이 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, 음수 기호를 나타내는 문자를 정의 하는.  
  
 `provider` 매개 변수는 다음 중 하나일 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다.  
  
-   <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
-   구현 하는 사용자 지정 개체 <xref:System.IFormatProvider>합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정을 인스턴스화하고 <xref:System.Globalization.NumberFormatInfo> 음수 부호로 물결표 (~)를 정의 하는 개체입니다. 합니다 <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> 메서드 사용 하 여 사용자 지정 <xref:System.Globalization.NumberFormatInfo> 음수를 표시할 개체 <xref:System.Numerics.BigInteger> 값입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">표준 또는 사용자 지정 숫자 서식 문자열입니다.</param>
        <summary>지정된 서식을 사용하여 현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당하는 문자열 표현으로 변환합니다.</summary>
        <returns><paramref name="format" /> 매개 변수로 지정된 서식에 따른 현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.ToString%28System.String%29> 메서드 형식을 <xref:System.Numerics.BigInteger> 사용 하 여 지정 된 형식으로 값을 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 규칙을 나타내는 개체입니다. "R" 또는 라운드트립 사용 하려는 경우 형식 또는 다른 문화권을 지정, 다른 오버 로드를 사용 하 여는 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 다음과 같이 합니다.  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 형식|기본 (현재) 문화권|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") 형식|특정 문화권|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|특정 형식|특정 문화권|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 `format` 매개 변수는 유효한 수 있습니다 [표준 숫자 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md), 또는의 임의 조합 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 현재의 반환 값 <xref:System.Numerics.BigInteger> 개체 라운드트립 서식 지정자 ("R")로 포맷 된 합니다. 하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.  
  
 다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   .NET Framework의 서식 지정에 대 한 지원에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 반환된 된 문자열의 형식은 의해 결정 되는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다. 에 따라는 `format` 매개 변수를이 개체는 출력 문자열에 소수점 기호가 음수 기호, 그룹 구분 기호 등 기호를 제어 합니다. 현재 문화권이 아닌 문화권에 대 한 서식 지정 정보를 제공 하려면 호출을 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 오버 로드 합니다.  
  
   
  
## Examples  
 다음 예제에서는 초기화를 <xref:System.Numerics.BigInteger> 값 및 각 표준 형식 문자열 및 일부 사용자 지정 형식 문자열을 사용 하 여 표시 합니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />은 유효한 서식 문자열이 아닙니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">표준 또는 사용자 지정 숫자 서식 문자열입니다.</param>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <summary>지정된 형식 및 문화권별 형식 정보를 사용하여 현재 <see cref="T:System.Numerics.BigInteger" /> 개체의 숫자 값을 해당 문자열 표현으로 변환합니다.</summary>
        <returns><paramref name="format" /> 및 <paramref name="provider" /> 매개 변수로 지정된 현재 <see cref="T:System.Numerics.BigInteger" /> 값의 문자열 표현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드 형식을 <xref:System.Numerics.BigInteger> 를 사용 하 여 지정 된 형식으로 값을 <xref:System.Globalization.NumberFormatInfo> 지정된 된 문화권의 개체입니다. 다른 오버 로드를 사용 하 여 라운드 트립 형식 또는 기본 문화권 설정을 사용 하려는 경우는 <xref:System.Numerics.BigInteger.ToString%2A> 같이 메서드:  
  
|형식을 사용 하려면|문화권에 대 한|오버 로드를 사용 합니다.|  
|-------------------|-----------------|----------------------|  
|Round-trip ("R") 형식|기본 (현재) 문화권|<xref:System.Numerics.BigInteger.ToString>|  
|Round-trip ("R") 형식|특정 문화권|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|특정 형식|기본 (현재) 문화권|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 `format` 매개 변수는 유효한 수 있습니다 [표준 숫자 문자열](~/docs/standard/base-types/standard-numeric-format-strings.md), 또는의 임의 조합 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 경우 `format` 값과 같음 <xref:System.String.Empty?displayProperty=nameWithType> 아니거나 `null`, 현재의 반환 값 <xref:System.Numerics.BigInteger> 개체 라운드트립 서식 지정자 ("R")로 포맷 된 합니다. 하는 경우 `format` 다른 값을 메서드가 throw를 <xref:System.FormatException>입니다.  
  
 다음 서식 항목에서 자세히 설명 되어 광범위 한 형식 지정 지원을 제공 하는.NET Framework:  
  
-   숫자 서식 지정자에 대 한 자세한 내용은 참조 하세요. [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [사용자 지정 숫자 서식 문자열](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다.  
  
-   .NET Framework의 서식 지정에 대 한 지원에 대 한 자세한 내용은 참조 하세요. [형식](~/docs/standard/base-types/formatting-types.md)합니다.  
  
 합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 이 메서드에서 반환 된 문자열의 형식에 대 한 문화권별 형식 정보를 제공 하는 개체입니다. 경우는 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드가 호출 되 면 호출를 `provider` 매개 변수의 <xref:System.IFormatProvider.GetFormat%2A> 메서드 전달를 <xref:System.Type> 나타내는 개체를 <xref:System.Globalization.NumberFormatInfo> 형식. <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 됩니다 합니다 <xref:System.Globalization.NumberFormatInfo> 서식 지정에 대 한 정보를 제공 하는 개체는 `value` 소수점 기호가 음수 기호, 그룹 구분 기호 등의 매개 변수입니다. 세 가지 방법으로 사용 하는 `provider` 매개 변수 형식 지정 정보를 제공 하기는 <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> 메서드:  
  
-   전달할 수는 <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 문화권에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.  
  
-   실제 전달할 수 있습니다 <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다. (해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체를 전달할 수 있습니다 <xref:System.IFormatProvider>합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 경우 `provider` 됩니다 `null`를 기반으로 반환된 된 문자열의 서식을 <xref:System.Globalization.NumberFormatInfo> 현재 문화권의 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 초기화 된 <xref:System.Numerics.BigInteger> 값을 표준 형식 문자열을 사용 하 여 콘솔에 표시 및 <xref:System.Globalization.NumberFormatInfo> 음수 부호로 물결표 (~)를 정의 하는 개체입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" />은 유효한 서식 문자열이 아닙니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숫자의 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환하고, 변환에 성공했는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">숫자의 문자열 표현입니다.</param>
        <param name="result">이 메서드가 반환되면 <paramref name="value" />에 포함된 숫자 또는 변환에 실패한 경우 0에 해당하는 <see cref="T:System.Numerics.BigInteger" />를 포함합니다. <paramref name="value" /> 매개 변수가 <see langword="null" />이거나 올바른 서식이 아니면 변환에 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>숫자의 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환하고, 변환에 성공했는지를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />가 성공적으로 변환되었으면 <paramref name="value" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> 메서드와 비슷합니다는 <xref:System.Numerics.BigInteger.Parse%28System.String%29> 메서드와 변환에 실패 하면 예외를 throw 하지 않습니다. 이 메서드는 테스트 하기 위해 예외 처리를 사용할 필요가 없습니다를 <xref:System.FormatException> 경우 `value` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 `value` 매개 변수 형식은 10 진수 숫자의 문자열 표현 이어야 합니다.  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다.|  
|*sign*|가 선택적 부호입니다. 유효한 부호 문자는 기준 합니다 <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 현재 문화권의 속성입니다.|  
|*digits*|0에서 9 까지의 10 진수 시퀀스로,|  
  
> [!NOTE]
>  지정 된 문자열을 `value` 매개 변수는 그룹 구분 기호 또는 소수 구분 기호를 포함할 수 없습니다 및 소수 부분이 가질 수 없습니다.  
  
 합니다 `value` 매개 변수를 사용 하 여 해석 되는 <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> 스타일입니다. 10 진수 외에도 선행 및 후행 공백을 앞에 부호가 허용 됩니다. 사용할 수 있는 culture 별 서식 지정 정보를 사용 하 여 스타일 요소를 명시적으로 정의 하려면 `value`를 호출 합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 메서드.  
  
 합니다 `value` 매개 변수에서 서식 지정 정보를 사용 하 여 구문 분석 되는 <xref:System.Globalization.NumberFormatInfo> 현재 문화권에 대 한 개체입니다. 자세한 내용은 <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>를 참조하십시오.  
  
 모든 숫자를 해석 하는이 오버 로드는 `value` 소수 자릿수 매개 변수입니다. 16 진수 숫자의 문자열 표현으로 구문 분석 하려면 호출을 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 오버 로드를 대신 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> 메서드를 두 <xref:System.Numerics.BigInteger> 개체입니다. 각 개체는 다른 수를 곱하고 그 다음 변환이 성공할 경우는 <xref:System.Numerics.BigInteger.Compare%2A> 두 개체 간의 관계를 확인 하는 방법입니다.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">숫자의 문자열 표현입니다. 이 문자열은 <paramref name="style" />이 지정하는 스타일을 사용하여 해석됩니다.</param>
        <param name="style"><paramref name="value" />에 나타날 수 있는 스타일 요소를 나타내는 열거형 값의 비트 조합입니다. 지정할 일반적인 값은 <see cref="F:System.Globalization.NumberStyles.Integer" />입니다.</param>
        <param name="provider"><paramref name="value" />에 대한 문화권별 형식 지정 정보를 제공하는 개체입니다.</param>
        <param name="result">이 메서드가 반환되면 <paramref name="value" />에 포함된 숫자 또는 변환에 실패한 경우 <see cref="T:System.Numerics.BigInteger" />에 해당하는 <see cref="P:System.Numerics.BigInteger.Zero" />를 포함합니다. <paramref name="value" /> 매개 변수가 <see langword="null" />이거나 <paramref name="style" />과 호환되지 않는 서식으로 되어 있으면 변환에 실패합니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>지정된 문화권별 형식과 지정된 스타일을 사용한 숫자의 문자열 표현을 해당 <see cref="T:System.Numerics.BigInteger" />로 변환해 보고, 변환에 성공했는지를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" /> 매개 변수가 변환되었으면 <paramref name="value" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 메서드와 비슷합니다는 <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> 메서드와 변환에 실패 하면 예외를 throw 하지 않습니다. 이 메서드는 테스트 하기 위해 예외 처리를 사용할 필요가 없습니다를 <xref:System.FormatException> 경우 `value` 잘못 되었으며 성공적으로 구문 분석할 수 없습니다.  
  
 합니다 `style` 매개 변수 (예: 공백 또는 양수 또는 음수 기호)에 사용할 수 있는 스타일 요소를 정의 합니다 `value` 구문 분석 작업이 성공 하기 위해 매개 변수입니다. 비트 플래그 조합 이어야 합니다는 <xref:System.Globalization.NumberStyles> 열거형입니다. 값에 따라 `style`, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 경우는 `style` 매개 변수 포함 <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` 매개 변수는 다음 요소가 포함 될 수 있습니다.  
  
 [*ws*]*hexdigits*[*ws*]  
  
 대괄호 ([ 및 ]) 안의 요소는 선택적 요소입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*ws*|선택적 공백입니다. 공백의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 플래그를 또는 끝에 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> 플래그 합니다.|  
|*$*|Culture 별 통화 기호입니다. 문자열의 해당 위치에서 정의 됩니다는 <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> 의 속성을 <xref:System.Globalization.NumberFormatInfo> 에서 반환 된 개체를 <xref:System.IFormatProvider.GetFormat%2A> 메서드의 `provider` 매개 변수. 통화 기호에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> 플래그입니다.|  
|*sign*|가 선택적 부호입니다. 로그인의 시작 부분에 나타날 수 있습니다 `value` 경우 `style` 포함 합니다 <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> 끝에 있고, 나타날 수 있습니다 `value` 경우 `style` 포함를 <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> 플래그. 괄호를 사용할 수 있습니다 `value` 경우 음수 값을 나타내는 데 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> 플래그입니다.|  
|*digits*|0부터 9 까지의 숫자 시퀀스입니다.|  
|*,*|Culture 별 그룹 구분 기호입니다. 에 지정 된 문화권의 그룹 구분 기호 `provider` 에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> 플래그입니다.|  
|*.*|Culture 별 소수점 기호입니다. 에 지정 된 문화권의 소수점 기호가 `provider` 에 나타날 수 있습니다 `value` 경우 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그.|  
|*fractional_digits*|숫자 0 개 이상의 발견 합니다. 소수 자릿수에 나타날 수 있습니다 `value` 경우에만 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> 플래그입니다.|  
|E|"E" 또는 "E" 문자 값은 지 수 (과학적 표기법) 표기법으로 표현 됨을 나타내는입니다. `value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.|  
|*exponential_digits*|0부터 9 까지의 숫자 시퀀스입니다. `value` 매개 변수는 경우 지 수 표기법으로 숫자를 나타낼 수 `style` 포함 된 <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> 플래그.|  
|*hexdigits*|16 진수 숫자 0 ~ f 또는 0 ~ 6. 시퀀스|  
  
> [!NOTE]
> 종료 NUL (U + 0000)에 임의 문자를 `s` 의 값에 관계 없이 구문 분석 작업에서 무시 되는 `style` 인수입니다.

 진수만 포함 된 문자열 (해당 하는 <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> 플래그) 항상 성공적으로 구문 분석 합니다. 나머지 대부분 <xref:System.Globalization.NumberStyles> 멤버 있을 수 있지만 하지 않아도이 입력된 문자열에 나타날 수 있는 요소를 제어 합니다. 다음 표에서 개별 <xref:System.Globalization.NumberStyles> 멤버에 나타날 수 있는 요소에 영향을 줄 `value`합니다.  
  
|비 복합 `NumberStyles` 값|숫자 외에도 값에 허용 되는 요소|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|소수 자릿수에만 해당 합니다.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|소수점 (*합니다.*) 및 *소수 자릿수* 요소입니다. 그러나 *소수 자릿수* 하나 이상의 0 숫자 또는 메서드 반환으로 구성 되어야 합니다 `false`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E" 또는 "E" 문자를 함께 지 수 표기법으로 나타냅니다 *지 수 표기법*합니다. 경우 `value` 숫자를 나타내는 지 수 표기법으로, 소수 자릿수 0이 아닌 구성 요소를 가질 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|합니다 *ws* 의 시작 부분에 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|합니다 *ws* 의 끝에 있는 요소 `value`합니다.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*sign* 앞에 요소 *자릿수*합니다.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|합니다 *기호* 요소 뒤 *자릿수*합니다.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|합니다 *기호* 형식의 숫자 값을 묶는 괄호는 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|그룹 구분 기호 (*,*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|통화 (*$*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Currency>|모든 요소입니다. 그러나 `value` 16 진수 또는 지 수 표기법으로 숫자를에서 나타낼 수 없습니다.|  
|<xref:System.Globalization.NumberStyles.Float>|합니다 *ws* 시작 또는 끝에 요소 `value`, *로그인* 의 시작 부분에 `value`, 및 소수점 (*.*) 기호입니다. `value` 매개 변수 지 수 표기법을 사용할 수도 있습니다.|  
|<xref:System.Globalization.NumberStyles.Number>|*ws*, *로그인*, 그룹 구분 기호 (*,*), 소수점 및 (*.*) 요소입니다.|  
|<xref:System.Globalization.NumberStyles.Any>|모든 요소입니다. 그러나 `value` 16 진수 숫자를 나타낼 수 없습니다.|  
  
> [!IMPORTANT]
>  사용 하는 경우는 <xref:System.Numerics.BigInteger.TryParse%2A> 왕복 문자열 표현 하기 위해의를 <xref:System.Numerics.BigInteger> 의해 출력 된 값을 <xref:System.Numerics.BigInteger.ToString%2A> 메서드를 사용할지를 <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> 의 문자열 표현을 생성 "R" 서식 지정자를 사용 하 여 메서드를 <xref:System.Numerics.BigInteger> 값입니다. 이 고, 그렇지의 문자열 표현 합니다 <xref:System.Numerics.BigInteger> 50 사용 하는 경우 원래 값 및 데이터의 최대 유효 자릿수 손실 될 수 있습니다만 유지 합니다 <xref:System.Numerics.BigInteger.TryParse%2A> 복원 하는 방법을 <xref:System.Numerics.BigInteger> 값.  
  
 경우는 <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> 플래그를 사용할 `value` 16 진수 값 이어야 합니다. 만 다른 플래그에 있을 수 있는 `style` 됩니다 <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> 고 <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>입니다. (합니다 <xref:System.Globalization.NumberStyles> 열거형에는 복합 스타일 인 <xref:System.Globalization.NumberStyles.HexNumber>, 모두 공백 플래그를 포함 하는.)  
  
> [!NOTE]
>  하는 경우 `value` 문자열 표현인 16 진수 숫자의 고 수 없습니다. 뒤에 야 모든 장식 (같은 `0x` 또는 `&h`) 16 진수 숫자로 구분 하는 합니다. 이렇게 하면 변환이 실패할 수 있습니다.  
  
 경우 `value` 16 진수 문자열을 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 보다 크거나 같습니다 `value` 음수로 처음 두 16 진수 보다 크거나 같은 경우에 2의 보수 표현이 사용 하 여 저장 `0x80`합니다. 메서드는 첫 번째 바이트의 최상위 비트를 해석 하는 즉, `value` 부호 비트로입니다. 16 진수 문자열에서 첫 번째 숫자가 양수 숫자로 해석 됩니다 있도록 `value` 0의 값이 있어야 합니다. 예를 들어이 메서드는 해석 `0x80` 음수 값을 해석 하거나 대로 `0x080` 또는 `0x0080` 양수 값으로. 다음 예에서는 양수 및 음수 값을 나타내는 16 진수 문자열 간의 차이점을 보여 줍니다.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 합니다 `provider` 매개 변수는 <xref:System.IFormatProvider> 구현 합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 개체의 형식에 대 한 문화권별 형식 정보를 제공 하는 `value`합니다. `provider` 매개 변수는 다음 중 하나일 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> 서식 지정 정보를 제공 하는 문화권을 나타내는 개체입니다. 해당 <xref:System.Globalization.CultureInfo.GetFormat%2A> 메서드가 반환 되는 <xref:System.Globalization.NumberFormatInfo> 해당 문화권에 대 한 숫자 형식 지정 정보를 제공 하는 개체입니다.  
  
-   <xref:System.Globalization.NumberFormatInfo> 숫자 형식 지정 정보를 제공 하는 개체입니다. (해당 구현의 <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> 자체를 반환 합니다.)  
  
-   구현 하는 사용자 지정 개체 <xref:System.IFormatProvider>합니다. 해당 <xref:System.IFormatProvider.GetFormat%2A> 메서드를 인스턴스화하고 반환 된 <xref:System.Globalization.NumberFormatInfo> 서식 지정 정보를 제공 하는 개체입니다.  
  
 하는 경우 `provider` 됩니다 `null`는 <xref:System.Globalization.NumberFormatInfo> 개체가 현재 문화권이 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 일부 호출을 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 다양 한 조합에 대 한 값을 사용 하 여 메서드를 `style` 및 `provider` 매개 변수입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 에 대 한 개별 호출 수를 <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> 메서드는 다음의 인스턴스를 전달 `BigIntegerFormatProvider` 음수 부호와 물결표 (~)를 정의 하는 클래스입니다.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" />이 <see cref="T:System.Globalization.NumberStyles" /> 값이 아닙니다.  
  
또는 
 <paramref name="style" />에는 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 또는 <see cref="F:System.Globalization.NumberStyles.HexNumber" /> 플래그가 다른 값과 함께 포함됩니다.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>숫자 0을 나타내는 값을 가져옵니다.</summary>
        <value>값이 0인 정수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.BigInteger> 이 속성에 의해 반환 되는 개체 할당과 비교에 사용할 값이 0 이면의 편리한 원본을 제공 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>