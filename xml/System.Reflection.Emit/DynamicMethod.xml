<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fe87216ba1f265cd00a79ccaf0af1ff1779e4945" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56370707" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>컴파일, 실행 및 삭제할 수 있는 동적 메서드를 정의하고 나타냅니다. 삭제된 메서드는 가비지 수집에 사용할 수 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Reflection.Emit.DynamicMethod> 클래스를 생성 하는 메서드를 포함 하는 동적 어셈블리 및 동적 형식을 생성 하지 않고 런타임에 메서드를 실행 합니다. 실행 시간 (JIT) 컴파일러에서 만든 코드를 회수 하는 경우는 <xref:System.Reflection.Emit.DynamicMethod> 개체를 회수 합니다. 동적 메서드 생성 하 고 적은 양의 코드를 실행 하는 가장 효율적인 방법은 됩니다.  
  
 동적 메서드가 익명으로 호스팅될 수 또는 형식 또는 모듈을 사용 하 여 논리적으로 연결할 수 있습니다.  
  
-   동적 메서드가 익명으로 호스팅된 시스템에서 제공 된 어셈블리에 있고 이므로 다른 코드에서 분리 합니다. 기본적으로 public이 아닌 데이터에 액세스할 수 없는 것입니다. 익명으로 호스트 된 동적 메서드를 권한이 부여 된 경우 JIT 컴파일러의 표시 유형 확인을 건너뛰는 기능을 제한 될 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그입니다. 동적 메서드가 public이 아닌 멤버가 액세스 어셈블리의 신뢰 수준과 같거나 하위 집합인 동적 메서드를 내보내는 호출 스택의 트러스트 수준 이어야 합니다. 익명으로 호스트 된 동적 메서드에 대 한 자세한 내용은 참조 하십시오 [연습: 부분 신뢰 시나리오에서 코드 내보내기](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)합니다.  
  
-   동적 메서드를 지정 하는 모듈에 연결 하는 경우에 동적 메서드는 해당 모듈에 효과적으로 전역입니다. 모듈의 모든 형식 및 모든 액세스할 수 있습니다 `internal` (`Friend` Visual basic에서) 형식의 멤버입니다. 동적을 연결할 수 있습니다에 대 한 요청 하는 모듈을 만들었는지 여부에 관계 없이 모든 모듈을 사용 하 여 메서드 제공 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 코드에 포함 된 호출 스택은 여 플래그를 처리할 수 있습니다. 경우는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그는 권한 부여에 포함 된, 동적 메서드가 JIT 컴파일러의 가시성 검사를 생략 및 모듈 또는 어셈블리의 다른 모든 모듈을 선언 하는 모든 종류의 개인 데이터에 액세스할 수 있습니다.  
  
    > [!NOTE]
    >  동적 메서드가 연결 된 모듈을 지정 하는 경우에 익명 호스팅에 사용 되는 시스템 제공 어셈블리에서 해당 모듈 되지 않아야 합니다.  
  
-   동적 메서드를 지정 하는 형식과 연결 하는 경우 액세스 수준에 관계 없이 형식의 모든 멤버에 대 한 액세스를 했습니다. 또한 JIT 표시 유형 확인을 건너뛸 수 있습니다. 그러면 모든 어셈블리의 다른 모든 모듈 또는 같은 모듈에서 선언 된 다른 종류의 개인 데이터에 동적 메서드에 대 한 액세스를 있습니다. 모든 형식을 사용 하 여 동적 메서드를 연결할 수 있지만 코드를 부여 되어야 합니다 <xref:System.Security.Permissions.ReflectionPermission> 둘 다와 함께 합니다 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 및 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> 플래그입니다.  
  
 다음 표에서 형식 및 멤버는 익명으로 호스트 된 동적 메서드 및 인지에 따라 JIT 가시성 검사를 하지 않고 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> 플래그 부여 됩니다.  
  
||<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>를 사용하지 않는 경우|<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>과 함께|  
|-|-|-|  
|JIT 표시 유형 확인을 건너뛰지 않고|모든 어셈블리에서 public 형식의 공용 멤버입니다.|모든 어셈블리에서 public 형식의 공용 멤버입니다.|  
|건너뜁니다 JIT 가시성 검사를 제한|모든 어셈블리에서 public 형식의 공용 멤버입니다.|해당 신뢰 수준이 동적 메서드를 내보내는 어셈블리의 신뢰 수준 보다 작거나 같음은 어셈블리에만 모든 유형의 모든 멤버입니다.|  
  
> [!NOTE]
>  이전에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 필요한 코드를 내보내는 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. FullTrust 및 LocalIntranet 명명 된 권한 집합에는 기본적으로이 권한이 포함 되어 있지만 하지 인터넷 사용 권한을 설정 합니다. 따라서 이전 버전의에서 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 있을 경우에 인터넷 권한으로 라이브러리를 사용할 수 있습니다 합니다 <xref:System.Security.SecurityCriticalAttribute> 특성 및 실행는 <xref:System.Security.PermissionSet.Assert%2A> 에 대 한 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>합니다. 코딩 오류가 있을 경우 보안 허점이 발생할 수 있으므로 이러한 라이브러리는 신중한 보안 검토가 필요합니다. [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]에서는 코드 생성이 기본적으로 권한 있는 작업이 아니기 때문에 보안 요구를 실행하지 않고 부분 신뢰 시나리오에서 코드를 내보낼 수 있습니다. 즉, 생성된 코드에 코드를 내보내는 어셈블리보다 많은 권한이 없습니다. 따라서 코드를 내보내는 라이브러리가 보안상 투명할 수 있으며 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>를 어설션할 필요가 없으므로 보안 라이브러리 작성 작업이 간소화됩니다. 이 기능을 사용 하려면 애플리케이션이 대상 해야는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 다음 표에서 형식 및 멤버는 모듈을 사용 하 여 또는 모듈의 형식과 연결 된 동적 메서드에서 액세스할 수 있습니다.  
  
||모듈에 연결 된|형식과 사용 하 여 연결|  
|-|-|-|  
|JIT 표시 유형 확인을 건너뛰지 않고|모듈의 공용, 내부 및 개인 형식의 public 및 내부 멤버입니다.<br /><br /> 모든 어셈블리에서 public 형식의 공용 멤버입니다.|연결 된 형식의 모든 멤버입니다. 모듈의 다른 모든 종류의 public 및 내부 멤버입니다.<br /><br /> 모든 어셈블리에서 public 형식의 공용 멤버입니다.|  
|JIT 가시성 검사를 건너뜀|모든 어셈블리에 있는 모든 유형의 모든 멤버입니다.|모든 어셈블리에 있는 모든 유형의 모든 멤버입니다.|  
  
 모듈을 사용 하 여 연결 된 동적 메서드는 해당 모듈의 권한을 갖습니다. 형식과 연결 된 동적 메서드는 해당 형식이 포함 된 모듈의 권한을 갖습니다.  
  
 동적 메서드 및 해당 매개 변수 명명 수 없지만 디버깅 하는 데 도움이 되는 이름을 지정할 수 있습니다. 동적 메서드 또는 해당 매개 변수에서 사용자 지정 특성을 사용할 수 없습니다.  
  
 동적 메서드는 있지만 `static` 메서드 (`Shared` Visual Basic의 메서드), 대리자 바인딩이에서 도입 된 규칙을 완화 합니다 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 인스턴스 메서드처럼 작동할 수 있도록 개체를 바인딩할 동적 메서드를 허용 때 해당 대리자 인스턴스를 사용 하 여 호출 합니다. 이 보여 주는 예제는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 메서드 오버 로드 합니다.  
  
> [!NOTE]
>  에 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], 기호 정보를, 로컬 변수 이름 및 줄 번호 매핑 동적 메서드를 지원 하지 않습니다. 이 제한은 이후 버전에서 제거 될 수 있습니다. 사용할 수 있습니다 <xref:System.Reflection.Emit.AssemblyBuilder> 는 생성 된 MSIL (Microsoft intermediate language), 디버깅을 간소화 하기 때문에 동적 메서드를 최종 배포 하는 동안 다음 전환 하는 개발 하는 동안는 <xref:System.Reflection.Emit.ILGenerator> 호출은 두 경우 모두에서 동일 합니다.  
  
## <a name="verification"></a>확인  
 다음 목록에는 동적 메서드는 확인할 수 없는 코드를 포함할 수 있습니다 조건이 요약 되어 있습니다. (예를 들어, 동적 메서드를 확인할 수 없습니다 경우 해당 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 속성이 `false`.)  
  
-   보안에 중요 한 어셈블리와 연결 된 동적 메서드가 보안에 중요 한 이기도 하며 확인을 건너뛸 수 있습니다. 예를 들어, 데스크톱 애플리케이션으로 실행 되는 보안 특성 없이 어셈블리는 런타임에서 보안에 중요로 처리 됩니다. 어셈블리와 동적 메서드를 연결 하는 경우 동적 메서드에 확인할 수 없는 코드를 포함할 수 있습니다.  
  
-   비안정형 코드를 포함 하는 동적 메서드는 수준 1 투명도 어셈블리와 연결 된 경우-just-in-time (JIT) 컴파일러는 보안 요청을 삽입 합니다. 요청에는 완전히 신뢰할 수 있는 코드에서 동적 메서드를 실행 하는 경우에 성공 합니다. 참조 [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md)합니다.  
  
-   확인할 수 없는 코드를 포함 하는 동적 메서드 (예: mscorlib.dll) 수준 2 투명도 있는 어셈블리와 연결 된 경우 보안 요청을 하는 대신 (JIT 컴파일러에 의해 삽입) 예외가 throw 됩니다. 참조 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
-   항상 확인할 수 없는 코드를 포함 하는 익명으로 호스트 된 동적 메서드는 예외를 throw 합니다. 생성 되 고 완전히 신뢰할 수 있는 코드 실행 하는 경우에 확인을 생략할 수 없습니다.  
  
 확인할 수 없는 코드에 대해 throw 되는 예외 동적 메서드가 호출 된 방식에 따라 달라 집니다. 반환 된 대리자를 사용 하 여 동적 메서드를 호출 하는 경우는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드는 <xref:System.Security.VerificationException> throw 됩니다. 사용 하 여 동적 메서드를 호출 하는 경우는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 <xref:System.Reflection.TargetInvocationException> 내부 예외가 <xref:System.Security.VerificationException>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 인쇄 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">연습: 부분 신뢰 시나리오에서 코드 내보내기</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 메서드를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <summary>메서드 이름, 반환 형식 및 매개 변수 형식을 지정하여 익명으로 호스팅된 동적 메서드를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 의해 만들어진 동적 메서드가 익명 어셈블리 대신 기존 형식이 나 모듈에 연결 됩니다. 익명 어셈블리에 다른 코드에서 격리 하 고, 즉 동적 메서드에 대 한 샌드박스 환경을 제공 하기 위해서만 존재 합니다. 이 환경에서는 내보내지고 부분적으로 신뢰할 수 있는 코드 실행에 동적 메서드에 대 한 안전 합니다.  
  
 이 생성자는 (적시에 JIT) 가시성 검사를 MSIL (Microsoft intermediate language)에 적용 됩니다 동적 메서드를 지정 합니다. 즉, 동적 메서드의 코드에서에서 공용 클래스의 공용 메서드에 액세스할 수 있습니다. 메서드가 형식 또는 멤버에 액세스 하려고 하는 경우 예외가 throw 됩니다 `private`, `protected`, 또는 `internal` (`Friend` Visual basic에서). JIT 가시성 검사를 건너뛰는 기능을 제한 된 동적 메서드를 만들려면 사용 합니다 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> 생성자입니다.  
  
 익명으로 호스트 된 동적 메서드를 생성 될 때 내보내는 어셈블리 호출 스택이 포함 됩니다. 메서드가 호출 될 때 내보내는 어셈블리의 사용 권한은 실제 호출자의 권한 대신 사용 됩니다. 따라서 동적 메서드는 전달 되 고 더 높은 신뢰 수준을 가진 어셈블리에서 실행 하는 경우에 내보낸 어셈블리 보다 높은 수준의 권한에서 실행할 수 없습니다.  
  
 이 생성자에 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 하 고 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 및 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  이 생성자에 도입 된 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">연습: 부분 신뢰 시나리오에서 코드 내보내기</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="restrictedSkipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에 대해 JIT 가시성 검사를 건너뛰려면(단, 이러한 형식과 멤버를 포함하는 어셈블리의 트러스트 수준이 동적 메서드를 내보내는 호출 스택의 트러스트 수준보다 작거나 같아야 한다는 제한이 적용되는 경우) <see langword="true" />이며, 건너뛰지 않으려면 <see langword="false" />입니다.</param>
        <summary>메서드 이름, 반환 형식, 매개 변수 형식, 그리고 동적 메서드의 MSIL(Microsoft Intermediate Language)에서 액세스하는 형식 및 멤버에 대해 JIT(적시) 가시성 검사를 건너뛰어야 하는지 여부를 지정하는 익명으로 호스팅된 동적 메서드를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 의해 만들어진 동적 메서드가 익명 어셈블리 대신 기존 형식이 나 모듈에 연결 됩니다. 익명 어셈블리에 다른 코드에서 격리 하 고, 즉 동적 메서드에 대 한 샌드박스 환경을 제공 하기 위해서만 존재 합니다. 이 환경에서는 내보내지고 부분적으로 신뢰할 수 있는 코드 실행에 동적 메서드에 대 한 안전 합니다.  
  
 익명으로 호스트 된 동적 메서드 형식 또는 멤버에 자동으로 액세스를 필요가 없습니다 `private`, `protected`, 또는 `internal` (`Friend` Visual basic에서). 이 해당 범위의 숨겨진된 멤버에 액세스할 수 있는 기존 형식이 나 모듈에 연결 된 동적 메서드 다릅니다.  
  
 지정할 `true` 에 대 한 `restrictedSkipVisibility` 동적 메서드에 형식 또는 멤버에 액세스할 수 있는지 `private`를 `protected`, 또는 `internal`합니다. 그러면 이러한 멤버에 대 한 액세스를 제한 하는 동적 메서드 있습니다. 즉, 다음 조건에 해당 하는 경우에 멤버를 액세스할 수 있습니다.  
  
-   대상 멤버 크거나 동적 메서드를 내보내는 호출 스택의 보다 낮은 신뢰 수준을 가진 어셈블리에 속하는 합니다.  
  
-   부여 된 동적 메서드를 내보내는 호출 스택의 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그입니다. 이 완전 신뢰를 사용 하 여 코드를 실행 하는 경우에 항상 true입니다. 부분적으로 신뢰할 수 있는 코드에 대 한 것은 사실 호스트에는 명시적으로 권한을 부여 하는 경우에 합니다.  
  
    > [!IMPORTANT]
    >  보안 예외가 때 throw 권한이 부여 되지 않은, 경우 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 라고 또는 동적 메서드를 호출 하면 되지 경우이 생성자를 호출 합니다. 동적 메서드를 내보낼 수 없는 특별 한 권한이 필요 합니다.  
  
 예를 들어, 동적 메서드를 사용 하 여 만들어집니다 `restrictedSkipVisibility` 로 `true` 호출 스택 제한 된 멤버 액세스 권한이 부여 된 경우 호출 스택에 있는 모든 어셈블리의 private 멤버에 액세스할 수 있습니다. 동적 메서드를 호출 스택에 부분적으로 신뢰할 수 있는 코드를 사용 하 여 만든 경우에서 형식의 private 멤버에 액세스할 수 없습니다 것을 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 어셈블리 이러한 어셈블리는 완전히 신뢰할 수 있는 이기 때문입니다.  
  
 하는 경우 `restrictedSkipVisibility` 는 `false`, JIT 표시 유형 확인을 적용 합니다. 동적 메서드의 코드에서에서 공용 클래스의 공용 메서드에 액세스할 수 있고 형식이 나 멤버에 액세스 하려고 시도 하는 경우 예외가 throw 됩니다 `private`하십시오 `protected`, 또는 `internal`합니다.  
  
 익명으로 호스트 된 동적 메서드를 생성 될 때 내보내는 어셈블리 호출 스택이 포함 됩니다. 메서드가 호출 되 면 내보내는 호출 스택의 권한은 실제 호출자의 권한 대신 사용 됩니다. 따라서 동적 메서드는 전달 되 고 더 높은 신뢰 수준을 가진 어셈블리에서 실행 하는 경우에 내보낸 어셈블리 보다 높은 수준의 권한에서 실행할 수 없습니다.  
  
 이 생성자에 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 하 고 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 및 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  이 생성자에 도입 된 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">연습: 부분 신뢰 시나리오에서 코드 내보내기</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="m">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <see cref="T:System.Reflection.Module" />입니다.</param>
        <summary>메서드 이름, 반환 형식, 매개 변수 형식 및 모듈을 지정하여 모듈 전체에서 사용되는 동적 메서드를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 및-just-in-time (JIT) 표시 유형 확인을 건너뛰지 않습니다.  
  
 이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 `internal` (`Friend` Visual basic에서) 모듈에 포함 된 모든 형식의 멤버 `m`합니다.  
  
> [!NOTE]
>  이전 버전과 호환성을 위해이 생성자는 다음과 같이 요구 됩니다. <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 둘 다 다음과 같은 경우 true: `m` 호출 모듈 및 수요 이외의 모듈인 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그 실패 했습니다. 경우에 대 한 수요 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 인쇄 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  
  
또는 
 <paramref name="m" />이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="m" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 모듈이 아닌 모듈을 사용 하 여 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="owner">동적 메서드가 논리적으로 연결되는 <see cref="T:System.Type" />입니다. 동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</param>
        <summary>메서드 이름, 반환 형식, 매개 변수 형식 및 동적 메서드가 논리적으로 연결된 형식을 지정하여 동적 메서드를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 동적 메서드가 형식의 모든 멤버에 액세스할 `owner`, 및 공용 및 `internal` (`Friend` Visual basic에서) 포함 된 모듈의 다른 모든 형식 멤버 `owner`합니다.  
  
 이 생성자에 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 및-just-in-time (JIT) 표시 유형 확인을 건너뛰지 않습니다.  
  
> [!NOTE]
>  이전 버전과 호환성을 위해이 생성자는 다음과 같이 요구 됩니다. <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 둘 다 다음과 같은 경우 true: `owner` 호출 모듈을 대 한 수요 아닌 모듈에 있는 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그에 실패 했습니다. 경우에 대 한 수요 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Reflection.Emit.DynamicMethod> 형식과 논리적으로 연결 합니다. 이 연결 제공 해당 형식의 private 멤버에 액세스 합니다.  
  
 이라는 클래스를 정의 하는 코드 예제 `Example` 클래스 라는 private 필드를 사용 하 여 `DerivedFromxample` 첫 번째 클래스에서 파생 된 이라는 대리자 형식을 `UseLikeStatic` 반환 하는 <xref:System.Int32> 형식의 매개 변수가 및 `Example` 및 <xref:System.Int32>, 및 라는 대리자 형식을 `UseLikeInstance` 반환 하는 <xref:System.Int32> 형식의 매개 변수가 하나이 고 <xref:System.Int32>입니다.  
  
 예제 코드를 다음 만듭니다는 <xref:System.Reflection.Emit.DynamicMethod> 인스턴스의 private 필드를 변경 하는 `Example` 이전 값을 반환 합니다.  
  
> [!NOTE]
>  일반적으로 클래스의 내부 필드를 변경 합니다. 아닌 경우 좋은 개체 지향 코딩 사례  
  
 예제 코드의 인스턴스를 만들고 `Example` 다음 두 명의 대리자를 만듭니다. 형식의 첫 번째는 `UseLikeStatic`을 동적 방법으로 동일한 매개 변수가 있는 합니다. 두 번째 형식입니다 `UseLikeInstance`에 첫 번째 매개 변수는 없는 (형식의 `Example`). 이 대리자를 사용 하 여 만들어집니다 합니다 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> ; 메서드 오버 로드 두 번째 메서드 오버 로드 하는 매개 변수는 인스턴스의 `Example`,이 경우에 새로 생성된 된 대리자에 바인딩되는 방금 만든 인스턴스. 인스턴스에 바인딩된 동적 메서드는 작동 대리자가 호출 될 때마다 `Example`합니다.  
  
> [!NOTE]
>  도입 된 대리자 바인딩이 이것이 관대 한 규칙의 예는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], 새 오버 로드와 함께 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 메서드. 자세한 내용은 <xref:System.Delegate> 클래스를 참조하세요.  
  
 `UseLikeStatic` 대리자를 호출 하는 인스턴스를 전달 `Example` 에 바인딩되는 `UseLikeInstance` 대리자. 그런 다음 `UseLikeInstance` 둘 다 대리자의 동일한 인스턴스에서 작동할 수 있도록 대리자가 호출 `Example`합니다. 호출한 후 마다 내부 필드의 값에 변경 내용이 표시 됩니다. 마지막으로 `UseLikeInstance` 인스턴스의 대리자가 바인딩된 `DerivedFromxample`, 대리자를 호출 하 여 반복 됩니다.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  
  
또는 
 <paramref name="owner" />가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="owner" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />은 <see langword="null" />이거나 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">동적 메서드 호출 모듈이 아닌 모듈 유형으로 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="m">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <see cref="T:System.Reflection.Module" />입니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />입니다.</param>
        <summary>모듈 전체에 적용되는 동적 메서드를 만들어 메서드 이름, 반환 형식, 매개 변수 형식, 모듈을 지정하고, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 하 고 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 및 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
 이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 `internal` (`Friend` Visual basic에서) 포함 된 모듈에 있는 모든 형식의 멤버 `m`합니다. JIT 건너뜁니다 컴파일러의 가시성 검사 모든 다른 형식 에서도 전용 및 보호 된 멤버에 액세스 하려면 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
> [!NOTE]
>  이전 버전과 호환성을 위해이 생성자는 다음과 같이 요구 됩니다. <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 둘 다 다음과 같은 경우 true: `m` 호출 모듈 및 수요 이외의 모듈인 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그 실패 했습니다. 경우에 대 한 수요 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  
  
또는 
 <paramref name="m" />이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="m" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 모듈이 아닌 모듈을 사용 하 여 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="owner">동적 메서드가 논리적으로 연결되는 <see cref="T:System.Type" />입니다. 동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>동적 메서드를 만들고, 메서드 이름, 반환 형식, 매개 변수 형식, 동적 메서드가 논리적으로 연결되는 형식, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 동적 메서드가 형식의 모든 멤버에 액세스할 `owner`, 및 공용 및 `internal` (`Friend` Visual basic에서) 포함 된 모듈의 다른 모든 형식 멤버 `owner`합니다. JIT 건너뜁니다 컴파일러의 가시성 검사 모든 다른 형식 에서도 전용 및 보호 된 멤버에 액세스 하려면 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
 이 생성자에 메서드 특성 지정 <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> 하 고 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, 호출 규칙 및 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  이전 버전과 호환성을 위해이 생성자는 다음과 같이 요구 됩니다. <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 둘 다 다음과 같은 경우 true: `owner` 호출 모듈을 대 한 수요 아닌 모듈에 있는 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그에 실패 했습니다. 경우에 대 한 수요 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  
  
또는 
 <paramref name="owner" />가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="owner" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" />은 <see langword="null" />이거나 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">동적 메서드 호출 모듈이 아닌 모듈 유형으로 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="attributes">동적 메서드의 특성을 지정하는 <see cref="T:System.Reflection.MethodAttributes" /> 값의 비트 조합입니다. 허용되는 유일한 조합은 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" />입니다.</param>
        <param name="callingConvention">동적 메서드에 대한 호출 규칙입니다. <see cref="F:System.Reflection.CallingConventions.Standard" />여야 합니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="m">동적 메서드를 논리적으로 연결할 모듈을 나타내는 <see cref="T:System.Reflection.Module" />입니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>모듈 전체에 적용되는 동적 메서드를 만들어 메서드 이름, 특성, 호출 규칙, 반환 형식, 매개 변수 형식, 모듈을 지정하고, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 만든 동적 메서드가 public에 대 한 액세스 및 `internal` (`Friend` Visual basic에서) 모듈에 포함 된 모든 public 및 내부 형식이 멤버인 `m`합니다.  
  
 JIT 건너뜁니다 컴파일러의 가시성 검사 모듈에 다른 모든 어셈블리에도 다른 모든 종류의 전용 및 보호 된 멤버에 액세스할 수 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
> [!NOTE]
>  이전 버전과 호환성을 위해이 생성자는 다음과 같이 요구 됩니다. <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 둘 다 다음과 같은 경우 true: `m` 호출 모듈 및 수요 이외의 모듈인 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그 실패 했습니다. 경우에 대 한 수요 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  
  
또는 
 <paramref name="m" />이 동적 메서드에 대한 익명 호스팅을 제공하는 모듈입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="m" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" />는 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" /> 이외의 플래그 조합입니다.  
  
또는 
 <paramref name="callingConvention" />이 <see cref="F:System.Reflection.CallingConventions.Standard" />가 아닙니다.  
  
또는 
 <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 모듈이 아닌 모듈을 사용 하 여 동적 메서드를 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">동적 메서드의 이름입니다. 이 항목에는 빈 문자열을 지정할 수 있지만 <see langword="null" />은 지정할 수 없습니다.</param>
        <param name="attributes">동적 메서드의 특성을 지정하는 <see cref="T:System.Reflection.MethodAttributes" /> 값의 비트 조합입니다. 허용되는 유일한 조합은 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" />입니다.</param>
        <param name="callingConvention">동적 메서드에 대한 호출 규칙입니다. <see cref="F:System.Reflection.CallingConventions.Standard" />여야 합니다.</param>
        <param name="returnType">동적 메서드의 반환 형식을 지정하는 <see cref="T:System.Type" /> 개체이거나, 메서드에 반환 형식이 없으면 <see langword="null" />입니다.</param>
        <param name="parameterTypes">동적 메서드의 매개 변수 형식을 지정하는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드에 매개 변수가 없으면 <see langword="null" />입니다.</param>
        <param name="owner">동적 메서드가 논리적으로 연결되는 <see cref="T:System.Type" />입니다. 동적 메서드에 해당 형식의 모든 멤버에 대한 액세스 권한이 있습니다.</param>
        <param name="skipVisibility">동적 메서드의 MSIL에서 액세스하는 형식 및 멤버에서 JIT 표시 유형 확인을 건너뛰는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>동적 메서드를 만들고, 메서드 이름, 특성, 호출 규칙, 반환 형식, 매개 변수 형식, 동적 메서드가 논리적으로 연결되는 형식, 동적 메서드의 MSIL(Microsoft Intermediate Language)이 액세스하는 형식과 멤버에 대해 JIT(just-in-time) 표시 유형 확인을 건너뛸지 여부를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 메서드는 형식을 포함 하는 모듈에 전역 `owner`합니다. 형식의 모든 멤버에 액세스할 수 `owner`입니다.  
  
 이 생성자를 사용 하 여 만든 동적 메서드가 형식의 모든 멤버에 액세스할 `owner`, 및 공용 및 `internal` (`Friend` Visual basic에서) 포함 된 모듈에 포함 된 모든 형식의 멤버 `owner`합니다. JIT 건너뜁니다 컴파일러의 가시성 검사 모든 다른 형식 에서도 전용 및 보호 된 멤버에 액세스 하려면 동적 메서드를 사용할 수 있습니다. 예를 들어 개체를 serialize 하는 코드를 작성할 때 유용 합니다.  
  
> [!NOTE]
>  이전 버전과 호환성을 위해이 생성자는 다음과 같이 요구 됩니다. <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 플래그를 둘 다 다음과 같은 경우 true: `owner` 호출 모듈을 대 한 수요 아닌 모듈에 있는 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여를 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그에 실패 했습니다. 경우에 대 한 수요 <xref:System.Security.Permissions.SecurityPermission> 성공 하면이 작업은 허용 합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" />의 요소는 <see langword="null" /> 또는 <see cref="T:System.Void" />입니다.  
  
또는 
 <paramref name="owner" />가 인터페이스, 배열, 개방형 제네릭 형식, 제네릭 형식 또는 메서드의 형식 매개 변수입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="owner" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" />는 <see cref="F:System.Reflection.MethodAttributes.Public" /> 및 <see cref="F:System.Reflection.MethodAttributes.Static" /> 이외의 플래그 조합입니다.  
  
또는 
 <paramref name="callingConvention" />이 <see cref="F:System.Reflection.CallingConventions.Standard" />가 아닙니다.  
  
또는 
 <paramref name="returnType" />은 <see cref="P:System.Type.IsByRef" />가 <see langword="true" />를 반환하는 형식입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">동적 메서드 호출 모듈이 아닌 모듈 유형으로 연결 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드를 만들 때 지정된 특성을 가져옵니다.</summary>
        <value>메서드의 특성을 나타내는 <see cref="T:System.Reflection.MethodAttributes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 동적 메서드에 대 한 메서드 특성은 항상 <xref:System.Reflection.MethodAttributes.Public> 고 <xref:System.Reflection.MethodAttributes.Static>입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드를 메서드 특성을 표시 합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드를 만들 때 지정된 호출 규칙을 가져옵니다.</summary>
        <value>메서드의 호출 규칙을 나타내는 <see cref="T:System.Reflection.CallingConventions" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재, 동적 메서드의 호출 규칙은 항상 <xref:System.Reflection.CallingConventions.Standard>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 호출 규칙을 표시 합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 메서드를 완료하고 실행하는 데 사용할 수 있는 대리자를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">서명이 동적 메서드의 서명과 일치하는 대리자 형식입니다.</param>
        <summary>동적 메서드를 완료하고 실행하는 데 사용할 수 있는 대리자를 만듭니다.</summary>
        <returns>지정된 형식의 대리자로, 동적 메서드를 실행하는 데 사용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드는 동적 메서드를 완료 합니다. 추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하려고 또는 자세한 MSIL (Microsoft intermediate language)을 내보내는 설정은 무시 됩니다. 예외가 throw 됩니다.  
  
 동적 메서드에 대 한 메서드 본문을 만들면 고유한 MSIL 생성기가를 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> 메서드는 <xref:System.Reflection.Emit.DynamicILInfo> 개체입니다. 고유한 MSIL 생성기가 없는 경우 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> 메서드는 <xref:System.Reflection.Emit.ILGenerator> 메서드 본문을 생성 하는 데 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 인쇄 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에 메서드 본문이 없습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" />의 매개 변수 개수가 잘못되었거나 매개 변수 유형이 잘못되었습니다.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">서명이 동적 메서드의 서명과 일치하는 대리자 형식에서 첫 번째 매개 변수를 뺀 값입니다.</param>
        <param name="target">대리자가 바인딩된 개체입니다. 동적 메서드의 첫 번째 매개 변수와 동일한 형식이어야 합니다.</param>
        <summary>동적 메서드를 완료하고 대리자 형식과 대리자가 바인딩되는 개체를 지정하여 해당 메서드를 실행하는 데 사용할 수 있는 대리자를 만듭니다.</summary>
        <returns>지정된 형식의 대리자로, 지정된 대상 개체를 사용하여 동적 메서드를 실행하는 데 사용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 오버 로드는 특정 개체에 바인딩된 대리자를 만듭니다. 이러한 대리자는 첫 번째 인수에 대해 닫혀 라고 합니다. 인스턴스 메서드를 사용 하는 것 처럼 동작 메서드가 정적이 있지만 인스턴스가 `target`합니다.  
  
 이 메서드 오버 로드가 필요 `target` 동적 메서드의 첫 번째 매개 변수로 동일한 형식 이어야 하거나 해당 형식 (예: 파생된 클래스)에 할당할 수 있습니다.  서명의 `delegateType` 첫 번째를 제외한 동적 메서드의 매개 변수를 모두 포함 합니다. 예를 들어 동적 메서드에 매개 변수가 <xref:System.String>, <xref:System.Int32>, 및 <xref:System.Byte>, 한 다음 `delegateType` 매개 변수에 <xref:System.Int32> 및 <xref:System.Byte>; `target` 유형의 <xref:System.String>합니다.  
  
 호출 된 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드는 동적 메서드를 완료 합니다. 추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하려고 또는 자세한 MSIL (Microsoft intermediate language)을 내보내는 설정은 무시 됩니다. 예외가 throw 됩니다.  
  
 동적 메서드에 대 한 메서드 본문을 만들면 고유한 MSIL 생성기가를 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> 메서드는 <xref:System.Reflection.Emit.DynamicILInfo> 개체입니다. 고유한 MSIL 생성기가 없는 경우 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> 메서드는 <xref:System.Reflection.Emit.ILGenerator> 메서드 본문을 생성 하는 데 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 바인딩하는 대리자를 만듭니다를 <xref:System.Reflection.Emit.DynamicMethod> 형식의 인스턴스로 메서드 될 때마다 동일한 인스턴스에서 작동할 수 있도록 호출 됩니다.  
  
 이라는 클래스를 정의 하는 코드 예제 `Example` 클래스 라는 private 필드를 사용 하 여 `DerivedFromxample` 첫 번째 클래스에서 파생 된 이라는 대리자 형식을 `UseLikeStatic` 반환 하는 <xref:System.Int32> 형식의 매개 변수가 및 `Example` 및 <xref:System.Int32>, 및 라는 대리자 형식을 `UseLikeInstance` 반환 하는 <xref:System.Int32> 형식의 매개 변수가 하나이 고 <xref:System.Int32>입니다.  
  
 예제 코드를 다음 만듭니다는 <xref:System.Reflection.Emit.DynamicMethod> 인스턴스의 private 필드를 변경 하는 `Example` 이전 값을 반환 합니다.  
  
> [!NOTE]
>  일반적으로 클래스의 내부 필드를 변경 합니다. 아닌 경우 좋은 개체 지향 코딩 사례  
  
 예제 코드의 인스턴스를 만들고 `Example` 다음 두 명의 대리자를 만듭니다. 형식의 첫 번째는 `UseLikeStatic`을 동적 방법으로 동일한 매개 변수가 있는 합니다. 두 번째 형식입니다 `UseLikeInstance`에 첫 번째 매개 변수는 없는 (형식의 `Example`). 이 대리자를 사용 하 여 만들어집니다 합니다 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> ; 메서드 오버 로드 두 번째 메서드 오버 로드 하는 매개 변수는 인스턴스의 `Example`,이 경우에 새로 생성된 된 대리자에 바인딩되는 방금 만든 인스턴스. 인스턴스에 바인딩된 동적 메서드는 작동 대리자가 호출 될 때마다 `Example`합니다.  
  
> [!NOTE]
>  도입 된 대리자 바인딩이 이것이 관대 한 규칙의 예는 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], 새 오버 로드와 함께 <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> 메서드. 자세한 내용은 <xref:System.Delegate> 클래스를 참조하세요.  
  
 `UseLikeStatic` 대리자를 호출 하는 인스턴스를 전달 `Example` 에 바인딩되는 `UseLikeInstance` 대리자. 그런 다음 `UseLikeInstance` 둘 다 대리자의 동일한 인스턴스에서 작동할 수 있도록 대리자가 호출 `Example`합니다. 호출한 후 마다 내부 필드의 값에 변경 내용이 표시 됩니다. 마지막으로 `UseLikeInstance` 인스턴스의 대리자가 바인딩된 `DerivedFromxample`, 대리자를 호출 하 여 반복 됩니다.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에 메서드 본문이 없습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" />이 동적 메서드의 첫 번째 매개 변수와 동일한 형식이 아니며 해당 형식에 할당할 수 없습니다.  
  
또는 
 <paramref name="delegateType" />의 매개 변수 개수가 잘못되었거나 매개 변수 유형이 잘못되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에 대해 항상 <see langword="null" />인 메서드를 선언하는 형식을 가져옵니다.</summary>
        <value>항상 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 반환 `null` 동적 메서드에 대 한 합니다. 동적 메서드를 논리적으로 형식과 연결 하는 경우에 형식으로 선언 되지 않았습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 동적 메서드의 선언 형식이 표시 됩니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">매개 변수 목록에서 매개 변수의 위치입니다. 매개 변수가 첫 번째 매개 변수에 대한 숫자 1부터 시작해서 인덱싱됩니다.</param>
        <param name="attributes">매개 변수의 특성을 지정하는 <see cref="T:System.Reflection.ParameterAttributes" /> 값의 비트 조합입니다.</param>
        <param name="parameterName">매개 변수의 이름입니다. 이름은 빈 문자열일 수 있습니다.</param>
        <summary>동적 메서드의 매개 변수를 정의합니다.</summary>
        <returns>항상 <see langword="null" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `position` 가 0 이면는 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 메서드 반환 값을 가리킵니다. 매개 변수 정보 설정 해도 반환 값에는 영향이 없습니다.  
  
 경우 동적 메서드가 이미 완료 된를 호출 하 여는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 메서드는 효과가 없습니다. 예외가 throw되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에는 동적 메서드에 대 한 매개 변수 정보를 정의 하는 방법을 보여 줍니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">메서드에 매개 변수가 없습니다.  
  
또는 
 <paramref name="position" />가 0보다 작은 경우  
  
또는 
 <paramref name="position" />이 메서드의 매개 변수 수보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드에 대한 기본 구현을 반환합니다.</summary>
        <returns>메서드의 기본 구현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 항상 현재 반환 `DynamicMethod` 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>메서드에 적용된 사용자 지정 특성을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <see langword="true" />이고, 현재 메서드만 확인하려면 <see langword="false" />입니다.</param>
        <summary>이 메서드에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</summary>
        <returns>이 메서드의 모든 사용자 지정 특성을 나타내는 개체 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 동적 메서드에 대 한 `true` 에 대 한 `inherit` 메서드 형식에서 선언 되지 않았으므로 아무 효과가 있습니다.  
  
> [!NOTE]
>  동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다. 유일한 특성은 반환 <xref:System.Runtime.CompilerServices.MethodImplAttribute>; 얻을 수 있습니다 메서드 구현 플래그 보다 쉽게 사용 하 여는 <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">반환할 사용자 지정 특성의 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="inherit">상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <see langword="true" />이고, 현재 메서드만 확인하려면 <see langword="false" />입니다.</param>
        <summary>메서드에 적용된 지정된 형식의 사용자 지정 특성을 반환합니다.</summary>
        <returns><paramref name="attributeType" /> 형식이거나 <paramref name="attributeType" /> 형식에서 파생되는 메서드의 특성을 나타내는 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 동적 메서드에 대 한 `true` 에 대 한 `inherit` 메서드 형식에서 선언 되지 않았으므로 아무 효과가 있습니다.  
  
> [!NOTE]
>  동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다. 유일한 특성은 반환 <xref:System.Runtime.CompilerServices.MethodImplAttribute>; 얻을 수 있습니다 메서드 구현 플래그 보다 쉽게 사용 하 여는 <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메타데이터 토큰, 범위 및 MSIL(Microsoft Intermediate Language) 스트림에서 메서드 본문을 생성하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 개체입니다.</summary>
        <returns>메타데이터 토큰, 범위 및 MSIL 스트림에서 메서드 본문을 생성하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo> 클래스는 관리 되지 않는 코드 생성을 지원 하기 위해 제공 됩니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 실행 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 메서드의 본문을 내보내는 데 사용할 수 있는 MSIL 생성기를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>64바이트의 기본 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하는 메서드에 대한 MSIL 생성기를 반환합니다.</summary>
        <returns>메서드에 대한 <see cref="T:System.Reflection.Emit.ILGenerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 메서드가 완료 된 후에 호출 하 여 합니다 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 하나 더 추가 하려고 MSIL은 무시 됩니다. 예외가 throw되지 않습니다.  
  
> [!NOTE]
>  일부 완전 신뢰 시나리오 에서도 동적 메서드에 확인할 수 없는 코드에는 제한이 있습니다. <xref:System.Reflection.Emit.DynamicMethod>에 대한 설명에서 "확인" 섹션을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 매개 변수를 사용 하는 동적 메서드를 만듭니다. 이 예제에서는 콘솔에 첫 번째 매개 변수를 인쇄 하는 간단한 함수 본문을 내보내는 및 예제에서는 메서드의 반환 값으로 두 번째 매개 변수를 사용 합니다. 이 예제에서는 대리자를 만들어 메서드를 완료 다른 매개 변수를 사용 하 여 대리자를 호출 하 고 마지막으로 사용 하 여 동적 메서드를 호출 합니다 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 스트림에 바이트의 크기입니다.</param>
        <summary>지정된 된 MSIL 스트림 크기를 사용하는 메서드에 대한 MSIL(Microsoft Intermediate Language) 생성기를 반환합니다.</summary>
        <returns>지정된 MSIL 스트림 크기를 가진 메서드의 <see cref="T:System.Reflection.Emit.ILGenerator" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 메서드가 완료 된 후에 호출 하 여 합니다 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 또는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드를 하나 더 추가 하려고 MSIL은 무시 됩니다. 예외가 throw되지 않습니다.  
  
> [!NOTE]
>  일부 완전 신뢰 시나리오 에서도 동적 메서드에 확인할 수 없는 코드에는 제한이 있습니다. <xref:System.Reflection.Emit.DynamicMethod>에 대한 설명에서 "확인" 섹션을 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는이 메서드 오버 로드를 보여 줍니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">방법: 동적 메서드 정의 및 실행</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드에 대한 구현 플래그를 반환합니다.</summary>
        <returns>메서드의 구현 플래그를 나타내는 <see cref="T:System.Reflection.MethodImplAttributes" /> 값의 비트 조합입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 동적 메서드에 대 한 메서드 구현 특성은 항상 <xref:System.Reflection.MethodImplAttributes.IL> 고 <xref:System.Reflection.MethodImplAttributes.NoInlining>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>동적 메서드의 매개 변수를 반환합니다.</summary>
        <returns>동적 메서드의 매개 변수를 나타내는 <see cref="T:System.Reflection.ParameterInfo" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo> 이 메서드에서 반환 된 개체는 정보 제공 용입니다. 사용 된 <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> 매개 변수의 특성을 변경 하는 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드의 매개 변수를 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 로컬 변수가 0으로 초기화되었는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메서드의 로컬 변수가 0으로 초기화되었으면 <see langword="true" />이고, 초기화되지 않았으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`에 내보낸된 MSIL (Microsoft intermediate language) 로컬 변수의 초기화를 포함 합니다. 로 설정 된 경우 `false`, 로컬 변수가 초기화 되지 및 생성된 된 코드를 확인할 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> 동적 메서드는 속성입니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">이 매개 변수는 정적이기 때문에 동적 메서드에 대해 무시됩니다. <see langword="null" />을 지정합니다.</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" /> 값의 비트 조합입니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see cref="T:System.Reflection.MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 <see cref="T:System.Reflection.Binder" /> 개체입니다. <paramref name="binder" />가 <see langword="null" />이면 기본 바인더가 사용됩니다. 자세한 내용은 <see cref="T:System.Reflection.Binder" />을 참조하십시오.</param>
        <param name="parameters">인수 목록입니다. 호출되는 메서드의 매개 변수와 숫자, 순서, 형식이 동일한 인수의 배열입니다. 매개 변수가 없는 경우에는 이 매개 변수가 <see langword="null" />이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see cref="T:System.Globalization.CultureInfo" />의 인스턴스입니다. 이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다. 예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 <see cref="T:System.String" />을 <see cref="T:System.Double" /> 값으로 올바르게 변환하기 위해 이 정보가 필요합니다.</param>
        <summary>지정된 문화권 정보를 사용하고 지정된 바인더의 제약 조건에 따라, 지정된 매개 변수를 사용하여 동적 메서드를 호출합니다.</summary>
        <returns>호출된 메서드의 반환 값을 포함하는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예외를 나열된 하는 것 외에도 호출 코드에서 동적 메서드에 의해 throw 된 예외를 catch 하도록 준비 해야 합니다.  
  
 만든 대리자를 사용 하 여 동적 메서드를 실행 합니다 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드는 사용 하 여 실행할 때 보다 더 효율적는 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드.  
  
 호출 된 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> 메서드 또는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> 메서드는 동적 메서드를 완료 합니다. 추가 매개 변수 정의 수정 하는 등 동적 메서드를 변경 하려고 또는 자세한 MSIL (Microsoft intermediate language)을 내보내는 설정은 무시 됩니다. 예외가 throw 됩니다.  
  
 모든 동적 메서드는 정적 이므로 `obj` 매개 변수는 항상 무시 됩니다. 동적 메서드가 인스턴스 메서드인 것 처럼 처리를 사용 하 여는 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> 개체 인스턴스를 사용 하는 오버 로드 합니다.  
  
 동적 메서드의 매개 변수가 없는 경우, 값 `parameters` 있어야 `null`합니다. 그렇지 않으면 개수, 형식 및 매개 변수 배열에서 요소의 순서는 개수, 형식 및 동적 메서드의 매개 변수의 순서와 같아야 합니다.  
  
> [!NOTE]
>  이 메서드 오버 로드는 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> 에서 상속 된 메서드 오버 로드는 <xref:System.Reflection.MethodBase> 클래스, 오버 로드를 모두에 게 이전 설명을 적용 합니다.  
  
 이 메서드는 권한이 직접 필요 하지 않지만 동적 메서드를 호출 하는 방법에 따라 보안 요구 사항을 충족에서 될 수 있습니다. 로 생성 되는 익명으로 호스트 된 동적 메서드의 없는 요구가 수행 됩니다는 예를 들어 합니다 `restrictedSkipVisibility` 매개 변수 설정 `false`합니다. 반면, 사용 하 여 메서드를 만드는 경우 `restrictedSkipVisibility` 로 설정 `true` 메서드를 더하기 대상 어셈블리의 사용 권한 요청 하면 대상 어셈블리의 숨겨진된 멤버를 액세스할 수 있도록 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.  
  
> [!NOTE]
>  이전에 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드는 데 필요한 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> 플래그입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 영어 (미국) 문화권을 사용 하는 정확한 바인딩으로 동적 메서드를 호출 합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Reflection.CallingConventions.VarArgs" /> 호출 규칙은 지원되지 않습니다.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" />의 요소 개수가 동적 메서드의 매개 변수 개수와 일치하지 않습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" />에 있는 하나 이상의 요소 형식이 동적 메서드의 해당 매개 변수의 형식과 일치하지 않습니다.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">동적 메서드가 모듈과 연결되어 있고, 익명으로 호스팅되지 않으며, <paramref name="skipVisibility" /> 값을 <see langword="false" />로 설정하여 만들어졌지만, 동적 메서드가 <see langword="public" /> 또는 <see langword="internal" />(Visual Basic에서는 <see langword="Friend" />)가 아닌 멤버에 액세스합니다.  
  
또는 
동적 메서드가 익명으로 호스팅되고 <paramref name="skipVisibility" /> 값을 <see langword="false" />로 설정하여 만들어졌지만, <see langword="public" />이 아닌 멤버에 액세스합니다.  
  
또는 
동적 메서드에 확인할 수 없는 코드가 포함되어 있습니다. <see cref="T:System.Reflection.Emit.DynamicMethod" />에 대한 설명에서 "확인" 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">검색할 사용자 지정 특성의 형식을 나타내는 <see cref="T:System.Type" />입니다.</param>
        <param name="inherit">상속 체인을 검색하여 사용자 지정 특성을 찾으려면 <see langword="true" />이고, 현재 메서드만 확인하려면 <see langword="false" />입니다.</param>
        <summary>지정된 사용자 지정 특성 유형이 정의되었는지 여부를 나타냅니다.</summary>
        <returns>지정된 사용자 지정 특성 유형이 정의되어 있으면 <see langword="true" />이고, 정의되어 있지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 하는 동적 메서드에 대 한 `true` 에 대 한 `inherit` 영향을 주지 않습니다. 동적 메서드는 상속 되지 않습니다.  
  
> [!NOTE]
>  동적 메서드에 사용자 지정 특성이 현재 지원 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동적 메서드가 보안에 중요하거나 보안 안전에 중요하여 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 동적 메서드가 보안에 중요하거나 보안 안전에 중요한 경우 <see langword="true" />이고 투명한 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다. 동적 메서드가 모듈 대신 형식을 사용 하 여 연결 된 경우 해당 투명도 형식을 포함 하는 모듈에 따라 달라 집니다. 동적 메서드는 관련 된 모듈에 대 한 투명도 할당 보안 주석을 갖지 않습니다.  
  
-   익명으로 호스트 된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 고, 항상입니다.  
  
-   투명도 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된) 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드는 다음 표에 설명 되어 있습니다.  
  
    |어셈블리 주석|수준 1 투명도|수준 2 투명도|  
    |-------------------------|--------------------------|--------------------------|  
    |완전히 투명 하 게|투명|투명|  
    |완벽 하 게 중요 한|위험|위험|  
    |혼합된 투명도|투명|투명|  
    |보안 중립적|안전에 중요|위험|  
  
     예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식을 사용 하 여 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다. 투명도 수준에 대 한 자세한 내용은 [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md) 하 고 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
    > [!NOTE]
    >  보안에 종속 되지 않으므로, System.dll과 같은 신뢰할 수 있는 수준 1 어셈블리에 모듈을 사용 하 여 동적 메서드를 연결 하는 경우에 신뢰 권한 상승이 허용 하지 않습니다. 동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 집합이 포함 되어 있지 않으면 <xref:System.Security.SecurityException> 동적 메서드를 호출할 때 throw 됩니다.  
  
-   투명도 부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드의 어셈블리를 로드 하는 방법에 따라 달라 집니다. 어셈블리 (예를 들어 샌드박스 애플리케이션 도메인)으로 부분 신뢰를 사용 하 여 로드 된 경우 런타임은 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다. 런타임 (예를 들어, 데스크톱 애플리케이션의 기본 애플리케이션 도메인)에 완전 신뢰 여 부분 신뢰 어셈블리를 로드 하는 경우에 보안 주석에 주의 지불 합니다. 이 경우 런타임은 어셈블리의 주석에 따라 메서드에 대 한 투명도 동적 메서드를 할당합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 투명도 참조 하세요 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 메서드 본문이 없습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">보안 투명 코드, 수준 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">보안 투명 코드, 수준 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동적 메서드가 현재 신뢰 수준에서 보안 안전에 중요한 형식인지, 즉 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>동적 메서드가 현재 신뢰 수준에서 보안 안전에 중요한 형식인 경우 <see langword="true" />이고, 보안에 중요한 형식이거나 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다. 동적 메서드가 모듈 대신 형식을 사용 하 여 연결 된 경우 해당 투명도 형식을 포함 하는 모듈에 따라 달라 집니다. 동적 메서드는 관련 된 모듈에 대 한 투명도 할당 보안 주석을 갖지 않습니다.  
  
-   익명으로 호스트 된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 고, 항상입니다.  
  
-   투명도 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된) 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드는 다음 표에 설명 되어 있습니다.  
  
    |어셈블리 주석|수준 1 투명도|수준 2 투명도|  
    |-------------------------|--------------------------|--------------------------|  
    |완전히 투명 하 게|투명|투명|  
    |완벽 하 게 중요 한|위험|위험|  
    |혼합된 투명도|투명|투명|  
    |보안 중립적|안전에 중요|위험|  
  
     예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식을 사용 하 여 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다. 투명도 수준에 대 한 자세한 내용은 [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md) 하 고 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
    > [!NOTE]
    >  보안에 종속 되지 않으므로, System.dll과 같은 신뢰할 수 있는 수준 1 어셈블리에 모듈을 사용 하 여 동적 메서드를 연결 하는 경우에 신뢰 권한 상승이 허용 하지 않습니다. 동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 집합이 포함 되어 있지 않으면 <xref:System.Security.SecurityException> 동적 메서드를 호출할 때 throw 됩니다.  
  
-   투명도 부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드의 어셈블리를 로드 하는 방법에 따라 달라 집니다. 어셈블리 (예를 들어 샌드박스 애플리케이션 도메인)으로 부분 신뢰를 사용 하 여 로드 된 경우 런타임은 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다. 런타임 (예를 들어, 데스크톱 애플리케이션의 기본 애플리케이션 도메인)에 완전 신뢰 여 부분 신뢰 어셈블리를 로드 하는 경우에 보안 주석에 주의 지불 합니다. 이 경우 런타임은 어셈블리의 주석에 따라 메서드에 대 한 투명도 동적 메서드를 할당합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 투명도 참조 하세요 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 메서드 본문이 없습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">보안 투명 코드, 수준 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">보안 투명 코드, 수준 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동적 메서드가 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</summary>
        <value>동적 메서드가 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)에 의해 결정 된 동적 메서드의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 동적 메서드의 투명도와 연결 된 모듈에 따라 달라 집니다. 동적 메서드가 모듈 대신 형식을 사용 하 여 연결 된 경우 해당 투명도 형식을 포함 하는 모듈에 따라 달라 집니다. 동적 메서드는 관련 된 모듈에 대 한 투명도 할당 보안 주석을 갖지 않습니다.  
  
-   익명으로 호스트 된 동적 메서드는 포함 하는 시스템 제공 모듈 투명 하기 때문에 투명 하 고, 항상입니다.  
  
-   투명도 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된) 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드는 다음 표에 설명 되어 있습니다.  
  
    |어셈블리 주석|수준 1 투명도|수준 2 투명도|  
    |-------------------------|--------------------------|--------------------------|  
    |완전히 투명 하 게|투명|투명|  
    |완벽 하 게 중요 한|위험|위험|  
    |혼합된 투명도|투명|투명|  
    |보안 중립적|안전에 중요|위험|  
  
     예를 들어 2의 혼합된 투명도 수준에 mscorlib.dll에 있는 형식을 사용 하 여 동적 메서드를 연결 하는 경우 동적 메서드는 투명 및 중요 한 코드를 실행할 수 없습니다. 투명도 수준에 대 한 자세한 내용은 [보안 투명 코드, 수준 1](~/docs/framework/misc/security-transparent-code-level-1.md) 하 고 [보안 투명 코드, 수준 2](~/docs/framework/misc/security-transparent-code-level-2.md)합니다.  
  
    > [!NOTE]
    >  보안에 종속 되지 않으므로, System.dll과 같은 신뢰할 수 있는 수준 1 어셈블리에 모듈을 사용 하 여 동적 메서드를 연결 하는 경우에 신뢰 권한 상승이 허용 하지 않습니다. 동적 메서드를 호출 하는 코드의 권한 부여 집합 (즉, 완전 신뢰), System.dll의 권한 집합이 포함 되어 있지 않으면 <xref:System.Security.SecurityException> 동적 메서드를 호출할 때 throw 됩니다.  
  
-   투명도 부분적으로 신뢰할 수 있는 어셈블리와 연결 된 동적 메서드의 어셈블리를 로드 하는 방법에 따라 달라 집니다. 어셈블리 (예를 들어 샌드박스 애플리케이션 도메인)으로 부분 신뢰를 사용 하 여 로드 된 경우 런타임은 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식 및 멤버에 동적 메서드를 포함 하 여 투명 하 게 처리 됩니다. 런타임 (예를 들어, 데스크톱 애플리케이션의 기본 애플리케이션 도메인)에 완전 신뢰 여 부분 신뢰 어셈블리를 로드 하는 경우에 보안 주석에 주의 지불 합니다. 이 경우 런타임은 어셈블리의 주석에 따라 메서드에 대 한 투명도 동적 메서드를 할당합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 투명도 참조 하세요 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 메서드 본문이 없습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">보안 투명 코드, 수준 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">보안 투명 코드, 수준 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에는 지원되지 않습니다.</summary>
        <value>동적 메서드에는 지원되지 않습니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">동적 메서드에는 허용되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드가 논리적으로 연결되는 모듈을 가져옵니다.</summary>
        <value>현재 동적 메서드가 연결되는 <see cref="T:System.Reflection.Module" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모듈 동적 메서드를 만들 때 지정 된 경우이 속성이 해당 모듈을 반환 합니다. 동적 메서드를 만들 때 소유자 형식이 지정 된,이 속성 형식임을 포함 하는 모듈을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Reflection.Emit.DynamicMethod.Module%2A> 동적 메서드는 속성입니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드의 이름입니다.</summary>
        <value>메서드의 단순한 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  동적 메서드 이름 하는 데 필요한 것입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드 이름을 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드를 얻기 위해 리플렉션에 사용된 클래스를 가져옵니다.</summary>
        <value>항상 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 반환 `null` 동적 메서드에 대 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 반영된 형식의 동적 메서드를 표시합니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드의 반환 매개 변수를 가져옵니다.</summary>
        <value>항상 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 항상 반환 `null` 동적 메서드에 대 한 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에 대한 반환 값 형식을 가져옵니다.</summary>
        <value>현재 메서드의 반환 값 형식을 나타내는 <see cref="T:System.Type" />입니다. 메서드에 반환 형식이 없으면 <see cref="T:System.Void" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `null` 동적 메서드 생성 된이 속성을 반환 하는 경우 반환 형식에 대 한 지정 된 <xref:System.Void?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 동적 메서드의 반환 형식 표시 됩니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 메서드에 대한 반환 형식의 사용자 지정 특성을 가져옵니다.</summary>
        <value>동적 메서드에 대한 반환 형식의 사용자 지정 특성을 나타내는 <see cref="T:System.Reflection.ICustomAttributeProvider" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 특성의 배열을 반환 하 여 동적 메서드의 반환 형식에 사용자 지정 특성이 지원 되지 않습니다는 <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> 메서드는 항상 비어 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 메서드 반환 형식의 사용자 지정 특성을 표시 하는 방법을 보여 줍니다. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>문자열로 표현된 메서드의 서명을 반환합니다.</summary>
        <returns>메서드 시그니처를 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서명이 있는 경우 형식과 메서드 이름을 포함 됩니다. 매개 변수 이름이 포함 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> 동적 메서드의 메서드. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.DynamicMethod> 클래스입니다.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>