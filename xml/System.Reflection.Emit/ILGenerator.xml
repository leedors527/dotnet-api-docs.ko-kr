<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ca2e1013cb2b77f0e0eafae9f9f5baa73cf5d97" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="26e79-101">MSIL(Microsoft Intermediate Language) 명령을 생성합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="26e79-101">Generates Microsoft intermediate language (MSIL) instructions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-102"><xref:System.Reflection.Emit.ILGenerator> 동적 어셈블리에서 메서드와 생성자에 대 한 메서드 본문을 생성 하는 데 사용 됩니다 (표시는 <xref:System.Reflection.Emit.MethodBuilder> 및 <xref:System.Reflection.Emit.ConstructorBuilder> 클래스) 및 독립 실행형 동적 메서드에 대 한 (나타내는 <xref:System.Reflection.Emit.DynamicMethod> 클래스).</span><span class="sxs-lookup"><span data-stu-id="26e79-102"><xref:System.Reflection.Emit.ILGenerator> is used to generate method bodies for methods and constructors in dynamic assemblies (represented by the <xref:System.Reflection.Emit.MethodBuilder> and <xref:System.Reflection.Emit.ConstructorBuilder> classes) and for standalone dynamic methods (represented by the <xref:System.Reflection.Emit.DynamicMethod> class).</span></span> <span data-ttu-id="26e79-103">가져올 수는 <xref:System.Reflection.Emit.ILGenerator>를 사용 하 여는 <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, 및 <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-103">To obtain an <xref:System.Reflection.Emit.ILGenerator>, use the <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="26e79-104">MSIL 타임 (JIT) 컴파일러에 대 한 입력으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-104">MSIL is used as input to a just-in-time (JIT) compiler.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType">
          <span data-ttu-id="26e79-105">예외를 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-105">The <see cref="T:System.Type" /> object that represents the exception.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-106">catch 블록을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-106">Begins a catch block.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-107">현재 예외 블록의 끝에 분기 명령을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-107">Emits a branch instruction to the end of the current exception block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26e79-108">예외 필터 블록 반환 하는 경우는 `constant exception_execute_handler` (의 공용 언어 인프라 명령 집합에 대 한 설명서 참조)에 대 한 인수는 `BeginCatchBlock` 확인 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-108">If the filter exception block returns the `constant exception_execute_handler` (see the documentation for the Common Language Infrastructure Instruction Set), the argument to the `BeginCatchBlock` is not checked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-109">다음 코드 예제에서는 사용 하 여는 `BeginCatchBlock` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-109">The code sample below demonstrates the contextual usage of the `BeginCatchBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-110">catch 블록이 필터링된 예외 내에 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-110">The catch block is within a filtered exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-111">
            <paramref name="exceptionType" />이 <see langword="null" />이고, 해당 catch 블록을 찾을 때까지 finally 블록을 실행해야 한다는 것을 나타내는 값을 예외 필터 블록에서 반환하지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-111">
              <paramref name="exceptionType" /> is <see langword="null" />, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-112">생성되는 MSIL(Microsoft Intermediate Language)이 현재 예외 블록에 들어 있지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-112">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-113">필터링된 예외에 대한 예외 블록을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-113">Begins an exception block for a filtered exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-114">현재 예외 블록의 끝에 분기 명령을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-114">Emits a branch instruction to the end of the current exception block.</span></span>  
  
 <span data-ttu-id="26e79-115">하는 경우 현재 <xref:System.Reflection.Emit.ILGenerator> 연관는 <xref:System.Reflection.Emit.DynamicMethod> 개체를 표시 하 고 필터링 된 예외 블록 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-115">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting filtered exception blocks is not supported.</span></span> <span data-ttu-id="26e79-116"><xref:System.Reflection.Emit.DynamicILInfo> 사용할 수는 동적 메서드를 사용 하 여 필터링 된 예외 블록을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-116"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses filtered exception blocks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-117">생성되는 MSIL(Microsoft Intermediate Language)이 현재 예외 블록에 들어 있지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-117">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span>
          </span>
          <span data-ttu-id="26e79-118">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-118">-or-</span>
          </span>
          <span data-ttu-id="26e79-119">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 속해 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-119">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-120">필터링되지 않은 예외에 대한 예외 블록을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-120">Begins an exception block for a non-filtered exception.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26e79-121">블록의 끝에 대한 레이블입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-121">The label for the end of the block.</span>
          </span>
          <span data-ttu-id="26e79-122">사용자는 이 레이블을 통해 올바른 위치에서 finally 블록을 실행하거나 try를 종료할 수 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-122">This will leave you in the correct place to execute finally blocks or to finish the try.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-123">예외 블록을 만드는 몇 가지 정보를 기록 하는 모든 Microsoft MSIL (intermediate language) 스트림에 실제로 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-123">Creating an exception block records some information, but does not actually emit any Microsoft intermediate language (MSIL) onto the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-124">다음 코드 예제에서는 사용 하 여는 `BeginExceptionBlock` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-124">The code sample below demonstrates the contextual usage of the `BeginExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-125">MSIL(Microsoft Intermediate Language) 스트림의 예외 오류 블록을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-125">Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-126">하는 경우 현재 <xref:System.Reflection.Emit.ILGenerator> 연관는 <xref:System.Reflection.Emit.DynamicMethod> 표시 하 고 오류 블록 예외 개체가 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-126">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting exception fault blocks is not supported.</span></span> <span data-ttu-id="26e79-127"><xref:System.Reflection.Emit.DynamicILInfo> 용도 예외 오류 블록을 사용 하는 동적 메서드를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-127"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses exception fault blocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-128">다음 코드 샘플에서는 `BeginFaultBlock`합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-128">The following code sample illustrates the use of `BeginFaultBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-129">생성 중인 MSIL이 현재 예외 블록에 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-129">The MSIL being generated is not currently in an exception block.</span>
          </span>
          <span data-ttu-id="26e79-130">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-130">-or-</span>
          </span>
          <span data-ttu-id="26e79-131">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 속해 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-131">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-132">MSIL(Microsoft Intermediate Language) 명령 스트림의 finally 블록을 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-132">Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26e79-133">다음 코드 샘플에서는 `BeginFinallyBlock`합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-133">The following code sample illustrates the use of `BeginFinallyBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-134">생성 중인 MSIL이 현재 예외 블록에 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-134">The MSIL being generated is not currently in an exception block.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-135">어휘 범위를 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-135">Begins a lexical scope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-136">이 메서드는 기호화 된 정보를 내보내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-136">This method is used to emit symbolic information.</span></span> <span data-ttu-id="26e79-137">다음에 선언 된 지역 변수 <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> 해당 될 때까지 범위 <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-137">Local variables declared after <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> are scoped until the corresponding <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> is called.</span></span>  
  
 <span data-ttu-id="26e79-138">하는 경우 현재 <xref:System.Reflection.Emit.ILGenerator> 연결 된 한 <xref:System.Reflection.Emit.DynamicMethod> 개체, 기호화 된 정보를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-138">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-139">다음 코드 샘플에서는 `BeginScope` 및 `EndScope`합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-139">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-140">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 속해 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-140">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26e79-141">지역 변수를 선언합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-141">Declares a local variable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType">
          <span data-ttu-id="26e79-142">지역 변수의 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-142">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-143">지정한 형식의 지역 변수를 선언합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-143">Declares a local variable of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26e79-144">선언된 지역 변수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-144">The declared local variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-145">지역 변수는 현재 어휘 범위;에 만들어집니다. 예를 들어, 코드에서 내보내지는 `for` 루프 (`For` Visual Basic의 루프), 변수의 범위는 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-145">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="26e79-146">이 오버 로드를 사용 하 여 만든 지역 변수 고정 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-146">A local variable created with this overload is not pinned.</span></span> <span data-ttu-id="26e79-147">고정된 변수를 사용 하 여 관리 되지 않는 포인터를 만들려면 사용은 <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-147">To create a pinned variable for use with unmanaged pointers, use the <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-148">다음 코드 예제에서는 `DeclareLocal` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-148">The following code example demonstrates the use of the `DeclareLocal` method.</span></span> <span data-ttu-id="26e79-149">이 코드는 일부에 대 한 더 큰 코드 예제는 <xref:System.Reflection.Emit.LocalBuilder> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-149">This code is part of a larger code example for the <xref:System.Reflection.Emit.LocalBuilder> class.</span></span>  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-150">
            <paramref name="localType" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-150">
              <paramref name="localType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26e79-151">포함하는 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드에 의해 만들어진 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-151">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="localType">
          <span data-ttu-id="26e79-152">지역 변수의 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-152">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span>
          </span>
        </param>
        <param name="pinned">
          <span data-ttu-id="26e79-153">메모리에 개체를 고정하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-153">
              <see langword="true" /> to pin the object in memory; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-154">지정한 형식의 지역 변수를 선언하고, 선택적으로 해당 변수가 참조하는 개체를 고정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-154">Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26e79-155">지역 변수를 나타내는 <see cref="T:System.Reflection.Emit.LocalBuilder" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-155">A <see cref="T:System.Reflection.Emit.LocalBuilder" /> object that represents the local variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-156">지역 변수는 현재 어휘 범위;에 만들어집니다. 예를 들어, 코드에서 내보내지는 `for` 루프 (`For` Visual Basic의 루프), 변수의 범위는 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-156">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="26e79-157">안전 하지 않은 코드에서 개체를 고정 해야 관리 되지 않는 포인터에 의해를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-157">In unsafe code, an object must be pinned before it can be referred to by an unmanaged pointer.</span></span> <span data-ttu-id="26e79-158">참조 된 개체의 고정 되어 있는 동안에 가비지 수집에 의해 이동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-158">While the referenced object is pinned, it cannot be moved by garbage collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-159">
            <paramref name="localType" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-159">
              <paramref name="localType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26e79-160">포함하는 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드에 의해 만들어진 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-160">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
          <span data-ttu-id="26e79-161">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-161">-or-</span>
          </span>
          <span data-ttu-id="26e79-162">바깥쪽 메서드의 메서드 본문이 <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> 메서드에 의해 만들어진 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-162">The method body of the enclosing method has been created by the <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-163">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 연결되어 있는 메서드가 <see cref="T:System.Reflection.Emit.MethodBuilder" />에 표시되지 않을 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-163">The method with which this <see cref="T:System.Reflection.Emit.ILGenerator" /> is associated is not represented by a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-164">새 레이블을 선언합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-164">Declares a new label.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="26e79-165">분기에 대한 토큰으로 사용할 수 있는 새 레이블을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-165">Returns a new label that can be used as a token for branching.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-166">스트림 내의 레이블의 위치를 설정 하려면 호출 해야 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-166">To set the position of the label within the stream, you must call <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span>  
  
 <span data-ttu-id="26e79-167">토큰 일 뿐 이므로 아직 스트림 내의 특정 위치를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-167">This is just a token and does not yet represent any particular location within the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-168">다음 코드 예제에서는 사용 하 여는 `DefineLabel` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-168">The code sample below demonstrates the contextual usage of the `DefineLabel` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26e79-169">JIT(Just-In-Time) 컴파일러에 대한 MSIL(Microsoft Intermediate Language) 스트림에 명령을 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-169">Puts an instruction onto the Microsoft Intermediate Language (MSIL) stream for the just-in-time (JIT) compiler.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-170">스트림에 배치될 MSIL(Microsoft Intermediate Language) 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-170">The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-171">명령 스트림에 지정된 명령을 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-171">Puts the specified instruction onto the stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-172">경우는 `opcode` 인수를 사용 해야 매개 변수, 선언 된 매개 변수의 길이 일치 하는 인수는 호출자에 게 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-172">If the `opcode` parameter requires an argument, the caller must ensure that the argument length matches the length of the declared parameter.</span></span> <span data-ttu-id="26e79-173">그렇지 않으면 결과 예측할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-173">Otherwise, results will be unpredictable.</span></span> <span data-ttu-id="26e79-174">예를 들어 Emit 명령에는 2 바이트 피연산자가 있어야 합니다. 호출자는 4 바이트 피연산자를 제공 하는 경우 런타임은 추가로 2 바이트를 명령 스트림의를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-174">For example, if the Emit instruction requires a 2-byte operand and the caller supplies a 4-byte operand, the runtime will emit two additional bytes to the instruction stream.</span></span> <span data-ttu-id="26e79-175">이러한 추가 바이트 <xref:System.Reflection.Emit.OpCodes.Nop> 지침.</span><span class="sxs-lookup"><span data-stu-id="26e79-175">These extra bytes will be <xref:System.Reflection.Emit.OpCodes.Nop> instructions.</span></span>  
  
 <span data-ttu-id="26e79-176">명령 값에 정의 된 <xref:System.Reflection.Emit.OpCodes>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-176">The instruction values are defined in <xref:System.Reflection.Emit.OpCodes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-177">아래 코드 샘플의 사용법을 보여줍니다 `Emit` 요소의 인스턴스를 통해 MSIL 출력을 생성할 <xref:System.Reflection.Emit.ILGenerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-177">The code sample below demonstrates the use of `Emit` to generate MSIL output via an instance of <xref:System.Reflection.Emit.ILGenerator>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-178">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-178">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-179">명령 바로 다음에 스트림으로 푸시되는 문자 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-179">The character argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-180">지정된 명령 및 문자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-180">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-181">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-181">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-182">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-182">The MSIL instruction to be put onto the stream.</span>
          </span>
          <span data-ttu-id="26e79-183">
            <see langword="OpCodes" /> 열거형에 정의됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-183">Defined in the <see langword="OpCodes" /> enumeration.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-184">명령 바로 다음에 스트림으로 푸시되는 숫자 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-184">The numerical argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-185">지정된 명령 및 숫자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-185">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-186">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-186">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-187">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-187">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-188">명령 바로 다음에 스트림으로 푸시되는 <see langword="Int" /> 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-188">The <see langword="Int" /> argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-189">지정된 명령 및 숫자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-189">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-190">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-190">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-191">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-191">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-192">명령 바로 다음에 스트림으로 푸시되는 숫자 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-192">The numerical argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-193">지정된 명령 및 숫자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-193">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-194">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-194">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-195">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-195">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-196">명령 바로 다음에 스트림으로 푸시되는 숫자 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-196">The numerical argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-197">지정된 명령 및 숫자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-197">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-198">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-198">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-199">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-199">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="con">
          <span data-ttu-id="26e79-200">생성자를 나타내는 <see langword="ConstructorInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-200">A <see langword="ConstructorInfo" /> representing a constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-201">MSIL(Microsoft Intermediate Language) 명령 스트림에 지정된 명령 및 지정된 생성자에 대한 메타데이터 토큰을 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-201">Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-202">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-202">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="26e79-203">위치 `con` 모듈 이식 가능한 실행 (PE) 파일을 유지할 때 필요한 경우와 명령 스트림의 패치할 수 있도록 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-203">The location of `con` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-204">
            <paramref name="con" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-204">
              <paramref name="con" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="26e79-205">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 새 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-205">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-206">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-206">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="label">
          <span data-ttu-id="26e79-207">이 위치에서 분기될 레이블입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-207">The label to which to branch from this location.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-208">지정된 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치하고 고정이 완료되면 레이블을 포함할 공간을 남겨 둡니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-208">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-209">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-209">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="26e79-210">레이블을 사용 하 여 만든 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, 스트림 내의 위치를 사용 하 여 고정 됩니다 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-210">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="26e79-211">단일 바이트 명령을 사용 하는 경우 레이블에 최대 127 바이트 스트림 따라가고의 점프를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-211">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="26e79-212">`opcode` 분기 명령이 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-212">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="26e79-213">분기는 상대 명령 `label` 픽스업 과정 중 분기에 대 한 올바른 오프셋으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-213">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-214">다음 코드 예제 점프 테이블이 포함 된 동적 메서드를 만들기에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-214">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="26e79-215">점프 테이블의 배열을 사용 하 여 빌드될 <xref:System.Reflection.Emit.Label>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-215">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-216">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-216">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="labels">
          <span data-ttu-id="26e79-217">이 위치에서 분기될 레이블 개체 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-217">The array of label objects to which to branch from this location.</span>
          </span>
          <span data-ttu-id="26e79-218">모든 레이블을 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-218">All of the labels will be used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-219">지정된 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치하고 고정이 완료되면 레이블을 포함할 공간을 남겨 둡니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-219">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-220">스위치 테이블을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-220">Emits a switch table.</span></span>  
  
 <span data-ttu-id="26e79-221">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-221">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="26e79-222">레이블을 사용 하 여 만든 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> 스트림 내에서 위치를 사용 하 여 고정 됩니다 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-222">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="26e79-223">단일 바이트 명령을 사용 하는 경우 레이블에 최대 127 바이트 스트림 따라가고의 점프를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-223">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="26e79-224">`opcode` 분기 명령이 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-224">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="26e79-225">분기는 상대 명령 `label` 픽스업 과정 중 분기에 대 한 올바른 오프셋으로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-225">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-226">다음 코드 예제 점프 테이블이 포함 된 동적 메서드를 만들기에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-226">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="26e79-227">점프 테이블의 배열을 사용 하 여 빌드될 <xref:System.Reflection.Emit.Label>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-227">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-228">
            <paramref name="con" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-228">
              <paramref name="con" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="26e79-229">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]의 새 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-229">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-230">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-230">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="local">
          <span data-ttu-id="26e79-231">지역 변수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-231">A local variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-232">MSIL(Microsoft Intermediate Language) 스트림에 지정된 명령을 배치합니다. 해당 스트림 다음에는 지정된 지역 변수에 대한 메타데이터 인덱스가 옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-232">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-233">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-233">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-234">
            <paramref name="local" /> 매개 변수의 부모 메서드가 해당 <see cref="T:System.Reflection.Emit.ILGenerator" />에 연결된 메서드와 일치하지 않는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-234">The parent method of the <paramref name="local" /> parameter does not match the method associated with this <see cref="T:System.Reflection.Emit.ILGenerator" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-235">
            <paramref name="local" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-235">
              <paramref name="local" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26e79-236">
            <paramref name="opcode" />가 싱글바이트 명령이며 <paramref name="local" />이 <see langword="Byte.MaxValue" />보다 큰 인덱스의 지역 변수를 나타내는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-236">
              <paramref name="opcode" /> is a single-byte instruction, and <paramref name="local" /> represents a local variable with an index greater than <see langword="Byte.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-237">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-237">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="signature">
          <span data-ttu-id="26e79-238">시그니처 토큰을 생성하는 도우미입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-238">A helper for constructing a signature token.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-239">MSIL(Microsoft Intermediate Language) 명령 스트림에 지정된 명령 및 시그니처 토큰을 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-239">Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-240">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-240">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-241">
            <paramref name="signature" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-241">
              <paramref name="signature" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-242">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-242">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="26e79-243">필드를 나타내는 <see langword="FieldInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-243">A <see langword="FieldInfo" /> representing a field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-244">MSIL(Microsoft Intermediate Language) 명령 스트림에 지정된 명령 및 지정된 필드에 대한 메타데이터 토큰을 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-244">Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-245">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-245">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="26e79-246">위치 `field` 모듈 이식 가능한 실행 (PE) 파일을 유지할 때 필요한 경우와 명령 스트림의 패치할 수 있도록 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-246">The location of `field` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-247">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-247">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="meth">
          <span data-ttu-id="26e79-248">메서드를 나타내는 <see langword="MethodInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-248">A <see langword="MethodInfo" /> representing a method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-249">지정된 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치합니다. 해당 스트림 다음에는 지정한 메서드에 대한 메타데이터 토큰이 옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-249">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-250">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-250">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="26e79-251">위치 `meth` 모듈 이식 가능한 실행 (PE) 파일을 유지할 때 필요한 경우와 명령 스트림의 패치할 수 있도록 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-251">The location of `meth` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 <span data-ttu-id="26e79-252">경우 `meth` 제네릭 메서드를 나타내는 제네릭 메서드 정의 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-252">If `meth` represents a generic method, it must be a generic method definition.</span></span> <span data-ttu-id="26e79-253">즉, 해당 [MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) 속성 이어야 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-253">That is, its [MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) property must be `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-254">
            <paramref name="meth" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-254">
              <paramref name="meth" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-255">
            <paramref name="meth" />가 <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> 속성이 <see langword="false" />인 제네릭 메서드인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-255">
              <paramref name="meth" /> is a generic method for which the <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-256">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-256">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-257">명령 바로 다음에 스트림으로 푸시되는 문자 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-257">The character argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-258">지정된 명령 및 문자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-258">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-259">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-259">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-260">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-260">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="arg">
          <span data-ttu-id="26e79-261">명령 바로 다음에 스트림으로 푸시되는 <see langword="Single" /> 인수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-261">The <see langword="Single" /> argument pushed onto the stream immediately after the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-262">지정된 명령 및 숫자 인수를 MSIL(Microsoft Intermediate Language) 명령 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-262">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-263">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-263">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-264">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-264">The MSIL instruction to be emitted onto the stream.</span>
          </span>
        </param>
        <param name="str">
          <span data-ttu-id="26e79-265">내보낼 <see langword="String" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-265">The <see langword="String" /> to be emitted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-266">지정된 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치합니다. 해당 스트림 다음에는 지정한 문자열에 대한 메타데이터 토큰이 옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-266">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-267">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-267">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="26e79-268">위치 `str` 모듈이 pe (이식 가능) 파일에 유지 하는 경우 향후 픽스업에 대해 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-268">The location of `str` is recorded for future fixups if the module is persisted to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-269">스트림에 배치될 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-269">The MSIL instruction to be put onto the stream.</span>
          </span>
        </param>
        <param name="cls">
          <span data-ttu-id="26e79-270">
            <see langword="Type" />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-270">A <see langword="Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-271">지정된 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치합니다. 해당 스트림 다음에는 지정한 형식에 대한 메타데이터 토큰이 옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-271">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-272">에 정의 된 명령 값의 `OpCodes` 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-272">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="26e79-273">위치 `cls` 모듈 이식 가능한 실행 (PE) 파일을 유지할 때 필요한 경우 토큰을 패치할 수 있도록 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-273">The location of `cls` is recorded so that the token can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-274">
            <paramref name="cls" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-274">
              <paramref name="cls" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-275">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-275">The MSIL instruction to be emitted onto the stream.</span>
          </span>
          <span data-ttu-id="26e79-276">
            <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> 또는 <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />여야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-276">Must be <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, or <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</span>
          </span>
        </param>
        <param name="methodInfo">
          <span data-ttu-id="26e79-277">호출할 <see langword="varargs" /> 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-277">The <see langword="varargs" /> method to be called.</span>
          </span>
        </param>
        <param name="optionalParameterTypes">
          <span data-ttu-id="26e79-278">메서드가 <see langword="varargs" /> 메서드이면 선택적 인수의 형식이고, 그렇지 않으면 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-278">The types of the optional arguments if the method is a <see langword="varargs" /> method; otherwise, <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-279">
            <see langword="call" /> 또는 <see langword="callvirt" /> 명령을 MSIL(Microsoft intermediate language) 스트림에 배치하여 <see langword="varargs" /> 메서드를 호출합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-279">Puts a <see langword="call" /> or <see langword="callvirt" /> instruction onto the Microsoft intermediate language (MSIL) stream to call a <see langword="varargs" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-280"><xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 메서드 호출을 내보내고는 `varargs` 메서드의 오버 로드가 없으므로 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 가변 매개 변수 형식을 지정 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-280">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is used to emit calls to `varargs` methods because there is no overload of the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method that specifies the parameter types of the variable arguments.</span></span>  
  
 <span data-ttu-id="26e79-281">사용 하지 않는 메서드 호출을 내보내는 <xref:System.Reflection.CallingConventions.VarArgs> 호출 규칙을 사용 하 여는 <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> 메서드 오버 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-281">To emit calls to methods that do not use the <xref:System.Reflection.CallingConventions.VarArgs> calling convention, use the <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="26e79-282">버전 정보</span><span class="sxs-lookup"><span data-stu-id="26e79-282">Version Information</span></span>  
 <span data-ttu-id="26e79-283">.NET Framework 버전 2.0 부터는 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 없는 메서드에 선택적 매개 변수 형식이 지정 되 면 메서드는 예외를 throw 하지 않습니다 `varargs`합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-283">Beginning with the .NET Framework version 2.0, the <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method does not throw an exception when optional parameter types are specified for a method that is not `varargs`.</span></span> <span data-ttu-id="26e79-284"><xref:System.InvalidProgramException> 호출이 실행 되 면 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-284"><xref:System.InvalidProgramException> is thrown when the call is executed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-285">다음 코드 예제에서는 두 가지 방법에서 한 `varargs` 메서드 및 메서드를 호출 하는 `varargs` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-285">The following code example emits two methods, a `varargs` method and a method that calls the `varargs` method.</span></span> <span data-ttu-id="26e79-286">`EmitCall` 메서드 호출을 내보내는를 사용 하는 `varargs` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-286">The `EmitCall` method is used to emit the call to the `varargs` method.</span></span>  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-287">
            <paramref name="opcode" />에서 메서드 호출을 지정하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-287">
              <paramref name="opcode" /> does not specify a method call.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-288">
            <paramref name="methodInfo" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-288">
              <paramref name="methodInfo" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26e79-289">메서드에 대한 호출 규칙이 <see langword="varargs" />가 아니고 선택적 매개 변수 형식이 제공됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-289">The calling convention for the method is not <see langword="varargs" />, but optional parameter types are supplied.</span>
          </span>
          <span data-ttu-id="26e79-290">이 예외는 .NET Framework 버전 1.0 및 1.1에서 throw됩니다. 후속 버전에서는 예외가 throw되지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-290">This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26e79-291">MSIL(Microsoft Intermediate Language) 스트림에 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 명령을 넣습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-291">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-292">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-292">The MSIL instruction to be emitted onto the stream.</span>
          </span>
          <span data-ttu-id="26e79-293">
            <see cref="F:System.Reflection.Emit.OpCodes.Calli" />여야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-293">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span>
          </span>
        </param>
        <param name="unmanagedCallConv">
          <span data-ttu-id="26e79-294">사용될 관리되지 않는 호출 규칙입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-294">The unmanaged calling convention to be used.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="26e79-295">결과의 <see cref="T:System.Type" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-295">The <see cref="T:System.Type" /> of the result.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="26e79-296">명령에 사용되는 필수 인수의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-296">The types of the required arguments to the instruction.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-297">간접 호출에 대해 관리되지 않는 호출을 지정하여 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-297">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-298">사용 하 여 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 배치 하는 <xref:System.Reflection.Emit.OpCodes.Calli> 명령을 스트림에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-298">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="26e79-299"><xref:System.Reflection.Emit.ILGenerator.Emit%2A>를 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="26e79-299">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-300">다음 코드 샘플을 사용 하 여는 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 외부 동적 클래스에는 관리 되지 않는 형식의 메서드를 호출 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-300">The following code sample demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> method to call an unmanaged type method external to the dynamic class.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">
          <span data-ttu-id="26e79-301">스트림에 내보낼 MSIL 명령입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-301">The MSIL instruction to be emitted onto the stream.</span>
          </span>
          <span data-ttu-id="26e79-302">
            <see cref="F:System.Reflection.Emit.OpCodes.Calli" />여야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-302">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="26e79-303">사용될 관리되는 호출 규칙입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-303">The managed calling convention to be used.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="26e79-304">결과의 <see cref="T:System.Type" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-304">The <see cref="T:System.Type" /> of the result.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="26e79-305">명령에 사용되는 필수 인수의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-305">The types of the required arguments to the instruction.</span>
          </span>
        </param>
        <param name="optionalParameterTypes">
          <span data-ttu-id="26e79-306">
            <see langword="varargs" /> 호출에 사용되는 선택적 인수의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-306">The types of the optional arguments for <see langword="varargs" /> calls.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-307">간접 호출에 대해 관리되는 호출을 지정하여 <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> 명령을 MSIL(Microsoft Intermediate Language) 스트림에 배치합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-307">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-308">사용 하 여 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 배치 하는 <xref:System.Reflection.Emit.OpCodes.Calli> 명령을 스트림에 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-308">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="26e79-309"><xref:System.Reflection.Emit.ILGenerator.Emit%2A>를 사용하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="26e79-309">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
 <span data-ttu-id="26e79-310">경우 `optionalParameterTypes` 선택적 인수를 지정 `callingConvention` 포함 되어야 합니다는 <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-310">If `optionalParameterTypes` specifies optional arguments, `callingConvention` must include the <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> flag.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26e79-311">
            <paramref name="optionalParameterTypes" />가 <see langword="null" />이 아니지만 <paramref name="callingConvention" />에 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 플래그가 포함되어 있지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-311">
              <paramref name="optionalParameterTypes" /> is not <see langword="null" />, but <paramref name="callingConvention" /> does not include the <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flag.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="26e79-312">여러 형식의 값을 사용하여 <see cref="M:System.Console.WriteLine" />에 대한 호출을 내보내는 도우미 함수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-312">Helper functions to emit a call to <see cref="M:System.Console.WriteLine" /> with different types of values.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder">
          <span data-ttu-id="26e79-313">해당 값이 콘솔에 기록될 로컬 변수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-313">The local variable whose value is to be written to the console.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-314">지정된 로컬 변수를 사용하여 <see cref="Overload:System.Console.WriteLine" />을 호출하는 데 필요한 MSIL(Microsoft 중간 언어)를 내보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-314">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given local variable.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-315">유형의 `localBuilder` 의 오버 로드의 매개 변수 형식과 일치 해야 합니다는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-315">The type of `localBuilder` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-316">다음 코드 예제에 사용 하 여 보여 줍니다는 <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> 메서드가 콘솔에 동적 메서드는 문자열을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-316">The code sample below demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-317">
            <paramref name="localBuilder" /> 형식이 지원되지 않는 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.EnumBuilder" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-317">The type of <paramref name="localBuilder" /> is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span>
          </span>
          <span data-ttu-id="26e79-318">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-318">-or-</span>
          </span>
          <span data-ttu-id="26e79-319">
            <paramref name="localBuilder" /> 형식을 수락하는 <see cref="Overload:System.Console.WriteLine" />의 오버로드가 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-319">There is no overload of <see cref="Overload:System.Console.WriteLine" /> that accepts the type of <paramref name="localBuilder" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-320">
            <paramref name="localBuilder" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-320">
              <paramref name="localBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld">
          <span data-ttu-id="26e79-321">해당 값을 콘솔에 기록할 필드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-321">The field whose value is to be written to the console.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-322">지정한 필드로 <see cref="Overload:System.Console.WriteLine" />을 호출하는 데 필요한 MSIL(Microsoft Intermediate Language)을 내보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-322">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given field.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-323">유형의 `fld` 의 오버 로드의 매개 변수 형식과 일치 해야 합니다는 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-323">The type of `fld` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-324">다음 코드 샘플의 사용법을 보여줍니다는 <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> 메서드가 콘솔에 동적 메서드는 문자열을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-324">The following code sample demonstrates the use of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-325">지정한 필드의 형식을 받아들이는 <see cref="Overload:System.Console.WriteLine" /> 메서드의 오버로드가 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-325">There is no overload of the <see cref="Overload:System.Console.WriteLine" /> method that accepts the type of the specified field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-326">
            <paramref name="fld" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-326">
              <paramref name="fld" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-327">필드의 형식이 지원되지 않는 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 또는 <see cref="T:System.Reflection.Emit.EnumBuilder" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-327">The type of the field is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="26e79-328">인쇄할 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-328">The string to be printed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-329">문자열로 <see cref="Overload:System.Console.WriteLine" />을 호출하는 MSIL(Microsoft Intermediate Language)을 내보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-329">Emits the Microsoft intermediate language (MSIL) to call <see cref="Overload:System.Console.WriteLine" /> with a string.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-330">문자열이 이미 정의 된 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-330">The string must have already been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-331">다음 코드 예제에 사용 하 여 보여 줍니다는 `EmitWriteLine` 메서드가 콘솔에 동적 메서드는 문자열을 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-331">The code sample below demonstrates the contextual usage of the `EmitWriteLine` method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-332">예외 블록을 끝냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-332">Ends an exception block.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26e79-333">다음 코드 예제에서는 사용 하 여는 `EndExceptionBlock` 메서드.</span><span class="sxs-lookup"><span data-stu-id="26e79-333">The code sample below demonstrates the contextual usage of the `EndExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26e79-334">코드 스트림의 예기치 않은 위치에서 end 예외 블록이 발생하는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-334">The end exception block occurs in an unexpected place in the code stream.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-335">생성되는 MSIL(Microsoft Intermediate Language)이 현재 예외 블록에 들어 있지 않은 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-335">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="26e79-336">어휘 범위를 종료합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-336">Ends a lexical scope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-337">이 메서드는 기호화 된 정보를 내보내는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-337">This method is used to emit symbolic information.</span></span> <span data-ttu-id="26e79-338">함께 사용 하는 <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-338">It is used with <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>.</span></span>  
  
 <span data-ttu-id="26e79-339">하는 경우 현재 <xref:System.Reflection.Emit.ILGenerator> 연결 된 한 <xref:System.Reflection.Emit.DynamicMethod> 개체, 기호화 된 정보를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-339">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-340">다음 코드 샘플에서는 `BeginScope` 및 `EndScope`합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-340">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-341">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 속해 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-341">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="26e79-342">
            <see cref="T:System.Reflection.Emit.ILGenerator" />에서 내보내는 MSIL(Microsoft Intermediate Language) 스트림의 현재 오프셋을 바이트 단위로 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-342">Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <see cref="T:System.Reflection.Emit.ILGenerator" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="26e79-343">MSIL 스트림에서 다음 명령을 내보낼 오프셋입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-343">The offset in the MSIL stream at which the next instruction will be emitted.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-344">이 메서드는 투명 하며 부분적으로 신뢰할 수 있는 코드에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-344">This method is transparent, and can be called from partially trusted code.</span></span>  
  
 <span data-ttu-id="26e79-345">경우는 <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> 모든 MSIL 명령을 내보낸 전에 속성에 액세스, 0 (영)을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-345">If the <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> property is accessed before any MSIL instructions have been emitted, it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="26e79-346">MSIL 동적 언어에 대해 생성 되 면 소스 코드 줄 번호에 MSIL 스트림에의 오프셋을 매핑할이 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-346">When MSIL is generated for dynamic languages, this property can be used to map offsets in the MSIL stream to source code line numbers.</span></span> <span data-ttu-id="26e79-347">결과 정보는 예외가 throw 되 면 스택 추적을 제공 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-347">The resulting information can be used to provide stack traces when exceptions are thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc">
          <span data-ttu-id="26e79-348">인덱스를 설정할 레이블입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-348">The label for which to set an index.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-349">지정된 레이블로 MSIL(Microsoft Intermediate Language) 스트림의 현재 위치를 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-349">Marks the Microsoft intermediate language (MSIL) stream's current position with the given label.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-350">레이블은 두 번 이상 정의할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-350">A label cannot be defined more than once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26e79-351">다음 코드 예제에 사용 하 여 보여 줍니다 `MarkLabel` 를 MSIL 분기는 동적 메서드를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-351">The code sample below demonstrates the contextual usage of `MarkLabel` to implement MSIL branching in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-352">
            <paramref name="loc" />가 레이블 배열의 잘못된 인덱스를 나타내는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-352">
              <paramref name="loc" /> represents an invalid index into the label array.</span>
          </span>
          <span data-ttu-id="26e79-353">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-353">-or-</span>
          </span>
          <span data-ttu-id="26e79-354">
            <paramref name="loc" />에 대한 인덱스가 이미 정의되어 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-354">An index for <paramref name="loc" /> has already been defined.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">
          <span data-ttu-id="26e79-355">시퀀스 위치를 정의할 문서입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-355">The document for which the sequence point is being defined.</span>
          </span>
        </param>
        <param name="startLine">
          <span data-ttu-id="26e79-356">시퀀스 위치가 시작되는 줄입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-356">The line where the sequence point begins.</span>
          </span>
        </param>
        <param name="startColumn">
          <span data-ttu-id="26e79-357">시퀀스 위치가 시작하는 줄의 열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-357">The column in the line where the sequence point begins.</span>
          </span>
        </param>
        <param name="endLine">
          <span data-ttu-id="26e79-358">시퀀스 위치가 끝나는 줄입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-358">The line where the sequence point ends.</span>
          </span>
        </param>
        <param name="endColumn">
          <span data-ttu-id="26e79-359">시퀀스 위치가 끝나는 줄의 열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-359">The column in the line where the sequence point ends.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-360">MSIL(Microsoft Intermediate Language) 스트림에 시퀀스 위치를 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-360">Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-361">줄 번호는 1에서 인덱스가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-361">Line numbers are indexed from 1.</span></span> <span data-ttu-id="26e79-362">열은 0에서 인덱싱됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-362">Columns are indexed from 0.</span></span>  
  
 <span data-ttu-id="26e79-363">기호화 된 정보에는 일반적으로 각 소스 줄에 대 한 MSIL 오프셋을 하나 이상 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-363">The symbolic information normally includes at least one MSIL offset for each source line.</span></span> <span data-ttu-id="26e79-364">JIT(Just-In-Time) 컴파일러에서 메서드를 컴파일할 때, 컴파일러에서는 프로파일링 서비스에 저장된 MSIL 오프셋 목록을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-364">When the just-in-time (JIT) compiler is about to compile a method, it asks the profiling services for a list of MSIL offsets that should be preserved.</span></span> <span data-ttu-id="26e79-365">이러한 MSIL 오프셋을 라고 *시퀀스 위치*합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-365">These MSIL offsets are called *sequence points*.</span></span>  
  
 <span data-ttu-id="26e79-366">하는 경우 현재 <xref:System.Reflection.Emit.ILGenerator> 연결 된 한 <xref:System.Reflection.Emit.DynamicMethod> 개체, 기호화 된 정보를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-366">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26e79-367">
            <paramref name="startLine" /> 또는 <paramref name="endLine" />은 &lt;= 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-367">
              <paramref name="startLine" /> or <paramref name="endLine" /> is &lt;= 0.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-368">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 속해 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-368">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="26e79-369">나중에 사용하기 위해 예약되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-369">Reserved for future use.</span>
          </span>
          <span data-ttu-id="26e79-370">IID_NULL이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-370">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="26e79-371">매핑할 전달된 이름의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-371">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="26e79-372">매핑할 이름의 수입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-372">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="26e79-373">이름을 해석할 로캘 컨텍스트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-373">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="26e79-374">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-374">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-375">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-375">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-376">이 메서드는 비관리 코드에서 관리 되는 클래스에 액세스 하기 위한 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-376">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="26e79-377">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-377">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="26e79-378">이 메서드는 COM <c>IDispatch</c> 인터페이스를 사용하여 런타임에 바인딩된 상태로 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-378">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="26e79-379">반환할 형식 정보입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-379">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="26e79-380">형식 정보의 로캘 식별자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-380">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="26e79-381">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-381">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-382">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-382">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-383">이 메서드는 비관리 코드에서 관리 되는 클래스에 액세스 하기 위한 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-383">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="26e79-384">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-384">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="26e79-385">이 메서드는 COM <c>IDispatch</c> 인터페이스를 사용하여 런타임에 바인딩된 상태로 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-385">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="26e79-386">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-386">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-387">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-387">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-388">이 메서드는 비관리 코드에서 관리 되는 클래스에 액세스 하기 위한 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-388">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="26e79-389">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-389">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="26e79-390">이 메서드는 COM <c>IDispatch</c> 인터페이스를 사용하여 런타임에 바인딩된 상태로 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-390">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="26e79-391">멤버를 식별합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-391">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="26e79-392">나중에 사용하기 위해 예약되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-392">Reserved for future use.</span>
          </span>
          <span data-ttu-id="26e79-393">IID_NULL이어야 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-393">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="26e79-394">인수를 해석할 로캘 컨텍스트입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-394">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="26e79-395">호출의 컨텍스트를 설명하는 플래그입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-395">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="26e79-396">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-396">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="26e79-397">결과를 저장할 위치에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-397">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="26e79-398">예외 정보가 포함된 구조체에 대한 포인터입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-398">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="26e79-399">오류가 있는 첫 번째 인수의 인덱스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-399">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-400">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-400">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-401">이 메서드는 비관리 코드에서 관리 되는 클래스에 액세스 하기 위한 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-401">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="26e79-402">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-402">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="26e79-403">이 메서드는 COM <c>IDispatch</c> 인터페이스를 사용하여 런타임에 바인딩된 상태로 호출됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-403">The method is called late-bound using the COM <c>IDispatch</c> interface.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType">
          <span data-ttu-id="26e79-404">throw할 예외 형식의 클래스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-404">The class of the type of exception to throw.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-405">예외를 throw하는 명령을 내보냅니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-405">Emits an instruction to throw an exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="26e79-406">다음 코드 샘플을 사용 하 여 `ThrowException` 동적 메서드의 MSIL 내부 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-406">The following code sample demonstrates the contextual usage of `ThrowException` to throw an exception inside the MSIL of a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-407">
            <paramref name="excType" />이 <see cref="T:System.Exception" /> 클래스가 아니거나 <see cref="T:System.Exception" />의 파생 클래스가 아닌 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-407">
              <paramref name="excType" /> is not the <see cref="T:System.Exception" /> class or a derived class of <see cref="T:System.Exception" />.</span>
          </span>
          <span data-ttu-id="26e79-408">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-408">-or-</span>
          </span>
          <span data-ttu-id="26e79-409">해당 형식에 기본 생성자가 없는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-409">The type does not have a default constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-410">
            <paramref name="excType" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-410">
              <paramref name="excType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace">
          <span data-ttu-id="26e79-411">지역 변수를 계산하는 데 사용되는 네임스페이스를 지정하고 현재 활성화된 어휘의 범위를 조사합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-411">The namespace to be used in evaluating locals and watches for the current active lexical scope</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="26e79-412">지역 변수를 계산하는 데 사용되는 네임스페이스를 지정하고 현재 활성화된 어휘의 범위를 조사합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-412">Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26e79-413">하는 경우 현재 <xref:System.Reflection.Emit.ILGenerator> 연결 된 한 <xref:System.Reflection.Emit.DynamicMethod> 개체를이 메서드가 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="26e79-413">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, this method is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26e79-414">
            <paramref name="usingNamespace" />의 길이가 0입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-414">Length of <paramref name="usingNamespace" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26e79-415">
            <paramref name="usingNamespace" />가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-415">
              <paramref name="usingNamespace" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="26e79-416">이 <see cref="T:System.Reflection.Emit.ILGenerator" />가 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 속해 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="26e79-416">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>