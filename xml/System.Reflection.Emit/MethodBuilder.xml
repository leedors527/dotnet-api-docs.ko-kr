<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7340649aca6e8cf6ed3ffde1f98df8cddd7e22ab" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48749562" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <TypeSignature Language="F#" Value="type MethodBuilder = class&#xA;    inherit MethodInfo&#xA;    interface _MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>동적 클래스에 메서드(또는 생성자)를 정의하고 표시합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder> 클래스 이름, 특성, 서명 및 메서드 본문을 포함 한 MSIL (Microsoft intermediate language), 메서드를 완벽 하 게 설명 하는 데 사용 됩니다. 와 함께에서 사용 됩니다는 <xref:System.Reflection.Emit.TypeBuilder> 런타임으로 클래스를 생성 하는 클래스입니다.  
  
## <a name="global-methods-and-methods-as-type-members"></a>전역 메서드 및 형식 멤버와 메서드  
 리플렉션을 사용할 수 있습니다 전역 메서드를 정의 하 고 형식 멤버 메서드 정의 내보냅니다. 메서드를 정의 하는 Api 반환 <xref:System.Reflection.Emit.MethodBuilder> 개체입니다.  
  
### <a name="global-methods"></a>전역 메서드  
 전역 메서드를 사용 하 여 정의 된 <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> 반환 하는 메서드를 **MethodBuilder** 개체입니다.  
  
 전역 메서드는 정적 이어야 합니다. 동적 모듈을 전역 메서드를 포함 하는 경우는 <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> 공용 언어 런타임 동적 모듈을 수정 하는 모든 전역 함수까지 연기 하기 때문에 동적 모듈 또는 포함 하는 동적 어셈블리를 유지 하기 전에 메서드를 호출 해야 합니다 정의 되어 있습니다.  
  
 전역 기본 메서드를 사용 하 여 정의 된 <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> 메서드. 플랫폼 호출 (PInvoke) 메서드는 추상 또는 가상으로 선언 되지 않아야 합니다. 런타임 설정 된 <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> 메서드를 호출 하는 플랫폼에 대 한 특성입니다.  
  
### <a name="methods-as-members-of-types"></a>형식의 멤버와 메서드  
 메서드를 사용 하 여 형식 멤버로 정의 된 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 반환 하는 메서드를 <xref:System.Reflection.Emit.MethodBuilder> 개체.  
  
 <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> 메서드 반환 값 또는 매개 변수의 이름과 매개 변수 특성을 설정 하는 합니다. <xref:System.Reflection.Emit.ParameterBuilder> 매개 변수 또는 반환 값이 메서드에서 반환 된 개체를 나타냅니다. <xref:System.Reflection.Emit.ParameterBuilder> 마샬링을 설정 하려면, 상수 값을 설정 하 고 사용자 지정 특성을 적용 하는 개체를 사용할 수 있습니다.  
  
## <a name="attributes"></a>특성  
 멤버를 <xref:System.Reflection.MethodAttributes> 열거형에서 정확한 문자 동적 메서드를 정의 합니다.  
  
-   정적 메서드를 사용 하 여 지정 된 된 <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> 특성입니다.  
  
-   최종 메서드 (재정의할 수 없는 메서드)를 사용 하 여 지정 된 된 <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> 특성입니다.  
  
-   가상 메서드를 사용 하 여 지정 된 된 <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> 특성입니다.  
  
-   추상 메서드를 사용 하 여 지정 된 된 <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> 특성입니다.  
  
-   여러 특성 메서드 표시 여부를 결정합니다. 에 대 한 설명을 참조는 <xref:System.Reflection.MethodAttributes> 열거형입니다.  
  
-   메서드 오버 로드 된 연산자를 구현 하는 설정 해야 합니다는 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 특성입니다.  
  
-   종료자를 설정 해야 합니다는 <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> 특성입니다.  
  
## <a name="known-issues"></a>알려진 문제  
  
-   하지만 <xref:System.Reflection.Emit.MethodBuilder> 에서 파생 됩니다 <xref:System.Reflection.MethodInfo>에 정의 된 추상 메서드 중 일부는 <xref:System.Reflection.MethodInfo> 클래스에서 완전히 구현 되지 <xref:System.Reflection.Emit.MethodBuilder>합니다. 이러한 <xref:System.Reflection.Emit.MethodBuilder> 메서드는 throw 된 <xref:System.NotSupportedException>합니다. 예를 들어를 <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> 메서드가 완전히 구현 되지 않습니다. 사용 하 여 바깥쪽 형식을 검색 하 여 이러한 메서드에 반영할 수 있습니다 합니다 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 메서드.  
  
-   사용자 지정 한정자는.NET Framework 버전 2.0부터 지원 됩니다. 이전 버전에서 지원 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.Emit.MethodBuilder> 동적 형식 내에서 메서드를 만드는 클래스입니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="methodBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">요청, 어설션 등과 같은 수행할 보안 작업입니다.</param>
        <param name="pset">작업이 적용되는 사용 권한 집합입니다.</param>
        <summary>이 메서드에 선언적 보안을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 보안 동작을 지정 하는 각 호출을 사용 하 여 여러 번 호출할 수 있습니다 (같은 `Demand`, `Assert`, 및 `Deny`) 및 작업에 적용 되는 사용 권한 집합입니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0, 1.1 및 2.0을 사용 하 여 메서드에 적용 되는 선언적 보안 특성을 <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 메서드 이전 XML 메타 데이터 형식으로 저장 됩니다. 선언적 보안 특성 내보내기를 참조 하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 컨텍스트를 사용 `AddDeclarativeSecurity` 에 게 무제한 권한을 메서드의 호출자가 필요 합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" />이 유효하지 않습니다(<see langword="RequestMinimum" />, <see langword="RequestOptional" /> 및 <see langword="RequestRefuse" />가 유효하지 않음).</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식을 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만들었습니다.  
  
또는 
사용 권한 집합 <paramref name="pset" />에 이전에 <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />에 의해 추가된 작업이 포함되어 있습니다.  
  
또는 
현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드에 대한 특성을 검색합니다.</summary>
        <value>읽기 전용입니다. 이 메서드에 대해 <see langword="MethodAttributes" />를 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 호출 규칙을 반환합니다.</summary>
        <value>읽기 전용입니다. 메서드의 호출 규칙입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식에 대해 지원되지 않습니다.</summary>
        <value>지원되지 않습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder> 항상 제네릭 메서드 정의 나타내고 호출할 수 없습니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출된 메서드가 기본 클래스에서 지원되지 않습니다.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberSignature Language="F#" Value="member this.CreateMethodBody : byte[] * int -&gt; unit" Usage="methodBuilder.CreateMethodBody (il, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">유효한 MSIL 명령이 들어 있는 배열입니다. 이 매개 변수가 <see langword="null" />이면 메서드 본문이 지워집니다.</param>
        <param name="count">유효한 MSIL 배열의 바이트의 수입니다. MSIL이 <see langword="null" />이면 이 값은 무시됩니다.</param>
        <summary>MSIL(Microsoft Intermediate Language) 명령의 제공된 바이트 배열을 사용하여 메서드의 본문을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 만드는 메서드의 본문에서 `il`, opcode MSIL 명령이 들어 있는 배열입니다. 유효한 msil 바이트 수가 수로 지정 됩니다.  
  
> [!NOTE]
>  이 현재 완전히 지원 되지 않습니다. 사용자 토큰 수정 및 예외 처리기의 위치를 지정할 수 없습니다.  
  
   
  
## Examples  
 아래 예제에서는 두 정수를 추가 하는 간단한 방법을 opcode를 사용 하 여을 통해 생성 됩니다 `CreateMethodBody`합니다.  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />이(가) 제공된 MSIL 명령 배열의 인덱스 범위 내에 있지 않으며 <paramref name="il" />이(가) <see langword="null" />이 아닙니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
또는 
이 메서드는 <see langword="null" />이 아닌 <paramref name="il" /> 인수를 사용하여 이 <see langword="MethodBuilder" />에서 이전에 호출되었습니다.  
  
또는 
현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드를 선언하는 형식을 반환합니다.</summary>
        <value>읽기 전용입니다. 이 메서드를 선언하는 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드에서는 사용 된 `Type` 속성입니다.  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="methodBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">제네릭 형식 매개 변수의 이름을 나타내는 문자열의 배열입니다.</param>
        <summary>현재 메서드에 대한 제네릭 형식 매개 변수의 개수를 설정하고 이러한 매개 변수의 이름을 지정하며 관련 제약 조건을 정의하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열을 반환합니다.</summary>
        <returns>제네릭 메서드의 형식 매개 변수를 나타내는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 된 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 사용 하면 현재 메서드가 제네릭입니다. 이 변경 내용을 실행 취소할 방법이 없습니다. 이 메서드를 두 번째로 호출 하면는 <xref:System.InvalidOperationException>합니다.  
  
 제네릭 메서드의 형식 매개 변수를 사용 하 여 나중에 검색할 수 있습니다는 <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> 메서드.  
  
 규칙에 따라 형식 매개 변수 이름에는 단일 대문자는 합니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 동적 형식을 만들 `DemoType`, 동적 제네릭 메서드를 포함 하는 `DemoMethod`합니다. 이 메서드는는 데 사용 되는 매개 변수 및 반환 형식으로 다른 두 개의 제네릭 형식 매개 변수를 합니다.  
  
 코드를 실행하면 동적 어셈블리가 DemoGenericMethod1.dll로 저장되며 [Ildasm.exe(IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)를 사용하여 검사할 수 있습니다.  
  
> [!NOTE]
>  이 코드 예제에서는 단순히 null 참조를 반환 하는 간단한 메서드 본문을 생성 합니다. 만들고 제네릭 형식을 사용 하는 자세한 완전히 개발 된 메서드 본문을 사용 하 여 코드 예제를 참조 하세요 [방법: 리플렉션 내보내기를 사용 하 여 제네릭 메서드 정의](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)합니다.  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">제네릭 형식 매개 변수가 이 메서드에 대해 이미 정의되었습니다.  
  
또는 
메서드가 이미 완료되었습니다.  
  
또는 
현재 메서드에 대해 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> 메서드가 호출되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="names" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" />가 빈 배열인 경우</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="methodBuilder.DefineParameter (position, attributes, strParamName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">매개 변수 목록에서 매개 변수의 위치입니다. 매개 변수 중 첫 번째 매개 변수의 경우 인덱스가 1부터 시작하며, 숫자 0은 메서드의 반환 값을 나타냅니다.</param>
        <param name="attributes">매개 변수의 매개 변수 특성입니다.</param>
        <param name="strParamName">매개 변수의 이름입니다. 이름이 null 문자열일 수 있습니다.</param>
        <summary>이 메서드의 매개 변수 특성 및 이름 또는 이 메서드의 반환 값 특성 및 이름을 설정합니다. 사용자 지정 특성을 적용하는 데 사용할 수 있는 ParameterBuilder를 반환합니다.</summary>
        <returns>이 메서드의 매개 변수 또는 이 메서드의 반환 값을 나타내는 <see langword="ParameterBuilder" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ParameterBuilder> 매개 변수의 기본값을 설정 하거나 사용자 지정 특성을 적용 하려면이 메서드에서 반환 된 개체를 사용할 수 있습니다.  
  
 따라서는 1부터 시작 매개 변수 번호 `position` 첫 번째 매개 변수는 1입니다. 경우 `position` 가 0 이면이 메서드 반환 값에 영향을 줍니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0 및 1.1에서는 예외가 발생 하는 경우 `position` 0 이므로 해당 버전의 반환 값의 속성을 수정 하려면이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">메서드에 매개 변수가 없습니다.  
  
또는 
 <paramref name="position" />가 0보다 작은 경우  
  
또는 
 <paramref name="position" />이 메서드의 매개 변수 수보다 큽니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
또는 
현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 <see langword="MethodBuilder" /> 인스턴스와 비교할 개체입니다.</param>
        <summary>지정된 개체가 이 인스턴스와 같은지 여부를 확인합니다.</summary>
        <returns>
          <paramref name="obj" />가 <see langword="MethodBuilder" />의 인스턴스이고 이 개체와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치가 동일한 이름, 특성 및 서명 함으로써 결정 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드의 기본 구현을 반환합니다.</summary>
        <returns>이 메서드의 기본 구현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 항상 반환 `MethodBuilder` 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 메서드에 대해 정의된 사용자 지정 특성을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</param>
        <summary>이 메서드에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</summary>
        <returns>이 메서드의 모든 사용자 지정 특성을 나타내는 개체 배열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="methodBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">사용자 지정 특성 유형입니다.</param>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</param>
        <summary>지정된 형식으로 식별되는 사용자 지정 특성을 반환합니다.</summary>
        <returns>
          <paramref name="attributeType" /> 형식인 이 메서드의 특성을 나타내는 개체의 배열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>제네릭인 경우 메서드의 형식 매개 변수를 나타내는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열을 반환합니다.</summary>
        <returns>메서드가 제네릭인 경우 형식 매개 변수를 나타내는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체의 배열이거나, 제네릭이 아닌 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도 제네릭 메서드의 형식 매개 변수에서 반환 되는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 정의 하는 데 사용 됩니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드를 반환합니다.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" />의 현재 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder> 직접 생성된 된 제네릭 메서드를 내보내는 데 사용할 수 없습니다. 내보낸된 메서드는 제네릭 메서드 정의입니다.  
  
 자세한 내용은 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>를 참조하세요. 제네릭 형식에 대 한 자세한 내용은 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드의 해시 코드를 가져옵니다.</summary>
        <returns>이 메서드의 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 메서드에 대한 <see langword="ILGenerator" />를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>64바이트의 기본 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하는 이 메서드에 대한 <see langword="ILGenerator" />를 반환합니다.</summary>
        <returns>이 메서드에 대한 <see langword="ILGenerator" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하 여 보여 줍니다는 `GetILGenerator` 메서드를 만들고 내보내는 두 3D 공간의 점의 내적을 계산 하는 동적 어셈블리입니다.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드는 해당 <see cref="T:System.Reflection.MethodAttributes" /> 또는 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그 때문에 본문이 없어야 합니다(예: <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 플래그 포함).  
  
또는 
이 메서드는 제네릭 메서드 정의가 아닌 제네릭 메서드입니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="methodBuilder.GetILGenerator size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">MSIL 스트림에 바이트의 크기입니다.</param>
        <summary>지정된 MSIL(Microsoft Intermediate Language) 스트림 크기를 사용하여 이 메서드에 대한 <see langword="ILGenerator" />를 반환합니다.</summary>
        <returns>이 메서드에 대한 <see langword="ILGenerator" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하 여 보여 줍니다는 `GetILGenerator` 메서드를 만들고 내보내는 두 3D 공간의 점의 내적을 계산 하는 동적 어셈블리입니다.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드는 해당 <see cref="T:System.Reflection.MethodAttributes" /> 또는 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그 때문에 본문이 없어야 합니다(예: <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 플래그 포함).  
  
또는 
이 메서드는 제네릭 메서드 정의가 아닌 제네릭 메서드입니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBuilder.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>메서드에 대한 구현 플래그를 반환합니다.</summary>
        <returns>메서드에 대한 구현 플래그를 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberSignature Language="F#" Value="member this.GetModule : unit -&gt; System.Reflection.Module" Usage="methodBuilder.GetModule " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드를 포함하는 모듈에 대한 참조를 반환합니다.</summary>
        <returns>이 메서드를 포함하는 모듈에 대한 참조를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 아래 샘플 코드의 사용법을 보여 줍니다.는 `GetModule` 동적으로 생성 된 모듈에 대 한 정보를 검색할 메서드입니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBuilder.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드의 매개 변수를 반환합니다.</summary>
        <returns>메서드의 매개 변수를 나타내는 <see langword="ParameterInfo" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 `GetParameters` 동적으로 생성 된 메서드에 전달 된 매개 변수에 대 한 정보를 검색 합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see langword="GetParameters" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberSignature Language="F#" Value="member this.GetToken : unit -&gt; System.Reflection.Emit.MethodToken" Usage="methodBuilder.GetToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드의 토큰을 나타내는 <see langword="MethodToken" />을 반환합니다.</summary>
        <returns>이 메서드의 <see langword="MethodToken" />을 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드의 로컬 변수가 0으로 초기화되었는지 여부를 지정하는 부울 값을 가져오거나 설정합니다. 이 속성의 기본값은 <see langword="true" />입니다.</summary>
        <value>이 메서드의 로컬 변수가 0으로 초기화되면 <see langword="true" />이고, 초기화되지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`, 내보낸된 MSIL 지역 변수의 초기화를 포함 합니다. 로 설정 된 경우 `false`, 로컬 변수가 초기화 되지 및 생성된 된 코드를 확인할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다. (가져오기 또는 설정)</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBuilder.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">지정한 메서드를 호출할 개체입니다. 메서드가 정적이면 이 매개 변수가 무시됩니다.</param>
        <param name="invokeAttr">이것은 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등과 같은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <param name="binder">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 MemberInfo 개체 검색을 사용할 수 있도록 하는 개체입니다. 바인더가 <see langword="null" />이면 기본 바인더가 사용됩니다. 자세한 내용은 <see cref="T:System.Reflection.Binder" />을 참조하십시오.</param>
        <param name="parameters">인수 목록입니다. 호출되는 메서드의 매개 변수와 숫자, 순서, 형식이 동일한 인수의 배열입니다. 매개 변수가 없는 경우에는 <see langword="null" />이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see cref="T:System.Globalization.CultureInfo" />의 인스턴스입니다. 이 인스턴스가 null이면 현재 스레드의 <see cref="T:System.Globalization.CultureInfo" />가 사용됩니다. 예를 들면 1000은 각 문화권마다 다르게 표현되므로 1000을 나타내는 <see cref="T:System.String" />을 <see cref="T:System.Double" /> 값으로 변환하기 위해 필요합니다.</param>
        <summary>지정된 바인더의 제약 조건에 따라 지정한 매개 변수를 전달하여 지정된 개체에 있는 이 인스턴스에 의해 반영된 메서드를 동적으로 호출합니다.</summary>
        <returns>호출된 메서드의 반환 값을 포함하는 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드가 정적 이면는 `obj` 매개 변수가 무시 됩니다. 비정적 메서드에 대해 `obj` 상속 하거나 메서드를 선언 하 고,이 클래스와 동일한 형식 이어야 하는 클래스의 인스턴스여야 합니다. 메서드 매개 변수가 없는의 값이 있으면 `parameters` 있어야 `null`합니다. 그렇지 않으면 개수, 형식 및 매개 변수 배열에서 요소의 순서는 개수, 형식 및이 인스턴스에서 리플 렉 트 메서드에 대 한 매개 변수의 순서와 같아야 합니다.  
  
> [!NOTE]
>  완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다. 즉, 개인 생성자, 메서드, 필드 및 속성에 액세스할 수 있습니다 및 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 사용 하 여 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="methodBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">사용자 지정 특성 유형입니다.</param>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 사용자 지정 특성을 찾을지 여부를 지정합니다.</param>
        <summary>지정된 사용자 지정 특성 유형이 정의되었는지 확인합니다.</summary>
        <returns>지정된 사용자 지정 특성 형식이 정의되어 있으면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 제네릭 메서드인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>메서드가 제네릭인 경우 <see langword="true" />이고, 그렇지 않은 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드는 제네릭 형식 매개 변수가 있는 경우. 제네릭으로 만들 있습니다 메서드를 호출 하 여는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드 형식 매개 변수를 추가 합니다. 이 변경은 되돌릴 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메서드의 상태를 표시합니다. 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체가 제네릭 메서드의 정의를 나타내는지 여부를 표시하는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체가 제네릭 메서드 정의를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder> ; 제네릭 메서드 정의를 만들 수만 생성된 된 제네릭 메서드를 직접 만들려면 사용할 수 없습니다. 그러나의 서브 클래스 <xref:System.Reflection.Emit.MethodBuilder> 생성된 된 제네릭 메서드를 나타낼 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메서드의 상태를 표시합니다. 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</summary>
        <value>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리의 메서드를 보안에 중요 한 인지를 확인 하려면 형식을 호출 하 여 완료 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, 호출 합니다 <xref:System.Type.GetMethod%2A> 완료 된 유형 및 get 메서드는 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 결과 속성 <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">모든 경우 동적 어셈블리에서는 이 속성이 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</summary>
        <value>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리의 메서드에서 보안 안전에 중요 한 인지를 확인 하려면 형식을 호출 하 여 완료 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, 호출 합니다 <xref:System.Type.GetMethod%2A> 완료 된 유형 및 get 메서드는 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 결과 속성 <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">모든 경우 동적 어셈블리에서는 이 속성이 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</summary>
        <value>모든 경우에 <see cref="T:System.NotSupportedException" />을(를) throw합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리의 메서드를 보안 투명 인지를 확인 하려면 형식을 호출 하 여 완료 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, 호출 합니다 <xref:System.Type.GetMethod%2A> 완료 된 유형 및 get 메서드는 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 결과 속성 <xref:System.Reflection.MethodInfo>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">모든 경우 동적 어셈블리에서는 이 속성이 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodBuilder.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">제네릭 메서드의 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</param>
        <summary>지정된 제네릭 형식 인수를 사용하여 현재 제네릭 메서드 정의에서 생성된 제네릭 메서드를 반환합니다.</summary>
        <returns>지정된 제네릭 형식 인수를 사용하여 현재 제네릭 메서드 정의에서 생성된 제네릭 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 코드를 내보낼 때 나타내는 제네릭 메서드 정의에서 생성 된 메서드를 호출 해야 할 수 있습니다는 <xref:System.Reflection.Emit.MethodBuilder>바깥쪽 형식 완료 되기 전에, 합니다. 사용할 수는 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 메서드를를 <xref:System.Reflection.MethodInfo> 이러한 생성 된 메서드를 사용 하 여에 대 한는 <xref:System.Reflection.MethodInfo> 내보낸 호출에서.  
  
   
  
## Examples  
 다음 코드 예제는 불완전 한 형식에서 불완전 한 제네릭 메서드 정의에서 생성 된 메서드를 만듭니다.  
  
 이 예제에서는 단일 형식을 사용 하 여 임시 어셈블리 및 모듈을 만듭니다, 메서드를 추가 `M`를 사용 하 여 형식 매개 변수 T를 추가 하 여 제네릭 메서드로 만듭니다 및는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드. 형식 매개 변수는 메서드의 매개 변수의 형식 및 반환 형식으로 사용 됩니다. 제네릭 메서드 정의 본문을 지정 하지 않으면 및 바깥쪽 형식이 완료 되지 않습니다. 합니다 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 메서드는 다음 생성된 된 메서드를 확인 하는 데 사용 됩니다 `M<String>` (`M(Of String)` Visual basic에서). 때문에 코드 예제는 아무 것도 출력의 서브 클래스 <xref:System.Reflection.MethodInfo> 반환한는 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 메서드 매개 변수를 통해 리플렉션을 허용 하지 않습니다.  
  
> [!NOTE]
>  사용 하는 다른 코드 예제 <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>를 참조 하세요 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>합니다. <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 제네릭 형식을 사용 하는 코드를 내보낼 때 광범위 하 게 사용도 됩니다. 참조 [방법: 리플렉션 사용 하 여 제네릭 메서드 정의 내보내기](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)합니다.  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드에 대한 내부 핸들을 검색합니다. 이 핸들을 사용하여 내부 메타데이터 핸들에 액세스할 수 있습니다.</summary>
        <value>읽기 전용입니다. 메서드에 대한 내부 핸들입니다. 이 핸들을 사용하여 내부 메타데이터 핸들에 액세스할 수 있습니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 지원되지 않습니다. <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />를 사용하여 메서드를 검색하고 반환된 <see cref="T:System.Reflection.MethodInfo" />에 대해 <see cref="P:System.Reflection.MethodBase.MethodHandle" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.MethodBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 메서드가 정의되는 모듈을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.Module" />가 나타내는 멤버가 정의되는 <see cref="T:System.Reflection.MemberInfo" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 편의 위해 제공 됩니다. 사용 하는 것과 같습니다를 <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> 한 다음 호출 하는 메서드 선언 되는 형식을 가져올 속성을 <xref:System.Type.Module%2A> 결과 속성 <xref:System.Type> 개체.  
  
 이 속성은 또한 호출 <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.MethodBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드의 이름을 검색합니다.</summary>
        <value>읽기 전용입니다. 이 메서드의 단순 이름을 포함하는 문자열을 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 개체를 얻은 리플렉션에서 사용된 클래스를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 메서드를 얻는 데 사용된 형식입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 반환 형식에 대한 정보(예: 반환 형식에 사용자 지정 한정자가 포함되는지 여부)가 포함된 <see cref="T:System.Reflection.ParameterInfo" /> 개체를 가져옵니다.</summary>
        <value>반환 형식에 대한 정보가 포함된 <see cref="T:System.Reflection.ParameterInfo" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컴파일러 디자이너에서 사용할 수는 <xref:System.Reflection.ParameterInfo> 사용자 지정 하는지 여부를 검색 하려면이 속성에서 반환 된 개체 한정자와 같은 <xref:Microsoft.VisualC.IsConstModifier>, 반환 형식에 적용 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">선언 형식이 만들어지지 않았습니다.</exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Reflection.Emit.MethodBuilder" />가 나타내는 메서드의 반환 형식을 가져옵니다.</summary>
        <value>메서드의 반환 형식입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  .NET Framework 2.0 및.NET Compact Framework 2.0 부터는이 멤버는 기본 클래스에서 상속 된 <xref:System.Reflection.MethodInfo>합니다. <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드 반환 형식의 사용자 지정 특성을 반환합니다.</summary>
        <value>읽기 전용입니다. 메서드 반환 형식의 사용자 지정 특성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 항상 `null`을 반환합니다. 가져오기는 <xref:System.Reflection.MethodInfo> 포함 된 뒤 <xref:System.Type> 생성 되었으며 호출 <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> 에 <xref:System.Reflection.MethodInfo>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>사용자 지정 특성을 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="methodBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">사용자 지정 특성을 설명하는 도우미 클래스의 인스턴스입니다.</param>
        <summary>사용자 지정 특성 작성기를 사용하여 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드를 조작할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드 두 가지 방법을 함께에서 사용 하는 경우. 설명 섹션을 참조 합니다 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드 세부 정보에 대 한 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="methodBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">사용자 지정 특성에 대한 생성자입니다.</param>
        <param name="binaryAttribute">특성을 나타내는 바이트 blob입니다.</param>
        <summary>지정된 사용자 지정 특성 blob을 사용하여 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서식을 지정 하는 방법에 대 한 내용은 `binaryAttribute`, 공용 언어 인프라 (CLI) 설명서에서 "II: 메타 데이터 정의 및 의미"를 참조 하세요. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](http://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](http://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드를 조작할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드 두 가지 방법을 함께에서 사용 하는 경우. 설명 섹션을 참조 합니다 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드 세부 정보에 대 한 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> 또는 <paramref name="binaryAttribute" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.SetImplementationFlags : System.Reflection.MethodImplAttributes -&gt; unit" Usage="methodBuilder.SetImplementationFlags attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">설정할 구현 플래그입니다.</param>
        <summary>이 메서드에 대한 구현 플래그를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 경우는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 함께에서 메서드는 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드를 상호 작용에 유의 합니다. 예를 들어,를 사용 하 여는 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드를 추가 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 집합 특성도 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그. 이후에 호출 하는 경우는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드는 <xref:System.Reflection.MethodImplAttributes.PreserveSig> 플래그를 덮어씁니다. 이 문제를 방지 하는 방법은 두 가지:  
  
-   호출 된 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드를 호출 하기 전에 <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드. <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> 메서드 항상 기존 메서드 구현 플래그를 존중 합니다.  
  
-   구현 플래그를 설정 하면 호출을 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> 방법 기존 플래그를 검색 하려면 비트 사용 또는 플래그를 추가 하 고 호출 하는 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 컨텍스트를 사용 합니다 `SetImplementationFlags` 메서드 본문의 msil 구현에 설명 하는 방법입니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
또는 
현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberSignature Language="F#" Value="member this.SetMarshal : System.Reflection.Emit.UnmanagedMarshal -&gt; unit" Usage="methodBuilder.SetMarshal unmanagedMarshal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">이 메서드의 반환 형식에 대한 마샬링 정보입니다.</param>
        <summary>이 메서드의 반환 형식에 대한 마샬링 정보를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하 여 보여 줍니다는 `SetMarshal` 메서드를 다른 형식으로 메서드 호출의 결과 마샬링합니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
또는 
현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberSignature Language="F#" Value="member this.SetMethodBody : byte[] * int * byte[] * seq&lt;System.Reflection.Emit.ExceptionHandler&gt; * seq&lt;int&gt; -&gt; unit" Usage="methodBuilder.SetMethodBody (il, maxStack, localSignature, exceptionHandlers, tokenFixups)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">유효한 MSIL 명령이 들어 있는 배열입니다.</param>
        <param name="maxStack">최대 스택 평가 깊이입니다.</param>
        <param name="localSignature">직렬화된 로컬 변수 구조를 포함하는 바이트 배열입니다. 메서드에 로컬 변수가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="exceptionHandlers">메서드에 대한 예외 처리기를 포함하는 컬렉션입니다. 메서드에 예외 처리기가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="tokenFixups">
          <c>il</c>의 오프셋을 나타내는 값 컬렉션으로, 각각이 수정할 수 있는 토큰의 시작을 지정합니다. 메서드에 수정해야 할 토큰이 없으면 <see langword="null" />을 지정합니다.</param>
        <summary>MSIL(Microsoft 중간 언어) 명령의 지정된 바이트 배열을 사용하여 메서드의 본문을 만듭니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="il" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStack" />가 음수입니다.  
  
또는 
<paramref name="exceptionHandlers" /> 중 하나가 <paramref name="il" /> 오프셋 외부를 지정합니다.  
  
또는 
<paramref name="tokenFixups" /> 중 하나가 <paramref name="il" /> 배열 외부의 오프셋을 지정합니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드를 사용하여 이미 만들어져 있는 경우  
  
또는 
이 메서드는 이 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체에 이미 호출되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.SetParameters : Type[] -&gt; unit" Usage="methodBuilder.SetParameters parameterTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">매개 변수 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.</param>
        <summary>메서드에 대한 매개 변수 개수와 형식을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매개 변수의 형식과 수에 알고 있는 경우 메서드가 정의 된 경우에 설정할 수 있습니다의 오버 로드를 사용 하 여는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드 매개 변수 형식의 배열만 받는다는 것입니다. 그러나 제네릭 메서드는 하나 이상의 메서드를 정의한 후까지 정의할 수 없습니다 고유한 제네릭 형식 매개 변수 형식이 지정 된 매개 변수를 가질 수 있습니다. 이 경우 형식 매개 변수를 설정 하려면이 메서드를 사용 합니다.  
  
 반환 형식이 있는지 선택 또는 필수 사용자 지정 한정자를 같은 <xref:System.Runtime.CompilerServices.IsConst>를 사용 하 여를 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 메서드 오버 로드 합니다.  
  
 사용 하 여 설정 된 모든 매개 변수 형식 대체이 메서드를 호출 합니다 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 제네릭 메서드로 만듭니다. <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드 형식의 첫 번째 제네릭 형식 매개 변수에 의해 지정 됩니다 메서드 하나 매개 제공를 사용 합니다. <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 메서드를 사용 하는 반환 형식을 두 번째 제네릭 형식 매개 변수로 지정 된 메서드를 제공 합니다.  
  
 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberSignature Language="F#" Value="member this.SetReturnType : Type -&gt; unit" Usage="methodBuilder.SetReturnType returnType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">메서드의 반환 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</param>
        <summary>메서드의 반환 형식을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 형식은 메서드의 제네릭 형식 매개 변수 중 하나에 의해 지정 된 경우 제네릭 메서드의 반환 형식을 설정 하려면이 메서드를 사용 합니다. 반환 형식이 있는지 선택 또는 필수 사용자 지정 한정자를 같은 <xref:System.Runtime.CompilerServices.IsConst>를 사용 하 여를 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> 메서드 오버 로드 합니다.  
  
 사용 하 여 설정 하는 반환 형식을 대체이 메서드를 호출 합니다 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드를 제네릭 메서드로 만듭니다. <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드 형식의 첫 번째 제네릭 형식 매개 변수에 의해 지정 됩니다 메서드 하나 매개 제공를 사용 합니다. <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 메서드를 사용 하는 반환 형식을 두 번째 제네릭 형식 매개 변수로 지정 된 메서드를 제공 합니다.  
  
 이 코드는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</related>
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.SetSignature : Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; unit" Usage="methodBuilder.SetSignature (returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="returnTypeRequiredCustomModifiers">메서드의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 필수 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="returnTypeOptionalCustomModifiers">메서드의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 선택적 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypes">메서드의 매개 변수 형식입니다.</param>
        <param name="parameterTypeRequiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypeOptionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <summary>반환 형식, 매개 변수 형식, 반환 형식과 매개 변수 형식의 필수 및 선택적 사용자 지정 한정자를 포함하여 메서드 시그니처를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 형식 및 수, 매개 변수 형식에 알고 있는 경우 메서드가 정의 된 경우를 설정할 수 있습니다의 오버 로드를 사용 하 여는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드 매개 변수 형식의 배열만 받는다는 것입니다. 그러나 제네릭 메서드는 하나 이상의 메서드를 정의한 후까지 정의할 수 없습니다 고유한 제네릭 형식 매개 변수 형식이 지정 된 매개 변수를 가질 수 있습니다. 이 경우 형식 매개 변수를 설정 하려면이 메서드를 사용 합니다.  
  
 경우 반환 형식이 아니고 형식 매개 변수 선택 또는 필수 사용자 지정 한정자와 같은 <xref:Microsoft.VisualC.IsConstModifier>를 사용할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 및 <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드.  
  
 매개 변수 및 반환 형식을 사용 하 여 설정 대신이 메서드를 호출 합니다 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 형식 매개 변수가 sample 클래스에 대 한 소스 코드 포함 `T`합니다. 클래스 라는 필드가 `Field`, 형식 `T`, 및 제네릭 메서드 `GM` 자체 형식 매개 변수를 사용 하 여 `U`입니다. 메서드 `GM` 고유한 형식 매개 변수를 대체 하는 샘플의 인스턴스를 만듭니다 `U` 샘플의 형식 매개 변수에서 해당 입력된 매개 변수를 가져와 `Field`합니다. 이 소스 코드 컴파일 되었지만 사용 되지 않습니다. 사용 하 여 볼 수 있습니다 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), 클래스에 의해 생성 된 코드 비교 `Example`합니다.  
  
 클래스의 코드 `Example` 사용을 보여 줍니다는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 제네릭 코드 내보내기에 메서드. `Main` 클래스의 메서드 `Example` 라는 클래스를 포함 하는 동적 어셈블리를 만듭니다 `Sample`를 사용 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 라는 형식 매개 변수를 추가 하 여 일반 확인 하는 방법 `T`합니다. 기본 생성자 및 필드가 `Field`, 형식 `T`, 클래스에 추가 됩니다 `Sample`합니다. 메서드 `GM` 에 추가 하 고 사용 하 여 제네릭 메서드 설정 된 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드. 형식 매개 변수에 `GM` 이름은 `U`합니다. 형식 매개 변수 정의 되 면 서명의 `GM` 를 사용 하 여 추가 되는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> 메서드. 반환 형식이 없는 및 필수 또는 사용자 지정 한정자가 없습니다 있으므로이 메서드의 모든 매개 변수가 `null` 제외한 `parameterTypes`, 메서드의 유일한 매개 변수의 형식을 설정 하는; 메서드의 형식 매개 변수에 설정 됩니다 `U`합니다. 메서드의 본문 생성 된 형식의 인스턴스를 만듭니다 `Sample<U>` (`Sample(Of U)` Visual basic에서), 메서드의 매개 변수를 할당 `Field`, 다음 값을 인쇄 `Field`합니다. 진입점 메서드를 보유 하기 위해 더미 형식 정의 `Main`합니다. 본문에 `Main`, 정적 `GM` 생성된 된 제네릭 형식에 메서드가 호출 되 `Sample<int>` (`Sample(Of Integer)` Visual Basic의), 형식과 <xref:System.String> 대체 `U`합니다. <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> 메서드는 만드는 데는 <xref:System.Reflection.MethodInfo> 는 정적 `GM` 생성 된 제네릭 형식의 메서드 `Sample<U>`, 및 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 메서드는 만드는 데 다음를 <xref:System.Reflection.MethodInfo> 메서드 호출에서 내보낼 수 있는 합니다.  
  
 코드 예제를 실행 하는 경우 내보낸된 어셈블리 TypeBuilderGetFieldExample.exe로 저장 합니다. TypeBuilderGetFieldExample.exe를 실행할 수 있으며 사용할 수 있습니다는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 내보낸된 코드에 대 한 코드를 사용 하 여 비교할는 `Sample` 자체 코드 예제로 컴파일되는 클래스입니다.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 메서드는 제네릭이지만 제네릭 메서드 정의는 아닙니다. 즉, <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="methodBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">기호화된 사용자 지정 특성의 이름입니다.</param>
        <param name="data">기호화된 사용자 지정 특성의 값을 나타내는 바이트 blob입니다.</param>
        <summary>blob을 사용하여 기호화된 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메타 데이터 사용자 지정 특성을 달리이 사용자 지정 특성 기호 작성기 연관 되어 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하 여 보여 줍니다는 `SetSymCustomAttribute` 메서드에 연결 된 이름 및 사용자 지정 특성의 키에 대 한 바이트 값을 설정 하는 방법입니다.  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 이전에 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만든 것입니다.  
  
또는 
이 메서드를 포함하는 모듈이 디버그 모듈이 아닙니다.  
  
또는 
현재 메서드에 대해 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 속성은 <see langword="true" />이지만 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Signature : string" Usage="System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 시그니처를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 <see langword="MethodBase" /> 인스턴스에서 리플렉션된 메서드의 시그니처를 포함하는 문자열입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터를 받습니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="methodBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see langword="MethodBuilder" /> 인스턴스를 문자열로 반환합니다.</summary>
        <returns>이 메서드의 이름, 특성, 메서드 서명, 예외 및 로컬 서명 뒤에 현재 MSIL(Microsoft Intermediate Language) 스트림이 포함된 문자열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>