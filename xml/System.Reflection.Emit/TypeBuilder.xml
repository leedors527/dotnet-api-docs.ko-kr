<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b136d33672d3676473ad75c5fba7be56988a9a86" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53229924" /></Metadata><TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <TypeSignature Language="F#" Value="type TypeBuilder = class&#xA;    inherit TypeInfo&#xA;    interface _TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>런타임 시 클래스의 새 인스턴스를 정의하고 만듭니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder> 런타임에 동적 클래스의 생성을 제어 하려면 루트 클래스 사용 됩니다. 클래스 정의 메서드 및 필드를 추가 하 고, 모듈 내에서 클래스를 만드는 데 사용 되는 루틴 집합을 제공 합니다. 새 <xref:System.Reflection.Emit.TypeBuilder> 를 호출 하 여 동적 모듈에서 만들 수 있습니다 합니다 <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> 반환 하는 메서드를 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 리플렉션 내보내기 형식을 정의 하기 위한 다음 옵션을 제공 합니다.  
  
-   클래스 또는 지정 된 이름의 인터페이스를 정의 합니다.  
  
-   지정 된 이름 및 특성을 사용 하 여 인터페이스나 클래스를 정의 합니다.  
  
-   지정 된 이름, 특성 및 기본 클래스를 사용 하 여 클래스를 정의 합니다.  
  
-   지정 된 이름, 특성, 기본 클래스 및 클래스를 구현 하는 인터페이스 집합을 사용 하 여 클래스를 정의 합니다.  
  
-   지정 된 이름, 특성, 기본 클래스 및 압축 크기를 사용 하 여 클래스를 정의 합니다.  
  
-   전체적으로 지정 된 이름, 특성, 기본 클래스 및 클래스 크기를 사용 하 여 클래스를 정의 합니다.  
  
-   전체적으로 지정 된 이름, 특성, 기본 클래스, 압축 크기 및 클래스 크기를 사용 하 여 클래스를 정의 합니다.  
  
 배열 형식, 포인터 형식, 또는 byref 형식으로 표현 되는 불완전 한 형식에 대해 만드는 데는 <xref:System.Reflection.Emit.TypeBuilder> 개체를 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> 메서드를 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> 메서드를 또는 <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> 메서드를 각각.  
  
 형식을 사용 하기 전에 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> 메서드를 호출 해야 합니다. **CreateType** 형식 만들기를 완료 합니다. 호출 다음에 **CreateType**, 호출자에 게 사용 하 여 형식을 인스턴스화할 수 합니다 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 메서드를 사용 하 여 형식의 멤버를 호출 하 고는 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> 메서드. 변경 후 형식 구현 하는 메서드를 호출 하면 오류가 발생 **CreateType** 가 호출 되었습니다. 예를 들어 호출자가 형식에 새 멤버를 추가 하려고 하는 경우 공용 언어 런타임 예외가 throw 됩니다.  
  
 클래스 이니셜라이저를 사용 하 여 만들어진 여 <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> 메서드. **DefineTypeInitializer** 반환을 <xref:System.Reflection.Emit.ConstructorBuilder> 개체입니다.  
  
 중첩된 형식 중 하나를 호출 하 여 정의 되는 <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> 메서드.  
  
## <a name="attributes"></a>특성  
 합니다 <xref:System.Reflection.Emit.TypeBuilder> 클래스가 사용 하 여 <xref:System.Reflection.TypeAttributes> 추가로 만들려는 유형의 특성을 지정 하는 열거형:  
  
-   인터페이스를 사용 하 여 지정 된 된 <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> 고 <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> 특성입니다.  
  
-   구체적인 클래스 (확장할 수 없는 클래스)를 사용 하 여 지정 된 된 <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> 특성입니다.  
  
-   여러 특성에는 형식 표시 유형을 결정합니다. 에 대 한 설명을 참조는 <xref:System.Reflection.TypeAttributes> 열거형입니다.  
  
-   경우 <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 지정 된 경우 클래스 로더에 메타 데이터에서 읽은 순서 필드를 배치 합니다. 클래스 로더에 지정 된 압축 크기를 고려 하 하지만 지정한 필드 오프셋을 무시 합니다. 메타 데이터 필드 정의 내보냅니다 순서를 유지 합니다. 병합, 에서도 메타 데이터는 순서를 변경 하지 필드 정의 합니다. 로더는 경우에만 지정 된 필드 오프셋을 적용 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> 지정 됩니다.  
  
## <a name="known-issues"></a>알려진 문제  
  
-   리플렉션 내보내기 인터페이스를 구현 하는 비추상 클래스에서 인터페이스에 선언 된 모든 메서드를 구현한 여부를 확인 하지 않습니다. 그러나 클래스는 인터페이스에 선언 된 모든 메서드를 구현 하지 않으면, 런타임 클래스를 로드 하지 않습니다.  
  
-   하지만 <xref:System.Reflection.Emit.TypeBuilder> 에서 파생 됩니다 <xref:System.Type>에 정의 된 추상 메서드 중 일부는 <xref:System.Type> 클래스에서 완전히 구현 되지 않습니다는 <xref:System.Reflection.Emit.TypeBuilder> 클래스입니다. 이러한 호출 <xref:System.Reflection.Emit.TypeBuilder> 메서드는 throw를 <xref:System.NotSupportedException> 예외입니다. 원하는 기능을 사용 하 여 생성된 된 형식을 검색 하 여 가져올 수 있습니다 합니다 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 고 검색 된 형식을 반영 합니다.  
  
   
  
## Examples  
 이 섹션에는 두 코드 예제가 있습니다. 첫 번째 예제에는 필드, 생성자, 속성 및 메서드를 사용 하 여 동적 형식을 만드는 방법을 보여 줍니다. 두 번째 예제 사용자 입력을 통해 동적으로 메서드를 작성합니다.  
  
 **예제 1**  
  
 다음 코드 예제에는 모듈 중 하나를 사용 하 여 동적 어셈블리를 정의 하는 방법을 보여 줍니다. 예제에서는 어셈블리 모듈에에서 포함 한 가지 형식만 `MyDynamicType`를 개인 필드, 전용 필드를 가져오거나 설정 하는 속성, private 필드를 초기화 하는 생성자 및 메서드를 private 필드는 사용자가 제공한 숫자를 곱하는 있는 값 및 결과 반환 합니다.  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> 어셈블리를 만들 때 필드를 지정 합니다. 어셈블리 코드는 즉시 사용 하 고 어셈블리 저장도 사용 하 여 검사할 수 있도록 디스크에 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 또는 다른 프로그램에서 사용 합니다.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **예제 2**  
  
 다음 코드 샘플에는 동적 형식을 사용 하 여 빌드하는 방법을 보여 줍니다. `TypeBuilder`합니다.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4">방법: 리플렉션 내보내기를 사용하여 제네릭 형식 정의</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="typeBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">요청, 어설션 등과 같은 수행할 보안 작업입니다.</param>
        <param name="pset">작업이 적용되는 사용 권한 집합입니다.</param>
        <summary>이 형식에 선언적 보안을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity` 보안 작업 (예: 요청, 어설션 또는 거부) 및 작업에 적용 되는 사용 권한 집합을 지정 하는 각 호출을 사용 하 여 여러 번 호출할 수 있습니다.  
  
> [!NOTE]
>  .NET Framework 버전 1.0, 1.1 및 2.0에서는이 메서드를 사용 하 여 형식에 적용 하는 선언적 보안 특성은 이전 XML 메타 데이터 형식으로 저장 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 합니다 `AddDeclarativeSecurity` 에 대 한 보안 요구를 추가 하는 방법 <xref:System.Security.Permissions.SecurityPermission> 사용 하 여는 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 라는 동적 형식 플래그 `MyDynamicClass`, EmittedExample.dll 라는 어셈블리에 합니다. 예제의 콘솔 출력이 없습니다. 를 실행 하면 후 사용할 수 있습니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) EmittedExample.dll를 검사 합니다. `MyDynamicClass`엽니다는 `.class public auto ansi` 선언적 권한을 확인 하는 문입니다.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="action" />이 유효하지 않습니다(<see langword="RequestMinimum" />, <see langword="RequestOptional" /> 및 <see langword="RequestRefuse" />가 유효하지 않음).</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식을 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 만들었습니다.  
  
또는 
사용 권한 집합 <paramref name="pset" />에 이전에 <see langword="AddDeclarativeSecurity" />에 의해 추가된 작업이 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pset" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : Type -&gt; unit" Usage="typeBuilder.AddInterfaceImplementation interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">이 형식이 구현하는 인터페이스입니다.</param>
        <summary>이 형식이 구현하는 인터페이스를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 샘플에 사용 하 여 동적으로 만들어진된 형식 인터페이스의 구현을 보여 줍니다 `AddInterfaceImplementation`합니다.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식 정의를 포함하는 동적 어셈블리를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 형식 정의를 포함하는 동적 어셈블리를 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리의 표시 이름으로 정규화된 이 형식의 전체 이름을 반환합니다.</summary>
        <value>읽기 전용입니다. 어셈블리의 표시 이름으로 정규화된 이 형식의 전체 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 문자열의 형식은 연결 된 형식의 전체 이름 (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) 및 어셈블리의 표시 이름 (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), 쉼표 및 공백을 구분 합니다.  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 어셈블리의 표시 이름에 대 한 합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 1.0 및 1.1에서는이 속성의 값을 문화권 또는 공개 키를 포함 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식의 기본 형식을 가져옵니다.</summary>
        <value>읽기 전용입니다. 이 형식의 기본 형식을 가져옵니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberSignature Language="F#" Value="member this.CreateType : unit -&gt; Type" Usage="typeBuilder.CreateType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>해당 클래스에 대한 <see cref="T:System.Type" /> 개체를 만듭니다. 클래스의 필드 및 메서드를 정의한 후에 <see langword="CreateType" />을 호출하여 해당 클래스의 <see langword="Type" /> 개체를 로드합니다.</summary>
        <returns>이 클래스에 대한 새 <see cref="T:System.Type" /> 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 형식은 중첩 된 형식인 경우는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 중첩 된 형식에 호출 되기 전에 바깥쪽 형식에서 메서드를 호출 해야 합니다.  
  
 현재 형식이 불완전 한 형식에서 파생 되, 불완전 한 인터페이스를 구현 하는 경우 호출 된 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 부모 형식을 현재 형식에 호출 하기 전에 인터페이스 형식에 메서드.  
  
 바깥쪽 형식 (예를 들어는 필드는 중첩 된 형식으로 정의 된 열거형), 중첩 된 형식으로 정의 된 값 형식 필드에 포함 하는 경우 호출 된 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드 생성 됩니다는 <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> 이벤트입니다. 즉, 중첩된 된 형식이 완료 될 때까지 로더 바깥쪽 형식의 크기를 확인할 수 없습니다. 호출자에 대 한 처리기를 정의 해야 합니다 <xref:System.AppDomain.TypeResolve> 를 호출 하 여 중첩 형식의 정의 완료 하는 이벤트 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 에 <xref:System.Reflection.Emit.TypeBuilder> 중첩된 형식을 나타내는 개체입니다. 이 항목에 대 한 코드 예제에는 이러한 이벤트 처리기를 정의 하는 방법을 보여 줍니다.  
  
 유형을 만들 한 번만 하는 방법에 관계 없이 여러 번의 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 메서드가 호출 됩니다. 모든 호출은 동일한 반환 <xref:System.Type> 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 이벤트 처리기를 정의 하는 방법을 보여 줍니다를 <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> 이벤트를 호출 하려면 합니다 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 중 중첩 된 형식에서 메서드를 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 호출 합니다.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">바깥쪽 형식이 만들어지지 않았습니다.  
  
또는 
이 형식이 비추상 형식이고 추상 메서드가 포함된 경우  
  
또는 
이 형식이 추상 클래스 또는 인터페이스가 아니고 메서드 본문이 없는 메서드가 들어 있는 경우</exception>
        <exception cref="T:System.NotSupportedException">형식에 잘못된 MSIL(Microsoft Intermediate Language) 코드가 들어 있는 경우  
  
또는 
분기 대상을 1바이트 오프셋으로 지정했지만 분기 대상이 분기에서 128바이트 이상 떨어져 있는 경우</exception>
        <exception cref="T:System.TypeLoadException">형식을 로드할 수 없는 경우. 예를 들어 호출 규칙 <see cref="F:System.Reflection.CallingConventions.HasThis" />가 있는 <see langword="static" /> 메서드가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberSignature Language="F#" Value="member this.CreateTypeInfo : unit -&gt; System.Reflection.TypeInfo" Usage="typeBuilder.CreateTypeInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 형식을 나타내는 <see cref="T:System.Reflection.TypeInfo" /> 개체를 가져옵니다.</summary>
        <returns>이 형식을 나타내는 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 제네릭 형식 매개 변수를 선언하는 메서드를 가져옵니다.</summary>
        <value>현재 형식이 제네릭 형식 매개 변수이면 현재 형식을 선언하는 메서드를 나타내는 <see cref="T:System.Reflection.MethodBase" />이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  제네릭 형식 매개 변수는 나타내는 코드를 내보낼 때는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 개체 보다는 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식을 선언한 형식을 반환합니다.</summary>
        <value>읽기 전용입니다. 해당 형식을 선언한 형식입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 형식에 새 생성자를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">생성자의 특성입니다.</param>
        <param name="callingConvention">생성자의 호출 규칙입니다.</param>
        <param name="parameterTypes">생성자의 매개 변수 형식입니다.</param>
        <summary>지정된 특성 및 서명을 사용하여 새 생성자를 형식에 추가합니다.</summary>
        <returns>정의된 생성자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 형식에 대 한 생성자를 정의 하지 않는 경우 기본 생성자를 자동으로 제공 됩니다 및 기본 클래스의 기본 생성자를 호출 합니다.  
  
 동적 형식에 대 한 생성자를 정의 하는 경우에 기본 생성자가 제공 되지 않습니다. 정의한 생성자 외에 기본 생성자를 제공 하는 것에 대 한 다음과 같은 옵션이 있습니다.  
  
-   기본 클래스의 기본 생성자를 호출 하는 기본 생성자를 원하는 경우 사용할 수 있습니다는 <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> 메서드를 만듭니다 (및 필요에 따라 액세스를 제한). 이 기본 생성자에 대 한 구현을 제공 하지 않습니다. 이렇게 하면 생성자를 사용 하려고 할 때 예외가 throw 됩니다. 때 예외가 throw 되지를 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 메서드가 호출 됩니다.  
  
-   기본 생성자가 단순히 기본 클래스의 기본 생성자를 호출 하거나의 다른 생성자를 호출 하려는 경우 기본 클래스 또는 다른 작업 수행 전적으로 사용 해야 합니다는 <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> 하나를 만드는 방법 고유한 구현을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 샘플의 사용법을 보여 줍니다 `DefineConstructor` 동적 형식에 생성자의 특정 시그니처 및 특성을 설정 하 고 해당 반환 <xref:System.Reflection.Emit.ConstructorBuilder> MSIL 모집단에 대 한 합니다.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes, requiredCustomModifiers, optionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">생성자의 특성입니다.</param>
        <param name="callingConvention">생성자의 호출 규칙입니다.</param>
        <param name="parameterTypes">생성자의 매개 변수 형식입니다.</param>
        <param name="requiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="optionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <summary>지정된 특성, 서명 및 사용자 지정 수정자를 사용하여 새 생성자를 형식에 추가합니다.</summary>
        <returns>정의된 생성자입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 관리 되는 컴파일러의 디자이너를 위해 제공 됩니다.  
  
> [!NOTE]
>  사용자 지정 한정자에 대 한 자세한 내용은 ECMA 파티션 II 메타 데이터가 설명서를 참조 하십시오. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="requiredCustomModifiers" /> 또는 <paramref name="optionalCustomModifiers" />의 크기가 <paramref name="parameterTypes" />의 크기와 같지 않습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDefaultConstructor : System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineDefaultConstructor attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">생성자에 적용될 특성을 나타내는 <see langword="MethodAttributes" /> 개체입니다.</param>
        <summary>기본 생성자를 정의합니다. 여기에 정의된 생성자는 부모의 기본 생성자를 호출하기만 하면 됩니다.</summary>
        <returns>생성자를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 생성자가 자동으로 정의 되므로 다음 경우에만이 메서드를 호출 하는 데 필요한:  
  
-   다른 생성자를 정의 했으며 고 기본 클래스 생성자를 호출 하는 기본 생성자도 합니다.  
  
-   이외의 값으로 기본 생성자의 특성을 설정 하려는 <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>를 <xref:System.Reflection.MethodAttributes.HideBySig>를 <xref:System.Reflection.MethodAttributes.SpecialName>, 및 <xref:System.Reflection.MethodAttributes.RTSpecialName>합니다.  
  
   
  
## Examples  
 다음 코드 샘플의 사용법을 보여 줍니다 `DefineConstructor` 동적 형식에 생성자의 특정 시그니처 및 특성을 설정 하 고 해당 반환 <xref:System.Reflection.Emit.ConstructorBuilder> MSIL 모집단에 대 한 합니다.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">부모 형식(기본 형식)에 기본 생성자가 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberSignature Language="F#" Value="member this.DefineEvent : string * System.Reflection.EventAttributes * Type -&gt; System.Reflection.Emit.EventBuilder" Usage="typeBuilder.DefineEvent (name, attributes, eventtype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">이벤트의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">이벤트의 특성입니다.</param>
        <param name="eventtype">이벤트의 형식입니다.</param>
        <summary>지정된 이름, 특성 및 이벤트 형식을 사용하여 형식에 새 이벤트를 추가합니다.</summary>
        <returns>정의된 이벤트입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="eventtype" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>동적 형식에 새 필드를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">필드 이름입니다. <paramref name="fieldName" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="type">필드의 형식</param>
        <param name="attributes">필드의 특성입니다.</param>
        <summary>지정된 이름, 특성 및 필드 형식을 사용하여 형식에 새 필드를 추가합니다.</summary>
        <returns>정의된 필드입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fieldName" />의 길이가 0입니다.  
  
또는 
 <paramref name="type" />이 System.Void입니다.  
  
또는 
이 필드의 부모 클래스에 대한 전체 크기가 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fieldName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * Type[] * Type[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">필드 이름입니다. <paramref name="fieldName" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="type">필드의 형식</param>
        <param name="requiredCustomModifiers"><see cref="T:Microsoft.VisualC.IsConstModifier" /> 같은 필드에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열입니다.</param>
        <param name="optionalCustomModifiers"><see cref="T:Microsoft.VisualC.IsConstModifier" />와 같은 필드에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열입니다.</param>
        <param name="attributes">필드의 특성입니다.</param>
        <summary>지정된 이름, 특성, 필드 형식 및 사용자 지정 한정자를 사용하여 형식에 새 필드를 추가합니다.</summary>
        <returns>정의된 필드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 관리 되는 컴파일러의 디자이너를 위해 제공 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fieldName" />의 길이가 0인 경우  
  
또는 
 <paramref name="type" />이 System.Void입니다.  
  
또는 
이 필드의 부모 클래스에 대한 전체 크기가 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="fieldName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="typeBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">제네릭 형식 매개 변수의 이름 배열입니다.</param>
        <summary>현재 형식에 대한 제네릭 형식 매개 변수를 정의하고 해당 번호 및 이름을 지정한 후, 해당 제약 조건을 설정하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체 배열을 반환합니다.</summary>
        <returns>현재 형식에 대한 제네릭 형식 매개 변수 제약 조건을 정의하는 데 사용할 수 있는 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 개체 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하면 현재 형식이 제네릭 형식입니다. 동일한 형식에서 메서드를 다시 호출을 <xref:System.InvalidOperationException> throw 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 제네릭 형식을 두 형식 매개 변수를 사용 하 여 만들고 GenericEmitExample1.dll 어셈블리에 저장 합니다. 사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 생성 된 형식을 볼 수 있습니다. 에 대 한 자세한 설명은 동적 제네릭 형식을 정의 하는 단계를 참조 하세요 [방법: 리플렉션 내보내기를 사용 하 여 제네릭 형식 정의](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)합니다.  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 형식에 대해 제네릭 형식 매개 변수가 이미 정의되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="names" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="names" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="names" />가 빈 배열인 경우</exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4">방법: 리플렉션 내보내기를 사용하여 제네릭 형식 정의</related>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">데이터를 참조하는 데 사용되는 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="data">데이터의 BLOB입니다.</param>
        <param name="attributes">필드에 대한 특성입니다.</param>
        <summary>PE(이식 가능) 파일의 .sdata 섹션에서 초기화되지 않은 데이터 필드를 정의합니다.</summary>
        <returns>데이터를 참조할 필드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 만든 필드 수 있습니다 `static`를 포함 하지 않는 경우에 `FieldAttributes.Static` 에 `attributes` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0입니다.  
  
또는 
데이터의 크기가 0보다 작거나 같습니다. 또는 0x3f0000보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 또는 <paramref name="data" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />이 이전에 호출되었습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>형식에 메서드를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <summary>지정된 이름 및 메서드 특성을 사용하여 새 메서드를 형식에 추가합니다.</summary>
        <returns>새로 정의된 메서드를 나타내는 <see cref="T:System.Reflection.Emit.MethodBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 정의 하는 시간에 메서드 시그니처를 알 수 없는 경우이 메서드 오버 로드를 사용 합니다. 예를 들어, 매개 변수 형식과 반환 형식이 제네릭 메서드의 형식에 메서드를 추가한 후 정의 되어야 하는 메서드의 제네릭 형식 매개 변수로 지정할 수 있습니다. 매개 변수 및 반환 형식의 메서드를 나중에 사용 하 여 설정할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 메서드.  
  
 이 메서드 오버 로드 된 메서드를 정의 <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>합니다. 다른 호출 규칙을 사용 하 여 서명 메서드를 정의 하는 경우 사용 된 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> 메서드 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 제네릭 메서드 정의 `DemoMethod` 해당 매개 변수 형식과 반환 형식이 제네릭 형식 매개 변수로 지정 됩니다. 메서드는 표준 호출 규칙을 사용 하 여 서명을 없이 정의 됩니다. 합니다 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 메서드는 만드는 데 사용 되 `DemoMethod` 서명에 사용 된 다음은 반환 형식이 제네릭 메서드를 및 새로 정의 된 형식 매개 변수입니다.  
  
 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> 메서드.  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우  
  
또는 
이 메서드의 부모 형식은 인터페이스이고 이 메서드는 가상(Visual basic에서 <see langword="Overridable" />)이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="callingConvention">메서드의 호출 규칙입니다.</param>
        <summary>지정된 이름, 메서드 특성 및 호출 규칙을 사용하여 형식에 새 메서드를 추가합니다.</summary>
        <returns>새로 정의된 메서드를 나타내는 <see cref="T:System.Reflection.Emit.MethodBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 정의 하는 시간에 메서드 시그니처를 알 수 없는 경우이 메서드 오버 로드를 사용 합니다. 예를 들어, 매개 변수 형식과 반환 형식이 제네릭 메서드의 형식에 메서드를 추가한 후 정의 되어야 하는 메서드의 제네릭 형식 매개 변수로 지정할 수 있습니다. 매개 변수 및 반환 형식의 메서드를 나중에 사용 하 여 설정할 수는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우  
  
또는 
이 메서드의 부모 형식이 인터페이스이고 이 메서드가 가상(Visual basic에서 <see langword="Overridable" />)이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="parameterTypes">메서드의 매개 변수 형식입니다.</param>
        <summary>지정된 이름, 메서드 특성 및 메서드 서명을 사용하여 형식에 새 메서드를 추가합니다.</summary>
        <returns>정의된 메서드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 샘플의 사용법을 보여 줍니다 `DefineMethod` 동적 형식에 생성자의 특정 시그니처 및 특성을 설정 하 고 해당 반환 <xref:System.Reflection.Emit.MethodBuilder> MSIL 모집단에 대 한 합니다.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우  
  
또는 
이 메서드의 부모 형식은 인터페이스이고 이 메서드는 가상(Visual basic에서 <see langword="Overridable" />)이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="callingConvention">메서드의 호출 규칙입니다.</param>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="parameterTypes">메서드의 매개 변수 형식입니다.</param>
        <summary>지정된 이름, 메서드 특성, 호출 규칙 및 메서드 서명을 사용하여 형식에 새 메서드를 추가합니다.</summary>
        <returns>새로 정의된 메서드를 나타내는 <see cref="T:System.Reflection.Emit.MethodBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 샘플의 사용법을 보여 줍니다 `DefineMethod` 동적 형식에 생성자의 특정 시그니처 및 특성을 설정 하 고 해당 반환 <xref:System.Reflection.Emit.MethodBuilder> MSIL 모집단에 대 한 합니다.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우  
  
또는 
이 메서드의 부모 형식은 인터페이스이고 이 메서드는 가상(Visual basic에서 <see langword="Overridable" />)이 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="callingConvention">메서드의 호출 규칙입니다.</param>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="returnTypeRequiredCustomModifiers">메서드의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 필수 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="returnTypeOptionalCustomModifiers">메서드의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 선택적 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypes">메서드의 매개 변수 형식입니다.</param>
        <param name="parameterTypeRequiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypeOptionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <summary>지정된 이름, 메서드 특성, 호출 규칙, 메서드 서명 및 사용자 지정 한정자를 사용하여 형식에 새 메서드를 추가합니다.</summary>
        <returns>새로 추가된 메서드를 나타내는 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 한정자를 지정 해야 하는 경우이 오버 로드를 사용 합니다. 마찬가지로 메서드를 만든 후 사용자 지정 한정자를 지정 해야 하는 경우 예를 들어, 매개 변수 형식이 해당 제네릭 형식 매개 변수로 지정 된 제네릭 메서드를 사용 하 여 사용할 수는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> 또는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> 정의 하는 메서드 오버 로드 사용 하 고 메서드는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 사용자 지정 한정자를 사용 하 여 매개 변수를 정의 하 고 반환 하는 메서드 형식입니다.  
  
> [!NOTE]
>  사용자 지정 한정자에 대 한 자세한 내용은 ECMA 파티션 II 메타 데이터가 설명서를 참조 하십시오. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우  
  
또는 
이 메서드의 부모 형식은 인터페이스이고 이 메서드는 가상(Visual basic에서 <see langword="Overridable" />)이 아닙니다.  
  
또는 
<paramref name="parameterTypeRequiredCustomModifiers" /> 또는 <paramref name="parameterTypeOptionalCustomModifiers" />의 크기가 <paramref name="parameterTypes" />의 크기와 같지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberSignature Language="F#" Value="member this.DefineMethodOverride : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; unit" Usage="typeBuilder.DefineMethodOverride (methodInfoBody, methodInfoDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">사용할 메서드의 본문입니다. 이는 <see langword="MethodBuilder" /> 개체여야 합니다.</param>
        <param name="methodInfoDeclaration">선언이 사용될 메서드입니다.</param>
        <summary>잠재적으로 다른 이름을 사용하여 지정된 메서드 선언을 구현하는 지정된 메서드 본문을 지정 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 재정의 또는 인터페이스 구현에는이 메서드를 사용 하지 마십시오. 기본 클래스의 메서드를 재정의 하거나 인터페이스의 메서드를 구현 하 내보내면 동일한 이름과 시그니처를 사용 하 여 메서드 재정의 되거나 구현 하는 방법으로 코드 예제에서 설명한 것 처럼 합니다.  
  
 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 메서드 본문 및 메서드 선언에 다른 이름을 가질 경우 메서드가 사용 됩니다. 예를 들어, 클래스 기본 클래스 메서드를 재정의 하 고도 별도 구현을 제공 인터페이스 멤버에 대 한 동일한 이름을 사용 하 여 코드 예제에서 설명한 대로 될 수 있습니다.  
  
 `DefineMethodOverride` 정의 `methodimpl`, 쌍 메타 데이터 토큰으로 구성 합니다. 하나의 토큰만 구현을 고 본문을 구현 하는 선언 다른 토큰 지점을 가리킵니다. 본문 메서드 구현이 정의 된 형식에 정의 되어야 하며 본문 virtual 이어야 합니다 (`Overridable` Visual basic에서). 선언 형식, 파생된 클래스에서 메서드 또는 형식에 정의 된 메서드를 구현한 인터페이스에서 정의 된 메서드를 만들 수 있습니다. 선언 인터페이스 에서만 경우 인터페이스에 대해 정의 된 슬롯 변경 됩니다. 기본 형식에서 메서드를 선언한 경우 메서드에 대 한 슬롯 재정의 되 고 모든 중복 메서드가 재정의 된 메서드에 대 한 대체 됩니다. 재정의 된 메서드 선언 된 실제 메서드 일 수 없습니다. 메서드를 같은 형식의 경우 슬롯 바뀌고 대체 메서드가 모든 중복 된 재정의 됩니다.  
  
> [!NOTE]
>  메서드 impls에 대 한 자세한 내용은 참조 하세요. `MethodImpl` ECMA 파티션 II 메타 데이터 문서의 합니다. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
> [!IMPORTANT]
>  후 합니다 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 메서드를 호출의 일부 기능은 `methodInfoBody` 변경할 수 없습니다. 제네릭 형식 매개 변수에 특성을 적용할 수 없습니다. 예를 들어 `methodInfoBody` 를 사용 하 여를 <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> 메서드. 사용 해야 하는 경우는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 메서드를의 특징을 모두 후 `methodInfoBody` 정의한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 인터페이스를 포함 `I` 메서드로 `M()`, 기본 클래스 `A` 인터페이스 및 파생된 클래스를 구현 하는 `C` 의 기본 클래스 구현을 재정의 하는 `M()` 그리고 별도 명시적 구현을 제공 `I.M()`합니다.  
  
 합니다 `main()` 코드 예제의 메서드를 파생된 클래스를 내보내는 방법을 보여 줍니다 `C`합니다. 재정의 `A.M()` 메서드를 내보내는 방법으로 간단히 이루어집니다 `M()` 동일한 서명을 사용 하 여 합니다. 그러나의 별도 구현을 제공 하도록 `I.M()`, 메서드 본문을 정의 하 고 사용 하 여는 <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> 메서드를 사용 하 여 해당 메서드 본문에 연결을 <xref:System.Reflection.MethodInfo> 나타내는 `I.M()`. 메서드 본문의 이름은 중요 하지 않습니다.  
  
 코드 예제에서는 내보낸된 클래스의 인스턴스를 만듭니다. 가져와서를 <xref:System.Reflection.MethodInfo> 개체에 대 한 `I.M()`를 사용 하는 내보낸된 클래스의 명시적 인터페이스 구현. 다음을 <xref:System.Reflection.MethodInfo> 개체에 대 한 `A.M()`, 내보낸된 클래스의 재정의 메서드를 호출 하는 데 사용 합니다.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="methodInfoBody" />이(가) 이 클래스에 속하지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="methodInfoBody" /> 또는 <paramref name="methodInfoDeclaration" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
<paramref name="methodInfoBody" />의 선언 형식이 이 <see cref="T:System.Reflection.Emit.TypeBuilder" />가 나타내는 형식이 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>중첩 형식을 정의합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <summary>지정된 이름의 중첩 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중첩 된 만드는 데 사용할 수 후에 형식는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드가 호출 되었습니다.  
  
 중첩된 된 형식이 해야 전체를 사용 하 여 리플렉션 <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, 또는 <xref:System.Type.GetNestedTypes%2A>합니다.  
  
 에 대 한 설명을 참조 하세요. <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 는 중첩된 형식 및 중첩 형식 완료 해야 하는 순서에 대 한 합니다.  
  
 경우에 중복 된 이름을 반드시 생성 되지는 않습니다 `name` 이전에 정의 된 형식 또는 중첩 된 형식 이름으로 동일 합니다. 중복 된 것을 동일 네임 스페이스 및 모든 중첩 형식을 비롯 한 전체 이름 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0이거나 1023보다 큽니다.  
  
또는 
이 작업을 수행하면 현재 어셈블리에 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" />이 중복된 형식이 만들어집니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attr">형식의 특성입니다.</param>
        <summary>이름 및 특성이 지정된 경우 중첩된 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중첩 된 만드는 데 사용할 수 후에 형식는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드가 호출 되었습니다.  
  
 중첩된 된 형식이 해야 전체를 사용 하 여 리플렉션 <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, 또는 <xref:System.Type.GetNestedTypes%2A>합니다.  
  
 에 대 한 설명을 참조 하세요. <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 는 중첩된 형식 및 중첩 형식 완료 해야 하는 순서에 대 한 합니다.  
  
 경우에 중복 된 이름을 반드시 생성 되지는 않습니다 `name` 이전에 정의 된 형식 또는 중첩 된 형식 이름으로 동일 합니다. 중복 된 것을 동일 네임 스페이스 및 모든 중첩 형식을 비롯 한 전체 이름 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">중첩된 특성이 지정되지 않았습니다.  
  
또는 
이 형식이 봉인되어 있습니다.  
  
또는 
이 형식은 배열입니다.  
  
또는 
이 형식은 인터페이스지만 중첩된 형식은 인터페이스가 아닙니다.  
  
또는 
<paramref name="name" />의 길이가 0이거나 1023보다 큽니다.  
  
또는 
이 작업을 수행하면 현재 어셈블리에 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" />이 중복된 형식이 만들어집니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attr">형식의 특성입니다.</param>
        <param name="parent">중첩된 형식이 확장하는 형식입니다.</param>
        <summary>해당 이름, 특성 및 확장되는 형식이 지정된 경우 중첩된 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중첩 된 만드는 데 사용할 수 후에 형식는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드가 호출 되었습니다.  
  
 중첩된 된 형식이 해야 전체를 사용 하 여 리플렉션 <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, 또는 <xref:System.Type.GetNestedTypes%2A>합니다.  
  
 에 대 한 설명을 참조 하세요. <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 는 중첩된 형식 및 중첩 형식 완료 해야 하는 순서에 대 한 합니다.  
  
 경우에 중복 된 이름을 반드시 생성 되지는 않습니다 `name` 이전에 정의 된 형식 또는 중첩 된 형식 이름으로 동일 합니다. 중복 된 것을 동일 네임 스페이스 및 모든 중첩 형식을 비롯 한 전체 이름 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">중첩된 특성이 지정되지 않았습니다.  
  
또는 
이 형식이 봉인되어 있습니다.  
  
또는 
이 형식은 배열입니다.  
  
또는 
이 형식은 인터페이스지만 중첩된 형식은 인터페이스가 아닙니다.  
  
또는 
<paramref name="name" />의 길이가 0이거나 1023보다 큽니다.  
  
또는 
이 작업을 수행하면 현재 어셈블리에 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" />이 중복된 형식이 만들어집니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attr">형식의 특성입니다.</param>
        <param name="parent">중첩된 형식이 확장하는 형식입니다.</param>
        <param name="typeSize">형식의 총 크기입니다.</param>
        <summary>해당 이름, 특성, 형식의 총 크기 및 해당 형식이 확장하는 형식을 지정하여 중첩된 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중첩 된 만드는 데 사용할 수 후에 형식는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드가 호출 되었습니다.  
  
 중첩된 된 형식이 해야 전체를 사용 하 여 리플렉션 <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, 또는 <xref:System.Type.GetNestedTypes%2A>합니다.  
  
 에 대 한 설명을 참조 하세요. <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 는 중첩된 형식 및 중첩 형식 완료 해야 하는 순서에 대 한 합니다.  
  
 경우에 중복 된 이름을 반드시 생성 되지는 않습니다 `name` 이전에 정의 된 형식 또는 중첩 된 형식 이름으로 동일 합니다. 중복 된 것을 동일 네임 스페이스 및 모든 중첩 형식을 비롯 한 전체 이름 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">중첩된 특성이 지정되지 않았습니다.  
  
또는 
이 형식이 봉인되어 있습니다.  
  
또는 
이 형식은 배열입니다.  
  
또는 
이 형식은 인터페이스지만 중첩된 형식은 인터페이스가 아닙니다.  
  
또는 
<paramref name="name" />의 길이가 0이거나 1023보다 큽니다.  
  
또는 
이 작업을 수행하면 현재 어셈블리에 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" />이 중복된 형식이 만들어집니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attr">형식의 특성입니다.</param>
        <param name="parent">중첩된 형식이 확장하는 형식입니다.</param>
        <param name="packSize">형식의 압축 크기입니다.</param>
        <summary>해당 이름, 특성, 해당 형식이 확장하는 형식, 압축 크기를 지정하여 중첩된 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중첩 된 만드는 데 사용할 수 후에 형식는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드가 호출 되었습니다.  
  
 중첩된 된 형식이 해야 전체를 사용 하 여 리플렉션 <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, 또는 <xref:System.Type.GetNestedTypes%2A>합니다.  
  
 에 대 한 설명을 참조 하세요. <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 는 중첩된 형식 및 중첩 형식 완료 해야 하는 순서에 대 한 합니다.  
  
 경우에 중복 된 이름을 반드시 생성 되지는 않습니다 `name` 이전에 정의 된 형식 또는 중첩 된 형식 이름으로 동일 합니다. 중복 된 것을 동일 네임 스페이스 및 모든 중첩 형식을 비롯 한 전체 이름 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">중첩된 특성이 지정되지 않았습니다.  
  
또는 
이 형식이 봉인되어 있습니다.  
  
또는 
이 형식은 배열입니다.  
  
또는 
이 형식은 인터페이스지만 중첩된 형식은 인터페이스가 아닙니다.  
  
또는 
<paramref name="name" />의 길이가 0이거나 1023보다 큽니다.  
  
또는 
이 작업을 수행하면 현재 어셈블리에 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" />이 중복된 형식이 만들어집니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attr">형식의 특성입니다.</param>
        <param name="parent">중첩된 형식이 확장하는 형식입니다.</param>
        <param name="interfaces">중첩된 형식이 구현하는 인터페이스입니다.</param>
        <summary>해당 이름, 특성, 해당 형식이 확장하는 형식, 구현하는 인터페이스를 지정하여 중첩된 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중첩 된 만드는 데 사용할 수 후에 형식는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 바깥쪽 형식에서 메서드가 호출 되었습니다.  
  
 중첩된 된 형식이 해야 전체를 사용 하 여 리플렉션 <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, 또는 <xref:System.Type.GetNestedTypes%2A>합니다.  
  
 에 대 한 설명을 참조 하세요. <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 는 중첩된 형식 및 중첩 형식 완료 해야 하는 순서에 대 한 합니다.  
  
 경우에 중복 된 이름을 반드시 생성 되지는 않습니다 `name` 이전에 정의 된 형식 또는 중첩 된 형식 이름으로 동일 합니다. 중복 된 것을 동일 네임 스페이스 및 모든 중첩 형식을 비롯 한 전체 이름 이어야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">중첩된 특성이 지정되지 않았습니다.  
  
또는 
이 형식이 봉인되어 있습니다.  
  
또는 
이 형식은 배열입니다.  
  
또는 
이 형식은 인터페이스지만 중첩된 형식은 인터페이스가 아닙니다.  
  
또는 
<paramref name="name" />의 길이가 0이거나 1023보다 큽니다.  
  
또는 
이 작업을 수행하면 현재 어셈블리에 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" />이 중복된 형식이 만들어집니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="interfaces" /> 배열의 요소가 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">형식의 약식 이름입니다. <paramref name="name" />에는 포함된 null이 있을 수 없습니다.</param>
        <param name="attr">형식의 특성입니다.</param>
        <param name="parent">중첩된 형식이 확장하는 형식입니다.</param>
        <param name="packSize">형식의 압축 크기입니다.</param>
        <param name="typeSize">형식의 총 크기입니다.</param>
        <summary>해당 이름, 특성, 크기 및 해당 형식이 확장하는 형식을 지정하여 중첩된 형식을 정의합니다.</summary>
        <returns>정의된 중첩 형식입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="PInvoke" /> 메서드를 정의합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> 메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="dllName"><see langword="PInvoke" /> 메서드가 정의된 DLL의 이름입니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="callingConvention">메서드의 호출 규칙입니다.</param>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="parameterTypes">메서드 매개 변수의 형식입니다.</param>
        <param name="nativeCallConv">네이티브 호출 규칙입니다.</param>
        <param name="nativeCharSet">메서드의 네이티브 문자 집합입니다.</param>
        <summary>해당 이름, 메서드가 정의된 DLL의 이름, 메서드의 특성, 메서드의 호출 규칙, 메서드의 반환 형식, 메서드의 매개 변수 형식 및 <see langword="PInvoke" /> 플래그를 지정하여 <see langword="PInvoke" /> 메서드를 정의합니다.</summary>
        <returns>정의된 <see langword="PInvoke" /> 메서드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 DLL 특성을 가져오려면 (에 대 한 설명을 참조 하세요. <xref:System.Runtime.InteropServices.DllImportAttribute>)이 메서드에 인수로 지정할 수 없습니다. 예를 들어, DLL 가져오기 특성 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 뒤에 추가 해야 합니다 `PInvoke` 메서드 값을 반환 하는 경우 메서드가 생성 됩니다. 이 작업을 수행 하는 방법을 보여 줍니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> 메서드를를 `PInvoke` 메서드와 추가 하는 방법을 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그를 만든 후에 메서드 구현 플래그를를 <xref:System.Reflection.Emit.MethodBuilder>를 사용 하 여를 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>메서드.  
  
> [!IMPORTANT]
>  0이 아닌 반환 값을 가져오려면 추가 해야 합니다는 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그입니다.  
  
 이 예에서는 하나의 동적 모듈 및 단일 형식에 사용 하 여 동적 어셈블리를 만듭니다 `MyType`를 포함 하는 `PInvoke` 메서드. 합니다 `PInvoke` 메서드는 Win32 나타냅니다 `GetTickCount` 함수입니다.  
  
 예제를 실행 하는 경우 실행을 `PInvoke` 메서드. 또한 PInvokeTest.dll 동적 어셈블리를 저장 합니다. 사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 검사할를 `MyType` 클래스 및 `static` (`Shared` Visual Basic의) `PInvoke` 메서드를 포함 합니다. 정적을 사용 하는 Visual Basic 또는 C# 프로그램을 컴파일할 수 있습니다 `MyType.GetTickCount` csc.exe 또는 vbc.exe;를 실행 하는 경우에 DLL에 대 한 참조를 포함 하 여 메서드 예를 들어 `/r:PInvokeTest.dll`합니다.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">메서드가 정적이 아닙니다.  
  
또는 
부모 형식이 인터페이스입니다.  
  
또는 
abstract 메서드입니다.  
  
또는 
메서드가 이전에 정의되었습니다.  
  
또는 
<paramref name="name" /> 또는 <paramref name="dllName" />의 길이가 0입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 또는 <paramref name="dllName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 만든 것입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> 메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="dllName"><see langword="PInvoke" /> 메서드가 정의된 DLL의 이름입니다.</param>
        <param name="entryName">DLL의 진입점 이름입니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="callingConvention">메서드의 호출 규칙입니다.</param>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="parameterTypes">메서드 매개 변수의 형식입니다.</param>
        <param name="nativeCallConv">네이티브 호출 규칙입니다.</param>
        <param name="nativeCharSet">메서드의 네이티브 문자 집합입니다.</param>
        <summary>해당 이름, 메서드가 정의된 DLL의 이름, 진입점의 이름, 메서드의 특성, 메서드의 호출 규칙, 메서드의 반환 형식, 메서드의 매개 변수 형식 및 <see langword="PInvoke" /> 플래그를 지정하여 <see langword="PInvoke" /> 메서드를 정의합니다.</summary>
        <returns>정의된 <see langword="PInvoke" /> 메서드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 DLL 특성을 가져오려면 (에 대 한 설명을 참조 하세요. <xref:System.Runtime.InteropServices.DllImportAttribute>)이 메서드에 인수로 지정할 수 없습니다. 예를 들어, DLL 가져오기 특성 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 뒤에 추가 해야 합니다 `PInvoke` 메서드 값을 반환 하는 경우 메서드가 생성 됩니다. 이 작업을 수행 하는 방법을 보여 줍니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> 메서드를를 `PInvoke` 메서드와 추가 하는 방법 합니다 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그를 만든 후에 메서드 구현 플래그를를 <xref:System.Reflection.Emit.MethodBuilder>를 사용 하 여를 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> 메서드.  
  
> [!IMPORTANT]
>  0이 아닌 반환 값을 가져오려면 추가 해야 합니다는 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그입니다.  
  
 이 예에서는 하나의 동적 모듈 및 단일 형식에 사용 하 여 동적 어셈블리를 만듭니다 `MyType`를 포함 하는 `PInvoke` 메서드. 합니다 `PInvoke` 메서드는 Win32 나타냅니다 `GetTickCount` 함수입니다.  
  
 예제를 실행 하는 경우 실행을 `PInvoke` 메서드. 또한 PInvokeTest.dll 동적 어셈블리를 저장 합니다. 사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 검사할를 `MyType` 클래스 및 `static` (`Shared` Visual Basic의) `PInvoke` 메서드를 포함 합니다. 정적을 사용 하는 Visual Basic 또는 C# 프로그램을 컴파일할 수 있습니다 `MyType.GetTickCount` csc.exe 또는 vbc.exe;를 실행 하는 경우에 DLL에 대 한 참조를 포함 하 여 메서드 예를 들어 `/r:PInvokeTest.dll`합니다.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">메서드가 정적이 아닙니다.  
  
또는 
부모 형식이 인터페이스입니다.  
  
또는 
abstract 메서드입니다.  
  
또는 
메서드가 이전에 정의되었습니다.  
  
또는 
<paramref name="name" />, <paramref name="dllName" /> 또는 <paramref name="entryName" />의 길이가 0입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />, <paramref name="dllName" /> 또는 <paramref name="entryName" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 만든 것입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> 메서드의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="dllName"><see langword="PInvoke" /> 메서드가 정의된 DLL의 이름입니다.</param>
        <param name="entryName">DLL의 진입점 이름입니다.</param>
        <param name="attributes">메서드의 특성입니다.</param>
        <param name="callingConvention">메서드의 호출 규칙입니다.</param>
        <param name="returnType">메서드의 반환 형식입니다.</param>
        <param name="returnTypeRequiredCustomModifiers">메서드의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 필수 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="returnTypeOptionalCustomModifiers">메서드의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 선택적 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypes">메서드 매개 변수의 형식입니다.</param>
        <param name="parameterTypeRequiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypeOptionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="nativeCallConv">네이티브 호출 규칙입니다.</param>
        <param name="nativeCharSet">메서드의 네이티브 문자 집합입니다.</param>
        <summary>해당 이름, 메서드가 정의된 DLL의 이름, 진입점의 이름, 메서드의 특성, 메서드의 호출 규칙, 메서드의 반환 형식, 메서드의 매개 변수 형식, <see langword="PInvoke" /> 플래그, 매개 변수/반환 형식에 대한 사용자 지정 한정자를 지정하여 <see langword="PInvoke" /> 메서드를 정의합니다.</summary>
        <returns>정의된 <see langword="PInvoke" /> 메서드를 나타내는 <see cref="T:System.Reflection.Emit.MethodBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 DLL 특성을 가져오려면 (에 대 한 설명을 참조 하세요. <xref:System.Runtime.InteropServices.DllImportAttribute>)이 메서드에 인수로 지정할 수 없습니다. 예를 들어, DLL 가져오기 특성 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 뒤에 추가 해야 합니다 `PInvoke` 메서드 값을 반환 하는 경우 메서드가 생성 됩니다. 이 작업을 수행 하는 방법을 보여 줍니다.  
  
> [!NOTE]
>  사용자 지정 한정자에 대 한 자세한 내용은 ECMA 파티션 II 메타 데이터가 설명서를 참조 하십시오. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 [\], 형식\[\], 유형\[\], 형식\[\]\[\], 형식\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > 메서드를를 `PInvoke` 메서드와 추가 하는 방법의 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그를 만든 후에 메서드 구현 플래그를는 <xref:System.Reflection.Emit.MethodBuilder>를 사용 하 여 합니다 <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> 메서드.  
  
 이 예에서는 하나의 동적 모듈 및 단일 형식에 사용 하 여 동적 어셈블리를 만듭니다 `MyType`를 포함 하는 `PInvoke` 메서드. 합니다 `PInvoke` 메서드는 Win32 나타냅니다 `GetTickCount` 함수입니다.  
  
> [!IMPORTANT]
>  0이 아닌 반환 값을 가져오려면 추가 해야 합니다는 <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> 플래그입니다.  
  
> [!NOTE]
>  이 예제에서는 사용자 지정 한정자를 지정 하지 않는 오버 로드를 사용 합니다. 사용자 지정 한정자를 지정 하려면이 메서드 오버 로드를 대신 사용 하는 예제 코드를 변경 합니다.  
  
 예제를 실행 하는 경우 실행을 `PInvoke` 메서드. 또한 PInvokeTest.dll 동적 어셈블리를 저장 합니다. 사용할 수는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 검사할를 `MyType` 클래스 및 `static` (`Shared` Visual Basic의) `PInvoke` 메서드를 포함 합니다. 정적을 사용 하는 Visual Basic 또는 C# 프로그램을 컴파일할 수 있습니다 `MyType.GetTickCount` csc.exe 또는 vbc.exe;를 실행 하는 경우에 DLL에 대 한 참조를 포함 하 여 메서드 예를 들어 `/r:PInvokeTest.dll`합니다.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">메서드가 정적이 아닙니다.  
  
또는 
부모 형식이 인터페이스입니다.  
  
또는 
abstract 메서드입니다.  
  
또는 
메서드가 이전에 정의되었습니다.  
  
또는 
<paramref name="name" />, <paramref name="dllName" /> 또는 <paramref name="entryName" />의 길이가 0입니다.  
  
또는 
<paramref name="parameterTypeRequiredCustomModifiers" /> 또는 <paramref name="parameterTypeOptionalCustomModifiers" />의 크기가 <paramref name="parameterTypes" />의 크기와 같지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />, <paramref name="dllName" /> 또는 <paramref name="entryName" />이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>형식에 새 속성을 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">속성의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">속성의 특성입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="parameterTypes">속성의 매개 변수 형식입니다.</param>
        <summary>지정된 이름 및 속성 서명을 사용하여 형식에 새 속성을 추가합니다.</summary>
        <returns>정의된 속성입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 샘플에 가져오고, 동적 속성을 정의 하는 방법을 보여 줍니다.는 <xref:System.Reflection.Emit.PropertyBuilder> 사양에 대 한 합니다. `PropertyBuilder` 해당 있어야 <xref:System.Reflection.Emit.MethodBuilder>, 속성에 대 한 IL 논리를 보관 하는 됩니다.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameterTypes" /> 배열의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">속성의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">속성의 특성입니다.</param>
        <param name="callingConvention">속성 접근자의 호출 규칙입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="parameterTypes">속성의 매개 변수 형식입니다.</param>
        <summary>지정된 이름, 특성, 호출 규칙 및 속성 서명을 사용하여 형식에 새 속성을 추가합니다.</summary>
        <returns>정의된 속성입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameterTypes" /> 배열의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">속성의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">속성의 특성입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="returnTypeRequiredCustomModifiers">속성의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 필수 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="returnTypeOptionalCustomModifiers">속성의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 선택적 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypes">속성의 매개 변수 형식입니다.</param>
        <param name="parameterTypeRequiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypeOptionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <summary>지정된 이름, 속성 서명 및 사용자 지정 한정자를 사용하여 형식에 새 속성을 추가합니다.</summary>
        <returns>정의된 속성입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 관리 되는 컴파일러의 디자이너를 위해 제공 됩니다.  
  
> [!NOTE]
>  사용자 지정 한정자에 대 한 자세한 내용은 ECMA 파티션 II 메타 데이터가 설명서를 참조 하십시오. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameterTypes" /> 배열의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">속성의 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="attributes">속성의 특성입니다.</param>
        <param name="callingConvention">속성 접근자의 호출 규칙입니다.</param>
        <param name="returnType">속성의 반환 형식입니다.</param>
        <param name="returnTypeRequiredCustomModifiers">속성의 반환 형식에 대한 필수 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 필수 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="returnTypeOptionalCustomModifiers">속성의 반환 형식에 대한 선택적 사용자 지정 한정자를 나타내는 형식의 배열(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />)입니다. 반환 형식에 선택적 사용자 지정 한정자가 없으면 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypes">속성의 매개 변수 형식입니다.</param>
        <param name="parameterTypeRequiredCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수에 필요한 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 필수 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <param name="parameterTypeOptionalCustomModifiers">형식 배열의 배열입니다. 각 형식의 배열은 해당 매개 변수의 선택적 사용자 지정 한정자를 나타냅니다(예: <see cref="T:System.Runtime.CompilerServices.IsConst" />). 특정 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다. 매개 변수에 선택적 사용자 지정 한정자가 없는 경우 형식 배열 대신 <see langword="null" />을 지정합니다.</param>
        <summary>지정된 이름, 호출 규칙, 속성 서명 및 사용자 지정 한정자를 사용하여 형식에 새 속성을 추가합니다.</summary>
        <returns>정의된 속성입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 관리 되는 컴파일러의 디자이너를 위해 제공 됩니다.  
  
> [!NOTE]
>  사용자 지정 한정자에 대 한 자세한 내용은 ECMA 파티션 II 메타 데이터가 설명서를 참조 하십시오. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
 이 메서드는 오버 로드는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="parameterTypes" /> 배열의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberSignature Language="F#" Value="member this.DefineTypeInitializer : unit -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineTypeInitializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 형식에 대한 이니셜라이저를 정의합니다.</summary>
        <returns>형식 이니셜라이저를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만든 이니셜라이저가 항상 public입니다.  
  
   
  
## Examples  
 다음 코드 샘플에 사용 하 여 초기화 생성자를 만드는 방법을 보여 줍니다 `DefineTypeInitializer`합니다.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">포함하는 형식은 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 만든 것입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">데이터를 참조하는 데 사용되는 이름입니다. <paramref name="name" />에는 내장된 null이 포함될 수 없습니다.</param>
        <param name="size">데이터 필드의 크기입니다.</param>
        <param name="attributes">필드에 대한 특성입니다.</param>
        <summary>PE(이식 가능) 파일의 <see langword=".sdata" /> 섹션에서 초기화되지 않은 데이터 필드를 정의합니다.</summary>
        <returns>데이터를 참조할 필드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 만든 필드 수 있습니다 `static`를 포함 하지 않는 경우에 `FieldAttributes.Static` 에 `attributes` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 샘플의 사용법을 보여 줍니다. `DefineUninitializedData` 동적 형식의 초기화 되지 않은 데이터 필드를 만들려면:  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />의 길이가 0입니다.  
  
또는 
 <paramref name="size" />가 0보다 작거나 같습니다. 또는 0x003f0000보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 형식의 전체 경로를 검색합니다.</summary>
        <value>읽기 전용입니다. 해당 형식의 전체 경로를 검색합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 형식은 "enclosingTypeFullName + nestedTypeName" 중첩된 형식 및 중첩 되지 않은 형식에 대 한 "typeName"입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 제네릭 형식 매개 변수의 공 분산과 특수 제약 조건을 나타내는 값을 가져옵니다.</summary>
        <value>현재 제네릭 형식 매개 변수의 공 분산 및 특수 제약 조건을 설명하는 <see cref="T:System.Reflection.GenericParameterAttributes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  제네릭 형식 매개 변수는 나타내는 코드를 내보낼 때는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 개체 보다는 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>매개 변수를 선언한 제네릭 형식의 형식 매개 변수 목록에서 형식 매개 변수의 위치를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 개체가 제네릭 형식 매개 변수를 나타내는 경우, 매개 변수를 선언한 제네릭 형식의 형식 매개 변수 목록에서 형식 매개 변수의 위치이며, 나타내지 않는 경우에는 정의되어 있지 않습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  제네릭 형식 매개 변수는 나타내는 코드를 내보낼 때는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 개체 보다는 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 하는 경우 현재 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식 매개 변수를 나타내지 않는이 속성의 값이 정의 되지 않습니다. 사용 하 여는 <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> 속성을 확인 하는지 여부를 현재 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식 매개 변수를 나타냅니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberSignature Language="F#" Value="override this.GetArrayRank : unit -&gt; int" Usage="typeBuilder.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeBuilder.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member GetConstructor : Type * System.Reflection.ConstructorInfo -&gt; System.Reflection.ConstructorInfo" Usage="System.Reflection.Emit.TypeBuilder.GetConstructor (type, constructor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">해당 생성자가 반환되는 생성된 제네릭 형식입니다.</param>
        <param name="constructor"><paramref name="type" />의 제네릭 형식 정의에 있는 생성자로, 반환할 <paramref name="type" />의 생성자를 지정합니다.</param>
        <summary>제네릭 형식 정의의 지정된 생성자에 해당하는 생성된 특정 제네릭 형식의 생성자를 반환합니다.</summary>
        <returns><paramref name="type" />의 제네릭 형식 정의에 속하는 생성자를 지정하는 <paramref name="constructor" />에 해당하는 <paramref name="type" />의 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 메서드 제공 하는 방법이 <xref:System.Reflection.ConstructorInfo> 생성된 된 제네릭 형식 나타내는 해당 제네릭 형식 정의의 생성자를 나타내는 개체를 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 예를 들어 있다고 가정를 <xref:System.Reflection.Emit.TypeBuilder> 형식을 나타내는 개체 `G<T>` C# 구문에서 (`G(Of T)` Visual basic에서는 `generic <T> ref class G` c + +에서) 및 <xref:System.Reflection.Emit.ConstructorBuilder> 개체의 생성자를 나타내는 `G<T>`합니다. 가정 `G<T>` 형식 매개 변수를 사용 하 여 제네릭 메서드가 `U` 생성 된 형식의 인스턴스를 만드는 `G<U>`합니다. 생성 된 형식의 인스턴스를 만드는 코드를 생성, 하려면를 <xref:System.Reflection.ConstructorInfo> 의 인스턴스를 만들고 개체 즉, 생성 된이 형식의 생성자를 나타내는 `G<U>`합니다. 이 작업을 수행 하려면 먼저 호출를 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드를 <xref:System.Reflection.Emit.TypeBuilder> 개체를 지정 하는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 나타내는 개체입니다 `U` 형식 인수로 합니다. 다음 호출을 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 의 반환 값을 사용 하 여 메서드를 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드 매개 변수로 `type` 및 <xref:System.Reflection.Emit.ConstructorBuilder> 의 생성자를 나타내는 개체입니다 `G<U>` 매개 변수로 `constructor`합니다. 반환 값은는 <xref:System.Reflection.ConstructorInfo> 함수 호출을 내보내는 데 필요한 개체입니다. 코드 예제에서는이 시나리오를 보여 줍니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 제네릭 클래스에 대 한 소스 코드를 포함 `Sample` 명명 된 형식 매개 변수가 있는 `T`합니다. 클래스 라는 필드가 `Field`, 형식 `T`, 및 라는 제네릭 메서드 `GM` 라는 고유한 형식 매개 변수를 사용 하 여 `U`합니다. 메서드 `GM` 의 인스턴스를 만듭니다 `Sample`, 고유한 형식 매개 변수를 대체 `U` 의 형식 매개 변수에 `Sample`, 해당 입력된 매개 변수를 가져와 `Field`합니다. 이 소스 코드 컴파일 되었지만 사용 되지 않습니다. 사용 하 여 볼 수 있습니다 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 클래스에 의해 생성 된 코드 비교 `Example`합니다.  
  
 클래스의 코드 `Example` 사용을 보여 줍니다는 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 일반 코드를 생성 하는 방법입니다. `Main` 클래스의 메서드 `Example` 라는 클래스를 포함 하는 동적 어셈블리를 만듭니다 `Sample` 사용 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 메서드는 형식 매개 변수를 추가 하 여 제네릭를 `T`. 기본 생성자 및 필드가 `Field`, 형식 `T`, 클래스에 추가 됩니다 `Sample`합니다. 메서드 `GM` 에 추가 하 고 사용 하 여 제네릭 메서드로 설정 된 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 메서드. 형식 매개 변수에 `GM` 이름은 `U`합니다. 형식 매개 변수를 정의한 후 서명의 `GM` 를 사용 하 여 추가 되는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 메서드. 반환 형식이 없는 및 필요한 아니요 또는 사용자 지정 한정자를이 메서드의 모든 매개 변수가 `null` 제외한 `parameterTypes`; `parameterTypes` 메서드의 유일한 매개 변수의 형식을 설정 `U`, 메서드의 제네릭 형식 매개 변수입니다. 메서드의 본문 생성 된 형식의 인스턴스를 만듭니다 `Sample<U>` (`Sample(Of U)` Visual basic에서), 메서드의 매개 변수를 할당 `Field`, 다음 값을 인쇄 `Field`합니다. <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> 메서드는 만드는 데는 <xref:System.Reflection.ConstructorInfo> 생성 된 제네릭 형식의 기본 생성자를 나타내는 `Sample<U>` 에서 <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> 명령 인스턴스를 만듭니다.  
  
 더미 형식을 정의 하는 진입점 메서드를 보유할 `Main`합니다. 본문에 `Main`, 정적 `GM` 생성된 된 제네릭 형식에 메서드가 호출 되 `Sample<int>` (`Sample(Of Integer)` Visual Basic의), 형식과 <xref:System.String> 대체 `U`합니다.  
  
 코드 예제를 실행 하는 경우 내보낸된 어셈블리 TypeBuilderGetFieldExample.exe로 저장 합니다. TypeBuilderGetFieldExample.exe를 실행할 수 있으며 사용할 수 있습니다는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 내보낸된 코드에 대 한 코드를 사용 하 여 비교할는 `Sample` 자체 코드 예제로 컴파일되는 클래스입니다.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="type" />이 제네릭 형식을 나타내지 않습니다.  
  
또는 
 <paramref name="type" />이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 형식이 아닌 경우  
  
또는 
<paramref name="constructor" />의 선언 형식이 제네릭 형식 정의가 아닙니다.  
  
또는 
<paramref name="constructor" />의 선언 형식이 <paramref name="type" />의 제네릭 형식 정의가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeBuilder.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeBuilder.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">이는 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등에서처럼 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>지정된 대로 이 클래스에 대해 정의된 public 또는 non-public 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체 배열을 반환합니다.</summary>
        <returns>이 클래스에 대해 정의된 지정된 생성자를 나타내는 <see cref="T:System.Reflection.ConstructorInfo" /> 개체 배열을 반환합니다. 생성자가 정의되지 않은 경우 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 형식에 대해 정의된 사용자 지정 특성을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 특성을 찾을지 여부를 지정합니다.</param>
        <summary>이 형식에 대해 정의된 모든 사용자 지정 특성을 반환합니다.</summary>
        <returns>이 형식의 모든 사용자 지정 특성을 나타내는 개체 배열을 반환합니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 불완전한 형식에 대해 지원되지 않습니다. <see cref="M:System.Type.GetType" />을 사용하여 형식을 검색하고 반환된 <see cref="T:System.Type" />에 대해 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />를 호출합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">검색할 특성의 형식입니다. 이 형식에 할당할 수 있는 특성만 반환됩니다.</param>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 특성을 찾을지 여부를 지정합니다.</param>
        <summary>지정된 형식에 할당할 수 있는 현재 형식의 모든 사용자 지정 특성을 반환합니다.</summary>
        <returns>현재 형식에 정의된 사용자 지정 특성의 배열입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 불완전한 형식에 대해 지원되지 않습니다. <see cref="M:System.Type.GetType" />을 사용하여 형식을 검색하고 반환된 <see cref="T:System.Type" />에 대해 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />를 호출합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">형식은 기본 런타임 시스템에서 제공하는 형식이어야 합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeBuilder.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메서드를 호출하면 <see cref="T:System.NotSupportedException" />이 항상 throw됩니다.</summary>
        <returns>이 메서드는 지원되지 않습니다. 값이 반환되지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeBuilder.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">검색할 이벤트의 이름입니다.</param>
        <param name="bindingAttr">검색을 제한하는 <see cref="T:System.Reflection.BindingFlags" /> 값의 비트 조합입니다.</param>
        <summary>지정된 이름의 이벤트를 반환합니다.</summary>
        <returns>지정한 이름을 가진 이 형식이 선언하거나 상속한 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체이거나, 일치 항목이 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 형식이 정의하는 이벤트를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 형식에 의해 선언되거나 상속되는 public 이벤트를 반환합니다.</summary>
        <returns>이 형식에 의해 선언되거나 상속되는 public 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체의 배열을 반환합니다. public 이벤트가 없는 경우 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A> 또는 <xref:System.Reflection.Assembly.GetType%2A> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">검색을 제한하는 <see cref="T:System.Reflection.BindingFlags" /> 값의 비트 조합입니다.</param>
        <summary>이 형식으로 선언되는 public 이벤트 및 public이 아닌 이벤트를 반환합니다.</summary>
        <returns>이 형식에 의해 선언되거나 상속되는 이벤트 중 지정된 바인딩 플래그와 일치하는 이벤트를 나타내는 <see cref="T:System.Reflection.EventInfo" /> 개체의 배열을 반환합니다. 일치하는 이벤트가 없으면 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.Emit.TypeBuilder" />에 의해 정의된 필드를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 필드의 이름입니다.</param>
        <param name="bindingAttr">이는 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등에서처럼 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>지정된 이름에 지정된 필드를 반환합니다.</summary>
        <returns>public 또는 non-public 한정자와 지정된 이름을 사용하여 이 형식에 의해 선언되거나 상속된 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체를 반환합니다. 일치하는 항목이 없으면 <see langword="null" />이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member GetField : Type * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.Emit.TypeBuilder.GetField (type, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">해당 필드가 반환되는 생성된 제네릭 형식입니다.</param>
        <param name="field"><paramref name="type" /> 제네릭 형식 정의에 있는 필드로, 반환할 <paramref name="type" /> 필드를 지정합니다.</param>
        <summary>제네릭 형식 정의의 지정된 필드에 해당하는 생성된 특정 제네릭 형식의 필드를 반환합니다.</summary>
        <returns><paramref name="type" />의 제네릭 형식 정의에 속하는 필드를 지정하는 <paramref name="field" />에 해당하는 <paramref name="type" />의 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 메서드 제공 하는 방법이 <xref:System.Reflection.FieldInfo> 생성된 된 제네릭 형식 나타내는 해당 제네릭 형식 정의의 필드를 나타내는 개체를 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 예를 들어 있다고 가정를 <xref:System.Reflection.Emit.TypeBuilder> 형식을 나타내는 개체 `G<T>` C# 구문에서 (`G(Of T)` Visual basic에서는 `generic <T> ref class G` c + +에서) 및 <xref:System.Reflection.Emit.FieldBuilder> 필드를 나타내는 개체 `public T F` C# 구문에서 (`Public F As T`Visual basic에서는 `public: T F` c + +에서) 정의 되는 `G<T>`합니다. 가정 `G<T>` 형식 매개 변수를 사용 하 여 제네릭 메서드가 `U` 생성 된 형식의 인스턴스를 만드는 `G<U>` 필드를 호출 `F` 해당 인스턴스에서 합니다. 해야 함수 호출을 내보내려면를 <xref:System.Reflection.FieldInfo> 나타내는 개체입니다 `F` 생성 된 형식-즉, 이것이 형식의 `U` 형식 대신 `T`합니다. 이 작업을 수행 하려면 먼저 호출를 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드를 <xref:System.Reflection.Emit.TypeBuilder> 개체를 지정 하는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 나타내는 개체입니다 `U` 형식 인수로 합니다. 다음 호출을 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 의 반환 값을 사용 하 여 메서드를 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드 매개 변수로 `type` 및 <xref:System.Reflection.Emit.FieldBuilder> 나타내는 개체입니다 `F` 매개 변수로 `field`합니다. 반환 값은는 <xref:System.Reflection.FieldInfo> 함수 호출을 내보내는 데 필요한 개체입니다. 코드 예제에서는이 시나리오를 보여 줍니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 명명 된 형식 매개 변수가 있는 샘플 라는 제네릭 클래스에 대 한 소스 코드 포함 `T`합니다. 클래스 라는 필드가 `Field`, 형식 `T`, 및 라는 제네릭 메서드 `GM` 라는 고유한 형식 매개 변수를 사용 하 여 `U`합니다. 메서드 `GM` 의 인스턴스를 만듭니다 `Sample`, 고유한 형식 매개 변수를 대체 `U` 의 형식 매개 변수에 `Sample`, 해당 입력된 매개 변수를 가져와 `Field`합니다. 이 소스 코드 컴파일 되었지만 사용 되지 않습니다. 사용 하 여 볼 수 있습니다 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 클래스에 의해 생성 된 코드 비교 `Example`합니다.  
  
 클래스의 코드 `Example` 사용을 보여 줍니다는 <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 일반 코드를 생성 하는 방법입니다. `Main` 클래스의 메서드 `Example` 라는 클래스를 포함 하는 동적 어셈블리를 만듭니다 `Sample`를 사용 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 라는 형식 매개 변수를 추가 하 여 일반 확인 하는 방법 `T`합니다. 기본 생성자 및 필드가 `Field`, 형식 `T`, 클래스에 추가 됩니다 `Sample`합니다. 메서드 `GM` 에 추가 하 고 사용 하 여 제네릭 메서드로 설정 된 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 메서드. 형식 매개 변수에 `GM` 이름은 `U`합니다. 형식 매개 변수를 정의한 후 서명의 `GM` 를 사용 하 여 추가 되는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 메서드. 반환 형식이 없는 및 필요한 아니요 또는 사용자 지정 한정자를이 메서드의 모든 매개 변수가 `null` 제외한 `parameterTypes`; `parameterTypes` 메서드의 유일한 매개 변수의 형식을 설정 `U`, 메서드의 제네릭 형식 매개 변수입니다. 메서드의 본문 생성 된 형식의 인스턴스를 만듭니다 `Sample<U>` (`Sample(Of U)` Visual basic에서), 메서드의 매개 변수를 할당 `Field`, 다음 값을 인쇄 `Field`합니다. <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> 메서드는 만드는 데는 <xref:System.Reflection.FieldInfo> 생성 된 제네릭 형식의 필드를 나타내는 `Sample<U>` 에 <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> 및 <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> 지침입니다.  
  
 더미 형식을 정의 하는 진입점 메서드를 보유할 `Main`합니다. 본문에 `Main`, 정적 `GM` 생성된 된 제네릭 형식에 메서드가 호출 되 `Sample<int>` (`Sample(Of Integer)` Visual Basic의), 형식과 <xref:System.String> 대체 `U`합니다.  
  
 코드 예제를 실행 하는 경우 내보낸된 어셈블리 TypeBuilderGetFieldExample.exe로 저장 합니다. TypeBuilderGetFieldExample.exe를 실행할 수 있으며 사용할 수 있습니다는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 내보낸된 코드에 대 한 코드를 사용 하 여 비교할는 `Sample` 자체 코드 예제로 컴파일되는 클래스입니다.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="type" />이 제네릭 형식을 나타내지 않습니다.  
  
또는 
 <paramref name="type" />이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 형식이 아닌 경우  
  
또는 
<paramref name="field" />의 선언 형식이 제네릭 형식 정의가 아닙니다.  
  
또는 
<paramref name="field" />의 선언 형식이 <paramref name="type" />의 제네릭 형식 정의가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeBuilder.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">이것은 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등과 같은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>이 형식으로 선언되는 public 필드 및 public이 아닌 필드를 반환합니다.</summary>
        <returns>이 형식에 의해 선언되거나 상속되는 public 및 public이 아닌 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체 배열을 반환합니다. 필드가 없으면 지정된 대로 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> 메서드 반환 하지 않습니다 필드를 특정 순서로 같은 알파벳 또는 선언 순서입니다. 이 순서는 달라질 수 있으므로 코드 필드가 반환 되는 순서에 종속 되지 않아야 합니다.  
  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="typeBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>제네릭 형식 정의의 형식 매개 변수나 제네릭 형식의 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns><see cref="T:System.Type" /> 개체의 배열입니다. 배열의 요소는 제네릭 형식의 형식 인수 또는 제네릭 형식 정의의 형식 매개 변수를 나타냅니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 배열 요소의 제네릭 형식 정의 대 한 형식 매개 변수 목록에 나타나는 순서는입니다.  
  
 A <xref:System.Reflection.Emit.TypeBuilder> 경우 개체는 제네릭 형식 정의 나타내는지를 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 제네릭 형식 매개 변수를 지정 하는 데 사용 된 메서드. 이 메서드는 검색 된 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 제네릭 형식 매개 변수를 나타내는 개체입니다.  
  
 제네릭 형식 리플렉션 및 제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대 한 자세한 내용은 참조는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="typeBuilder.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="typeBuilder.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 형식을 가져올 수 없는 제네릭 형식 정의를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식을 가져올 수 있는 제네릭 형식 정의를 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 경우는 <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> 메서드를 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다는 <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> 속성에서 반환 `true`, <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> 현재 인스턴스를 반환 하는 속성입니다. <xref:System.Reflection.Emit.TypeBuilder> 는 제네릭 형식을 나타내며는 항상 제네릭 형식 정의입니다.  
  
 사용 하는 경우는 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 에서 제네릭 형식을 생성 하는 방법을 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식 정의 나타내는 개체를 사용 하 여는 <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> 생성 된 형식에 메서드를 다시 가져옵니다는 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식을 나타내는 개체 정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식은 제네릭이 아닙니다. 즉, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />이 <see langword="false" />를 반환합니다.</exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeBuilder.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">인터페이스의 이름입니다.</param>
        <param name="ignoreCase"><see langword="true" />이면 검색은 대/소문자를 구분합니다. <see langword="false" />이면 검색은 대/소문자를 구분하지 않습니다.</param>
        <summary>지정된 인터페이스 이름과 일치하는 정규화된 이름을 사용하여 이 클래스에 의해 (직접 또는 간접적으로) 구현된 인터페이스를 반환합니다.</summary>
        <returns>구현된 인터페이스를 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다. 이름이 일치하는 인터페이스를 찾을 수 없으면 null을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeBuilder.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">매핑을 검색해야 할 인터페이스의 <see cref="T:System.Type" />입니다.</param>
        <summary>요청된 인터페이스에 대한 인터페이스 매핑을 반환합니다.</summary>
        <returns>요청된 인터페이스 매핑을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeBuilder.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 형식과 기본 형식에 대해 구현된 모든 인터페이스의 배열을 반환합니다.</summary>
        <returns>구현된 인터페이스를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다. 정의된 것이 없으면 빈 배열이 반환됩니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">멤버의 이름입니다.</param>
        <param name="type">반환할 멤버의 형식입니다.</param>
        <param name="bindingAttr">이는 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등에서처럼 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>지정된 대로 이 형식에 의해 선언되거나 상속되는 public 및 public이 아닌 모든 메서드를 반환합니다.</summary>
        <returns><paramref name="nonPublic" />이 사용될 경우 이 형식에 대해 정의된 public 및 public이 아닌 멤버를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체의 배열을 반환하고, 사용되지 않을 경우 public 멤버만 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">이것은 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등과 같은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>이 형식에 의해 선언되거나 상속되는 public 및 public이 아닌 메서드의 멤버를 반환합니다.</summary>
        <returns>이 형식에 의해 선언되거나 상속되는 public 및 non-public 멤버를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체 배열을 반환합니다. 일치하는 멤버가 없으면 빈 배열이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GetMethod : Type * System.Reflection.MethodInfo -&gt; System.Reflection.MethodInfo" Usage="System.Reflection.Emit.TypeBuilder.GetMethod (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">해당 메서드가 반환되는 생성된 제네릭 형식입니다.</param>
        <param name="method"><paramref name="type" />의 제네릭 형식 정의에 있는 메서드로, 반환할 <paramref name="type" />의 메서드를 지정합니다.</param>
        <summary>제네릭 형식 정의의 지정된 메서드에 해당하는 생성된 특정 제네릭 형식의 메서드를 반환합니다.</summary>
        <returns><paramref name="type" />의 제네릭 형식 정의에 속하는 메서드를 지정하는 <paramref name="method" />에 해당하는 <paramref name="type" />의 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 메서드 제공 하는 방법이 <xref:System.Reflection.MethodInfo> 나타내는 해당 제네릭 형식 정의 생성 된 제네릭 형식의 메서드를 나타내는 개체를 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 예를 들어 있다고 가정를 <xref:System.Reflection.Emit.TypeBuilder> 형식을 나타내는 개체 `G<T>` C# 구문에서 (`G(Of T)` Visual basic에서는 `generic <T> ref class G` c + +에서) 및 <xref:System.Reflection.Emit.MethodBuilder> 메서드를 나타내는 개체 `T M()` C# 구문에서 (`Function M() As T`Visual basic에서는 `T M()` c + +에서) 정의 되는 `G<T>`합니다. 가정 `G<T>` 형식 매개 변수를 사용 하 여 제네릭 메서드가 `U` 는 생성 된 형식의 인스턴스를 만듭니다 `G<U>` 메서드를 호출 하 고 `M` 해당 인스턴스에서 합니다. 해야 함수 호출을 내보내려면를 <xref:System.Reflection.MethodInfo> 개체를 나타내는 `M` 생성 된 형식-즉, 형식을 반환 하 `U` 형식 대신 `T`합니다. 이 작업을 수행 하려면 먼저 호출를 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드를 <xref:System.Reflection.Emit.TypeBuilder> 개체를 지정 하는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 나타내는 개체입니다 `U` 형식 인수로 합니다. 다음 호출을 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 의 반환 값을 사용 하 여 메서드를 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드 매개 변수로 `type` 및 <xref:System.Reflection.Emit.MethodBuilder> 나타내는 개체입니다 `T M()` 매개 변수로 `method`합니다. 반환 값은는 <xref:System.Reflection.MethodInfo> 함수 호출을 내보내는 데 필요한 개체입니다. 코드 예제에는 다음과 유사 하 게 시나리오를 보여 줍니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 제네릭 클래스에 대 한 소스 코드를 포함 `Sample` 명명 된 형식 매개 변수가 있는 `T`합니다. 클래스 라는 필드가 `Field`, 형식 `T`, 및 라는 제네릭 메서드 `GM` 라는 고유한 형식 매개 변수를 사용 하 여 `U`합니다. 메서드 `GM` 의 인스턴스를 만듭니다 `Sample`, 고유한 형식 매개 변수를 대체 `U` 의 형식 매개 변수에 `Sample`, 해당 입력된 매개 변수를 가져와 `Field`합니다. 이 소스 코드 컴파일 되었지만 사용 되지 않습니다. 사용 하 여 볼 수 있습니다 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 클래스에 의해 생성 된 코드 비교 `Example`합니다.  
  
 클래스의 코드 `Example` 사용을 보여 줍니다는 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 일반 코드를 생성 하는 방법입니다. `Main` 클래스의 메서드 `Example` 라는 클래스를 포함 하는 동적 어셈블리를 만듭니다 `Sample` 사용 하는 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 메서드는 형식 매개 변수를 추가 하 여 제네릭를 `T`. 기본 생성자 및 필드가 `Field`, 형식 `T`, 클래스에 추가 됩니다 `Sample`합니다. 메서드 `GM` 에 추가 하 고 사용 하 여 제네릭 메서드로 설정 된 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> 메서드. 형식 매개 변수에 `GM` 이름은 `U`합니다. 형식 매개 변수를 정의한 후 서명의 `GM` 를 사용 하 여 추가 되는 <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> 메서드. 반환 형식이 없는 및 필요한 아니요 또는 사용자 지정 한정자를이 메서드의 모든 매개 변수가 `null` 제외한 `parameterTypes`; `parameterTypes` 메서드의 유일한 매개 변수의 형식을 설정 `U`, 메서드의 제네릭 형식 매개 변수입니다. 메서드의 본문 생성 된 형식의 인스턴스를 만듭니다 `Sample<U>` (`Sample(Of U)` Visual basic에서), 메서드의 매개 변수를 할당 `Field`, 다음 값을 인쇄 `Field`합니다. 더미 형식을 정의 하는 진입점 메서드를 보유할 `Main`합니다. 본문에 `Main`, 정적 `GM` 생성된 된 제네릭 형식에 메서드가 호출 되 `Sample<int>` (`Sample(Of Integer)` Visual Basic의), 형식과 <xref:System.String> 대체 `U`합니다. <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> 메서드는 만드는 데는 <xref:System.Reflection.MethodInfo> 는 정적 `GM` 생성 된 제네릭 형식의 메서드 `Sample<U>`, 및 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 메서드는 만드는 데 다음를 <xref:System.Reflection.MethodInfo> 메서드 호출에서 내보낼 수 있는 합니다.  
  
 코드 예제를 실행 하는 경우 내보낸된 어셈블리 TypeBuilderGetFieldExample.exe로 저장 합니다. TypeBuilderGetFieldExample.exe를 실행할 수 있으며 사용할 수 있습니다는 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) 내보낸된 코드에 대 한 코드를 사용 하 여 비교할는 `Sample` 자체 코드 예제로 컴파일되는 클래스입니다.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="method" />가 제네릭 메서드 정의가 아닌 제네릭 메서드입니다.  
  
또는 
 <paramref name="type" />이 제네릭 형식을 나타내지 않습니다.  
  
또는 
 <paramref name="type" />이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 형식이 아닌 경우  
  
또는 
<paramref name="method" />의 선언 형식이 제네릭 형식 정의가 아닙니다.  
  
또는 
<paramref name="method" />의 선언 형식이 <paramref name="type" />의 제네릭 형식 정의가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeBuilder.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">이는 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등에서처럼 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>지정된 대로 이 형식에 의해 선언되거나 상속되는 public 및 public이 아닌 모든 메서드를 반환합니다.</summary>
        <returns><paramref name="nonPublic" />이 사용될 경우 이 형식에 대해 정의된 public 및 public이 아닌 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체의 배열을 반환하고, 그렇지 않은 경우 public 메서드만 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeBuilder.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">가져올 중첩 형식의 이름이 포함된 <see cref="T:System.String" />입니다.</param>
        <param name="bindingAttr">검색 방법을 지정하는 하나 이상의 <see cref="T:System.Reflection.BindingFlags" />로 구성된 비트 마스크입니다.  
  
또는 
public 메서드에 대해 대소문자 구분 검색을 수행하는 경우 0입니다.</param>
        <summary>이 형식에 의해 선언되는 public 중첩 형식 및 public이 아닌 중첩 형식을 반환합니다.</summary>
        <returns>지정된 요구 사항과 일치하는 중첩 형식을 나타내는 <see cref="T:System.Type" /> 개체이며(있는 경우), 이러한 개체가 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 이 이와 같은 경우 전체, 예를 들어 `CreateType` 가이 형식에 호출 된 후 완료 되지 않은 중첩된 형식 되지만 `GetNestedTypes` 는 이러한 중첩된 형식을 반환 합니다 `CreateType` 호출한 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeBuilder.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">이는 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등에서처럼 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>이 형식에 의해 선언되거나 상속되는 public 및 public이 아닌 중첩된 형식을 반환합니다.</summary>
        <returns>지정된 바인딩 제약 조건과 일치하는 현재 <see cref="T:System.Type" /> 내에 중첩된 모든 형식을 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다.  
  
현재 <see cref="T:System.Type" /> 내에 중첩된 형식이 없거나 중첩된 형식 중 해당 바인딩 제약 조건과 일치하는 형식이 없을 경우 <see cref="T:System.Type" /> 형식의 빈 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 이 이와 같은 경우 전체, 예를 들어 `CreateType` 가이 형식에 호출 된 후 완료 되지 않은 중첩된 형식 되지만 `GetNestedTypes` 는 이러한 중첩된 형식을 반환 합니다 `CreateType` 호출한 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeBuilder.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">이 호출의 특성입니다. 이것은 <see langword="InvokeMethod" />, <see langword="NonPublic" /> 등과 같은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그여야 합니다.</param>
        <summary>지정된 대로 이 형식에 의해 선언되거나 상속되는 public 및 non-public 속성을 모두 반환합니다.</summary>
        <returns><paramref name="nonPublic" />이 사용될 경우 이 형식에 대해 정의된 public 및 non-public 속성을 나타내는 <see langword="PropertyInfo" /> 개체의 배열을 반환하고, 사용되지 않을 경우 public 속성만 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 불완전한 형식에 대해 구현되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeBuilder.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식의 GUID를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 형식의 GUID를 검색합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 불완전한 형식에 대해 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeBuilder.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeBuilder.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">호출할 멤버의 이름입니다. 이 항목은 생성자, 메서드, 속성 또는 필드일 수 있습니다. 적합한 호출 특성을 지정해야 합니다. 빈 문자열을 멤버의 이름으로 전달하여 클래스의 기본 멤버를 호출할 수 있습니다.</param>
        <param name="invokeAttr">호출 특성입니다. 이 항목은 <see langword="BindingFlags" />의 비트 플래그여야 합니다.</param>
        <param name="binder">리플렉션을 통해 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see langword="MemberInfo" /> 개체의 검색을 가능하게 하는 개체입니다. 바인더가 <see langword="null" />이면 기본 바인더가 사용됩니다. <see cref="T:System.Reflection.Binder" />을 참조하세요.</param>
        <param name="target">지정한 멤버를 호출할 개체입니다. 멤버가 정적이면 이 매개 변수가 무시됩니다.</param>
        <param name="args">인수 목록입니다. 이 항목은 호출해야 할 멤버의 매개 변수 개수, 순서 및 형식을 포함하는 개체 배열입니다. 매개 변수가 없으면 이 값이 null이어야 합니다.</param>
        <param name="modifiers">호출할 멤버의 인수와 연결된 특성을 나타내는 요소를 가진 <paramref name="args" />와 길이가 동일한 배열입니다. 메타데이터에 있는 매개 변수에 특성이 연결되어 있습니다. 이러한 항목은 다양한 상호 운용성 서비스에 사용됩니다. 자세한 내용은 메타데이터 사양을 참조하세요.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see langword="CultureInfo" />의 인스턴스입니다. 이 매개 변수가 null이면 현재 스레드에 대한 <see langword="CultureInfo" />가 사용됩니다. 예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 문자열을 배정도 값으로 변환하려면 이 매개 변수가 필요합니다.</param>
        <param name="namedParameters"><paramref name="namedParameters" /> 배열의 각 매개 변수는 <paramref name="args" /> 배열의 해당 요소에 있는 값을 가져옵니다. <paramref name="args" />의 길이가 <paramref name="namedParameters" />의 길이보다 크면 남은 인수 값이 순서대로 전달됩니다.</param>
        <summary>지정된 멤버를 호출합니다. 호출해야 할 메서드에 액세스할 수 있어야 하며 이 메서드가 지정된 바인더 및 호출 특성의 제약 조건 하에서 지정된 인수 목록과 가장 구체적으로 일치하는 항목을 제공해야 합니다.</summary>
        <returns>호출된 멤버의 반환 값을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 선언에서 매개 변수 수가 지정 된 인수 목록의 인수 수에 도달 하 고 각 인수의 형식을 매개 변수의 형식 바인더를 통해 변환할 수 있으면 메서드가 호출 됩니다.  
  
 바인더 모든 일치 하는 메서드를 찾을 수 있습니다. 요청 (BindingFlags.InvokeMethod, BindingFlags.GetProperties, 및 등) 바인딩 형식에 따라 이들이 메서드를 찾습니다. 메서드의 집합 이름, 인수 개수를 및 바인더에서 정의 된 검색 한정자 집합으로 필터링 됩니다. 메서드를 선택한 후 호출 됩니다. 이때에 내게 필요한 옵션 확인 됩니다. 검색은 메서드를 사용 하 여 연결 된 내게 필요한 옵션 특성에 따라 검색할 메서드의 집합을 제어할 수 있습니다. `IBinder.BindToMethod` 메서드는 호출할 메서드를 선택 하는 일을 담당 합니다. 기본 바인더를 가장 구체적으로 일치를 선택합니다.  
  
> [!NOTE]
>  완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다. 즉, 개인 생성자, 메서드, 필드 및 속성에 액세스할 수 있습니다 및 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 사용 하 여 호출 합니다.  
  
 이 메서드는 현재 지원되지 않습니다. 사용 하 여 형식을 검색할 수 있습니다 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 불완전한 형식에 대해 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeBuilder.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 개체에 지정된 형식을 할당할 수 있는지 여부를 결정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeBuilder.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">테스트할 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Reflection.TypeInfo" /> 개체를 이 개체에 할당할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <returns><paramref name="typeInfo" />를 이 개체에 할당할 수 있으면 <see langword="true" />이고, 할당할 수 없으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Type -&gt; bool" Usage="typeBuilder.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">테스트할 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Type" />을 이 개체에 할당할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns><paramref name="c" /> 매개 변수와 현재 형식이 동일한 형식을 나타내는 경우, 현재 형식이 <paramref name="c" />의 상속 계층 구조 안에 있는 경우, 또는 현재 형식이 <paramref name="c" />에서 지원하는 인터페이스인 경우 <see langword="true" />입니다. 이러한 조건 중 올바른 조건이 없거나 <paramref name="c" />가 <see langword="null" />이면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeBuilder.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeBuilder.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 개체가 생성된 제네릭 형식을 나타내는지를 지정하는 값을 가져옵니다.</summary>
        <value>이 개체가 생성된 제네릭 형식을 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberSignature Language="F#" Value="member this.IsCreated : unit -&gt; bool" Usage="typeBuilder.IsCreated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 동적 형식이 만들어졌는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드가 호출되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 후 합니다 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 메서드를 호출한 나타내는 형식이 <xref:System.Reflection.Emit.TypeBuilder> 개체가 완료 합니다. 멤버를 추가 하거나 형식의 기타 특성을 변경 하려면 다시 시도 하면 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">검색할 특성의 형식입니다. 이 형식에 할당할 수 있는 특성만 반환됩니다.</param>
        <param name="inherit">이 멤버의 상속 체인을 검색하여 특성을 찾을지 여부를 지정합니다.</param>
        <summary>사용자 지정 특성이 현재 형식에 적용되는지 여부를 결정합니다.</summary>
        <returns><paramref name="attributeType" />의 하나 이상의 인스턴스 또는 <paramref name="attributeType" />에서 파생된 특성이 이 형식에 정의되어 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 불완전 한 제네릭 형식 매개 변수에 대 한 지원 되지 않습니다. 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 메서드는 현재 불완전한 형식에 대해 지원되지 않습니다. <see cref="M:System.Type.GetType" />을 사용하여 형식을 검색하고 반환된 <see cref="T:System.Type" />에 대해 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />를 호출합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" />이 정의되어 있지 않습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 제네릭 형식 매개 변수인지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 개체가 제네릭 형식 매개 변수를 나타내면 <see langword="true" />이고, 나타내지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  제네릭 형식 매개 변수는 나타내는 코드를 내보낼 때는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 개체 보다는 <xref:System.Reflection.Emit.TypeBuilder> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 제네릭 형식인지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 개체가 나타내는 형식이 제네릭이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> 경우 개체는 제네릭 형식 정의 나타내는지를 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 제네릭 형식 매개 변수를 지정 하는 데 사용 된 메서드. 인스턴스는 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 클래스는 항상 제네릭 형식 정의입니다.  
  
 제네릭 형식 리플렉션 및 제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대 한 자세한 내용은 참조는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Reflection.Emit.TypeBuilder" />가 다른 제네릭 형식을 생성하는 데 사용될 수 있는 제네릭 형식 정의를 나타내는지를 가리키는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Reflection.Emit.TypeBuilder" /> 개체가 제네릭 형식 정의를 나타내면 <see langword="true" />이고, 나타내지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> 경우 개체는 제네릭 형식 정의 나타내는지를 <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> 제네릭 형식 매개 변수를 지정 하는 데 사용 된 메서드. 인스턴스는 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 클래스는 항상 제네릭 형식 정의입니다.  
  
 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식 정의 만드는 데 사용할 수 있지만 제네릭 형식 생성 되지 않았습니다. 생성된 된 제네릭 형식을 가져오려고 호출을 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드를를 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식 정의 나타내는입니다.  
  
 제네릭 형식 리플렉션 및 제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대 한 자세한 내용은 참조는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeBuilder.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeBuilder.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 보안에 중요한 형식이거나 보안 안전에 중요한 형식이어서 중요한 작업을 수행할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식이 보안에 중요한 형식이거나 보안 안전에 중요한 형식인 경우 <see langword="true" />이고 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)을 기준으로 형식의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전에 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 런타임은은 어셈블리에서 투명도 수준을 평가 시작 합니다. 예를 들어, 동적 어셈블리를 보안에 중요 한 형식에 대 한 주석 무시 됩니다 및 모든 형식은 보안에 중요 합니다.  
  
 기본적으로 동적 어셈블리를 내보내는 어셈블리의 투명도 상속 합니다. 사용 하 여이 기본값을 재정의할 수 있습니다 합니다 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, 또는 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> 메서드 오버 로드 하 고 보안 특성을 지정 합니다. 이 수행 하 여 보안 수준을 높일 수 없습니다. 즉, 투명 코드는 보안에 중요 하거나 보안 안전에 중요 한 코드를 생성할 수 없습니다. 동적 어셈블리를 만들 때나 어셈블리가 디스크에 저장 되었으며 다시 로드 될 때까지 내용이 적용 되지 않습니다는 특성을 지정 해야 합니다.  
  
> [!NOTE]
>  기본 상속 투명도 런타임의 평가로 제한 됩니다. 특성이 없는 동적 어셈블리에 적용 됩니다. 보안 특성을 추가 하려는 경우를 직접 적용 해야 합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 투명도 참조 하세요 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">현재 동적 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드를 호출하여 생성되지 않았습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">보안 투명 코드, 수준 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">보안 투명 코드, 수준 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 보안 안전에 중요한 형식인지 즉, 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 형식이 보안 안전에 중요한 형식인 경우 <see langword="true" />이고 보안에 중요한 형식이거나 투명 형식인 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)을 기준으로 형식의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전에 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 런타임은은 어셈블리에서 투명도 수준을 평가 시작 합니다. 예를 들어, 동적 어셈블리를 보안에 중요 한 형식에 대 한 주석 무시 됩니다 및 모든 형식은 보안에 중요 합니다.  
  
 기본적으로 동적 어셈블리를 내보내는 어셈블리의 투명도 상속 합니다. 사용 하 여이 기본값을 재정의할 수 있습니다 합니다 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, 또는 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> 메서드 오버 로드 하 고 보안 특성을 지정 합니다. 이 수행 하 여 보안 수준을 높일 수 없습니다. 즉, 투명 코드는 보안에 중요 하거나 보안 안전에 중요 한 코드를 생성할 수 없습니다. 동적 어셈블리를 만들 때나 어셈블리가 디스크에 저장 되었으며 다시 로드 될 때까지 내용이 적용 되지 않습니다는 특성을 지정 해야 합니다.  
  
> [!NOTE]
>  기본 상속 투명도 런타임의 평가로 제한 됩니다. 특성이 없는 동적 어셈블리에 적용 됩니다. 보안 특성을 추가 하려는 경우를 직접 적용 해야 합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 투명도 참조 하세요 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">현재 동적 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드를 호출하여 생성되지 않았습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">보안 투명 코드, 수준 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">보안 투명 코드, 수준 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 형식이 투명하여 중요한 작업을 수행할 수 없는지를 나타내는 값을 가져옵니다.</summary>
        <value>형식이 보안 투명인 경우 <see langword="true" />이고, 보안 투명이 아닌 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> 속성의 CLR (공용 언어 런타임)을 기준으로 형식의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전에 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용하는 것이 어셈블리 및 해당 형식의 보안 주석을 검사하고 현재 신뢰 수준을 확인한 다음 런타임 규칙을 복제하는 것보다 훨씬 더 간단합니다.  
  
 런타임은은 어셈블리에서 투명도 수준을 평가 시작 합니다. 예를 들어, 동적 어셈블리를 보안에 중요 한 형식에 대 한 주석 무시 됩니다 및 모든 형식은 보안에 중요 합니다.  
  
 기본적으로 동적 어셈블리를 내보내는 어셈블리의 투명도 상속 합니다. 사용 하 여이 기본값을 재정의할 수 있습니다 합니다 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, 또는 <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> 메서드 오버 로드 하 고 보안 특성을 지정 합니다. 이 수행 하 여 보안 수준을 높일 수 없습니다. 즉, 투명 코드는 보안에 중요 하거나 보안 안전에 중요 한 코드를 생성할 수 없습니다. 동적 어셈블리를 만들 때나 어셈블리가 디스크에 저장 되었으며 다시 로드 될 때까지 내용이 적용 되지 않습니다는 특성을 지정 해야 합니다.  
  
> [!NOTE]
>  기본 상속 투명도 런타임의 평가로 제한 됩니다. 특성이 없는 동적 어셈블리에 적용 됩니다. 보안 특성을 추가 하려는 경우를 직접 적용 해야 합니다.  
  
 리플렉션에 대 한 자세한 내용은 내보내기 및 투명도 참조 하세요 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">현재 동적 형식이 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 메서드를 호출하여 생성되지 않았습니다.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">리플렉션 내보내기의 보안 문제점</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">보안 투명 코드, 수준 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">보안 투명 코드, 수준 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsSubclassOf : Type -&gt; bool" Usage="typeBuilder.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">확인할 <see cref="T:System.Type" />입니다.</param>
        <summary>이 형식이 지정된 형식에서 파생되었는지 여부를 확인합니다.</summary>
        <returns>읽기 전용입니다. 이 형식이 <paramref name="c" /> 형식과 동일하거나 <paramref name="c" /> 형식의 하위 형식이면 <see langword="true" />를 반환하고, 동일하지 않거나 하위 형식이 아니면 <see langword="false" />를 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeBuilder.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 형식의 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : unit -&gt; Type" Usage="typeBuilder.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>하한이 0인 현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>해당 요소 형식이 하한이 0인 현재 형식인 1차원 배열 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> 메서드는 제네릭 형식을 비롯 한 모든 가능한 요소 형식 가진 배열 형식을 생성 하는 방법을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추상 형식 동적 모듈을 만듭니다 `Sample`, 및 라는 추상 메서드를 `TestMethod`입니다. `TestMethod` 사용을 `ref` 매개 변수 (`ByRef` Visual Basic의) 형식의 `Sample`, 입력에 대 한 포인터 `Sample`, 및 형식의 배열을 `Sample`합니다. 형식의 2 차원 배열을 반환 `Sample`합니다. 코드 예제에서는 사용 하 여 검사할 수 있도록 동적 모듈을 디스크에 저장 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)합니다.  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : int -&gt; Type" Usage="typeBuilder.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">배열의 차수입니다.</param>
        <summary>지정된 차수의 현재 형식 배열을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식의 1차원 배열을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> 메서드는 제네릭 형식을 비롯 한 모든 가능한 요소 형식 가진 배열 형식을 생성 하는 방법을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추상 형식 동적 모듈을 만듭니다 `Sample`, 및 라는 추상 메서드를 `TestMethod`입니다. `TestMethod` 사용을 `ref` 매개 변수 (`ByRef` Visual Basic의) 형식의 `Sample`, 입력에 대 한 포인터 `Sample`, 및 형식의 배열을 `Sample`합니다. 형식의 2 차원 배열을 반환 `Sample`합니다. 코드 예제에서는 사용 하 여 검사할 수 있도록 동적 모듈을 디스크에 저장 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)합니다.  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" />가 유효한 배열 차원이 아닙니다.</exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="override this.MakeByRefType : unit -&gt; Type" Usage="typeBuilder.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="ref" /> 매개 변수(Visual Basic의 경우 <see langword="ByRef" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns><see langword="ref" /> 매개 변수(Visual Basic의 경우 <see langword="ByRef" />) 매개 변수로 전달될 때 현재 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> 메서드를 생성 하는 방법을 제공 `ref` 형식 (`ByRef` Visual basic에서) 매개 변수를 나열 합니다.  
  
> [!NOTE]
>  하는 경우 Microsoft MSIL (intermediate language) 구문을 사용 하 여 현재 <xref:System.Reflection.Emit.TypeBuilder> 나타냅니다 `MyType`,이 메서드에서 반환 된 형식은 다음 `MyType&`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추상 형식 동적 모듈을 만듭니다 `Sample`, 및 라는 추상 메서드를 `TestMethod`입니다. `TestMethod` 사용을 `ref` 매개 변수 (`ByRef` Visual Basic의) 형식의 `Sample`, 입력에 대 한 포인터 `Sample`, 및 형식의 배열을 `Sample`합니다. 형식의 2 차원 배열을 반환 `Sample`합니다. 코드 예제에서는 사용 하 여 검사할 수 있도록 동적 모듈을 디스크에 저장 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)합니다.  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericType : Type[] -&gt; Type" Usage="typeBuilder.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">현재 제네릭 형식 정의의 형식 매개 변수로 대체할 형식 배열입니다.</param>
        <summary>형식 배열의 요소를 현재 제네릭 형식 정의의 형식 매개 변수로 대체하며 생성된 결과 형식을 반환합니다.</summary>
        <returns><see cref="T:System.Type" />의 요소를 현재 제네릭 형식의 형식 매개 변수로 대체하여 생성된 형식을 나타내는 <paramref name="typeArguments" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 내보낸된 코드에는 현재 제네릭 형식 정의에서 생성 되는 형식에 필요한 경우이 메서드를 사용 합니다. 호출할 필요는 없습니다 합니다 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 메서드를 호출 하기 전에 <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> 메서드를 <xref:System.Reflection.Emit.TypeBuilder> 제네릭 형식 정의 나타내는입니다. 하는 경우 현재 <xref:System.Reflection.Emit.TypeBuilder> 이 제네릭 형식 정의 나타내지 않는 <xref:System.InvalidOperationException> throw 됩니다.  
  
 내보낸된 코드에서 생성된 된 제네릭 형식에 대 한 자리 표시자로이 메서드 함수에서 반환 된 개체입니다. 파생 된 클래스의 인스턴스이고 <xref:System.Type> 기능이 제한 되어 있습니다. 특히 다음과 같습니다.  
  
-   이러한 생성 된 제네릭 형식에 대 한 메서드, 필드 및 생성자를 가져오려면 합니다 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, 및 <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> 메서드 오버 로드 합니다.  
  
-   생성된 된 동일한 형식을 나타내는 두 인스턴스가 동일한 것으로 비교 하지 않습니다. 예를 들어, 다음 코드에에서 `t1.Equals(t2)` 반환 `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 형식이 제네릭 형식의 정의를 나타내지 않습니다. 즉, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />이 <see langword="false" />를 반환합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" />가 <see langword="null" />인 경우  
  
또는 
<paramref name="typeArguments" />의 요소가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeArguments" />의 요소에 대한 <see cref="P:System.Type.Module" /> 속성이 <see langword="null" />입니다.  
  
또는 
<paramref name="typeArguments" />의 임의 요소 모듈의 <see cref="P:System.Reflection.Module.Assembly" /> 속성이 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="override this.MakePointerType : unit -&gt; Type" Usage="typeBuilder.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 형식에 대한 관리되지 않는 포인터의 형식을 나타내는 <see cref="T:System.Type" /> 개체를 반환합니다.</summary>
        <returns>현재 형식에 대한 관리되지 않는 포인터의 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> 메서드 매개 변수 목록에 대 한 포인터 형식을 생성 하는 방법을 제공 합니다.  
  
> [!NOTE]
>  하는 경우 Microsoft MSIL (intermediate language) 구문을 사용 하 여 현재 <xref:System.Reflection.Emit.TypeBuilder> 나타냅니다 `MyType`,이 메서드에서 반환 된 형식은 다음 `MyType*`합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 추상 형식 동적 모듈을 만듭니다 `Sample`, 및 라는 추상 메서드를 `TestMethod`입니다. `TestMethod` 사용을 `ref` 매개 변수 (`ByRef` Visual Basic의) 형식의 `Sample`, 입력에 대 한 포인터 `Sample`, 및 형식의 배열을 `Sample`합니다. 형식의 2 차원 배열을 반환 `Sample`합니다. 코드 예제에서는 사용 하 여 검사할 수 있도록 동적 모듈을 디스크에 저장 합니다 [Ildasm.exe (IL 디스어셈블러)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)합니다.  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식 정의를 포함하는 동적 모듈을 검색합니다.</summary>
        <value>읽기 전용입니다. 이 형식 정의를 포함하는 동적 모듈을 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식의 이름을 검색합니다.</summary>
        <value>읽기 전용입니다. 이 형식의 <see cref="T:System.String" /> 이름을 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see langword="TypeBuilder" />가 정의되어 있는 네임스페이스를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 <see langword="TypeBuilder" />가 정의되어 있는 네임스페이스를 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberSignature Language="F#" Value="member this.PackingSize : System.Reflection.Emit.PackingSize" Usage="System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식의 압축 크기를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 형식의 압축 크기를 검색합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식은 획득하는 데 사용한 형식을 반환합니다.</summary>
        <value>읽기 전용입니다. 이 형식은 획득하는 데 사용한 형식입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>사용자 지정 특성을 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="typeBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">사용자 지정 특성을 정의하는 도우미 클래스의 인스턴스입니다.</param>
        <summary>사용자 지정 특성 작성기를 사용하여 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="customBuilder" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="typeBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">사용자 지정 특성에 대한 생성자입니다.</param>
        <param name="binaryAttribute">특성을 나타내는 바이트 blob입니다.</param>
        <summary>지정된 사용자 지정 특성 blob을 사용하여 사용자 지정 특성을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서식을 지정 하는 방법에 대 한 자세한 내용은 `binaryAttribute`, 공용 언어 인프라 (CLI) 설명서에서 "II: 메타 데이터 정의 및 의미"를 참조 하세요. 이 설명서는 온라인으로 제공됩니다. MSDN의 [ECMA C# 및 공용 언어 인프라 표준](https://go.microsoft.com/fwlink/?LinkID=99212) 및 Ecma International 웹 사이트의 [표준 ECMA-335 - CLI(공용 언어 인프라)](https://go.microsoft.com/fwlink/?LinkID=65552)를 참조하세요.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]를이 멤버는 더 이상 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 플래그입니다. (참조 [리플렉션 내보내기의 보안 문제점](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) 이 기능을 사용하려면 애플리케이션이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" /> 또는 <paramref name="binaryAttribute" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.SetParent : Type -&gt; unit" Usage="typeBuilder.SetParent parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">새 기본 형식입니다.</param>
        <summary>현재 생성 중인 형식의 기본 형식을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `parent` 됩니다 `null`, <xref:System.Object> 기본 형식으로 사용 됩니다.  
  
 하는 경우.NET Framework 버전 1.0 및 1.1에서는 예외가 throw 되지 `parent` 은 인터페이스 형식, 하지만 <xref:System.TypeLoadException> 때 throw 되는 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 메서드가 호출 됩니다.  
  
 <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> 대부분의 잘못 된 부모 형식에 대 한 메서드를 확인 하지 않습니다. 예를 들어, 기본 생성자가 없는 현재 형식에 기본 생성자를 sealed 형식 거부 하지 않습니다 하 고 거부 하지는 않습니다 부모 형식을 거부 하지 않습니다는 <xref:System.Delegate> 형식입니다. 이러한 모든 경우에 예외를 throw 합니다 <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.  
  
또는 
 <paramref name="parent" /> <see langword="null" />이고, 현재 인스턴스가 특성에 <see cref="F:System.Reflection.TypeAttributes.Abstract" />가 포함되지 않은 인터페이스를 나타냅니다.  
  
또는 
현재 동적 형식에 대해 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 속성은 <see langword="true" />지만 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 속성은 <see langword="false" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parent" />가 인터페이스입니다. 이 예외 상태는 .NET Framework 버전 2.0에 새로 추가되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>형식의 전체 크기를 검색합니다.</summary>
        <value>읽기 전용입니다. 이 형식의 전체 크기를 검색 합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터를 받습니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="typeBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>네임스페이스를 제외한 형식의 이름을 반환합니다.</summary>
        <returns>읽기 전용입니다. 네임스페이스를 제외한 형식의 이름입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 모듈에서 지원되지 않습니다.</summary>
        <value>읽기 전용입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 형식을 검색 <xref:System.Type.GetType%2A?displayProperty=nameWithType> 또는 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> 검색된 형식에 리플렉션을 사용 하 고 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">동적 모듈에서 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeToken : System.Reflection.Emit.TypeToken" Usage="System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 형식의 형식 토큰을 반환합니다.</summary>
        <value>읽기 전용입니다. 이 형식의 <see langword="TypeToken" />을 반환합니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />을 사용하여 이전에 형식을 만들었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see langword="TypeBuilder" />에 대한 내부 시스템 형식을 반환합니다.</summary>
        <value>읽기 전용입니다. 내부 시스템 형식을 반환합니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">이 형식은 열거형이지만 기본 시스템 형식이 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="F#" Value="val mutable UnspecifiedTypeSize : int" Usage="System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>형식에 대한 총 크기가 지정되지 않았음을 나타냅니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>