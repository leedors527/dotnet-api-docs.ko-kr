<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="22d00f07f020bfde53c8853e9755c40a7d2411fe" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52592131" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>다시 사용 및 버전 지정이 가능한, 공용 언어 런타임 응용 프로그램의 자체 설명 빌딩 블록인 어셈블리를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Reflection.Assembly> 어셈블리, 어셈블리에 포함 된 형식을 검색 하 고 해당 형식의 인스턴스를 만들 수의 메타 데이터 및 구성 요소를 탐색 하려면 어셈블리를 로드 하는 클래스입니다.  
  
 배열을 가져오려면 <xref:System.Reflection.Assembly> 어셈블리를 현재 나타내는 로드 응용 프로그램 도메인 (예를 들어, 응용 프로그램의 기본 도메인 간단한 프로젝트를)를 사용 하 여 개체를 <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> 메서드.  
  
 어셈블리를 동적으로 로드 하는 <xref:System.Reflection.Assembly> 정적 메서드를 제공 하는 클래스 (`Shared` Visual Basic의 메서드). 어셈블리 로드 작업이 발생 하는 응용 프로그램 도메인에 로드 됩니다.  
  
-   어셈블리를 로드 하는 권장된 방법은 사용 하는 것은 <xref:System.AppDomain.Load%2A> 표시 이름을 사용 하 여 로드할 어셈블리를 식별 하는 메서드 (예를 들어, "System.Windows.Forms, 버전 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089 ="). 어셈블리에 대 한 검색에 설명 된 규칙을 따릅니다 [런타임 어셈블리를 찾는 방법](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)합니다.  
  
-   합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드를 사용 하면 실행 아니라 리플렉션을 위해 어셈블리를 로드 합니다. 예를 들어 32 비트 플랫폼에서 실행 되는 코드에서 64 비트 플랫폼을 대상으로 하는 어셈블리를 검사할 수 있습니다.  
  
-   합니다 <xref:System.Reflection.Assembly.LoadFile%2A> 고 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 어셈블리 경로로 식별 해야 하는 드문 시나리오에 대 한 제공 됩니다.  
  
 가져올는 <xref:System.Reflection.Assembly> 사용 하 여 현재 실행 중인 어셈블리에 대 한 개체는 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 메서드.  
  
 많은 멤버를 <xref:System.Reflection.Assembly> 클래스는 어셈블리에 대 한 정보를 제공 합니다. 예:  
  
-   합니다 <xref:System.Reflection.Assembly.GetName%2A> 메서드가 반환 되는 <xref:System.Reflection.AssemblyName> 어셈블리 표시 이름 부분에 대 한 액세스를 제공 하는 개체입니다.  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A> 메서드는 어셈블리에 적용할 특성을 나열 합니다.  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A> 메서드는 어셈블리 매니페스트가 있는 파일에 대 한 액세스를 제공 합니다.  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> 메서드 어셈블리 매니페스트에서 리소스의 이름을 제공 합니다.  
  
 <xref:System.Reflection.Assembly.GetTypes%2A> 메서드는 어셈블리의 모든 형식을 나열 합니다. <xref:System.Reflection.Assembly.GetExportedTypes%2A> 메서드 호출자가 어셈블리 외부에 표시 되는 형식을 나열 합니다. <xref:System.Reflection.Assembly.GetType%2A> 어셈블리에서 특정 형식을 검색할 메서드를 사용할 수 있습니다. <xref:System.Reflection.Assembly.CreateInstance%2A> 메서드를 사용 하 여 어셈블리에서 형식의 인스턴스를 만들고 검색할 수 있습니다.  
  
 어셈블리에 대 한 자세한 내용은 "응용 프로그램 도메인 및 어셈블리" 섹션을 참조 합니다 [응용 프로그램 도메인](~/docs/framework/app-domains/application-domains.md) 항목입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 현재 실행 중인 어셈블리를 가져올, 해당 어셈블리에 포함 된 형식의 인스턴스를 만들고, 런타임에 바인딩을 사용 하 여 형식의 메서드 중 하나를 호출 하는 방법을 보여 줍니다. 코드 예제에서는이 목적을 위해 라는 클래스를 정의 `Example`, 라는 메서드를 사용 하 여 `SampleMethod`입니다. 클래스의 생성자는 메서드의 반환 값을 계산 하는 데 사용 되는 정수를 허용 합니다.  
  
 코드 예제에서는 또한의 사용을 보여 줍니다 합니다 <xref:System.Reflection.Assembly.GetName%2A> 메서드는 <xref:System.Reflection.AssemblyName> 어셈블리의 전체 이름을 구문 분석 하는 데 사용할 수 있습니다. 이 예제에서는 어셈블리의 버전 번호를 표시 합니다 <xref:System.Reflection.Assembly.CodeBase%2A> 속성인 및 <xref:System.Reflection.Assembly.EntryPoint%2A> 속성.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">상속자에 대 한 완전 신뢰 합니다. 부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</permission>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">응용 프로그램 도메인</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스에서 생성 하는 동안이 생성자가 호출 <xref:System.Reflection.Assembly> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>예를 들어 <see cref="T:System.Reflection.AssemblyName" /> 개체에 원래 지정된 어셈블리 위치를 가져옵니다.</summary>
        <value>원래 지정된 어셈블리 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로드 된 매니페스트가 들어 있는 파일의 절대 경로 가져오려면는 <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> 속성 대신 합니다.  
  
 오버 로드를 사용 하 여 어셈블리를 바이트 배열로 로드 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 메서드를이 속성에는 로드 된 어셈블리의 위치가 아닌 메서드의 호출자의 위치를 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.Assembly.CodeBase%2A> 속성입니다.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리에서 형식을 찾은 다음 시스템 활성기를 사용하여 해당 형식의 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</param>
        <summary>대/소문자 구분 검색 기능을 사용하여 이 어셈블리에서 지정된 형식을 찾은 다음 시스템 활성기를 사용하여 해당 형식의 인스턴스를 만듭니다.</summary>
        <returns>
          <see langword="null" />을 찾을 수 있는 경우 기본 생성자로 만든 지정된 형식의 인스턴스이며, 그렇지 않은 경우는 <paramref name="typeName" />입니다. 형식은 문화권 또는 활성화 특성을 지정하지 않고 <see cref="T:System.Reflection.BindingFlags" />를 <see langword="Public" /> 또는 <see langword="Instance" />로 설정하여 기본 바인더를 사용하여 확인됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 런타임에서 찾을 수 없으면 `typeName` 에 <xref:System.Reflection.Assembly> 인스턴스를 반환 합니다 `null` 예외를 throw 하는 대신 합니다. 이 때문에 발생할 수 있습니다.  
  
-   형식의 정규화 된 이름을 지정 하지 않았습니다.  
  
-   정규화 된 형식 이름을 지정한 이지만 해당 사례 형식의 소문자가 일치 하지 않습니다 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 속성입니다. 대/소문자 구분 비교 `typeName` 형식의 전체 이름을 사용 하 여 호출 합니다 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 오버 로드 하 고 지정 `true` 에 대 한는 `ignoreCase` 인수.  
  
-   현재에서 형식이 없는 <xref:System.Reflection.Assembly> 인스턴스.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Person` 클래스 및 호출 된 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 메서드를 인스턴스화합니다.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</param>
        <param name="ignoreCase">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자 구분 검색 기능을 선택적으로 사용하여, 지정된 형식을 이 어셈블리에서 찾은 다음 시스템 활성기를 사용하여 해당 인스턴스를 만듭니다.</summary>
        <returns>
          <see langword="null" />을 찾을 수 있는 경우 기본 생성자로 만든 지정된 형식의 인스턴스이며, 그렇지 않은 경우는 <paramref name="typeName" />입니다. 형식은 문화권 또는 활성화 특성을 지정하지 않고 <see cref="T:System.Reflection.BindingFlags" />를 <see langword="Public" /> 또는 <see langword="Instance" />로 설정하여 기본 바인더를 사용하여 확인됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 런타임에서 찾을 수 없으면 `typeName` 에 <xref:System.Reflection.Assembly> 인스턴스를 반환 합니다 `null` 예외를 throw 하는 대신 합니다. 이 때문에 발생할 수 있습니다.  
  
-   형식의 정규화 된 이름을 지정 하지 않았습니다.  
  
-   현재에서 형식이 없는 <xref:System.Reflection.Assembly> 인스턴스.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Person` 클래스입니다. 그런 다음 호출 하는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 를 인스턴스화하기 위한 메서드를 하지만의 대/소문자를 `typeName` 인수 형식의 일치 하지 않는 <xref:System.Type.FullName%2A> 속성, 메서드는 반환 `null`. 이 예제에서는 동일한 문자열을 전달 하는 경우는 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 오버 로드 하 고 비교, 대/소문자 이어야 함을 지정 합니다 `Person` 클래스를 찾을 수 및 `Person` 이 개체가 인스턴스화.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">찾을 형식의 <see cref="P:System.Type.FullName" />입니다.</param>
        <param name="ignoreCase">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <param name="bindingAttr">검색 수행 방법에 영향을 주는 비트 마스크입니다. 이 값은 <see cref="T:System.Reflection.BindingFlags" />의 비트 플래그 조합입니다.</param>
        <param name="binder">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see langword="MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <paramref name="binder" />가 <see langword="null" />이면 기본 바인더가 사용됩니다.</param>
        <param name="args">생성자에 전달되는 인수를 포함하는 배열입니다. 이 인수 배열은 실행될 생성자의 매개 변수와 개수, 순서 및 형식이 일치해야 합니다. 기본 생성자를 사용하려면 <paramref name="args" />가 빈 배열이거나 <see langword="null" />이어야 합니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see langword="CultureInfo" />의 인스턴스입니다. 이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see langword="CultureInfo" />가 사용됩니다. 예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 <see langword="String" />을 <see langword="Double" /> 값으로 변환하기 위해 이 매개 변수가 필요합니다.</param>
        <param name="activationAttributes">활성화할 수 있는 하나 이상의 특성으로 이루어진 배열입니다. 일반적으로, 원격 개체를 활성화하는 데 필요한 URL을 지정하는 단일 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 개체가 포함된 배열입니다.  이 매개 변수는 클라이언트 활성 개체와 관련되어 있습니다. 클라이언트 활성화는 이전 버전과의 호환성을 위해 유지되지만 새로운 개발에는 권장되지 않는 레거시 기술입니다. 분산된 응용 프로그램은 Windows Communication Foundation을 사용해야 합니다.</param>
        <summary>대/소문자 구분 검색 기능을 선택적으로 사용하고 지정된 문화권, 인수, 바인딩 및 활성화 특성을 사용하여, 지정된 형식을 이 어셈블리에서 찾은 다음 시스템 활성기를 사용하여 해당 인스턴스를 만듭니다.</summary>
        <returns>지정된 형식의 인스턴스 또는 <see langword="null" />이 없으면 <paramref name="typeName" />입니다. 제공된 인수는 형식을 확인하고 인스턴스를 만드는 데 사용된 생성자를 바인딩하는 데 사용됩니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />이 빈 문자열("") 또는 null 문자로 시작하는 문자열입니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.MissingMethodException">일치하는 생성자를 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException">비어 있지 않은 활성화 특성 배열이 <see cref="T:System.MarshalByRefObject" />에서 상속되지 않는 형식에 전달됩니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="typeName" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="typeName" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">대리자의 인스턴스를 만듭니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">어셈블리의 표시 이름입니다.</param>
        <param name="typeName">형식의 전체 이름입니다.</param>
        <summary>어셈블리의 표시 이름에 의해 정규화된 형식의 이름을 만듭니다.</summary>
        <returns>어셈블리의 표시 이름으로 정규화된 이 형식의 전체 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 문자열의 형식은 다음과 같습니다.  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 참조 <xref:System.Reflection.AssemblyName> 형식의 어셈블리의 표시 이름에 대 한 합니다.  
  
 공용 언어 런타임의 버전의 변경 내용에 맞게, 직접 정규화 된 이름을 생성 하는 대신이 메서드를 사용 합니다.  정규화 된 어셈블리 이름에 대 한 자세한 내용은 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 사용자 지정 특성을 포함하는 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리의 사용자 지정 특성을 포함하는 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리에 정의된 형식의 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리에 정의된 형식의 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A> 속성은 비교할 합니다 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 메서드는 <xref:System.Reflection.Assembly.DefinedTypes%2A> 속성의 컬렉션을 반환 <xref:System.Reflection.TypeInfo> 개체 및 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 의 배열을 반환 합니다 <xref:System.Type> 개체.  
  
 반환된 된 배열에는 중첩된 형식이 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 진입점을 가져옵니다.</summary>
        <value>이 어셈블리의 진입점을 나타내는 개체입니다. 예를 들어 어셈블리가 DLL이어서 진입점을 찾을 수 없는 경우에는 <see langword="null" />이 반환됩니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">이 인스턴스와 비교할 개체입니다.</param>
        <summary>이 어셈블리와 지정된 개체가 서로 같은지 확인합니다.</summary>
        <returns>
          <see langword="true" />가 이 인스턴스와 같으면 <paramref name="o" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A> 메서드를 확인 하려면 참조 같음 테스트를 수행 하는지 여부를 현재 인스턴스 및 `o` 같은지 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>코드베이스를 나타내는 URI를 가져옵니다(이스케이프 문자 포함).</summary>
        <value>이스케이프 문자를 포함하는 URI입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 증명을 가져옵니다.</summary>
        <value>이 어셈블리에 대한 증명 정보입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 증명 정보는 코드에 부여할 수 있는 권한 같이 보안 정책을 결정하기 위해 입력하는 정보 집합입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식의 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식의 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리의 표시 이름을 가져옵니다.</summary>
        <value>어셈블리의 표시 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 <xref:System.Reflection.AssemblyName> 형식의 어셈블리의 표시 이름에 대 한 합니다.  
  
> [!NOTE]
>  표시 이름을 구문 분석 하려면 사용자 고유의 코드를 작성 하는 것은 좋지 않습니다. 대신, 표시 이름을 전달 합니다 <xref:System.Reflection.AssemblyName.%23ctor%2A> 생성자를 구문 분석 하 고 새의 적절 한 필드를 채웁니다 <xref:System.Reflection.AssemblyName>합니다.  
  
 .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 그러나 반환 하는 문자열에서 제외 됩니다는 <xref:System.Reflection.Assembly.FullName%2A> 호환성을 위해 속성입니다. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 현재 실행 중인 어셈블리의 표시 이름 및 포함 된 어셈블리의 표시 이름을 검색 합니다 <xref:System.Int32> 형식 (`int` C#에서 `Integer` Visual basic에서).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">정규화된 형식 이름 지정</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">어셈블리에서 반환될 형식을 나타내는 개체입니다.</param>
        <summary>지정된 형식이 정의되어 있는 현재 로드된 어셈블리를 가져옵니다.</summary>
        <returns>지정된 형식이 정의되어 있는 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 호출의 값을 검색 하는 것은 <xref:System.Type.Assembly?displayProperty=nameWithType> 속성입니다. 그러나는 <xref:System.Type.Assembly?displayProperty=nameWithType> 속성에는 일반적으로 뛰어난 성능을 제공 합니다.  
  
 이 메서드를 호출 하려면 있어야를 <xref:System.Type> 개체 클래스 정의 되어 있는 어셈블리가 이미 로드 되어 있어야 함을 의미 합니다.  
  
   
  
## Examples  
 다음 예제에서는 포함 된 어셈블리를 검색 합니다 <xref:System.Int32> 형식과 해당 이름 및 파일 위치를 표시 합니다.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 실행 중인 메서드를 호출한 메서드의 <see cref="T:System.Reflection.Assembly" />를 반환합니다.</summary>
        <returns>현재 실행 중인 메서드를 호출하는 메서드의 <see langword="Assembly" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하는 메서드를 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 메서드는 시간 (JIT) 컴파일러에 의해 확장 된 인라인 또는 해당 호출자에 게 확장 된 인라인 인 경우 어셈블리는 반환한 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 예기치 않게 다를 수 있습니다. 예를 들어 다음 메서드 및 어셈블리를 고려 합니다.  
  
-   메서드 `M1` 어셈블리에서 `A1` 호출 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>합니다.  
  
-   메서드 `M2` 어셈블리에서 `A2` 호출 `M1`합니다.  
  
-   메서드 `M3` 어셈블리에서 `A3` 호출 `M2`합니다.  
  
 때 `M1` 인라인 화 되지 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A2`합니다. 때 `M1` 인라인 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A3`합니다. 마찬가지로, `M2` 인라인 화 되지 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A2`합니다. 때 `M2` 인라인 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 반환 `A3`합니다.  
  
 이 효과도 발생 하면 `M1` 마무리 호출에서 실행 되 `M2`, 때나 `M2` 마무리 호출에서 실행 되 `M3`합니다. JIT 컴파일러를 방지할 수 있습니다 인라인 호출 하는 메서드 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>를 적용 하 여는 <xref:System.Runtime.CompilerServices.MethodImplAttribute> 특성과 <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> 플래그를 이지만 마무리 호출을 방지 하는 것에 대 한 유사한 메커니즘이 없습니다.  
  
   
  
## Examples  
 다음 예에서는 현재 메서드의 호출 어셈블리를 가져옵니다.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리에 대한 사용자 지정 특성을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">이 인수는 <see cref="T:System.Reflection.Assembly" /> 형식의 개체에 대해 무시됩니다.</param>
        <summary>이 어셈블리에 대한 사용자 지정 특성을 모두 가져옵니다.</summary>
        <returns>이 어셈블리에 대한 사용자 지정 특성이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 해당 구현 <xref:System.Reflection.ICustomAttributeProvider> 인터페이스 메서드. 따라서는 `inherit` 무시 하는 경우에 매개 변수를 지정 해야 합니다.  
  
 의사 (pseudo) 특성을 특성이 있는 경우 설정 해야 하는 핵심적인 메타 데이터의 비트를 나타냅니다. 형식에 대 한 메타 데이터를 확장 하 고 유형과 함께 저장 되는 사용자 지정 특성을 달리 의사 (pseudo) 특성을 형식에 대 한 메타 데이터를 수정 하 고 삭제 됩니다. 결과 비트 중 일부 기존 리플렉션 Api를 사용 하 여 액세스할 수 없습니다.  
  
 다음 표에서 다양 한 의사 (pseudo) 특성 및 리플렉션을 사용할 수 있는 비트에 대 한 접근자입니다.  
  
|의사 (pseudo) 특성|메타 데이터 비트|리플렉션 접근자|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 이름|일반 메서드/전역 메서드 특성에 대 한 PInvokeMap에 없는 접근자입니다.<br /><br /> DLL 이름에 대 한 접근자가 없습니다.|  
|GuidAttribute|실제 사용자 지정 특성으로 저장 합니다.|실제 사용자 지정 특성으로 액세스 합니다.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|다양 한 비트입니다.|접근자가 없습니다.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 클래스 압축 합니다.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 접근자가 없습니다.|  
|FieldOffsetAttribute|필드 오프셋입니다.|접근자가 없습니다.|  
|AssemblyLoadAttribute|CorAssemblyFlags|접근자 또는 열거자 없습니다.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">사용자 지정 특성이 반환될 형식입니다.</param>
        <param name="inherit">이 인수는 <see cref="T:System.Reflection.Assembly" /> 형식의 개체에 대해 무시됩니다.</param>
        <summary>형식에 의해 지정된 대로, 이 어셈블리에 대한 사용자 지정 특성을 가져옵니다.</summary>
        <returns>
          <paramref name="attributeType" />에 의해 지정된 대로 이 어셈블리에 대한 사용자 지정 특성이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 해당 구현 <xref:System.Reflection.ICustomAttributeProvider> 인터페이스 메서드. 따라서는 `inherit` 무시 하는 경우에 매개 변수를 지정 해야 합니다.  
  
 의사 (pseudo) 특성을 특성이 있는 경우 설정 해야 하는 핵심적인 메타 데이터의 비트를 나타냅니다. 형식에 대 한 메타 데이터를 확장 하 고 유형과 함께 저장 되는 사용자 지정 특성을 달리 의사 (pseudo) 특성을 형식에 대 한 메타 데이터를 수정 하 고 삭제 됩니다. 결과 비트 중 일부 기존 리플렉션 Api를 사용 하 여 액세스할 수 없습니다.  
  
 다음 표에서 다양 한 의사 (pseudo) 특성 및 리플렉션을 사용할 수 있는 비트에 대 한 접근자입니다.  
  
|의사 (pseudo) 특성|메타 데이터 비트|리플렉션 접근자|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 이름|일반 메서드/전역 메서드 특성에 대 한 PInvokeMap에 없는 접근자입니다.<br /><br /> DLL 이름에 대 한 접근자가 없습니다.|  
|GuidAttribute|실제 사용자 지정 특성으로 저장 합니다.|실제 사용자 지정 특성으로 액세스 합니다.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|다양 한 비트입니다.|접근자가 없습니다.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 클래스 압축 합니다.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 접근자가 없습니다.|  
|FieldOffsetAttribute|필드 오프셋입니다.|접근자가 없습니다.|  
|AssemblyLoadAttribute|CorAssemblyFlags|접근자 또는 열거자 없습니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />이 런타임 형식이 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> 개체로 표현되는, 현재 <see cref="T:System.Reflection.CustomAttributeData" />에 적용된 특성 관련 정보를 반환합니다.</summary>
        <returns>현재 어셈블리에 적용된 특성에 대한 데이터를 나타내는 <see cref="T:System.Reflection.CustomAttributeData" /> 개체의 제네릭 목록입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리플렉션 전용 컨텍스트에 리플렉션 전용 컨텍스트에 로드 되는 코드에서 직접 사용자 지정 특성이 정의 되어 있는 경우 코드의 사용자 지정 특성을 검사할이 메서드를 사용 합니다. 와 같은 메서드 <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> 고 <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> 특성의 인스턴스를 만들기 때문에 이러한 경우에 사용할 수 없습니다. 리플렉션 전용 컨텍스트에서 코드를 실행할 수 없습니다. 자세한 내용 및 예를 들어 코드를 실행 하는 것에 대 한 참조를 <xref:System.Reflection.CustomAttributeData> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 응용 프로그램 도메인에 있는 프로세스 실행 파일을 가져옵니다. 이 실행 파일은 다른 응용 프로그램 도메인에서 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />에 의해 실행된 첫 번째 실행 파일입니다.</summary>
        <returns>어셈블리는 기본 응용 프로그램 도메인에 있는 프로세스 실행 파일이거나 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />에 의해 실행된 첫 번째 실행 파일입니다. 비관리 코드에서 호출한 경우에는 <see langword="null" />이 반환될 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 메서드를 반환할 수 있습니다 `null` 경우 관리 되는 어셈블리를 관리 되지 않는 응용 프로그램에서 로드 되었습니다. 예를 들어 관리 되지 않는 응용 프로그램 C#에 대 한 호출에서 작성 한 COM 구성 요소의 인스턴스를 만듭니다는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 관리 되는 어셈블리 보다는 비관리 코드 진입점 프로세스에 있어서 메서드는 C# 구성 요소에서 null을 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 실행 중인 코드가 포함된 어셈블리를 가져옵니다.</summary>
        <returns>현재 실행 중인 코드가 포함된 어셈블리를 가져옵니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 성능상의 이유로 알 수 없는 디자인 타임에 어셈블리는 현재 실행 중인 경우에이 메서드를 호출 해야 합니다. 검색 하는 권장된 방법은 <xref:System.Reflection.Assembly> 현재 어셈블리를 나타내는 개체를 사용 하는 것은 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 다음 예제와 같이 어셈블리에서 형식의 속성을 찾을.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 현재 실행 중인 코드를 호출한 메서드를 포함 하는 어셈블리를 가져오려면 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 현재 실행 중인 어셈블리를 가져올 속성 형식을 기반으로 해당 어셈블리에 포함 합니다. 또한 호출을 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 표시를 반환 하는 방법은 <xref:System.Reflection.Assembly> 동일한 어셈블리를 나타내는 개체입니다.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 정의된 형식 중 어셈블리 외부에서 볼 수 있는 public 형식을 가져옵니다.</summary>
        <returns>이 어셈블리에 정의되어 있고 어셈블리 외부에서 볼 수 있는 형식을 나타내는 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Public 형식 및 다른 공용 형식에 중첩 된 public 형식의 하는 어셈블리 외부에 표시 형식 뿐입니다.  
  
   
  
## Examples  
 다양 한 액세스 수준 및 호출을 사용 하 여 클래스 수를 정의 하는 다음 코드 샘플 <xref:System.Reflection.Assembly.GetExportedTypes%2A> 어셈블리 외부에서 표시 되는 것을 표시 합니다.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">어셈블리가 동적 어셈블리입니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">종속 어셈블리를 로드할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">지정된 파일의 이름입니다. 파일 경로는 포함하지 않습니다.</param>
        <summary>이 어셈블리의 매니페스트 파일 테이블에서 지정된 파일에 대한 <see cref="T:System.IO.FileStream" />을 가져옵니다.</summary>
        <returns>파일이 없는 경우 지정된 파일 또는 <see langword="null" />을 포함하는 스트림입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 및 개인 리소스 파일을 모두에서 작동합니다.  
  
 `name` 파일 경로가 포함 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로 지정 된 파일을 읽는 데 필요한 권한입니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> 및 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리 매니페스트의 파일 테이블에 있는 파일을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>어셈블리 매니페스트의 파일 테이블에 있는 파일을 가져옵니다.</summary>
        <returns>파일을 포함하는 스트림의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.  
  
 이 오버 로드는 호출에 해당 하는 <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> 오버 로드 하 고 지정 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">파일이 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>리소스 모듈의 포함 여부를 지정하여 어셈블리 매니페스트의 파일 테이블에서 파일을 가져옵니다.</summary>
        <returns>파일을 포함하는 스트림의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">파일이 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리의 일부인 로드된 모듈을 모두 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리의 일부인 로드된 모듈을 모두 가져옵니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>이 어셈블리의 일부인 로드된 모듈을 모두 가져오며 리소스 모듈의 포함 여부를 지정합니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">리소스의 이름(대/소문자 구분)입니다.</param>
        <summary>지정된 리소스가 지속되는 방법에 대한 정보를 반환합니다.</summary>
        <returns>리소스의 토폴로지에 대한 정보로 채워진 개체이거나, 리소스를 찾을 수 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 있는 모든 리소스의 이름을 반환합니다.</summary>
        <returns>모든 리소스의 이름이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음과 같이이 메서드에서 반환 된 배열의 각 리소스 이름을 사용할 수 있습니다.  
  
-   리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> 메서드는 리소스에 대 한 추가 정보를 가져옵니다.  
  
-   .Resources 파일 확장명을 제거 하 고 전달할 수 이름을 이진.resources 파일을 식별 하는 경우는 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> 리소스 관리자를 인스턴스화하는 생성자입니다.  
  
-   리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 검색 하는 메서드를 <xref:System.IO.Stream> 개체를 전달할 수 있습니다는 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 생성자입니다.  
  
-   리소스 이름을 전달할 수 있습니다는 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 검색 하는 메서드를 <xref:System.IO.Stream> 개체를 전달할 수 있습니다는 <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 생성자입니다.  
  
 리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">요청된 매니페스트 리소스의 이름(대/소문자 구분)입니다.</param>
        <summary>지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</summary>
        <returns>매니페스트 리소스이거나 컴파일하는 동안 리소스가 지정되지 않은 경우 또는 호출자가 리소스를 볼 수 없는 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 매니페스트 리소스는 컴파일 타임에 어셈블리에 포함 된 리소스 (예: 이미지 파일). 매니페스트 리소스에 대 한 자세한 내용은 참조 하세요. [Microsoft.NET Framework 리소스의 기본](https://go.microsoft.com/fwlink/?LinkId=204554) MSDN 라이브러리에서.  
  
 리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
> [!NOTE]
>  이 메서드는 반환 `null` 다른 어셈블리의 전용 리소스에 액세스 하 고 호출자에 게 없는 경우 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.  
  
 어셈블리 매니페스트 리소스 파일을 나열 하는 경우 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 반환을 <xref:System.IO.Stream> 시 디스크에 리소스 파일을 찾을 수 없는 경우에 개체입니다. 리소스 파일을 찾을 수 없습니다를 전달 하는 경우 결과 <xref:System.IO.Stream> 개체를 <xref:System.Resources.ResourceReader> 생성자에 의해는 <xref:System.ArgumentException>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
        <exception cref="T:System.NotImplementedException">리소스 길이는 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">어셈블리 매니페스트</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">해당 네임스페이스가 매니페스트 리소스 이름의 범위를 지정하는 데 사용된 형식입니다.</param>
        <param name="name">요청된 매니페스트 리소스의 이름(대/소문자 구분)입니다.</param>
        <summary>지정된 형식의 네임스페이스에 의해 범위가 지정된 매니페스트 리소스를 이 어셈블리에서 로드합니다.</summary>
        <returns>매니페스트 리소스이거나 컴파일하는 동안 리소스가 지정되지 않은 경우 또는 호출자가 리소스를 볼 수 없는 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어의 전체 이름을 지정 하는 경우 `type` "MyNameSpace.MyClasses"은 및 `name` "MyNameSpace.Net" 라는 리소스 검색을 오버 로드는 "Net",이 메서드는 합니다.  
  
 매니페스트 리소스는 컴파일 타임에 어셈블리에 포함 된 리소스 (예: 이미지 파일). 매니페스트 리소스에 대 한 자세한 내용은 참조 하세요. [Microsoft.NET Framework 리소스의 기본](https://go.microsoft.com/fwlink/?LinkId=204554) MSDN 라이브러리에서.  
  
 리소스 정보 리소스 호출자에 게 표시 되는지 또는 호출자에 게 하는 경우에 반환 됩니다 <xref:System.Security.Permissions.ReflectionPermission>합니다.  
  
> [!NOTE]
>  이 메서드는 반환 `null` 다른 어셈블리의 전용 리소스에 액세스 하 고 호출자에 게 없는 경우 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 플래그입니다.  
  
 어셈블리 매니페스트 리소스 파일을 나열 하는 경우 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 반환을 <xref:System.IO.Stream> 시 디스크에 리소스 파일을 찾을 수 없는 경우에 개체입니다. 리소스 파일을 찾을 수 없습니다를 전달 하는 경우 결과 <xref:System.IO.Stream> 개체를 <xref:System.Resources.ResourceReader> 생성자에 의해는 <xref:System.ArgumentException>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
        <exception cref="T:System.NotImplementedException">리소스 길이는 <see cref="F:System.Int64.MaxValue" />보다 큽니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">어셈블리 매니페스트</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">요청되는 모듈의 이름입니다.</param>
        <summary>이 어셈블리에 있는 지정된 모듈을 가져옵니다.</summary>
        <returns>요청되는 모듈 또는 모듈이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파일 이름에서 작동합니다.  
  
 클래스는 `Reflection.Emit` 네임 스페이스는 동적 모듈에 대 한 범위 이름을 내보냅니다. 범위 이름으로 확인할 수 있습니다는 <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> 속성입니다. 전달 하려는 모듈의 종류 `Assembly.GetModule`합니다. 예를 들어, 어셈블리 매니페스트가 포함 된 모듈을 사용 하도록 하려는 경우 모듈의 범위 이름을 전달 `GetModule`합니다. 그렇지 않은 경우 모듈의 파일 이름을 전달 합니다. 어셈블리 중 하나에 의해 로드 된 `Load` 메서드는 byte 매개 변수는 모듈 하나만 있고 매니페스트 모듈입니다. 항상 범위 이름을 사용 하 여 이러한 모듈을 검색 합니다.  
  
 형식을 사용 하 여 특정 모듈에서 검색할 수 있습니다 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>합니다. 호출 `Module.GetType` 모듈 매니페스트를 포함 하는 시작 하지 않습니다 전체 어셈블리를 검색 합니다. 에서는 이기는 모듈에 관계 없이 어셈블리에서 형식을 검색 하려면 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />을 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />는 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리의 일부인 모듈을 모두 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리의 일부인 모듈을 모두 가져옵니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.  
  
> [!NOTE]
>  파일 이름 확장명을 사용 하 여 모듈을 내보내야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 반환 되는 어셈블리 매니페스트가 포함 된 배열에서 모듈의 이름을 표시 합니다.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">로드할 모듈은 파일 이름 확장명을 지정하지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">리소스 모듈을 포함하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>이 어셈블리의 일부인 모듈을 모두 가져오며 리소스 모듈의 포함 여부를 지정합니다.</summary>
        <returns>모듈의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공용 및 개인 리소스 파일에서 작동합니다.  
  
> [!NOTE]
>  파일 이름 확장명을 사용 하 여 모듈을 내보내야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져옵니다.</summary>
        <returns>이 어셈블리에 대해 완전히 구문 분석된 표시 이름을 포함하는 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">어셈블리의 경로에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">어셈블리를 섀도 복사한 후 <see langword="true" />를 어셈블리 위치로 설정하려면 <see cref="P:System.Reflection.Assembly.CodeBase" />이고, <see langword="false" />를 원래 위치로 설정하려면 <see cref="P:System.Reflection.Assembly.CodeBase" />입니다.</param>
        <summary>이 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" />을 가져오며 <paramref name="copiedName" />에 의해 지정된 대로 코드베이스를 설정합니다.</summary>
        <returns>이 어셈블리에 대해 완전히 구문 분석된 표시 이름을 포함하는 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">어셈블리의 경로에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">serialization 정보로 채울 개체입니다.</param>
        <param name="context">serialization의 대상 컨텍스트입니다.</param>
        <summary>이 어셈블리를 다시 인스턴스화하는 데 필요한 데이터가 모두 포함된 serialization 정보를 가져옵니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리가 참조하는 모든 어셈블리에 대한 <see cref="T:System.Reflection.AssemblyName" /> 개체를 가져옵니다.</summary>
        <returns>이 어셈블리가 참조하는 모든 어셈블리의 완전 구문 분석된 표시 이름이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  부터 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 의 속성을 <xref:System.Reflection.AssemblyName> 이 메서드에 의해 반환 되는 개체는 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> 참조 된 어셈블리에 대 한 해시 알고리즘이 없는 경우 또는 참조 된 어셈블리의 해시 알고리즘이 아닌 경우 로 식별 되는 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> 열거형입니다. 이전 버전의.NET Framework에는 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 반환 되는 속성 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> 이런에서 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 된 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> 메서드. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Reflection.Assembly> 클래스입니다.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>위성 어셈블리를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">지정된 문화권입니다.</param>
        <summary>지정된 문화권에 대한 위성 어셈블리를 가져옵니다.</summary>
        <returns>지정된 위성 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위성 어셈블리에 지역화할 수 없는 실행 코드와 기본 또는 중립 문화권으로 사용 되는 단일 문화권에 대 한 리소스를 포함 하는 기본 응용 프로그램 어셈블리와 구별 하 여 지역화 된 리소스를 포함 합니다.  
  
 현재 어셈블리 버전을 사용 하려면이 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">파일 이름이 일치하는 위성 어셈블리가 있지만 <see langword="CultureInfo" />가 지정된 어셈블리와 일치하지 않습니다.</exception>
        <exception cref="T:System.BadImageFormatException">위성 어셈블리가 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">지정된 문화권입니다.</param>
        <param name="version">위성 어셈블리의 버전입니다.</param>
        <summary>지정된 문화권에 대한 지정된 버전의 위성 어셈블리를 가져옵니다.</summary>
        <returns>지정된 위성 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위성 어셈블리에 지역화할 수 없는 실행 코드와 기본 또는 중립 문화권으로 사용 되는 단일 문화권에 대 한 리소스를 포함 하는 기본 응용 프로그램 어셈블리와 구별 하 여 지역화 된 리소스를 포함 합니다.  
  
 호출 된 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> 오버 로드를 현재 어셈블리 버전을 사용 합니다.  
  
 하는 경우 `version` 는 `null`, 리소스와 주 어셈블리가 서명 된 경우 현재 어셈블리 버전이 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileLoadException">파일 이름이 일치하는 위성 어셈블리가 있지만 <see langword="CultureInfo" /> 또는 버전이 지정된 어셈블리와 일치하지 않습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">위성 어셈블리가 유효한 어셈블리가 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 형식을 나타내는 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">형식의 전체 이름입니다.</param>
        <summary>어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
        <returns>지정된 클래스를 나타내는 개체이며 클래스가 없는 경우 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 어셈블리 인스턴스에서 검색합니다. `name` 어셈블리를 제외한 네임 스페이스 매개 변수를 포함 합니다. 다른 어셈블리의 형식 검색 하려면 사용 된 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 선택적으로 포함할 수 있습니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리로 전달 되었습니다, 하는 경우 여전히이 메서드에서 반환 됩니다. 형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 추상 `MeansOfTransportation` 클래스는 `Transportation` 네임 스페이스입니다. 호출를 <xref:System.Reflection.Assembly.GetType%28System.String%29> 검색 하는 방법 해당 <xref:System.Type> 개체를 호출 합니다 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> 배열을 가져올 메서드를 <xref:System.Reflection.PropertyInfo> 속성을 추상화 하는 형식에서 정보를 표시 한 다음 형식의 속성을 나타내는 개체입니다. 에 대 한 호출을 <xref:System.Reflection.Assembly.GetType%28System.String%29> 메서드 형식의 정규화 된 이름 (즉, 해당 네임 스페이스의 형식 이름과 함께)를 사용 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 잘못되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>
          <paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">형식의 전체 이름입니다.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</param>
        <summary>어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져오고, 형식을 찾을 수 없는 경우 선택적으로 예외를 throw합니다.</summary>
        <returns>지정된 클래스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 어셈블리 인스턴스에서 검색합니다. `name` 어셈블리를 제외한 네임 스페이스 매개 변수를 포함 합니다. 다른 어셈블리의 형식 검색 하려면 사용 된 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 선택적으로 포함할 수 있습니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리로 전달 되었습니다, 하는 경우 여전히이 메서드에서 반환 됩니다. 형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
 `throwOnError` 형식을 찾을 수 없으면 어떻게 되나요 매개 변수에 적용 됩니다. Throw 될 수 있는 다른 모든 예외에는 영향을 주지 않습니다. 특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 할 수 있습니다 경우에 `throwOnError` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 잘못되었습니다.  
  
또는 
<paramref name="name" />의 길이가 1024자를 초과합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">형식의 전체 이름입니다.</param>
        <param name="throwOnError">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</param>
        <param name="ignoreCase">형식 이름의 대/소문자를 무시하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>대/소문자를 무시할지 여부와 형식이 없으면 예외를 throw할지를 선택적으로 지정하여 어셈블리 인스턴스에서 지정된 이름을 가진 <see cref="T:System.Type" /> 개체를 가져옵니다.</summary>
        <returns>지정된 클래스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 현재 어셈블리 인스턴스에서 검색합니다. `name` 어셈블리를 제외한 네임 스페이스 매개 변수를 포함 합니다. 다른 어셈블리의 형식 검색 하려면 사용 된 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 메서드 오버 로드를 어셈블리 표시 이름을 형식 이름의 일부로 선택적으로 포함할 수 있습니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리로 전달 되었습니다, 하는 경우 여전히이 메서드에서 반환 됩니다. 형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
 `throwOnError` 형식을 찾을 수 없으면 어떻게 되나요 매개 변수에 적용 됩니다. Throw 될 수 있는 다른 모든 예외에는 영향을 주지 않습니다. 특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 할 수 있습니다 경우에 `throwOnError` 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 잘못되었습니다.  
  
또는 
<paramref name="name" />의 길이가 1024자를 초과합니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.  
  
또는 
현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="name" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="name" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 어셈블리에 정의되어 있는 형식을 가져옵니다.</summary>
        <returns>이 어셈블리에 정의되어 있는 모든 형식이 포함된 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 배열에는 중첩된 형식이 포함 됩니다.  
  
 경우는 <xref:System.Reflection.Assembly.GetTypes%2A> 어셈블리가 로드 되지 않은 (예를 들어 경우 두 번째 어셈블리의 형식에서 파생), 어셈블리의 형식에 종속 되는 어셈블리 및 형식에 메서드를 호출을 <xref:System.Reflection.ReflectionTypeLoadException> throw 됩니다. 예를 들어, 첫 번째 어셈블리를 사용 하 여 로드 된 경우 발생할 수 있습니다 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 또는 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드 및 두 번째 어셈블리 로드 되지 않았습니다. 사용 하 여 로드 된 어셈블리를 사용 하 여 발생할 수도 있습니다는 <xref:System.Reflection.Assembly.Load%2A> 및 <xref:System.Reflection.Assembly.LoadFile%2A> 두 번째 어셈블리를 찾을 수 없는 경우 메서드를 <xref:System.Reflection.Assembly.GetTypes%2A> 메서드가 호출 됩니다.  
  
> [!NOTE]
>  형식을 다른 어셈블리로 전달 되었습니다, 반환된 된 배열에 포함 되지 않습니다. 형식 전달에 대 한 내용은 참조 하세요 [공용 언어 런타임의 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.  
  
 컬렉션을 검색할 <xref:System.Reflection.TypeInfo> 개체의 배열이 아닌 <xref:System.Type> 개체를 사용 하 여는 <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 지정된 된 어셈블리의 형식에 대 한 메서드의 매개 변수를 표시합니다.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">어셈블리에 로드할 수 없는 하나 이상의 형식이 포함되어 있습니다. <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 속성에는 로드할 수 없는 각 형식에 대한 예외가 포함되어 있으나, 이 예외의 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 속성에 의해 반환된 배열에는 로드된 각 형식에 대한 <see cref="T:System.Type" /> 개체 및 로드할 수 없는 각 형식에 대한 <see langword="null" /> 개체가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리를 전역 어셈블리 캐시에서 로드했는지를 나타내는 값을 가져옵니다.</summary>
        <value>어셈블리를 전역 어셈블리 캐시에서 로드했으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>어셈블리를 로드하는 데 사용된 호스트 컨텍스트를 가져옵니다.</summary>
        <value>어셈블리를 로드하는 데 사용된 호스트 컨텍스트가 있을 경우 호스트 컨텍스트를 나타내는 <see cref="T:System.Int64" /> 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>매니페스트가 포함된 파일에 저장된 CLR(공용 언어 런타임) 버전을 나타내는 문자열을 가져옵니다.</summary>
        <value>CLR 버전 폴더 이름입니다. 이 값은 전체 경로가 아닙니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 예를 들어,.NET Framework 버전 1.1에 대 한 값 v1.1.4322 것입니다. 해당 버전에 대 한 이진 파일 경로 %windir%\Microsoft.NET\Framework\v1.1.4322 위치 합니다.  
  
 기본적으로 <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> 어셈블리를 빌드하는 데 사용 하는 CLR의 버전으로 설정 됩니다. 그러나이 설정 되어 다른 값으로 컴파일할 때.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">이 어셈블리에 대해 확인할 특성의 형식입니다.</param>
        <param name="inherit">이 인수는 이 형식의 개체에 대해 무시됩니다.</param>
        <summary>지정된 특성이 어셈블리에 적용되었는지를 나타냅니다.</summary>
        <returns>특성이 어셈블리에 적용되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 적용 하는 다음 코드 예제는 <xref:System.Reflection.AssemblyTitleAttribute> 어셈블리로 사용 하 여 다음 특성 <xref:System.Reflection.Assembly.IsDefined%2A> 정책이 적용 되었는지 여부를 나타냅니다. 또한 적용 되지 않은 특성을 테스트 합니다.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />이 잘못된 형식을 사용합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리가 현재 프로세스에서 리플렉션 내보내기를 사용하여 동적으로 생성되었는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 어셈블리가 현재 프로세스에서 동적으로 생성되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 어셈블리 파생 클래스로 표현 됩니다 <xref:System.Reflection.Emit.AssemblyBuilder>합니다.  
  
 동적 어셈블리를 디스크에 저장된 된 어셈블리에 저장 될 때 동적 아닙니다. 다른 응용 프로그램 도메인 또는 프로세스에 로드 되 면 저장된 된 어셈블리를 <xref:System.Reflection.Assembly.IsDynamic%2A> 속성이 반환 `false`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리가 완전히 신뢰되어 로드되는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 어셈블리가 완전히 신뢰되어 로드되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <summary>내보낸 어셈블리가 포함된 COFF(Common Object File Format) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 호출 어셈블리의 신뢰 수준으로 동일 합니다. 응용 프로그램 도메인의 신뢰 수준 사용 하 여 바이트 배열에서 어셈블리를 로드 하려면 사용 된 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 메서드 오버 로드 합니다. 오버 로드를 사용 하 여 증명 정보를 사용 하는 방법에 대 한 자세한 내용은 합니다 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 메서드를 참조 합니다 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 메서드 오버 로드 합니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 이 메서드 오버 로드 항상 만들어집니다 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">로드될 어셈블리를 설명하는 개체입니다.</param>
        <summary>해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 이 throw `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다. 기본적으로 원격 어셈블리의 코드를 실행할 수 없기 때문에.NET Framework 4부터를 <xref:System.IO.FileLoadException> 경우에 throw 됩니다 `assemblyRef` 원격 어셈블리를 지정 합니다. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.     
  
> [!NOTE]
>  사용 하지 마십시오는 <xref:System.Reflection.AssemblyName> 만 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 집합입니다. 합니다 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 요소를 제공 하지 않습니다 (예: 이름 또는 버전)에서 어셈블리 id의 로드가 발생 하지 않습니다 부하-id 별 규칙에 따라에서 예상한 대로 <xref:System.Reflection.Assembly.Load%2A> 메서드. 대신, 어셈블리 로드 규칙을 사용 하 여 로드 됩니다. 로드 컨텍스트를 사용 하 여 단점에 대 한 정보를 참조 하세요. 합니다 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드 오버 로드 또는 [어셈블리를 로드 하기 위한 모범 사례](~/docs/framework/deployment/best-practices-for-assembly-loading.md)합니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다. .NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
> [!NOTE]
>  모두를 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 어셈블리를 로드 하려는 첫 번째 시도에서는 표시 이름으로 속성 설정 (반환한 버전, 문화권 및 등을 포함 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성). 파일이 없으면 <xref:System.Reflection.AssemblyName.CodeBase%2A> 어셈블리를 검색 하는 데 사용 됩니다. 사용 하 여 어셈블리 있으면 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름을 어셈블리에 대해 일치 합니다. 검색이 실패 하는 경우는 <xref:System.IO.FileLoadException> throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.AssemblyName> 개체를 로드 하는 데 사용 된 `sysglobal.dll` 어셈블리입니다. 어셈블리의 public 형식의 전체 이름을 표시합니다.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" />가 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.IO.IOException" />을 catch합니다.  
  
</para>
          </block>  
  
 찾은 파일을 로드할 수 없습니다.

또는

<paramref name="assemblyRef" />은 원격 어셈블리를 지정하지만 원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다. 또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />가 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">런타임에서 어셈블리를 찾는 방법</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">긴 형식의 어셈블리 이름입니다.</param>
        <summary>긴 형식의 이름으로 지정된 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 형식의 어셈블리 이름 (예: "System" System.dll 어셈블리에 대 한) 해당 버전, 문화권, 공개 키 토큰 및 선택적으로 해당 프로세서 아키텍처와 함께 간단한 이름은 이루어져 있습니다. 어셈블리의 해당 <xref:System.Reflection.Assembly.FullName%2A> 속성입니다. 다음 예제에서는 System.dll.NET Framework 4 어셈블리를 로드 하는 긴 이름 사용을 보여 줍니다.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> 이 throw `assemblyString` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다. .NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어, "ProcessorArchitecture = msil"입니다. 하지만 어셈블리 이름을 지정 하는 방법이 권장된 만들 때를 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드로 전달 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 정규화 된 이름, 어셈블리를 로드 하 고 지정된 된 어셈블리에 포함 된 모든 형식을 나열 합니다. 이 코드 예제를 실행 하려면 정규화 된 어셈블리 이름을 제공 해야 합니다. 참조 된 정규화 된 어셈블리 이름을 가져오는 방법에 대 한 내용은 [어셈블리 이름](~/docs/framework/app-domains/assembly-names.md)합니다.  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" />이 빈 문자열입니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />가 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">런타임에서 어셈블리를 찾는 방법</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</param>
        <summary>생성된 어셈블리가 들어 있고 경우에 따라 어셈블리에 대한 기호도 포함하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 로드 된 어셈블리의 신뢰 수준을 호출 어셈블리의 신뢰 수준으로 동일 합니다. 응용 프로그램 도메인의 신뢰 수준 사용 하 여 바이트 배열에서 어셈블리를 로드 하려면 사용 된 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 메서드 오버 로드 합니다. 오버 로드를 사용 하 여 증명 정보를 사용 하는 방법에 대 한 자세한 내용은 합니다 <xref:System.Reflection.Assembly.Load%2A> 바이트 배열을 사용 하는 메서드를 참조 합니다 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 메서드 오버 로드 합니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 이 메서드 오버 로드 항상 만들어집니다 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">로드될 어셈블리를 설명하는 개체입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>해당 <see cref="T:System.Reflection.AssemblyName" />이 지정된 어셈블리를 로드합니다. 어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 이 throw `assemblyRef` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  기본적으로 원격 어셈블리의 코드를 실행할 수 없기 때문에.NET Framework 4부터를 <xref:System.IO.FileLoadException> 경우에 throw 됩니다 `assemblyRef` 원격 어셈블리를 지정 합니다. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.   
  
> [!NOTE]
>  사용 하지 마십시오는 <xref:System.Reflection.AssemblyName> 만 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 집합입니다. 합니다 <xref:System.Reflection.AssemblyName.CodeBase%2A> 속성 요소를 제공 하지 않습니다 (예: 이름 또는 버전)에서 어셈블리 id의 로드가 발생 하지 않습니다 부하-id 별 규칙에 따라에서 예상한 대로 <xref:System.Reflection.Assembly.Load%2A> 메서드. 대신, 어셈블리 로드 규칙을 사용 하 여 로드 됩니다. 로드 컨텍스트를 사용 하 여 단점에 대 한 정보를 참조 하세요. 합니다 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 메서드 오버 로드 또는 [어셈블리를 로드 하기 위한 모범 사례](~/docs/framework/deployment/best-practices-for-assembly-loading.md)합니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다. .NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
> [!NOTE]
>  모두를 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 속성 및 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 어셈블리를 로드 하려는 첫 번째 시도에서는 표시 이름으로 속성 설정 (반환한 버전, 문화권 및 등을 포함 하 여는 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 속성). 파일이 없으면 <xref:System.Reflection.AssemblyName.CodeBase%2A> 어셈블리를 검색 하는 데 사용 됩니다. 사용 하 여 어셈블리 있으면 <xref:System.Reflection.AssemblyName.CodeBase%2A>, 표시 이름을 어셈블리에 대해 일치 합니다. 검색이 실패 하는 경우는 <xref:System.IO.FileLoadException> throw 됩니다.  
  
 호출 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 한 번 동일한 어셈블리에 있지만 지정 된 다른 증명 공용 언어 런타임에서 throw 하지 않는 보다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성 수 없기 때문에 결정 합니다. 먼저 성공 하는 증명 정보는 사용 되는 증거입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyRef" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.

또는

<paramref name="assemblyRef" />은 원격 어셈블리를 지정하지만 원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">런타임에서 어셈블리를 찾는 방법</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">어셈블리의 표시 이름입니다.</param>
        <param name="assemblySecurity">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>해당 표시 이름이 지정된 어셈블리를 로드한 다음 제공된 증명을 사용하여 이 어셈블리를 호출자의 도메인에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 이 throw `assemblyString` 전체 어셈블리 이름 및 간단한 이름과 일치 하는 첫 번째 어셈블리에 다른 버전, 문화권 또는 공개 키 토큰을 지정 합니다. 로더는 간단한 이름과 일치 하는 다른 어셈블리에 대 한 검색을 계속 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다. .NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 한 번에이 메서드를 호출 하면 동일한 어셈블리에 있지만 지정 된 다른 증명, 공용 언어 런타임에서 throw 하지 않습니다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성을 확인할 수 없으므로 합니다. 먼저 성공 하는 증명 정보는 사용 되는 증거입니다.  
  
 .NET framework 버전 2.0에서 프로세서 아키텍처가 어셈블리 id에 추가 되 고 어셈블리 이름 문자열의 일부로 지정할 수 있습니다. 예를 들어, "ProcessorArchitecture = msil"입니다. 하지만 어셈블리 이름을 지정 하는 방법이 권장된 만들 때를 <xref:System.Reflection.AssemblyName> 개체의 적절 한 오버 로드로 전달 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드. <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.  
  
또는 
어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">런타임에서 어셈블리를 찾는 방법</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>생성된 어셈블리가 들어 있고 경우에 따라 어셈블리에 대한 기호 및 증명 정보도 포함하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다. 어셈블리에 대 한 기호를 나타내는 원시 바이트도 로드 됩니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.Load%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수를 호출 하는 어셈블리에서 상속 됩니다. .NET Framework 버전 1.1에 적용 됩니다이 서비스 팩 1 (SP1) 및 이후 버전입니다.  
  
    > [!NOTE]
    >  .NET framework 버전 1.0 및 버전 1.1 sp1을 사용 하는 경우에 <xref:System.Reflection.Assembly.Load%2A> 메서드 오버 로드는 `Byte[]` 증거 COFF 이미지를 로드 하려면 매개 변수는 함께 합니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.Load%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 C + + 실행 파일을 리플렉션를 throw 할 수는 <xref:System.BadImageFormatException>합니다. 이 원인은 c + + 컴파일러가 재배치 주소 또는 `.reloc` 실행 파일의 섹션입니다. 보존 하는 `.reloc` c + + 실행 파일에 대 한 주소를 지정 `/fixed:no` 링크할 때.  
  
 호출 하는 경우는 [\], 바이트\<xref:System.Reflection.Assembly.Load%2A > 메서드를 한 번 동일한 어셈블리에 있지만 지정 된 다른 증명 공용 언어 런타임에서 throw 하지 않는 보다는 <xref:System.IO.FileLoadException> 때문에 같음 및 다른 증명 사양의 무결성을 확인할 수 없습니다. 먼저 성공 하는 증명 정보는 사용 되는 증거입니다.  
  
 이 메서드 오버 로드 항상 만들어집니다 새 <xref:System.Reflection.Assembly> 자체 매핑 사용 하 여 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다.  기본적으로 레거시 CAS 정책은 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 사용되지 않습니다. 사용되지 않도록 설정되면 <paramref name="securityEvidence" />가 <see langword="null" />이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> 보안 동작: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">어셈블리의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다.</param>
        <param name="securityContextSource">보안 컨텍스트의 소스입니다.</param>
        <summary>생성된 어셈블리가 들어 있고 경우에 따라 기호도 포함하고 보안 컨텍스트의 소스도 지정하는 COFF(공용 개체 파일 형식) 기반 이미지를 사용하여 어셈블리를 로드합니다. 이 어셈블리는 호출자의 응용 프로그램 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어셈블리 보안 컨텍스트에 대 한 지정된 된 소스를 사용 하 여 호출자의 응용 프로그램 도메인에 로드 됩니다. 경우 `rawSymbolStore` 지정 어셈블리에 대 한 기호를 나타내는 원시 바이트도 로드 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="rawAssembly" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> 값이 열거형 값 중 하나가 아닙니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리 파일의 내용을 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">로드할 파일의 정규화된 경로입니다.</param>
        <summary>지정된 경로에 있는 어셈블리 파일의 내용을 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 로드 하 고 id는 동일 하지만 서로 다른 경로에 있는 어셈블리를 검사 합니다. <xref:System.Reflection.Assembly.LoadFile%2A> 파일에서 로드 컨텍스트에 로드 하지 않습니다 하 고으로 로드 경로 사용 하 여 종속성을 해결 되지 않으면를 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 하지 않습니다. <xref:System.Reflection.Assembly.LoadFile%2A> 이 제한 된 시나리오에서 유용 하기 때문에 <xref:System.Reflection.Assembly.LoadFrom%2A> 어셈블리 로드를 사용할 수는 서로 다른 경로 이지만 동일한 id를 가진; 첫 번째만 로드 됩니다 이러한 어셈블리.  

경우.NET Framework 4부터 `path` 로드 하는 어셈블리는 기본적으로 사용 하지 않도록 설정, 원격 위치에서 어셈블리를 지정 하며 `LoadFile` 메서드가 throw를 <xref:System.IO.FileLoadException>. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 인수는 절대 경로가 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.

또는

원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 매개 변수가 빈 문자열("")이거나 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="path" />가 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">어셈블리 파일의 정규화된 경로입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>경로가 지정된 어셈블리를 로드한 다음 제공된 증명 정보를 사용하여 이 어셈블리를 호출자의 도메인에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드를 로드 하 고 id는 동일 하지만 서로 다른 경로에 있는 어셈블리를 검사 합니다. <xref:System.Reflection.Assembly.LoadFile%2A> 파일을 로드 하지 않습니다는 <xref:System.Reflection.Assembly.LoadFrom%2A> 컨텍스트를으로 로드 경로 사용 하 여 종속성을 해결 하지 않습니다는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 하지 않습니다. <xref:System.Reflection.Assembly.LoadFile%2A> 이 제한 된 시나리오에서 유용 하기 때문에 <xref:System.Reflection.Assembly.LoadFrom%2A> 어셈블리 로드를 사용할 수는 서로 다른 경로 이지만 동일한 id를 가진; 첫 번째만 로드 됩니다 이러한 어셈블리.  

경우.NET Framework 4부터 `path` 로드 하는 어셈블리는 기본적으로 사용 하지 않도록 설정, 원격 위치에서 어셈블리를 지정 하며 `LoadFile` 메서드가 throw를 <xref:System.IO.FileLoadException>. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 인수는 절대 경로가 아닙니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 매개 변수가 빈 문자열("")이거나 없습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.

또는

원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="path" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" />이 <see langword="null" />가 아닙니다. 기본적으로 레거시 CAS 정책은 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]에서 사용되지 않습니다. 사용되지 않도록 설정되면 <paramref name="securityEvidence" />가 <see langword="null" />이어야 합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일이 나 디렉터리에서 읽고 경로 자체의 정보에 대 한 액세스에 액세스 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

.NET Framework 4 부터는 원격 위치에서 로드 된 어셈블리에서 코드를 실행 하는 기능은 사용 되지 기본적으로 호출 합니다 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다. 에 어셈블리를 로드 하 고 해당 코드를 실행 하거나 다음을 수행 해야 합니다.

- 어셈블리에 대 한 샌드박스를 명시적으로 만듭니다. (참조 [방법: 샌드박스에서 부분적으로 신뢰할 수 있는 코드 실행](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)

- 완전 신뢰 수준에서 설정 하 여 어셈블리의 코드를 실행 합니다 `enabled` 특성을 [ `<loadFromRemoteSources>` 구성 요소](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 를 `true`. 자세한 내용은 참조는 [ `<loadFromRemoteSources>` 구성 요소](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 문서.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.  
  
 어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.  
  
-   로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: GAC에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인입니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트를 검색 하 여 검색 된 디렉터리에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다. 

    경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.    
  
-   리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다. 어셈블리가 deserialize 될 때 발생할 수 있습니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리가는 도메인 중립적으로 로드할 수 없습니다.  
  
-   .NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 해당 파일 이름이 나 경로가 지정 된 어셈블리를 로드 합니다.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.

또는

원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI를 읽는 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리를 로드하고 보안 증명을 제공합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.  
  
 어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.  
  
-   로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: GAC에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인입니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트를 검색 하 여 검색 된 디렉터리에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.

    경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.    
  
-   리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다. 어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리가는 도메인 중립적으로 로드할 수 없습니다.  
  
-   .NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   한 번에이 메서드를 호출 하면 동일한 어셈블리에 있지만 지정 된 다른 증명, 공용 언어 런타임에서 throw 하지 않습니다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성을 확인할 수 없으므로 합니다. 먼저 성공 하는 증명 정보는 사용 되는 증거입니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수 결합 됩니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.  
  
또는 
<paramref name="securityEvidence" />가 모호하며 올바르지 않은 것으로 확인되었습니다.

또는

원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI를 읽는 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값입니다.</param>
        <param name="hashAlgorithm">파일을 해시하고 강력한 이름을 생성하는 데 사용된 해시 알고리즘입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리, 해시 값 및 해시 알고리즘을 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.  
  
 어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.  
  
-   로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: 전역 어셈블리 캐시에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인입니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트는 사용자 검색에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.  

    경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.    
  
-   리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다. 어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리는 도메인 중립적으로 로드될 수 없습니다.  
  
 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.

또는

원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  
  
또는 
 <paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI를 읽는 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <param name="hashValue">계산된 해시 코드의 값입니다.</param>
        <param name="hashAlgorithm">파일을 해시하고 강력한 이름을 생성하는 데 사용된 해시 알고리즘입니다.</param>
        <summary>해당 파일 이름이나 경로가 지정된 어셈블리, 보안 증명 정보, 해시 값 및 해시 알고리즘을 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.  
  
> [!NOTE]
>  파일 전송 프로토콜 (FTP) 지원 되지 않습니다. 에 대 한 제공 된 URI `assemblyFile` FTP 주소를 사용 하는 어셈블리가 로드 되지 않습니다. 예외가 throw되지 않습니다.  
  
 `assemblyFile` 현재 디렉터리에 절대적 이거나 상대적 않을 어셈블리는 호출자의 도메인에 로드 합니다.  
  
 어셈블리는 세 개의 컨텍스트 중 하나로 로드할 수 있습니다 또는 컨텍스트 없이 로드 될 수 있습니다.  
  
-   로드 컨텍스트를 검색 하 여 찾은 어셈블리가 포함: GAC에 호스트 어셈블리에서는 런타임 호스트 되는 경우 또는 저장 된 <xref:System.AppDomainSetup.ApplicationBase%2A> 및 <xref:System.AppDomainSetup.PrivateBinPath%2A> 응용 프로그램 도메인입니다. <xref:System.Reflection.Assembly.Load%2A> 메서드의 대부분 오버로드는 어셈블리 이 컨텍스트에 로드합니다.  
  
-   로드 컨텍스트를 검색 하 여 검색 된 디렉터리에 포함 되지 않은 경로 제공 하는 어셈블리를 포함 합니다. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> 및 <xref:System.AppDomain.ExecuteAssembly%2A>는 경로로 로드되는 메서드의 예제입니다.  

    경우.NET Framework 4부터의 URI `assemblyFile` 원격 위치를 지정 어셈블리 로드는 기본적으로 사용 하지 않도록 설정 하며 `LoadFrom` 메서드가 throw를 <xref:System.IO.FileLoadException>입니다. 원격 위치에서 로드 된 코드의 실행을 사용 하도록 설정 하려면 사용 합니다 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) 구성 요소입니다.    
  
-   리플렉션 전용 컨텍스트에 로드 된 어셈블리를 포함 합니다 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 및 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 메서드, 이러한 코드 컨텍스트를 실행할 수 없습니다.  
  
-   사용자 생성 된 어셈블리를 찾을 수, 하는 경우 모든 컨텍스트에서 아닙니다. 이 오버 로드를 사용 하 여 로드 된 어셈블리에 적용 됩니다는 <xref:System.Reflection.Assembly.Load%2A> 와 어셈블리를 포함 하는 바이트 배열을 지정 하 고, 리플렉션을 사용 하 여 만든 임시 동적 어셈블리 내보내기를 하 고, 디스크에 저장 되지 메서드입니다.  
  
 로드 컨텍스트 검색에 포함 되지 않은 경로에서 로드 되도록 어셈블리 있으며 아직 컨텍스트 경로 정보를 유지 하기 때문에 해당 경로에 종속성을 허용 합니다.  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드가 다음과 같은 단점이 있습니다. 대신 <xref:System.Reflection.Assembly.Load%2A>을 사용하는 것이 좋습니다.  
  
-   같은 ID를 가진 어셈블리가 이미 로드되어 있으면 다른 경로가 지정된 경우에도 <xref:System.Reflection.Assembly.LoadFrom%2A>은 로드된 어셈블리를 반환합니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, 로드 컨텍스트에 어셈블리 표시 이름으로 동일한 어셈블리를 로드 하려고 시도 하는 나중에 로드 하려고 하면 실패 합니다. 어셈블리가 deserialize되면 이 문제가 발생할 수 있습니다.  
  
-   어셈블리를 사용 하 여 로드 <xref:System.Reflection.Assembly.LoadFrom%2A>, id가 같지만 다른 위치를 사용 하 여 어셈블리 검색 경로 포함 되어는 <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, 또는 기타 예기치 않은 동작이 발생할 수 있습니다.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A>은 지정된 경로에서 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType>와 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 또는 <xref:System.Net.WebPermission>을 요구합니다.  
  
-   네이티브 이미지에 대 한 있으면 `assemblyFile`, 사용 되지 않습니다. 어셈블리가는 도메인 중립적으로 로드할 수 없습니다.  
  
-   .NET Framework 버전 1.0 및 1.1에서는 정책이 적용 되지 않습니다.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 사용 하 여 <xref:System.Security.Policy.Evidence> 매개 변수, 어셈블리 로더를 제공 하는 증명 정보를 사용 하 여 로드 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 <xref:System.Security.Policy.Evidence> 매개 변수를 증거의 조각을 병합 됩니다. 인수로 제공 하는 증거의 조각을 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 로더에 의해 제공 된 증명 정보를 대체 합니다.  
  
-   한 번에이 메서드를 호출 하면 동일한 어셈블리에 있지만 지정 된 다른 증명, 공용 언어 런타임에서 throw 하지 않습니다는 <xref:System.IO.FileLoadException> 같음 및 다른 증명 사양의 무결성을 확인할 수 없으므로 합니다. 먼저 성공 하는 증명 정보는 사용 되는 증거입니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드는 `Byte[]` 공용 개체 파일 (COFF) 형식 이미지를 증명 정보를 로드 하려면 매개 변수 결합 됩니다. `Zone`를 `Url` 하 고 `Site` 호출 하는 어셈블리에서 상속 됩니다 및 `Hash` 및 `StrongName` COFF 어셈블리에서 수행 됩니다.  
  
-   사용 하는 경우는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드를 `Byte[]` 매개 변수 및 <xref:System.Security.Policy.Evidence> COFF 이미지를 로드 하려면 제공 된 증명 정보를 사용 합니다. 호출 어셈블리 및 COFF 이미지의 증명 정보는 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.  
  
또는 
<paramref name="securityEvidence" />가 모호하며 올바르지 않은 것으로 확인되었습니다.

또는

원격 어셈블리에서 코드를 실행하는 기능은 사용할 수 없습니다. <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>를 확인하세요.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />이 유효한 어셈블리가 아닙니다. 예를 들어, 64비트 프로세스의 32비트 어셈블리입니다. 자세한 정보는 예외 항목을 참조하세요.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 사용 하 여 어셈블리를 로드 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI를 읽는 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 어셈블리의 내부 모듈을 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">모듈의 이름입니다. 이 문자열은 어셈블리 매니페스트에 있는 파일 이름과 일치해야 합니다.</param>
        <param name="rawModule">내보낸 모듈 또는 리소스가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <summary>내보낸 모듈인 리소스 파일이 포함된 COFF(Common Object File Format) 기반 이미지가 포함된 이 어셈블리의 내부 모듈을 로드합니다.</summary>
        <returns>로드된 모듈입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 또는 <paramref name="rawModule" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" />과 일치하는 파일 항목이 이 어셈블리의 매니페스트에 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" />은 유효한 모듈이 아닙니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">모듈의 이름입니다. 이 문자열은 어셈블리 매니페스트에 있는 파일 이름과 일치해야 합니다.</param>
        <param name="rawModule">내보낸 모듈 또는 리소스가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <param name="rawSymbolStore">모듈의 기호를 나타내는 원시 바이트가 포함된 바이트 배열입니다. 이 배열이 리소스 파일이면 <see langword="null" />이어야 합니다.</param>
        <summary>내보낸 모듈인 리소스 파일이 포함된 COFF(Common Object File Format) 기반 이미지가 포함된 이 어셈블리의 내부 모듈을 로드합니다. 모듈의 기호를 나타내는 원시 바이트도 로드됩니다.</summary>
        <returns>로드된 모듈입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> 또는 <paramref name="rawModule" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" />과 일치하는 파일 항목이 이 어셈블리의 매니페스트에 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" />은 유효한 모듈이 아닙니다.</exception>
        <exception cref="T:System.IO.FileLoadException">찾은 파일을 로드할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">증명 정보를 제공 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  오버 로드는 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 메서드는 사용 되지 않으며 이전 버전과 호환성을 위해 보존 합니다. 사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">어셈블리의 표시 이름입니다.</param>
        <summary>부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다. <paramref name="partialName" />이 없으면 이 메서드에서 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> 메서드는 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다 했습니다. 사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.  
  
 이 메서드를 사용 하 여 어셈블리를 로드 하는 응용 프로그램 업그레이드 이러한 어셈블리의 영향을 받습니다. 따라서이 메서드를 사용 하지 마세요 사용 하도록 응용 프로그램을 다시 디자인 된 <xref:System.Reflection.Assembly.Load%28System.String%29> 메서드 오버 로드 또는 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 메서드 오버 로드 합니다.  
  
 이 메서드는 먼저 호출 <xref:System.Reflection.Assembly.Load%2A>합니다. 어셈블리가 없으면이 메서드는 같은 간단한 이름 및 가장 높은 버전 번호를 포함 하는 전역 어셈블리 캐시에서 어셈블리를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="partialName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">어셈블리의 표시 이름입니다.</param>
        <param name="securityEvidence">어셈블리 로드에 사용할 증명 정보입니다.</param>
        <summary>부분 이름을 사용하여 응용 프로그램 디렉터리 또는 전역 어셈블리 캐시에서 어셈블리를 로드합니다. 어셈블리는 제공된 증명을 사용하여 호출자의 도메인에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다. <paramref name="partialName" />이 없으면 이 메서드에서 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> 메서드는 사용 되지 않으며 이전 버전과 호환성을 위해 유지 되었습니다 했습니다. 사용되는 대체 항목은 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>입니다.  
  
 증명 정보는 코드에 부여할 수 있는 권한 같이 보안 정책을 결정하기 위해 입력하는 정보 집합입니다.  
  
 이 메서드를 사용 하 여 어셈블리를 로드 하는 응용 프로그램 업그레이드 이러한 어셈블리의 영향을 받습니다. 따라서이 메서드를 사용 하지 마세요 사용 하도록 응용 프로그램을 다시 디자인 된 <xref:System.Reflection.Assembly.Load%2A> 메서드 또는 <xref:System.Reflection.Assembly.LoadFrom%2A> 메서드.  
  
 이 메서드는 먼저 호출 <xref:System.Reflection.Assembly.Load%2A>합니다. 어셈블리가 없으면이 메서드는 같은 간단한 이름 및 가장 높은 버전 번호를 포함 하는 전역 어셈블리 캐시에서 어셈블리를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">어셈블리 또는 모듈이 서로 다른 두 증명 정보 집합으로 두 번 로드되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="partialName" />가 이후 버전으로 컴파일되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드 호출에 대 한 증명 정보를 사용 하 여 어셈블리를 로드 하려면. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>매니페스트가 포함된 로드된 파일의 전체 경로나 UNC 위치를 가져옵니다.</summary>
        <value>매니페스트가 포함된 로드된 파일의 위치입니다. 로드된 파일이 섀도 복사된 경우 위치는 해당 파일이 섀도 복사된 후의 위치입니다. <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 메서드 오버로드를 사용한 경우처럼 어셈블리가 바이트 배열에서 로드되면 빈 문자열("")이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 위치를 가져오려면 파일이 섀도 복사 되기 전에 <xref:System.Reflection.Assembly.CodeBase%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 매니페스트를 포함 하는 로드 된 파일의 위치를 표시 합니다.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">현재 어셈블리가 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 개체로 표현되는 동적 어셈블리입니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">경로에 액세스 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">어셈블리 섀도 복사</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리의 매니페스트가 포함된 모듈을 가져옵니다.</summary>
        <value>어셈블리의 매니페스트가 포함된 모듈입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>공용 언어 런타임 클래스 로더가 일반적인 방법으로 어셈블리의 내부 모듈에 대한 참조를 확인할 수 없는 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 콜백 검색 모듈 자체를 로드 하 고 반환할 수를 제공 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리의 모듈을 포함하는 컬렉션을 가져옵니다.</summary>
        <value>이 어셈블리의 모듈을 포함하는 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <paramref name="right" />와 비교할 어셈블리입니다.</param>
        <param name="right">
          <paramref name="left" />와 비교할 어셈블리입니다.</param>
        <summary>두 <see cref="T:System.Reflection.Assembly" /> 개체가 같은지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <paramref name="right" />와 비교할 어셈블리입니다.</param>
        <param name="right">
          <paramref name="left" />와 비교할 어셈블리입니다.</param>
        <summary>두 <see cref="T:System.Reflection.Assembly" /> 개체가 같지 않은지를 나타냅니다.</summary>
        <returns>
          <see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 어셈블리의 권한 부여 집합을 가져옵니다.</summary>
        <value>현재 어셈블리의 권한 부여 집합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 개체는 경로 같은 중요 한 정보를 포함할 수 있습니다. 따라서 이러한 개체에 액세스 하려면 완전 신뢰가 필요 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 어셈블리가 리플렉션 전용 컨텍스트에 로드되었는지를 나타내는 <see cref="T:System.Boolean" /> 값을 가져옵니다.</summary>
        <value>어셈블리가 실행 컨텍스트가 아니라 리플렉션 전용 컨텍스트에 로드되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 어셈블리를 리플렉션 전용 컨텍스트에 로드 되었으면를 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 메서드를 어셈블리에서 코드를 실행할 수 없습니다. 어셈블리 코드를 실행 하려면 실행 컨텍스트에 로드 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>어셈블리를 검사할 수 있지만 실행할 수는 없는 리플렉션 전용 컨텍스트에 어셈블리를 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">내보낸 어셈블리가 포함된 COFF 기반 이미지인 바이트 배열입니다.</param>
        <summary>내보낸 어셈블리가 포함된 COFF(Common Object File Format) 기반 이미지에서 어셈블리를 로드합니다. 어셈블리는 호출자 응용 프로그램 도메인의 리플렉션 전용 컨텍스트에 로드됩니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다. 코드를 실행 하려면 어셈블리에 로드 해야만 실행 컨텍스트를 사용 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
 리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다. 컨텍스트에 로드 된 어셈블리를 응용 프로그램 도메인을 언로드하는 유일한 언로드될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="rawAssembly" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" />를 로드할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <see cref="P:System.Reflection.AssemblyName.FullName" /> 속성에서 반환된 어셈블리의 표시 이름입니다.</param>
        <summary>지정된 표시 이름을 사용하여 어셈블리를 리플렉션 전용 컨텍스트에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성은 리플렉션 전용 컨텍스트에 자동으로 로드 되지 않습니다.  
  
 리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다. 코드를 실행 하려면 어셈블리에 로드 해야만 실행 컨텍스트를 사용 하 여 <xref:System.Reflection.Assembly.Load%2A> 메서드.  
  
 어셈블리에 대한 특정 권한 부여 여부는 증명 정보를 바탕으로 합니다. 어셈블리와 병합 하는 보안 증명에 대 한 규칙 아래와 같습니다.  
  
> [!NOTE]
>  C + +에서 컴파일된 실행 파일에 반영를 throw 할 수는 <xref:System.IO.FileLoadException>합니다. C + + 컴파일러가 실행 파일에서.reloc 섹션 이나 재배치 주소 원인인 것 같습니다. .Reloc 주소를 유지 하려면 지정 `/fixed:no` 링크할 때.  
  
 리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다. 컨텍스트에 로드 된 어셈블리를 응용 프로그램 도메인을 언로드하는 유일한 언로드될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" />가 빈 문자열("")인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" />가 없는 경우</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" />을 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyString" />가 이후 버전으로 컴파일되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 경로입니다.</param>
        <summary>지정된 경로를 사용하여 어셈블리를 리플렉션 전용 컨텍스트에 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 종속성은 리플렉션 전용 컨텍스트에 자동으로 로드 되지 않습니다. 종속성을 자동으로 로드 하려면 처리는 <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> 이벤트 및 이벤트 처리기에 종속성을 로드 합니다.  
  
 리플렉션 전용 컨텍스트에 로드 된 어셈블리에서 코드를 실행할 수 없습니다. 코드를 실행 하려면 사용 하 여 어셈블리를 로드 합니다 <xref:System.Reflection.Assembly.LoadFile%2A> 메서드.  
  
 `assemblyFile` 매개 변수 이스케이프 문자가 없는 URI 참조 해야 합니다. 이 메서드는 URI에서 모든 잘못 된 문자가 이스케이프 문자를 제공합니다.  
  
 지정 된 경로 `assemblyFile` 현재 디렉터리에 상대적입니다. 어셈블리는 호출자의 도메인에 로드 됩니다.  
  
 리플렉션 전용 컨텍스트에 다른 컨텍스트에서 다르지 않습니다. 컨텍스트에 로드 된 어셈블리를 응용 프로그램 도메인을 언로드하는 유일한 언로드될 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 이름 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" />을 찾았지만 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
또는 
버전 2.0 이상의 공용 언어 런타임이 현재 로드되어 있으며 <paramref name="assemblyFile" />가 이후 버전으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" />가 빈 문자열("")인 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">"file://"로 시작 하는 URI를 읽는 합니다. 연관 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">"file://"로 시작 하지 않는 URI를 읽는 합니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>CLR(공용 언어 런타임)가 이 어셈블리에 대해 적용해야 하는 보안 규칙 집합을 나타내는 값을 가져옵니다.</summary>
        <value>CLR가 이 어셈블리에 대해 적용하는 보안 규칙 집합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 사용 하 여 컴파일하는 어셈블리는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 대신에 명시적으로 만들 수 있지만 투명성을 갖습니다. 이전 버전의.NET Framework를 사용 하 여 컴파일된 어셈블리에는 수준 1 투명도 있습니다.  
  
 [보안 변경 내용](~/docs/framework/security/security-changes.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">보안 투명 코드</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4의에서 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 형식을 반환합니다.</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 형식을 나타내는 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>표시 이름이라고도 하는 어셈블리의 전체 이름을 반환합니다.</summary>
        <returns>어셈블리의 전체 이름입니다. 어셈블리의 전체 이름을 확인할 수 없는 경우에는 클래스 이름입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">어셈블리 매니페스트가 포함된 파일의 이름 또는 경로입니다.</param>
        <summary>일부 보안 검사를 무시하고 로드 소스 컨텍스트로 어셈블리를 로드합니다.</summary>
        <returns>로드된 어셈블리입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 운영 체제 (예를 들어, 임시 파일 인터넷 이나 인트라넷에서 다운로드) 웹에서 로드 되었음을 표시에 로컬 어셈블리를 로드 합니다. 전에 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 이러한 어셈블리는 샌드박스 응용 프로그램 도메인에 자동으로 로드 되었습니다. 부터 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 완전 신뢰를 사용 하 여 로드 됩니다.  
  
 이 메서드를 사용 하는 대신에 적용할 수 있습니다 합니다 [ &lt;NetFx40_LegacySecurityPolicy&gt; 요소](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) 응용 프로그램 구성 파일에 있습니다. 이렇게 하면 공용 언어 런타임에서의 보안 정책으로 되돌리려면는 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]합니다.  
  
> [!CAUTION]
>  이러한 솔루션 중 하나를 사용 하는 경우 확인 해야 로드 해도 안전 하다 `assemblyFile` 완전 신뢰를 사용 하 여 합니다.  
  
 로드 컨텍스트를 포함 하 여 로드 컨텍스트의 참조는 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" />이 없거나 로드하려는 모듈이 파일 확장명을 지정하지 않습니다.</exception>
        <exception cref="T:System.IO.FileLoadException">발견된 파일을 로드할 수 없습니다.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" />는 유효한 어셈블리가 아닙니다.  
  
또는 
 <paramref name="assemblyFile" />가 현재 로드된 버전보다 이후 버전의 공용 언어 런타임으로 컴파일되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">"file://"로 시작하지 않는 Codebase가 필수 <see cref="T:System.Net.WebPermission" /> 없이 지정되었습니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 매개 변수가 빈 문자열("")입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">어셈블리 이름이 시스템 정의 최대 길이를 초과합니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>